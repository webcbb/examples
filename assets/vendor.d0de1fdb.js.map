{"version":3,"file":"vendor.d0de1fdb.js","sources":["../../../../node_modules/.pnpm/tslib@2.2.0/node_modules/tslib/tslib.es6.js","../../../../node_modules/.pnpm/@proc7ts+primitives@2.2.0/node_modules/@proc7ts/primitives/dist/primitives.js","../../../../node_modules/.pnpm/@proc7ts+push-iterator@2.5.0/node_modules/@proc7ts/push-iterator/dist/push-iterator.js","../../../../node_modules/.pnpm/@proc7ts+supply@1.0.0/node_modules/@proc7ts/supply/dist/supply.js","../../../../node_modules/.pnpm/@proc7ts+context-values@6.1.0_@proc7ts+fun-events@10.4.0/node_modules/@proc7ts/context-values/dist/context-values.js","../../../../node_modules/.pnpm/@proc7ts+amend@1.0.0-dev.5/node_modules/@proc7ts/amend/dist/amend.js","../../../../node_modules/.pnpm/@frontmeans+namespace-aliaser@2.3.0/node_modules/@frontmeans/namespace-aliaser/dist/namespace-aliaser.js","../../../../node_modules/.pnpm/@proc7ts+fun-events@10.4.0/node_modules/@proc7ts/fun-events/dist/_fun-events.base.js","../../../../node_modules/.pnpm/@proc7ts+fun-events@10.4.0/node_modules/@proc7ts/fun-events/dist/fun-events.js","../../../../node_modules/.pnpm/@frontmeans+dom-events@1.1.0_@proc7ts+fun-events@10.4.0/node_modules/@frontmeans/dom-events/dist/dom-events.js","../../../../node_modules/.pnpm/@proc7ts+context-values@6.1.0_@proc7ts+fun-events@10.4.0/node_modules/@proc7ts/context-values/dist/context-values.updatable.js","../../../../node_modules/.pnpm/@frontmeans+dom-primitives@1.0.0/node_modules/@frontmeans/dom-primitives/dist/dom-primitives.js","../../../../node_modules/.pnpm/@frontmeans+render-scheduler@1.6.0/node_modules/@frontmeans/render-scheduler/dist/render-scheduler.js","../../../../node_modules/.pnpm/@frontmeans+drek@1.1.0_@proc7ts+fun-events@10.4.0/node_modules/@frontmeans/drek/dist/drek.js","../../../../node_modules/.pnpm/@proc7ts+workbench@1.1.0/node_modules/@proc7ts/workbench/dist/workbench.js","../../../../node_modules/.pnpm/@frontmeans+httongue@2.2.0/node_modules/@frontmeans/httongue/dist/httongue.js","../../../../node_modules/.pnpm/@wesib+wesib@1.0.0-beta.43_089bfc86f1a25ca814bbf30aba20ce23/node_modules/@wesib/wesib/dist/wesib.js","../../../../node_modules/.pnpm/@wesib+generic@1.0.0-beta.43_6f184aeb2efb36c83740d6bae38b3497/node_modules/@wesib/generic/dist/wesib.generic.js","../../../../node_modules/.pnpm/@proc7ts+delta-set@1.4.2/node_modules/@proc7ts/delta-set/dist/delta-set.js","../../../../node_modules/.pnpm/@frontmeans+input-aspects@4.3.0_1eca465c0aaa87aec94c737f93123948/node_modules/@frontmeans/input-aspects/dist/input-aspects.js","../../../../node_modules/.pnpm/@wesib+forms@1.0.0-beta.43_9952e2e07909aef5d5d70df955942c61/node_modules/@wesib/forms/dist/wesib.forms.js","../../../../node_modules/.pnpm/@frontmeans+style-producer@6.1.0_1eca465c0aaa87aec94c737f93123948/node_modules/@frontmeans/style-producer/dist/style-producer.js","../../../../node_modules/.pnpm/@wesib+css@1.0.0-beta.43_95213b5cede77569176d8e7a90c26d65/node_modules/@wesib/css/dist/wesib.css.js","../../../../node_modules/.pnpm/@hatsy+http-header-value@3.5.3/node_modules/@hatsy/http-header-value/dist/_http-header-value.base.js","../../../../node_modules/.pnpm/@hatsy+http-header-value@3.5.3/node_modules/@hatsy/http-header-value/dist/http-header-value.js","../../../../node_modules/.pnpm/@wesib+navigation@1.0.0-beta.43_ae282c6ae714a124522fcebbb21c97e3/node_modules/@wesib/navigation/dist/wesib.navigation.js"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","function isArrayOfElements(value) {\n    return Array.isArray(value);\n}\nfunction arrayOfElements(value) {\n    return ( /*#__INLINE__*/isArrayOfElements(value)) ? value : value != null ? [value] : [];\n}\n\n/**\n * Checks whether two values are the same. I.e. strictly equal to each other.\n *\n * @typeParam T - A type of values.\n * @param first - First value to compare.\n * @param second - Second value to compare.\n *\n * @returns `true` if `first === second`, or `false` otherwise.\n */\nfunction areTheSame(first, second) {\n    return first === second;\n}\n\n/**\n * @internal\n */\nfunction isAsyncEvaluator(value) {\n    return typeof value === 'function';\n}\n/**\n * Asynchronously evaluates a value by its recipe.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Asynchronous value evaluation recipe.\n * @param args - Parameters required for value evaluation.\n *\n * @returns A promise resolved to the value.\n */\nasync function asyncByRecipe(recipe, ...args) {\n    return ( /*#__INLINE__*/isAsyncEvaluator(recipe)) ? recipe(...args) : recipe;\n}\n/**\n * Converts asynchronous value recipe to its {@link AsyncRecipe.Evaluator evaluator} function.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Asynchronous value recipe to convert.\n *\n * @returns A function asynchronously evaluating the value.\n */\nfunction asyncRecipe(recipe) {\n    return ( /*#__INLINE__*/isAsyncEvaluator(recipe))\n        ? (async (...args) => recipe(...args))\n        : () => Promise.resolve(recipe);\n}\n\n/**\n * Creates a provider of the only argument.\n *\n * @param value - A value to return.\n *\n * @returns A function that returns `value`.\n */\nfunction valueProvider(value) {\n    return () => value;\n}\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values - Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nfunction valuesProvider(...values) {\n    return () => values;\n}\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values - Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nfunction valuesCloner(...values) {\n    return () => values.slice();\n}\n\n/**\n * Creates a provider of lazily evaluated value.\n *\n * The returned function evaluates the value first time it is called. Then it just returns previously evaluated value.\n *\n * @param provider - A no-arg function evaluating the value.\n *\n * @returns A function that returns the value evaluated by `provider`.\n */\nfunction lazyValue(provider) {\n    let get = () => {\n        get = lazyValue$recurrent; // Prevent recurrent evaluation\n        const value = provider();\n        get = valueProvider(value);\n        return value;\n    };\n    return () => get();\n}\nfunction lazyValue$recurrent() {\n    throw new TypeError('Recurrent evaluation');\n}\n\n/**\n * @internal\n */\nfunction isValueEvaluator(value) {\n    return typeof value === 'function';\n}\n/**\n * Evaluates a value by its recipe.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Value evaluation recipe.\n * @param args - Parameters required for value evaluation.\n *\n * @returns Either the value itself, or the one evaluated by the given evaluator recipe.\n */\nfunction valueByRecipe(recipe, ...args) {\n    return ( /*#__INLINE__*/isValueEvaluator(recipe)) ? recipe(...args) : recipe;\n}\n/**\n * Converts a value recipe to its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Value recipe to convert.\n *\n * @returns Either evaluator itself, or the one evaluating to the given value.\n */\nfunction valueRecipe(recipe) {\n    return ( /*#__INLINE__*/isValueEvaluator(recipe)) ? recipe : valueProvider(recipe);\n}\n\nfunction arraysAreEqual(first, second, compareOrFromOrLength, fromOrLength, to) {\n    return typeof compareOrFromOrLength === 'function'\n        ? arrayElementsAreEqual(first, second, compareOrFromOrLength, fromOrLength, to)\n        : arrayElementsAreEqual(first, second, areTheSame, compareOrFromOrLength, fromOrLength);\n}\nfunction arrayElementsAreEqual(first, second, elementsAreEqual, fromOrLength, to) {\n    let start;\n    let end;\n    if (to !== undefined) {\n        start = fromOrLength ? Math.max(fromOrLength, 0) : 0;\n        end = to != null ? to : Math.max(first.length, second.length);\n    }\n    else if (fromOrLength != null) {\n        start = 0;\n        end = fromOrLength;\n    }\n    else {\n        start = 0;\n        end = Math.max(first.length, second.length);\n    }\n    if ((first.length <= end || second.length <= end) && first.length !== second.length) {\n        return false;\n    }\n    for (let i = start; i < end; ++i) {\n        if (!elementsAreEqual(first[i], second[i], i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Builds element or array of the given elements.\n *\n * @param source - A source of elements as their iterable or array-like container.\n *\n * @returns The only element of the `source`, an array of all elements of non-empty source, or `undefined` if the\n * `source` is empty.\n */\nfunction elementOrArray(source) {\n    const array = Array.from(source);\n    const { length } = array;\n    if (length) {\n        return length === 1 ? array[0] : array;\n    }\n    return;\n}\n\n/**\n * Builds a set of the given element or array of elements.\n *\n * @param elements Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns A new set containing all of the given elements, or empty set if `elements` is `null` or `undefined`.\n */\nfunction setOfElements(elements) {\n    return ( /*#__INLINE__*/isArrayOfElements(elements))\n        ? new Set(elements)\n        : (elements != null ? new Set([elements]) : new Set());\n}\n/**\n * Adds element of array of elements to the given set.\n *\n * Adds to the set a single element, all `elements` of the given array, or nothing when `elements` is `null`\n * or `undefined`.\n *\n * @param set - Target set to add elements to.\n * @param elements - Element(s) to add to the `set`. Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns The target `set`.\n */\nfunction extendSetOfElements(set, elements) {\n    if ( /*#__INLINE__*/isArrayOfElements(elements)) {\n        elements.forEach(element => set.add(element));\n    }\n    else if (elements != null) {\n        set.add(elements);\n    }\n    return set;\n}\n\n/**\n * Detects a super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @param type - The class constructor to find super class of.\n * @param satisfying - The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nfunction superClassOf(type, satisfying = () => true) {\n    const prototype = Reflect.getPrototypeOf(type.prototype);\n    if (prototype == null) {\n        return;\n    }\n    const superType = prototype.constructor;\n    if (satisfying(superType)) {\n        return superType;\n    }\n    return superClassOf(superType, satisfying);\n}\n\n/**\n * A function that returns its argument as is.\n *\n * @param value - A value to return.\n *\n * @returns `value`.\n */\nfunction asis(value) {\n    return value;\n}\n\n/**\n * Counts meaningful arguments passed to function.\n *\n * Ignores trailing `undefined` values.\n *\n * @param args - Function call arguments tuple.\n *\n * @returns The number of arguments, except for the trailing `undefined` values.\n */\nfunction countArgs(args) {\n    let len = args.length;\n    while (len > 0) {\n        const idx = len - 1;\n        if (args[idx] !== undefined) {\n            break;\n        }\n        len = idx;\n    }\n    return len;\n}\n\nfunction mergeFunctions(first, second, merge = (_f, s) => s) {\n    if (!first) {\n        return second;\n    }\n    if (!second) {\n        return first;\n    }\n    return function (...args) {\n        return merge(first.apply(this, args), second.apply(this, args));\n    };\n}\n\n/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nfunction noop() {\n    return;\n}\n\nconst hasOwnProperty$ = Object.prototype.hasOwnProperty;\n/**\n * Checks whether the `target` object has own property with the given `key`.\n *\n * This is a safer variant of `target.hasOwnProperty(key)` call.\n *\n * @param target - Target object to check.\n * @param key - A key of the property to check.\n *\n * @returns `true` if `target` object has own property with the given `key`, or `false` otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\n */\nfunction hasOwnProperty(target, key) {\n    return hasOwnProperty$.call(target, key);\n}\n\n/**\n * Checks whether two objects have equal properties.\n *\n * @typeParam - A type of objects to check.\n * @param first - First object to check.\n * @param second - Second object to check.\n * @param valuesAreEqual - A function that compares corresponding property values. Accepts property values from both\n * objects and their key as parameters. Returns `true` if property values are equal. By default, checks property values\n * for {@link areTheSame strict equality}.\n * @param keys - Either an iterable of property keys to compare, or a function returning one. Defaults to own keys\n * (`Reflect.ownKeys`) of both objects.\n *\n * @returns `true` if `valuesAreEqual` returned `true` for each property key, or `false` otherwise.\n */\nfunction propertiesAreEqual(first, second, valuesAreEqual, keys = propertiesAreEqual$ownKeys) {\n    valuesAreEqual || (valuesAreEqual = areTheSame);\n    const keyList = typeof keys === 'function' ? keys(first, second) : keys;\n    for (const key of keyList) {\n        const value1 = first[key];\n        const value2 = second[key];\n        if (!valuesAreEqual(value1, value2, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction* propertiesAreEqual$ownKeys(first, second) {\n    const keys = new Set();\n    for (const key of Reflect.ownKeys(first)) {\n        yield key;\n        keys.add(key);\n    }\n    for (const key of Reflect.ownKeys(second)) {\n        if (!keys.has(key)) {\n            yield key;\n        }\n    }\n}\n\n/**\n * Creates a promise resolver.\n *\n * @returns New promise resolver.\n */\nfunction newPromiseResolver() {\n    let resolvePromise;\n    let rejectPromise;\n    let buildPromise = lazyValue(() => new Promise((resolve, reject) => {\n        resolvePromise = resolve;\n        rejectPromise = reject;\n    }));\n    const settle = (resolution) => {\n        buildPromise = lazyValue(resolution);\n        resolvePromise = noop;\n        rejectPromise = noop;\n    };\n    resolvePromise = value => {\n        settle(() => Promise.resolve(value));\n    };\n    rejectPromise = error => {\n        settle(() => Promise.reject(error));\n    };\n    return {\n        resolve(value) {\n            resolvePromise(value);\n        },\n        reject(reason) {\n            rejectPromise(reason);\n        },\n        promise() {\n            return buildPromise();\n        },\n    };\n}\n\n/**\n * Creates a property accessor descriptor for the given field.\n *\n * @typeParam TObject - The type of target object.\n * @typeParam TKey - Target object property keys type.\n * @param target - The object containing target field.\n * @param fieldKey - Target field key.\n */\nfunction fieldAccessorDescriptor(target, fieldKey) {\n    const value__symbol = Symbol(`${String(fieldKey)}:value`);\n    const initial = target[fieldKey];\n    return {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return value__symbol in this ? this[value__symbol] : initial;\n        },\n        set(newValue) {\n            this[value__symbol] = newValue;\n        },\n    };\n}\n\n/**\n * Converts an object field to property accessor.\n *\n * Defines a new property with the given name in the target object and returns its descriptor.\n *\n * The converted descriptor is always configurable, enumerable, and writable.\n *\n * @typeParam TObject - The type of target object.\n * @typeParam TKey - Target object property keys type.\n * @param target - The object containing target field.\n * @param fieldKey - Target field key.\n *\n * @return New property accessor descriptor.\n */\nfunction field2accessor(target, fieldKey) {\n    const desc = fieldAccessorDescriptor(target, fieldKey);\n    Reflect.defineProperty(target, fieldKey, desc);\n    return desc;\n}\n\n/**\n * Detects whether the given property descriptor is the one of property accessor.\n *\n * @typeParam TValue - Property value type.\n * @param desc - Target property descriptor.\n *\n * @return `true` if the descriptor has no `value` or `writable` attributes set.\n */\nfunction isPropertyAccessorDescriptor(desc) {\n    return desc.value === undefined && desc.writable === undefined;\n}\n/**\n * Converts a property descriptor to property accessor descriptor.\n *\n * @typeParam TValue - Property value type.\n * @param desc - Target property descriptor.\n *\n * @return Either an accessor descriptor constructed from data descriptor, or `desc` if it is an accessor descriptor\n * already.\n */\nfunction toPropertyAccessorDescriptor(desc) {\n    if (isPropertyAccessorDescriptor(desc)) {\n        return desc;\n    }\n    const value__symbol = Symbol('value');\n    const initial = desc.value;\n    const accessorDesc = {\n        ...desc,\n        writable: undefined,\n        value: undefined,\n        get() {\n            return value__symbol in this ? this[value__symbol] : initial;\n        },\n    };\n    if (desc.writable) {\n        accessorDesc.set = function (newValue) {\n            this[value__symbol] = newValue;\n        };\n    }\n    delete accessorDesc.writable;\n    delete accessorDesc.value;\n    return accessorDesc;\n}\n\n/**\n * Checks whether the given value is array-like.\n *\n * @typeParam TElement - Array elements type.\n * @typeParam TOther - Non-array value type.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` has a `length` property, or `false` otherwise.\n */\nfunction isArrayLike(value) {\n    return !!value && typeof value === 'object' && typeof value.length === 'number';\n}\n\n/**\n * Checks whether the given object is iterable.\n *\n * @typeParam TElement - Iterable elements type.\n * @typeParam TOther - Non-iterable value type.\n * @param value - An object value to check.\n *\n * @returns `true` if the `value` has a `[Symbol.iterator]` property set, or `false` otherwise.\n */\nfunction isIterable(value) {\n    return !!value[Symbol.iterator];\n}\n\n/**\n * A function that checks whether the given value is present.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nfunction isPresent(value) {\n    return value != null;\n}\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nfunction isNotPresent(value) {\n    return value == null;\n}\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nfunction isDefined(value) {\n    return value !== undefined;\n}\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nfunction isUndefined(value) {\n    return value === undefined;\n}\n\nexport { areTheSame, arrayOfElements, arraysAreEqual, asis, asyncByRecipe, asyncRecipe, countArgs, elementOrArray, extendSetOfElements, field2accessor, fieldAccessorDescriptor, hasOwnProperty, isArrayLike, isArrayOfElements, isDefined, isIterable, isNotPresent, isPresent, isPropertyAccessorDescriptor, isUndefined, lazyValue, mergeFunctions, newPromiseResolver, noop, propertiesAreEqual, setOfElements, superClassOf, toPropertyAccessorDescriptor, valueByRecipe, valueProvider, valueRecipe, valuesCloner, valuesProvider };\n//# sourceMappingURL=primitives.js.map\n","/**\n * A key of {@link PushIterable} iteration method.\n */\nconst PushIterator__symbol = ( /*#__PURE__*/Symbol('push-iterator'));\n\nfunction isPushIterable(iterable) {\n    return !!iterable[PushIterator__symbol];\n}\n\nfunction iteratorOf(iterable) {\n    return iterable[Symbol.iterator]();\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a push iterable implementation.\n *\n * @typeParam T - Iterated elements type.\n * @param iterate - A function iterating over iterable elements conforming to {@link PushIterable.Iterate} requirements.\n *\n * @returns New push iterable instance performing iteration by `forNext` function.\n */\nfunction makePushIterable(iterate) {\n    return {\n        [Symbol.iterator]: PushIterable$iterator,\n        [PushIterator__symbol]: iterate,\n    };\n}\n/**\n * @internal\n */\nfunction PushIterable$iterator() {\n    return this[PushIterator__symbol]();\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Iterates over elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `!iterable[PushIterator__symbol](accept).isOver()`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nfunction pushIterated(iterable, accept) {\n    return !iterable[PushIterator__symbol](accept).isOver();\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a push iterator implementation.\n *\n * @typeParam T - Iterated elements type.\n * @param forNext - A function iterating over elements conforming to push iteration protocol.\n *\n * @returns New push iterator instance performing iteration by `forNext` function.\n */\nfunction makePushIterator(forNext) {\n    let over = false;\n    let iterate = (accept) => {\n        if (accept && !forNext(accept)) {\n            over = true;\n            iterate = PushIterator$dontIterate;\n        }\n    };\n    return {\n        [Symbol.iterator]: PushIterator$iterator,\n        [PushIterator__symbol](accept) {\n            iterate(accept);\n            return this;\n        },\n        next: PushIterator$next,\n        isOver: () => over,\n    };\n}\n/**\n * @internal\n */\nfunction PushIterator$iterator() {\n    return this;\n}\n/**\n * @internal\n */\nfunction PushIterator$next() {\n    for (;;) {\n        let result;\n        const over = !pushIterated(this, value => {\n            result = { value };\n            return true;\n        });\n        if (result) {\n            return result;\n        }\n        if (over) {\n            return { done: true };\n        }\n    }\n}\n/**\n * @internal\n */\nfunction PushIterator$noNext() {\n    return { done: true };\n}\n/**\n * @internal\n */\nfunction PushIterator$dontIterate(_accept) {\n    /* do not iterate */\n}\n/**\n * @internal\n */\nconst emptyPushIterator = {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](_accept) {\n        return this;\n    },\n    next: () => ({ done: true }),\n    isOver: () => true,\n};\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Iterates over the head elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `iterable[PushIterator__symbol](accept)`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nfunction pushHead(iterable, accept) {\n    return iterable[PushIterator__symbol](accept);\n}\n\n/**\n * @internal\n */\nfunction indexedItemOf(indexed, index) {\n    return indexed.item(index); // The index is always valid.\n}\n/**\n * @internal\n */\nfunction iterateOverIndexed(indexed, elementOf) {\n    return accept => {\n        let i = 0;\n        const forNext = (accept) => {\n            if (i >= indexed.length) {\n                return false;\n            }\n            for (;;) {\n                const goOn = accept(elementOf(indexed, i++));\n                if (i >= indexed.length || goOn === false) {\n                    return false;\n                }\n                if (goOn === true) {\n                    return true;\n                }\n            }\n        };\n        if (accept && !forNext(accept)) {\n            return emptyPushIterator;\n        }\n        let over = false;\n        let iterate = (accept) => {\n            if (accept && !forNext(accept)) {\n                over = true;\n                iterate = PushIterator$dontIterate;\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                next = PushIterator$noNext;\n            }\n        };\n        let next = () => {\n            if (i < indexed.length) {\n                return { value: elementOf(indexed, i++) };\n            }\n            over = true;\n            iterate = PushIterator$dontIterate;\n            next = PushIterator$noNext;\n            return { done: true };\n        };\n        return {\n            [Symbol.iterator]: PushIterator$iterator,\n            [PushIterator__symbol](accept) {\n                iterate(accept);\n                return this;\n            },\n            next: () => next(),\n            isOver: () => over,\n        };\n    };\n}\n\n/**\n * @internal\n */\nfunction arrayElementOf(array, index) {\n    return array[index];\n}\n/**\n * @internal\n */\nfunction iterateOverArray(array) {\n    return iterateOverIndexed(array, arrayElementOf);\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} over elements of array-like structure.\n *\n * @typeParam T - Array elements type.\n * @param array - An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns New push iterable over array elements.\n */\nfunction overArray(array) {\n    return makePushIterable(iterateOverArray(array));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushIterated} function, this one accepts any iterable instance.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nfunction itsIterated(iterable, accept) {\n    if (isPushIterable(iterable)) {\n        return pushIterated(iterable, accept);\n    }\n    const it = iteratorOf(iterable);\n    if (isPushIterable(it)) {\n        return pushIterated(it, accept);\n    }\n    for (;;) {\n        const next = it.next();\n        if (next.done) {\n            return false;\n        }\n        const status = accept(next.value);\n        if (typeof status === 'boolean') {\n            return status;\n        }\n    }\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable of elements to perform actions on.\n * @param action - An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nfunction itsEach(iterable, action) {\n    itsIterated(iterable, element => { action(element); });\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * @internal\n */\nconst itsElements$defaultConverter = (element) => element;\nfunction itsElements(source, convert = itsElements$defaultConverter) {\n    if (isPushIterable(source)) {\n        return pushedElements(source, convert);\n    }\n    const it = iteratorOf(source);\n    return isPushIterable(it) ? pushedElements(it, convert) : Array.from(source, convert);\n}\n/**\n * @internal\n */\nfunction pushedElements(it, convert) {\n    const result = [];\n    pushIterated(it, element => { result.push(convert(element)); });\n    return result;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable - An iterable or push iterable to check for elements.\n *\n * @returns `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nfunction itsEmpty(iterable) {\n    if (isPushIterable(iterable)) {\n        return pushedEmpty(iterable);\n    }\n    const it = iteratorOf(iterable);\n    return isPushIterable(it) ? pushedEmpty(it) : !!it.next().done;\n}\n/**\n * @internal\n */\nfunction pushedEmpty(it) {\n    let isEmpty = true;\n    pushIterated(it, _element /* Unused parameter to prevent deoptimization */ => isEmpty = false);\n    return isEmpty;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to test elements of.\n * @param test - A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nfunction itsEvery(iterable, test) {\n    let allMatch = true;\n    itsIterated(iterable, element => {\n        allMatch = !!test(element);\n        if (!allMatch) {\n            return false;\n        }\n        return;\n    });\n    return allMatch;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Searches for the value in `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @typeParam TFound - Found value type.\n * @param iterable - An iterable to extract element from.\n * @param search - A function extracting the value from elements. It is called for each iterated element until the value\n * found. Accepts element as the only parameter, and returns extracted value. If returns `false` or `undefined` the\n * search continues from the next element.\n *\n * @returns Either found value or `undefined`.\n */\nfunction itsFind(iterable, search) {\n    let find;\n    itsIterated(iterable, element => {\n        const result = search(element);\n        if (result !== false && result !== undefined) {\n            find = result;\n            return true;\n        }\n        return;\n    });\n    return find;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Extracts the first element of the given `iterable`, if any.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to extract element from.\n *\n * @returns Either the first element, or `undefined` if the given `iterable` is empty.\n */\nfunction itsFirst(iterable) {\n    if (isPushIterable(iterable)) {\n        return pushedFirst(iterable);\n    }\n    const it = iteratorOf(iterable);\n    return isPushIterable(it) ? pushedFirst(it) : rawFirst(it);\n}\n/**\n * @internal\n */\nfunction pushedFirst(it) {\n    let first;\n    pushIterated(it, element => {\n        first = element;\n        return false;\n    });\n    return first;\n}\n/**\n * @internal\n */\nfunction rawFirst(it) {\n    const result = it.next();\n    return result.done ? undefined : result.value;\n}\n\n/**\n * @internal\n */\nfunction toPushIterator(it, forNext) {\n    let over = false;\n    let iterate = (accept) => {\n        if ((over = !!accept && !forNext(accept))) {\n            iterate = PushIterator$dontIterate;\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            next = PushIterator$noNext;\n        }\n    };\n    let next = () => {\n        const res = it.next();\n        if (res.done) {\n            over = true;\n            iterate = PushIterator$dontIterate;\n            next = PushIterator$noNext;\n        }\n        return res;\n    };\n    return {\n        [Symbol.iterator]: PushIterator$iterator,\n        [PushIterator__symbol](accept) {\n            iterate(accept);\n            return this;\n        },\n        next() {\n            return next();\n        },\n        isOver: () => over,\n    };\n}\n/**\n * @internal\n */\nfunction rawIteratorPusher(it) {\n    return accept => {\n        for (;;) {\n            const res = it.next();\n            if (res.done) {\n                return false;\n            }\n            const status = accept(res.value);\n            if (typeof status === 'boolean') {\n                return status;\n            }\n        }\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushHead} function, this one accepts any iterable instance.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nfunction itsHead(iterable, accept) {\n    if (isPushIterable(iterable)) {\n        return pushHead(iterable, accept);\n    }\n    if (Array.isArray(iterable)) {\n        return arrayHead(iterable, accept);\n    }\n    return rawIterableHead(iterable, accept);\n}\n/**\n * @internal\n */\nfunction arrayHead(array, accept) {\n    return array.length ? iterateOverArray(array)(accept) : emptyPushIterator;\n}\n/**\n * @internal\n */\nfunction rawIterableHead(iterable, accept) {\n    const it = iteratorOf(iterable);\n    if (isPushIterable(it)) {\n        return pushHead(it, accept);\n    }\n    const forEach = rawIteratorPusher(it);\n    return forEach(accept) ? toPushIterator(it, forEach) : emptyPushIterator;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Starts iteration over the given `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable or push iterable to iterate over.\n *\n * @returns A push iterator iterating over the given iterable.\n */\nfunction itsIterator(iterable) {\n    const it = iteratorOf(iterable);\n    return isPushIterable(it) ? it : toPushIterator(it, rawIteratorPusher(it));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Extracts the first element matching the given condition from `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to extract element from.\n * @param test - A predicate function to test elements. Returns truthy value for matching one. It accepts the tested\n * element as the only parameter.\n *\n * @returns Either the matching element, or `undefined` if no elements match.\n */\nfunction itsMatch(iterable, test) {\n    let match;\n    itsIterated(iterable, element => {\n        if (test(element)) {\n            match = element;\n            return true;\n        }\n        return;\n    });\n    return match;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeParam T - Iterated elements type.\n * @typeParam TResult - A type of reduced value.\n * @param iterable - An iterable to reduce values of.\n * @param reducer - A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue - Initial value passed to the first `reducer` call.\n *\n * @returns Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nfunction itsReduction(iterable, reducer, initialValue) {\n    let reduced = initialValue;\n    itsIterated(iterable, element => { reduced = reducer(reduced, element); });\n    return reduced;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Tests whether at least one element of the given `iterable` passes the test implemented by the provided function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to test elements of.\n * @param test - A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n * and return `true` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the callback function returned a truthy value for at least one element in the array, or `false`\n * otherwise. Returns `false` for empty iterable.\n */\nfunction itsSome(iterable, test) {\n    let someMatches = false;\n    itsIterated(iterable, element => {\n        someMatches = !!test(element);\n        if (someMatches) {\n            return false;\n        }\n        return;\n    });\n    return someMatches;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Returns a {@link PushIterator | push iterable iterator} without elements.\n *\n * @typeParam T - Iterated elements type.\n *\n * @returns Empty push iterable and push iterator instance.\n */\nfunction overNone() {\n    return emptyPushIterator;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} over elements of iterator created by the given function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterate - A function creating new iterator.\n *\n * @returns New push iterable over elements of created iterator.\n */\nfunction overIterator(iterate) {\n    return makePushIterable(iterateOverRawIterator(iterate));\n}\n/**\n * @internal\n */\nfunction iterateOverRawIterator(iterate) {\n    return accept => {\n        const it = iterate();\n        if (isPushIterable(it)) {\n            return it[PushIterator__symbol](accept);\n        }\n        const forNext = rawIteratorPusher(it);\n        return accept && !forNext(accept) ? overNone() : toPushIterator(it, forNext);\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} over elements of the given raw iterable.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `iterable`.\n */\nfunction overIterable(iterable) {\n    return Array.isArray(iterable)\n        ? overArray(iterable)\n        : overIterator(() => iteratorOf(iterable));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} over elements of other iterables.\n *\n * @typeParam T - Iterated elements type.\n * @param sources - Source iterables to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `sources`.\n */\nfunction overElementsOf(...sources) {\n    return sources.length > 1\n        ? makePushIterable(iterateOverSubElements(sources))\n        : (sources.length\n            ? overIterable(sources[0])\n            : overNone());\n}\n/**\n * @internal\n */\nfunction iterateOverSubElements(sources) {\n    return accept => {\n        let i = 0;\n        let src = sources[0];\n        const forNext = (accept) => {\n            for (;;) {\n                // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n                let status;\n                const srcTail = itsHead(src, element => status = accept(element));\n                if (srcTail.isOver()) {\n                    if (++i >= sources.length) {\n                        return false;\n                    }\n                    src = sources[i];\n                }\n                else {\n                    src = srcTail;\n                }\n                if (typeof status === 'boolean') {\n                    return status;\n                }\n            }\n        };\n        return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} over items of {@link IndexedItemList | indexed list}.\n *\n * @typeParam T - Indexed items type.\n * @param indexed - An indexed list of items. E.g. DOM `NodeList`.\n *\n * @returns New push iterable over list items.\n */\nfunction overIndexed(indexed) {\n    return makePushIterable(iterateOverIndexed(indexed, indexedItemOf));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} over one value.\n *\n * @typeParam T - Iterated element value type.\n * @param value - A value to iterate over.\n *\n * @returns New push iterable over the given value.\n */\nfunction overOne(value) {\n    return makePushIterable(iterateOverOneValue(value));\n}\n/**\n * @internal\n */\nfunction iterateOverOneValue(value) {\n    return accept => {\n        if (accept) {\n            accept(value);\n            return overNone();\n        }\n        let over = false;\n        return {\n            [Symbol.iterator]: PushIterator$iterator,\n            [PushIterator__symbol](accept) {\n                if (over) {\n                    return overNone();\n                }\n                if (accept) {\n                    over = true;\n                    accept(value);\n                    return overNone();\n                }\n                return this;\n            },\n            next() {\n                if (over) {\n                    return { done: over };\n                }\n                over = true;\n                return { value };\n            },\n            isOver: () => over,\n        };\n    };\n}\n\n/**\n * Creates a {@link PushIterable | push iterable} over many values.\n *\n * @typeParam T - Iterated elements value type.\n * @param values - Values to iterate over.\n *\n * @returns New push iterable over the given values.\n */\nfunction overMany(...values) {\n    return values.length > 1\n        ? overArray(values)\n        : (values.length\n            ? overOne(values[0])\n            : overNone());\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} over elements of array-like structure in reverse order.\n *\n * @typeParam T - Array elements type.\n * @param array - An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns New push iterable over array elements in reverse order.\n */\nfunction reverseArray(array) {\n    return makePushIterable(iterateOverArrayReversely(array));\n}\n/**\n * @internal\n */\nfunction iterateOverArrayReversely(array) {\n    return accept => {\n        let i = array.length - 1;\n        const forNext = (accept) => {\n            if (i < 0) {\n                return false;\n            }\n            for (;;) {\n                const status = accept(array[i--]);\n                if (i < 0) {\n                    return false;\n                }\n                if (typeof status === 'boolean') {\n                    return true;\n                }\n            }\n        };\n        if (accept && !forNext(accept)) {\n            return overNone();\n        }\n        let over = false;\n        let iterate = (accept) => {\n            if (accept && !forNext(accept)) {\n                over = true;\n                iterate = PushIterator$dontIterate;\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                next = PushIterator$noNext;\n            }\n        };\n        let next = () => {\n            if (i < 0) {\n                over = true;\n                iterate = PushIterator$dontIterate;\n                next = PushIterator$noNext;\n                return { done: true };\n            }\n            return { value: array[i--] };\n        };\n        return {\n            [Symbol.iterator]: PushIterator$iterator,\n            [PushIterator__symbol](accept) {\n                iterate(accept);\n                return this;\n            },\n            next: () => next(),\n            isOver: () => over,\n        };\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} over keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam TObj - Source object type.\n * @param source - An object to select keys from.\n *\n * @returns New push iterable over own object keys retrieved by `Reflect.ownKeys()`.\n */\nfunction overKeys(source) {\n    return overArray(Reflect.ownKeys(source));\n}\n\n/**\n * @internal\n */\nfunction iterateOverFilteredIndexed(indexed, elementOf, test) {\n    return accept => {\n        let i = 0;\n        const forNext = (accept) => {\n            for (;;) {\n                if (i >= indexed.length) {\n                    return false;\n                }\n                const value = elementOf(indexed, i++);\n                if (test(value)) {\n                    const status = accept(value);\n                    if (typeof status === 'boolean') {\n                        return status;\n                    }\n                }\n            }\n        };\n        if (accept && !forNext(accept)) {\n            return overNone();\n        }\n        let over = false;\n        let iterate = (accept) => {\n            if (accept && !forNext(accept)) {\n                over = true;\n                iterate = PushIterator$dontIterate;\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                next = PushIterator$noNext;\n            }\n        };\n        let next = () => {\n            for (;;) {\n                if (i >= indexed.length) {\n                    over = true;\n                    iterate = PushIterator$dontIterate;\n                    next = PushIterator$noNext;\n                    return { done: true };\n                }\n                const value = elementOf(indexed, i++);\n                if (test(value)) {\n                    return { value };\n                }\n            }\n        };\n        return {\n            [Symbol.iterator]: PushIterator$iterator,\n            [PushIterator__symbol](accept) {\n                iterate(accept);\n                return this;\n            },\n            next: () => next(),\n            isOver: () => over,\n        };\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nfunction filterArray(array, test) {\n    return makePushIterable(iterateOverFilteredIndexed(array, arrayElementOf, test));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nfunction filterIndexed(indexed, test) {\n    return makePushIterable(iterateOverFilteredIndexed(indexed, indexedItemOf, test));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nfunction filterIt(source, test) {\n    return makePushIterable(accept => {\n        const forNext = isPushIterable(source) ? filterPusher(source, test) : filterRawPusher(source, test);\n        return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n    });\n}\n/**\n * @internal\n */\nfunction filterPusher(source, test) {\n    return accept => {\n        const tail = pushHead(source, element => {\n            if (test(element)) {\n                return accept(element);\n            }\n            return;\n        });\n        source = tail;\n        return !tail.isOver();\n    };\n}\n/**\n * @internal\n */\nfunction filterRawPusher(source, test) {\n    const it = iteratorOf(source);\n    if (isPushIterable(it)) {\n        return filterPusher(it, test);\n    }\n    return accept => {\n        for (;;) {\n            const next = it.next();\n            if (next.done) {\n                return false;\n            }\n            const value = next.value;\n            if (test(value)) {\n                const status = accept(value);\n                if (typeof status === 'boolean') {\n                    return status;\n                }\n            }\n        }\n    };\n}\n\n/**\n * @internal\n */\nfunction iterateOverFlattenedIndexed(indexed, elementsOf) {\n    return accept => {\n        let i = 0;\n        let subs;\n        const forNext = (accept) => {\n            if (i >= indexed.length) {\n                return false;\n            }\n            if (!subs) {\n                subs = elementsOf(indexed, i);\n            }\n            for (;;) {\n                let status;\n                const subsTail = itsHead(subs, element => status = accept(element));\n                if (subsTail.isOver()) {\n                    if (++i >= indexed.length) {\n                        return false;\n                    }\n                    subs = elementsOf(indexed, i);\n                }\n                else {\n                    subs = subsTail;\n                }\n                if (typeof status === 'boolean') {\n                    return status;\n                }\n            }\n        };\n        return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nfunction flatMapArray(array, convert) {\n    return makePushIterable(iterateOverFlattenedIndexed(array, convert\n        ? (array, index) => convert(array[index])\n        : flatMapArray$defaultElementOf));\n}\n/**\n * @internal\n */\nfunction flatMapArray$defaultElementOf(array, index) {\n    return array[index];\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nfunction flatMapIndexed(indexed, convert) {\n    return makePushIterable(iterateOverFlattenedIndexed(indexed, convert\n        ? (indexed, index) => convert(indexed.item(index))\n        : flatMapIndexed$defaultElementOf));\n}\n/**\n * @internal\n */\nfunction flatMapIndexed$defaultElementOf(indexed, index) {\n    return indexed.item(index);\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nfunction flatMapIt(source, convert = flatMapIt$defaultConverter) {\n    return makePushIterable(accept => {\n        const forNext = isPushIterable(source) ? flatMapPusher(source, convert) : flatMapRawPusher(source, convert);\n        return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n    });\n}\n/**\n * @internal\n */\nfunction flatMapPusher(source, convert) {\n    let subs;\n    let lastSrc = false;\n    return accept => {\n        for (;;) {\n            while (!subs) {\n                const sourceTail = pushHead(source, src => {\n                    subs = convert(src);\n                    return true;\n                });\n                source = sourceTail;\n                if (sourceTail.isOver()) {\n                    if (!subs) {\n                        return false;\n                    }\n                    lastSrc = true;\n                }\n            }\n            // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n            let status;\n            const subsTail = itsHead(subs, element => status = accept(element));\n            if (subsTail.isOver()) {\n                subs = undefined;\n                if (lastSrc) {\n                    return false;\n                }\n            }\n            else {\n                subs = subsTail;\n            }\n            if (typeof status === 'boolean') {\n                return status;\n            }\n        }\n    };\n}\n/**\n * @internal\n */\nfunction flatMapRawPusher(source, convert) {\n    const it = iteratorOf(source);\n    if (isPushIterable(it)) {\n        return flatMapPusher(it, convert);\n    }\n    let subs;\n    return accept => {\n        for (;;) {\n            if (!subs) {\n                const next = it.next();\n                if (next.done) {\n                    return false;\n                }\n                subs = convert(next.value);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n            let status;\n            const subsTail = itsHead(subs, element => status = accept(element));\n            subs = subsTail.isOver() ? undefined : subsTail;\n            if (typeof status === 'boolean') {\n                return status;\n            }\n        }\n    };\n}\n/**\n * @internal\n */\nfunction flatMapIt$defaultConverter(element) {\n    return element;\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} with the results of calling a provided function on every element\n * of the given `array`.\n *\n * @typeParam TSrc - A type of array elements.\n * @typeParam TConv - A type of converted elements.\n * @param array - A source array-like instance.\n * @param convert - A function that produces an element of new iterable, taking array element as the only parameter.\n *\n * @returns New push iterable of transformed elements.\n */\nfunction mapArray(array, convert) {\n    return makePushIterable(iterateOverIndexed(array, (array, index) => convert(array[index])));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} with the results of calling a provided function on every item of the\n * given indexed list.\n *\n * @typeParam TSrc - A type of indexed list items.\n * @typeParam TConv - A type of converted elements.\n * @param indexed - A source indexed items list.\n * @param convert - A function that produces an element of new iterable, taking list item as the only parameter.\n *\n * @returns New push iterable of transformed elements.\n */\nfunction mapIndexed(indexed, convert) {\n    return makePushIterable(iterateOverIndexed(indexed, (list, index) => convert(list.item(index) /* The index is always valid */)));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} with the results of calling a provided function on every element\n * of the `source` iterable.\n *\n * @typeParam TSrc - A type of source elements.\n * @typeParam TConv - A type of converted elements.\n * @param source - A source iterable.\n * @param convert - A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n *\n * @returns New push iterable of transformed elements.\n */\nfunction mapIt(source, convert) {\n    return makePushIterable(accept => {\n        const forNext = isPushIterable(source) ? mapPusher(source, convert) : mapRawPusher(source, convert);\n        return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n    });\n}\n/**\n * @internal\n */\nfunction mapPusher(source, convert) {\n    return accept => {\n        const tail = pushHead(source, element => accept(convert(element)));\n        source = tail;\n        return !tail.isOver();\n    };\n}\n/**\n * @internal\n */\nfunction mapRawPusher(source, convert) {\n    const it = iteratorOf(source);\n    if (isPushIterable(it)) {\n        return mapPusher(it, convert);\n    }\n    return accept => {\n        for (;;) {\n            const next = it.next();\n            if (next.done) {\n                return false;\n            }\n            const status = accept(convert(next.value));\n            if (typeof status === 'boolean') {\n                return status;\n            }\n        }\n    };\n}\n\n/**\n * @internal\n */\nfunction iterateOverValuedIndexed(indexed, elementOf, valueOf) {\n    return accept => {\n        let i = 0;\n        const forNext = (accept) => {\n            for (;;) {\n                if (i >= indexed.length) {\n                    return false;\n                }\n                const value = valueOf(elementOf(indexed, i++));\n                if (value != null && value !== false) {\n                    const status = accept(value);\n                    if (typeof status === 'boolean') {\n                        return status;\n                    }\n                }\n            }\n        };\n        if (accept && !forNext(accept)) {\n            return overNone();\n        }\n        let over = false;\n        let iterate = (accept) => {\n            if (accept && !forNext(accept)) {\n                over = true;\n                iterate = PushIterator$dontIterate;\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                next = PushIterator$noNext;\n            }\n        };\n        let next = () => {\n            for (;;) {\n                if (i >= indexed.length) {\n                    over = true;\n                    iterate = PushIterator$dontIterate;\n                    next = PushIterator$noNext;\n                    return { done: true };\n                }\n                const value = valueOf(elementOf(indexed, i++));\n                if (value != null && value !== false) {\n                    return { value };\n                }\n            }\n        };\n        return {\n            [Symbol.iterator]: PushIterator$iterator,\n            [PushIterator__symbol](accept) {\n                iterate(accept);\n                return this;\n            },\n            next: () => next(),\n            isOver: () => over,\n        };\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} with the values of elements of the given `array`.\n *\n * Element value is the result of provided function call, except `false`, `null`, and `undefined` which are filtered\n * out.\n *\n * This can be used as a more effective {@link mapArray} / {@link filterIt} combination.\n *\n * @typeParam T - A type of array elements.\n * @typeParam TValue - A type of array element values.\n * @param array - A source array.\n * @param valueOf - A function that values elements, taking the source element as the only parameter, and returning\n * either its value, or `false`/`null`/`undefined` to filter it out.\n *\n * @returns New push iterable with array element values.\n */\nfunction valueArray(array, valueOf) {\n    return makePushIterable(iterateOverValuedIndexed(array, arrayElementOf, valueOf));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} with the values of items of the given indexed list.\n *\n * Item value is the result of provided function call, except `false`, `null`, and `undefined` which are filtered out.\n *\n * This can be used as a more effective {@link mapIndexed} / {@link filterIt} combination.\n *\n * @typeParam T - Indexed items type.\n * @typeParam TValue - A type of item values.\n * @param indexed - A source indexed items list.\n * @param valueOf - A function that values items, taking the source item as the only parameter, and returning either\n * its value, or `false`/`null`/`undefined` to filter it out.\n *\n * @returns New push iterable with the item values.\n */\nfunction valueIndexed(indexed, valueOf) {\n    return makePushIterable(iterateOverValuedIndexed(indexed, indexedItemOf, valueOf));\n}\n\n/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\n/**\n * Creates a {@link PushIterable | push iterable} with the values of elements of the `source` iterable.\n *\n * Element value is the result of provided function call, except `false`, `null`, and `undefined` which are filtered\n * out.\n *\n * This can be used as a more effective {@link mapIt} / {@link filterIt} combination.\n *\n * @typeParam T - A type of source elements.\n * @typeParam TValue - A type of source element values.\n * @param source - A source iterable.\n * @param valueOf - A function that values elements, taking the source element as the only parameter, and returning\n * either its value, or `false`/`null`/`undefined` to filter it out.\n *\n * @returns New push iterable with the element values.\n */\nfunction valueIt(source, valueOf) {\n    return makePushIterable(accept => {\n        const forNext = isPushIterable(source) ? valuePusher(source, valueOf) : valueRawPusher(source, valueOf);\n        return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n    });\n}\n/**\n * @internal\n */\nfunction valuePusher(source, valueOf) {\n    return accept => {\n        const tail = pushHead(source, element => {\n            const value = valueOf(element);\n            if (value != null && value !== false) {\n                return accept(value);\n            }\n            return;\n        });\n        source = tail;\n        return !tail.isOver();\n    };\n}\n/**\n * @internal\n */\nfunction valueRawPusher(source, valueOf) {\n    const it = iteratorOf(source);\n    if (isPushIterable(it)) {\n        return valuePusher(it, valueOf);\n    }\n    return accept => {\n        for (;;) {\n            const next = it.next();\n            if (next.done) {\n                return false;\n            }\n            const value = valueOf(next.value);\n            if (value != null && value !== false) {\n                const status = accept(value);\n                if (typeof status === 'boolean') {\n                    return status;\n                }\n            }\n        }\n    };\n}\n\n/**\n * Creates a {@link PushIterable | push iterable} over the property key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam TObj - Object type.\n *\n * @param source - An object to select keys and values from.\n *\n * @returns New push iterable of object property entries.\n */\nfunction overEntries(source) {\n    return mapIt(overKeys(source), key => [key, source[key]]);\n}\n\nexport { PushIterator__symbol, filterArray, filterIndexed, filterIt, flatMapArray, flatMapIndexed, flatMapIt, isPushIterable, iteratorOf, itsEach, itsElements, itsEmpty, itsEvery, itsFind, itsFirst, itsHead, itsIterated, itsIterator, itsMatch, itsReduction, itsSome, makePushIterable, makePushIterator, mapArray, mapIndexed, mapIt, overArray, overElementsOf, overEntries, overIndexed, overIterable, overIterator, overKeys, overMany, overNone, overOne, pushHead, pushIterated, reverseArray, valueArray, valueIndexed, valueIt };\n//# sourceMappingURL=push-iterator.js.map\n","/**\n * @internal\n */\nlet Supply$unexpectedAbort = Supply$unexpectedAbort$byDefault;\n/**\n * @internal\n */\nfunction Supply$unexpectedAbort$handle(handler = Supply$unexpectedAbort$byDefault) {\n    Supply$unexpectedAbort = handler;\n}\nfunction Supply$unexpectedAbort$byDefault(reason) {\n    console.error('Supply aborted unexpectedly.', reason);\n}\n\nlet Supply$off = false;\nlet Supply$off$unexpected$reasons;\n/**\n * @internal\n */\nfunction Supply$off$start() {\n    const prevOff = Supply$off;\n    Supply$off = true;\n    return prevOff;\n}\n/**\n * @internal\n */\nfunction Supply$off$unexpected(reason) {\n    if (reason !== undefined) {\n        if (!Supply$off$unexpected$reasons) {\n            Supply$off$unexpected$reasons = new Set();\n        }\n        Supply$off$unexpected$reasons.add(reason);\n    }\n}\n/**\n * @internal\n */\nfunction Supply$off$end(prevOff) {\n    Supply$off = prevOff;\n    if (!prevOff) {\n        const reasons = Supply$off$unexpected$reasons;\n        if (reasons) {\n            Supply$off$unexpected$reasons = undefined;\n            for (const reason of reasons) {\n                Supply$unexpectedAbort(reason);\n            }\n        }\n    }\n}\n\n/**\n * @internal\n */\nconst SupplyState__symbol = ( /*#__PURE__*/Symbol('SupplyState'));\nconst SupplyState$done = {\n    isOff: true,\n    off: SupplyState$done$off,\n    whenOff(_supply, callback) {\n        callback();\n    },\n};\nfunction SupplyState$off(reason) {\n    if (reason === undefined) {\n        return SupplyState$done;\n    }\n    return {\n        isOff: true,\n        off: SupplyState$done$off,\n        whenOff(_supply, callback) {\n            callback(reason);\n        },\n    };\n}\nfunction SupplyState$done$off(_supply, _reason) {\n    /* no off */\n}\n/**\n * @internal\n */\nconst SupplyState$noCallback = {\n    isOff: false,\n    off(supply, reason) {\n        const prevOff = Supply$off$start();\n        try {\n            supply[SupplyState__symbol] = SupplyState$off(reason);\n            Supply$off$unexpected(reason);\n        }\n        finally {\n            Supply$off$end(prevOff);\n        }\n    },\n    whenOff(supply, callback) {\n        supply[SupplyState__symbol] = SupplyState$withCallback(callback);\n    },\n};\n/**\n * @internal\n */\nfunction SupplyState$withCallback(off) {\n    return {\n        isOff: false,\n        off(supply, reason) {\n            const prevOff = Supply$off$start();\n            try {\n                supply[SupplyState__symbol] = SupplyState$off(reason);\n                off(reason);\n            }\n            finally {\n                Supply$off$end(prevOff);\n            }\n        },\n        whenOff(_supply, callback) {\n            const prev = off;\n            off = reason => {\n                prev(reason);\n                callback(reason);\n            };\n        },\n    };\n}\n\n/**\n * Supply handle.\n *\n * Represents a supply of something.\n *\n * The supply can be {@link off cut off}, and can {@link whenOff inform} on cutting off.\n */\nclass Supply {\n    /**\n     * Constructs new supply instance.\n     *\n     * @param off - A function to call when the supply is {@link Supply.off cut off}. Accepts optional cut off reason\n     * as its only parameter. No-op by default.\n     */\n    constructor(off) {\n        this[SupplyState__symbol] = off ? SupplyState$withCallback(off) : SupplyState$noCallback;\n    }\n    /**\n     * Assigns unexpected abort handler.\n     *\n     * When a supply {@link off aborted}, and there is no {@link whenOff cut off callback} registered, the given handler\n     * will be called with the abort reason.\n     *\n     * By default, the unexpected abort reason will be logged to console.\n     *\n     * @param handler - A handler to call on unexpected abort, or `undefined` to reset to default one.\n     */\n    static onUnexpectedAbort(handler) {\n        Supply$unexpectedAbort$handle(handler);\n    }\n    /**\n     * `this` supply instance.\n     */\n    get supply() {\n        return this;\n    }\n    /**\n     * Whether this supply is {@link off cut off} already.\n     *\n     * `true` means nothing would be supplied any more.\n     */\n    get isOff() {\n        return this[SupplyState__symbol].isOff;\n    }\n    /**\n     * Cuts off this supply.\n     *\n     * After this method call nothing would be supplied any more.\n     *\n     * Calling this method for the second time has no effect.\n     *\n     * @param reason - An optional reason why the supply is cut off. It will be reported to {@link whenOff} callbacks.\n     * By convenience, an absent reason means the supply is done successfully.\n     *\n     * @returns The cut off supply instance.\n     */\n    off(reason) {\n        this[SupplyState__symbol].off(this, reason);\n        return this;\n    }\n    /**\n     * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n     * will be called immediately if {@link isOff} is `true`.\n     *\n     * @param callback - A callback function accepting optional cut off reason as its only parameter.\n     * By convenience an `undefined` reason means the supply is done successfully.\n     *\n     * @returns `this` instance.\n     */\n    whenOff(callback) {\n        this[SupplyState__symbol].whenOff(this, callback);\n        return this;\n    }\n    /**\n     * Builds a promise that will be resolved once this supply is {@link off done}.\n     *\n     * @returns A promise that will be successfully resolved once this supply is cut off without a reason, or rejected\n     * once this supply is cut off with any reason except `undefined`.\n     */\n    whenDone() {\n        return new Promise((resolve, reject) => this.whenOff(reason => reason === undefined ? resolve() : reject(reason)));\n    }\n    /**\n     * Makes another supply depend on this one.\n     *\n     * Once this supply is {@link off cut off}, `another` one will be cut off with the same reason.\n     *\n     * Calling this method has the same effect as calling `another.supply.needs(this)`.\n     *\n     * @param another - A supply peer to make dependent on this one.\n     *\n     * @returns `this` instance.\n     */\n    cuts(another) {\n        another.supply.needs(this);\n        return this;\n    }\n    /**\n     * Makes this supply depend on another one.\n     *\n     * Once `another` supply is {@link off cut off}, this one will be cut off with the same reason.\n     *\n     * @param another - A supply peer to make this one depend on.\n     *\n     * @returns `this` instance.\n     */\n    needs(another) {\n        another.supply.whenOff(reason => this.off(reason));\n        return this;\n    }\n    /**\n     * Makes this and another supply depend on each other.\n     *\n     * Calling this method is the same as calling `.needs(another).cuts(another)`.\n     *\n     * @param another - A supply peer to make this one to mutually depend on.\n     *\n     * @returns `this` instance.\n     */\n    as(another) {\n        return this.needs(another).cuts(another);\n    }\n}\n\n/**\n * @internal\n */\nclass AlwaysSupply extends Supply {\n    get isOff() {\n        return false;\n    }\n    off(_reason) {\n        return this;\n    }\n    whenOff(_callback) {\n        return this;\n    }\n    cuts(_another) {\n        return this;\n    }\n    needs(_another) {\n        return this;\n    }\n}\n/**\n * @internal\n */\nconst alwaysSupply$ = ( /*#__PURE__*/new AlwaysSupply());\n/**\n * Builds an always-supply instance.\n *\n * The {@link Supply.off} method of the returned supply does nothing.\n *\n * @returns A supply instance that can not be cut off.\n */\nfunction alwaysSupply() {\n    return alwaysSupply$;\n}\n/**\n * Checks whether the given supply is an {@link AlwaysSupply | always-supply} instance.\n *\n * @param supply - A supply to check.\n *\n * @returns `true` is the given `supply` can not be cut off, or `false` otherwise.\n */\nfunction isAlwaysSupply(supply) {\n    return supply === alwaysSupply$;\n}\n\n/**\n * @internal\n */\nclass NeverSupply extends Supply {\n    get isOff() {\n        return true;\n    }\n    off() {\n        return this;\n    }\n    whenOff(callback) {\n        callback();\n        return this;\n    }\n    cuts(another) {\n        another.supply.off();\n        return this;\n    }\n    needs(_another) {\n        return this;\n    }\n}\n/**\n * @internal\n */\nconst neverSupply$ = ( /*#__PURE__*/new NeverSupply());\n/**\n * Builds a never-supply instance.\n *\n * @returns A supply instance that is already cut off without any particular reason.\n */\nfunction neverSupply() {\n    return neverSupply$;\n}\n\nexport { Supply, alwaysSupply, isAlwaysSupply, neverSupply };\n//# sourceMappingURL=supply.js.map\n","import { valueProvider, lazyValue, valuesProvider, noop } from '@proc7ts/primitives';\nimport { overNone, overElementsOf, valueIt, itsEmpty, itsElements, overIterator } from '@proc7ts/push-iterator';\nimport { Supply, alwaysSupply } from '@proc7ts/supply';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nclass ContextKeyError extends Error {\n    /**\n     * Constructs an invalid context key error.\n     *\n     * @param key - Missing value key.\n     * @param message - Arbitrary error message.\n     */\n    constructor(key, message = `There is no value with key ${key}`) {\n        super(message);\n        this.key = key;\n    }\n}\n\n/**\n * A symbol of the property containing a {@link ContextKey} instance.\n */\nconst ContextKey__symbol = ( /*#__PURE__*/Symbol('ContextKey'));\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by {@link ContextKey.grow} method.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nclass ContextKey {\n    /**\n     * Constructs context value key.\n     *\n     * @param name - Human-readable key name.\n     */\n    constructor(name) {\n        this.name = name;\n    }\n    /**\n     * Always the key itself.\n     *\n     * This is to use this context value key both as a context value request and its definition target.\n     */\n    get [ContextKey__symbol]() {\n        return this;\n    }\n    toString() {\n        return `ContextKey(${this.name})`;\n    }\n}\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nclass ContextSeedKey extends ContextKey {\n    /**\n     * Constructs context value sources key.\n     *\n     * @param key - A key of context value having its sources associated with this key.\n     */\n    constructor(key) {\n        super(`${key.name}:seed`);\n    }\n    /**\n     * Always refers to itself.\n     */\n    get seedKey() {\n        return this;\n    }\n    grow(opts) {\n        const { seeder, seed } = opts;\n        if (!seeder.isEmpty(seed)) {\n            opts.insert(seed);\n        }\n        else if (!opts.hasFallback) {\n            opts.insert(seed);\n        }\n    }\n}\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nclass ContextValues {\n}\n\n/**\n * A key of {@link Contextual contextual value reference} method resolving a contextual instance.\n */\nconst Contextual__symbol = ( /*#__PURE__*/Symbol('Contextual'));\nfunction isContextual(value) {\n    return !!value\n        && (typeof value === 'object' || typeof value === 'function')\n        && typeof value[Contextual__symbol] === 'function';\n}\n\nfunction applyContextTo(value) {\n    return isContextual(value)\n        ? context => value[Contextual__symbol](context)\n        : valueProvider(value);\n}\n\n/**\n * @internal\n */\nclass IterativeContextSeeder {\n    constructor() {\n        this._providers = new Map();\n    }\n    provide(provider) {\n        const supply = new Supply();\n        this._providers.set(supply, provider);\n        return supply.whenOff(() => this._providers.delete(supply));\n    }\n    seed(context, initial = overNone()) {\n        return overElementsOf(initial, iterativeSeed(context, this._providers));\n    }\n    isEmpty(seed) {\n        return itsEmpty(seed);\n    }\n    combine(first, second) {\n        return overElementsOf(first, second);\n    }\n}\n/**\n * @internal\n */\nclass IterativeSeedKey extends ContextSeedKey {\n    seeder() {\n        return new IterativeContextSeeder();\n    }\n}\n/**\n * Iterative context value key implementation.\n *\n * Collects value sources as iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nclass IterativeContextKey extends ContextKey {\n    /**\n     * Constructs iterative context value key.\n     *\n     * @param name - Human-readable key name.\n     * @param seedKey - Value seed key. A new one will be constructed when omitted.\n     */\n    constructor(name, { seedKey, } = {}) {\n        super(name);\n        this.seedKey = seedKey || new IterativeSeedKey(this);\n    }\n}\n/**\n * @internal\n */\nfunction iterativeSeed(context, providers) {\n    // Lazily evaluated providers\n    const lazyProviders = itsElements(overIterator(() => providers.values()), provider => lazyValue(provider.bind(undefined, context)));\n    return valueIt(lazyProviders, provider => provider());\n}\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeParam TSrc - TValue source type and context value item type.\n */\nclass MultiContextKey extends IterativeContextKey {\n    /**\n     * Constructs multiple context values key.\n     *\n     * @param name - Human-readable key name.\n     * @param seedKey - Value seed key. A new one will be constructed when omitted.\n     * @param byDefault - Optional default value provider. If unspecified then the default value is empty array.\n     */\n    constructor(name, { seedKey, byDefault = valuesProvider(), } = {}) {\n        super(name, seedKey);\n        this.byDefault = byDefault;\n    }\n    grow(slot) {\n        const result = itsElements(slot.seed);\n        if (result.length) {\n            slot.insert(result);\n        }\n        else if (!slot.hasFallback) {\n            const defaultSources = this.byDefault(slot.context, this);\n            if (defaultSources) {\n                slot.insert(Array.from(defaultSources));\n            }\n        }\n    }\n}\n\n/**\n * @internal\n */\nclass SimpleContextSeeder {\n    constructor() {\n        this._providers = [];\n    }\n    provide(provider) {\n        // Ensure the same provider may be registered multiple times\n        const entry = [provider];\n        this._providers.unshift(entry);\n        return new Supply(() => this._providers.splice(this._providers.lastIndexOf(entry), 1));\n    }\n    seed(context, initial) {\n        const { length } = this._providers;\n        if (!length) {\n            return initial || noop;\n        }\n        const makeSeed = ([provider]) => lazyValue(provider.bind(undefined, context));\n        if (!initial && length === 1) {\n            return makeSeed(this._providers[0]);\n        }\n        const seeds = this._providers.map(makeSeed);\n        if (initial) {\n            seeds.push(initial);\n        }\n        return combineSimpleSeeds(seeds);\n    }\n    isEmpty(seed) {\n        return seed() == null;\n    }\n    combine(first, second) {\n        if (first === noop) {\n            return second;\n        }\n        if (second === noop) {\n            return first;\n        }\n        return combineSimpleSeeds([second, first]);\n    }\n}\n/**\n * @internal\n */\nfunction combineSimpleSeeds(seeds) {\n    return lazyValue(() => {\n        for (const seed of seeds) {\n            const value = seed();\n            if (value != null) {\n                return value;\n            }\n        }\n        return;\n    });\n}\n/**\n * @internal\n */\nclass SimpleSeedKey extends ContextSeedKey {\n    seeder() {\n        return new SimpleContextSeeder();\n    }\n}\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nclass SimpleContextKey extends ContextKey {\n    /**\n     * Constructs simple context value key.\n     *\n     * @param name - Human-readable key name.\n     * @param seedKey - Value seed key. A new one will be constructed when omitted.\n     */\n    constructor(name, { seedKey, } = {}) {\n        super(name);\n        this.seedKey = seedKey || new SimpleSeedKey(this);\n    }\n}\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeParam TValue - Context value type.\n */\nclass SingleContextKey extends SimpleContextKey {\n    /**\n     * Constructs single context value key.\n     *\n     * @param name - Human-readable key name.\n     * @param seedKey - Value seed key. A new one will be constructed when omitted.\n     * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n     * value.\n     */\n    constructor(name, { seedKey, byDefault = noop, } = {}) {\n        super(name, { seedKey });\n        this.byDefault = byDefault;\n    }\n    grow(slot) {\n        const value = slot.seed();\n        if (value != null) {\n            slot.insert(value);\n        }\n        else if (!slot.hasFallback) {\n            slot.insert(this.byDefault(slot.context, this));\n        }\n    }\n}\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey {\n    constructor() {\n        super('context-supply');\n    }\n    grow(slot) {\n        slot.insert(slot.seed()\n            || slot.context.supply\n            || (slot.hasFallback ? slot.or : alwaysSupply()));\n    }\n}\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `SupplyPeer` interface. Defaults to supply-always\n * otherwise.\n */\nconst ContextSupply = ( /*#__PURE__*/new ContextSupplyKey());\n\n/**\n * A key of {@link ContextBuilder context builder} method that provides context values.\n */\nconst ContextBuilder__symbol = ( /*#__PURE__*/Symbol('ContextBuilder'));\n\n/**\n * @internal\n */\nclass ContextSeeders {\n    constructor(_initial) {\n        this._initial = _initial;\n        this._issuers = new Map();\n    }\n    issuer(seedKey) {\n        const found = this._issuers.get(seedKey);\n        if (found) {\n            return found;\n        }\n        const seeder = seedKey.seeder();\n        const issuer = [\n            seeder,\n            context => seeder.seed(context, this._initial(seedKey, context)),\n        ];\n        this._issuers.set(seedKey, issuer);\n        return issuer;\n    }\n    newSeed(context, key) {\n        const { seedKey } = key;\n        const [seeder, factory] = this.issuer(seedKey);\n        if (seedKey !== key) {\n            // This is not a seed key\n            // Retrieve the seed by seed key\n            return [seeder, context.get(seedKey)];\n        }\n        return [seeder, factory(context)];\n    }\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TDeps - Dependencies tuple type.\n * @param spec - Explicit context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nfunction contextValueSpec(spec) {\n    if (isValueSpecByProvider(spec)) {\n        if (!isValueSpecWithDeps(spec)) {\n            return spec;\n        }\n        const { a, by, with: deps } = spec;\n        return {\n            a,\n            by(context) {\n                return by(...deps.map((dep) => context.get(dep)));\n            },\n        };\n    }\n    if (isConstantValueSpec(spec)) {\n        const { a, is: value } = spec;\n        return {\n            a,\n            by: valueProvider(value),\n        };\n    }\n    if (isValueSpecViaAlias(spec)) {\n        const { a, via } = spec;\n        return {\n            a,\n            by(ctx) {\n                return ctx.get(via);\n            },\n        };\n    }\n    if (isValueSpecAsInstance(spec)) {\n        if (isSelfInstanceValueSpec(spec)) {\n            spec = toAsInstance(spec);\n        }\n        if (!isValueSpecWithDeps(spec)) {\n            const { as: Type } = spec;\n            return {\n                a: spec.a,\n                by(ctx) {\n                    return new Type(ctx);\n                },\n            };\n        }\n        const { as: DepType, with: deps } = spec;\n        return {\n            a: spec.a,\n            by(context) {\n                return new DepType(...deps.map((dep) => context.get(dep)));\n            },\n        };\n    }\n    throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n/**\n * @internal\n */\nfunction isValueSpecByProvider(spec) {\n    return 'by' in spec;\n}\n/**\n * @internal\n */\nfunction isValueSpecAsInstance(spec) {\n    return 'as' in spec;\n}\n/**\n * @internal\n */\nfunction isSelfInstanceValueSpec(spec) {\n    return !('a' in spec);\n}\n/**\n * @internal\n */\nfunction toAsInstance(spec) {\n    return {\n        ...spec,\n        a: spec.as,\n    };\n}\n/**\n * @internal\n */\nfunction isConstantValueSpec(spec) {\n    return 'is' in spec;\n}\n/**\n * @internal\n */\nfunction isValueSpecViaAlias(spec) {\n    return 'via' in spec;\n}\n/**\n * @internal\n */\nfunction isValueSpecWithDeps(spec) {\n    return 'with' in spec;\n}\n\n/**\n * @internal\n */\nfunction newContextValues(registry, seeders) {\n    const values = new Map();\n    class ContextValues$ extends ContextValues {\n        get({ [ContextKey__symbol]: key }, opts) {\n            const cached = values.get(key);\n            if (cached != null) {\n                return cached;\n            }\n            const [constructed, setup] = new ContextValueSlot$(seeders, this, key, opts)._grow();\n            if (setup) {\n                values.set(key, constructed);\n                setup({\n                    key,\n                    context: this,\n                    registry: registry,\n                });\n            }\n            return constructed;\n        }\n    }\n    return new ContextValues$();\n}\n/**\n * @internal\n */\nclass ContextValueSlot$ {\n    constructor(seeders, context, key, _opts = {}) {\n        this.context = context;\n        this.key = key;\n        this._opts = _opts;\n        this._constructed = null;\n        this._setup = noop;\n        const [seeder, seed] = seeders.newSeed(context, key);\n        this.seeder = seeder;\n        this.seed = seed;\n        this.hasFallback = 'or' in _opts; // Fallback _may_ have `undefined` value.\n    }\n    get or() {\n        return this._opts.or; // Access here, as fallback value accessor may be implemented as getter.\n    }\n    insert(value) {\n        this._constructed = value;\n    }\n    fillBy(grow) {\n        grow(this);\n        return this._constructed;\n    }\n    setup(setup) {\n        const prevSetup = this._setup;\n        this._setup = opts => {\n            prevSetup(opts);\n            setup(opts);\n        };\n    }\n    _grow() {\n        this.key.grow(this);\n        if (this._constructed != null) {\n            return [this._constructed, this._setup];\n        }\n        if (!this.hasFallback) {\n            throw new ContextKeyError(this.key);\n        }\n        return [this.or];\n    }\n}\n\n/**\n * A registry of context value providers.\n *\n * @typeParam TCtx - Context type.\n */\nclass ContextRegistry {\n    /**\n     * Constructs a registry for context value providers.\n     *\n     * It can be chained with another registry by providing an initially known source of known context values.\n     *\n     * @param initial - An optional source of initially known context values. This can be either a function, or\n     * `ContextValues` instance.\n     */\n    constructor(initial) {\n        this._seeders = new ContextSeeders(initial\n            ? (typeof initial === 'function' ? initial : (seedKey => initial.get(seedKey)))\n            : noop);\n    }\n    /**\n     * Provides context value.\n     *\n     * @typeParam TSrc - Source value type.\n     * @typeParam TDeps - Dependencies tuple type.\n     * @param spec - Context value specifier.\n     *\n     * @returns Provider supply instance that removes just added context value provider once cut off.\n     */\n    provide(spec) {\n        if (isContextBuilder(spec)) {\n            return spec[ContextBuilder__symbol](this);\n        }\n        const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n        const [seeder] = this._seeders.issuer(seedKey);\n        return seeder.provide(by);\n    }\n    /**\n     * Creates a seed for the given key in target context.\n     *\n     * @param context - Target context.\n     * @param key - Context value seed key.\n     *\n     * @returns New context value seed.\n     */\n    seed(context, key) {\n        const [, factory] = this._seeders.issuer(key);\n        return factory(context);\n    }\n    /**\n     * Builds context seeds provider originated from this registry.\n     *\n     * @returns Mandatory context seeds provider.\n     */\n    seeds() {\n        return (seedKey, context) => this.seed(context, seedKey);\n    }\n    /**\n     * Builds context seeds provider that binds seeds to target `context`.\n     *\n     * @param context - Target value context.\n     *\n     * @returns A provider of context value seeds bound to the given `context`.\n     */\n    seedIn(context) {\n        return this.newValues().get.bind(context);\n    }\n    /**\n     * Creates new context values instance consulting this registry for value providers.\n     *\n     * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n     */\n    newValues() {\n        return newContextValues(this, this._seeders);\n    }\n    /**\n     * Appends values provided by another value registry to the ones provided by this one.\n     *\n     * @param other - Another context value registry or context seeds provider.\n     *\n     * @return New context value registry which values provided by both registries.\n     */\n    append(other) {\n        const otherSeeds = typeof other === 'function' ? other : other.seeds();\n        return new ContextRegistry((key, context) => {\n            const second = otherSeeds(key, context);\n            const [seeder, factory] = this._seeders.issuer(key);\n            const first = factory(context);\n            return second ? seeder.combine(first, second, context) : first;\n        });\n    }\n}\n/**\n * @internal\n */\nfunction isContextBuilder(spec) {\n    return typeof spec[ContextBuilder__symbol] === 'function';\n}\n\nexport { ContextBuilder__symbol, ContextKey, ContextKeyError, ContextKey__symbol, ContextRegistry, ContextSeedKey, ContextSupply, ContextValues, Contextual__symbol, IterativeContextKey, MultiContextKey, SimpleContextKey, SingleContextKey, applyContextTo, contextValueSpec, isContextual };\n//# sourceMappingURL=context-values.js.map\n","import { valueProvider, lazyValue, noop, superClassOf, hasOwnProperty } from '@proc7ts/primitives';\n\n/**\n * Converts arbitrary amendment to {@link Amender amender}.\n *\n * @typeParam TAmended - Amended entity type.\n * @param amendment - An amendment to convert.\n *\n * @returns Either the `amendment` itself if it is already an amender, or its {@link Amendatory.applyAmendment\n * applyAmendment} method if it is an {@link Amendatory} instance.\n */\nfunction amenderOf(amendment) {\n    return isAmendatoryAmendment(amendment) ? amendment.applyAmendment : amendment;\n}\n/**\n * Checks if the given amendment is represented by {@link Amendatory} instance.\n *\n * @typeParam TAmended - Amended entity type.\n * @param amendment - An amendment to check.\n *\n * @returns `true` if the given `amendment` has an {@link Amendatory.applyAmendment applyAmendment} method,\n * or `false` otherwise.\n */\nfunction isAmendatoryAmendment(amendment) {\n    return typeof amendment.applyAmendment === 'function';\n}\n/**\n * Checks whether the given value is an {@link Amendatory} instance.\n *\n * @typeParam TAmended - Amended entity type.\n * @typeParam TOther - Another type the `value` may have.\n * @param value - The value to check.\n *\n * @returns `true` if the given `value` is an object or function with {@link Amendatory.applyAmendment applyAmendment}\n * method, or `false` otherwise.\n */\nfunction isAmendatory(value) {\n    return !!value\n        && (typeof value === 'object' || typeof value === 'function')\n        && isAmendatoryAmendment(value);\n}\n\n/**\n * An {@link Amender amender} that amends nothing.\n *\n * @param _target - An unused amendment target that remains intact.\n *\n * @returns Itself for convenience.\n */\nfunction noopAmender(_target) {\n    return noopAmender;\n}\n\n/**\n * Combines multiple amendments into one amender.\n *\n * The resulting amender performs amendments in order. The subsequent amendments receive the amendment targets modified\n * by preceding ones.\n *\n * @typeParam TAmended - Amended entity type.\n * @param amendments - An iterable of amendments to apply in their application order.\n *\n * @returns A combining amender.\n */\nfunction allAmender(amendments) {\n    if (Array.isArray(amendments) && amendments.length < 2) {\n        const [amender = noopAmender] = amendments;\n        return amenderOf(amender);\n    }\n    return target => {\n        let amendBy = (amendment) => {\n            const amend = (request) => {\n                const result = target.amend(request);\n                amendBy = (next) => {\n                    const nextTarget = result();\n                    amenderOf(next)({\n                        ...nextTarget,\n                        amend,\n                    });\n                    return nextTarget;\n                };\n                return () => ({\n                    ...result(),\n                    amend,\n                });\n            };\n            amenderOf(amendment)({\n                ...target,\n                amend,\n            });\n        };\n        for (const amendment of amendments) {\n            amendBy(amendment);\n        }\n    };\n}\n\n/**\n * Creates custom amendment target.\n *\n * @typeParam TAmended - Amended entity type.\n * @param options - Options for created amendment target.\n *\n * @returns New amendment target instance.\n */\nfunction newAmendTarget(options) {\n    const { base, amend: baseAmend } = options;\n    const nextTarget = (createBase) => {\n        const nextBase = createBase();\n        return {\n            ...nextBase,\n            amend(nextRequest) {\n                const modify = lazyValue(baseAmend(nextBase, nextRequest)\n                    || (() => AmendTarget$default$modify(nextBase, nextRequest)));\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                return () => nextTarget(modify);\n            },\n        };\n    };\n    return nextTarget(valueProvider(base));\n}\nfunction AmendTarget$default$modify(base, request) {\n    return { ...base, ...request };\n}\n\nfunction AeClass$target(base) {\n    return newAmendTarget({\n        base,\n        amend: AeClass$target$amend(base),\n    });\n}\nfunction AeClass$target$amend({ amend }) {\n    if (!amend) {\n        return noop;\n    }\n    return (_base, request) => amend(request);\n}\n\n/**\n * Creates an amendment (and decorator) for a class.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TAmended - A type of the entity representing a class to amend.\n * @param amendments - Amendments to apply.\n *\n * @returns - New class amendment instance.\n */\nfunction AeClass(...amendments) {\n    const amender = allAmender(amendments);\n    const decorateAmended = (base) => amender(AeClass$target(base));\n    const decorator = ((target) => {\n        decorateAmended({ amendedClass: target });\n    });\n    decorator.applyAmendment = amender;\n    decorator.decorateAmended = decorateAmended;\n    return decorator;\n}\n\nconst autoAmended = ( /*#__PURE__*/new WeakSet());\n/**\n * Issues an auto-amendment of the given class.\n *\n * An amendment is done by {@link AmendableClass.autoAmend autoAmend} static method this function calls.\n *\n * A class is auto-amended at most once. The subsequent calls of this function for the same class would do nothing.\n *\n * Auto-amends a super-class prior to amending the given one.\n *\n * @param amendedClass - A class to auto-amend.\n *\n * @returns Amended class instance.\n */\nfunction amend(amendedClass) {\n    if (autoAmended.has(amendedClass)) {\n        // Already auto-amended.\n        return amendedClass;\n    }\n    autoAmended.add(amendedClass);\n    const superClass = superClassOf(amendedClass);\n    if (superClass) {\n        // Amend super-class first.\n        amend(superClass);\n    }\n    if (!hasOwnProperty(amendedClass, 'autoAmend')) {\n        return amendedClass;\n    }\n    amendedClass.autoAmend(AeClass$target({ amendedClass }));\n    return amendedClass;\n}\n\n/**\n * Abstract {@link AmendableClass amendable class} instance.\n *\n * Automatically issues an {@link amend amendment} of any subclass upon instance construction.\n */\nclass Amendable {\n    /**\n     * Constructs an amendable class instance.\n     *\n     * Issues a class amendment, unless the class already amended.\n     */\n    constructor() {\n        amend(new.target);\n    }\n}\n\n/**\n * Unique symbol used as a pseudo-member key by default.\n */\nconst PseudoMember__symbol = ( /*#__PURE__*/Symbol('PseudoMember'));\n\nfunction AeProp$notReadable(host, key) {\n    return _instance => {\n        throw new TypeError(`${host.kind.pName} ${host.cls.name}${AmendProp$accessString(key)} is not readable`);\n    };\n}\nfunction AeProp$notWritable(host, key) {\n    return (_instance, _update) => {\n        throw new TypeError(`${host.kind.pName} ${host.cls.name}${AmendProp$accessString(key)} is not writable`);\n    };\n}\nconst AeProp$idPattern = /^[a-z_$][a-z0-9_$]*$/i;\nfunction AmendProp$accessString(key) {\n    if (typeof key === 'string') {\n        return AeProp$idPattern.test(key) ? `.${key}` : `[${JSON.stringify(key)}]`;\n    }\n    return `[${String(key)}]`;\n}\n\nfunction createAePropAccessor(host, key, descriptor) {\n    if (descriptor) {\n        const { get, set } = descriptor;\n        if (get || set) {\n            return [\n                get\n                    ? instance => get.call(instance)\n                    : AeProp$notReadable(host, key),\n                set\n                    ? (instance, update) => set.call(instance, update)\n                    : AeProp$notWritable(host, key),\n                noop,\n            ];\n        }\n    }\n    const valueKey = Symbol(host.kind.vDesc(key));\n    let getValue = (host) => host[key];\n    let setValue = (host, update) => {\n        host[key] = update;\n    };\n    const writeValue = (host, update) => {\n        host[valueKey] = update;\n    };\n    let toAccessor;\n    if (descriptor && ('value' in descriptor || 'writable' in descriptor)) {\n        const { value, writable } = descriptor;\n        if (writable) {\n            toAccessor = () => {\n                getValue = host => valueKey in host\n                    ? host[valueKey]\n                    : host[valueKey] = value;\n                setValue = writeValue;\n            };\n        }\n        else {\n            setValue = AeProp$notWritable(host, key);\n            toAccessor = noop;\n        }\n    }\n    else {\n        toAccessor = () => {\n            const superProto = Reflect.getPrototypeOf(host.host);\n            if (superProto != null) {\n                getValue = hostInstance => {\n                    if (valueKey in hostInstance) {\n                        return hostInstance[valueKey];\n                    }\n                    return hostInstance[valueKey] = Reflect.get(superProto, key, hostInstance);\n                };\n            }\n            else {\n                getValue = instance => instance[valueKey];\n            }\n            setValue = writeValue;\n        };\n    }\n    return [\n        instance => getValue(instance),\n        (instance, update) => setValue(instance, update),\n        toAccessor,\n    ];\n}\n\nfunction createAePropApplicator(host, amender, key, init) {\n    return (baseTarget) => {\n        const result = { ...init };\n        amender(newAmendTarget({\n            base: {\n                ...baseTarget,\n                key,\n                ...init,\n            },\n            amend(_base, request = {}) {\n                const { key: $key, enumerable = result.enumerable, configurable = result.configurable, readable: $readable, writable: $writable, get: $get, set: $set, ...baseRequest } = request;\n                const createBaseTarget = baseTarget.amend(baseRequest);\n                let { get, set } = request;\n                let readable;\n                let writable;\n                if (!set) {\n                    if (get) {\n                        set = AeProp$notWritable(host, key);\n                        writable = false;\n                        readable = true;\n                    }\n                    else {\n                        // Neither get, not set provided.\n                        // Accessor remains the same.\n                        ({ readable, writable, get, set } = result);\n                    }\n                }\n                else if (get) {\n                    readable = true;\n                    writable = true;\n                }\n                else {\n                    get = AeProp$notReadable(host, key);\n                    readable = false;\n                    writable = true;\n                }\n                result.configurable = configurable;\n                result.enumerable = enumerable;\n                result.readable = readable;\n                result.writable = writable;\n                result.get = get;\n                result.set = set;\n                return () => ({\n                    ...createBaseTarget(),\n                    key,\n                    enumerable,\n                    configurable,\n                    readable,\n                    writable,\n                    get,\n                    set,\n                });\n            },\n        }));\n        return result;\n    };\n}\n\nfunction AeProp(createHost, hostClass, amendments) {\n    const amender = allAmender(amendments);\n    const decorateAmended = (decorated, key, descriptor) => {\n        const host = createHost(decorated);\n        const [getValue, setValue, toAccessor] = createAePropAccessor(host, key, descriptor);\n        const init = {\n            enumerable: !descriptor || !!descriptor.enumerable,\n            configurable: !descriptor || !!descriptor.configurable,\n            readable: !descriptor || !!descriptor.get,\n            writable: !descriptor || !!descriptor.set || !!descriptor.writable,\n            get: hostInstance => getValue(hostInstance),\n            set: (hostInstance, update) => setValue(hostInstance, update),\n        };\n        const applyAmendment = createAePropApplicator(host, amender, key, init);\n        let desc;\n        AeClass(classTarget => {\n            desc = applyAmendment(classTarget);\n        }).decorateAmended(decorated);\n        const { enumerable, configurable, get, set } = desc;\n        let newDescriptor;\n        if (set !== init.set || get !== init.get) {\n            newDescriptor = {\n                enumerable,\n                configurable,\n                get() {\n                    return get(this);\n                },\n                set(update) {\n                    set(this, update);\n                },\n            };\n            toAccessor();\n        }\n        else if (enumerable !== init.enumerable || configurable !== init.configurable) {\n            if (descriptor && (descriptor.get || descriptor.set)) {\n                newDescriptor = {\n                    ...descriptor,\n                    enumerable,\n                    configurable,\n                };\n            }\n            else {\n                newDescriptor = {\n                    ...descriptor,\n                    enumerable,\n                    configurable,\n                    writable: desc.writable,\n                };\n            }\n        }\n        if (newDescriptor && !descriptor) {\n            // Decorated field.\n            // Declare accessor.\n            Reflect.defineProperty(host.host, key, newDescriptor);\n        }\n        return newDescriptor;\n    };\n    const decorator = ((targetHost, key, descriptor) => {\n        const aeClass = { amendedClass: hostClass(targetHost) };\n        return decorateAmended(aeClass, key, descriptor);\n    });\n    decorator.decorateAmended = decorateAmended;\n    decorator.applyAmendment = amender;\n    return decorator;\n}\n\nfunction PseudoProp(createHost, { key, get, set }, amendments) {\n    const amender = allAmender(amendments);\n    const decorateAmended = (decorated, memberKey) => {\n        if (key) {\n            memberKey = key;\n        }\n        else if (!memberKey) {\n            memberKey = PseudoMember__symbol;\n        }\n        const host = createHost(decorated);\n        const init = {\n            enumerable: false,\n            configurable: true,\n            readable: !!get,\n            writable: !!set,\n            get: get || AeProp$notReadable(host, memberKey),\n            set: set || AeProp$notWritable(host, memberKey),\n        };\n        const applyAmendment = createAePropApplicator(host, amender, memberKey, init);\n        AeClass(applyAmendment).decorateAmended(decorated);\n    };\n    const decorator = ((amendedClass) => {\n        const aeClass = { amendedClass };\n        return decorateAmended(aeClass);\n    });\n    decorator.decorateAmended = decorateAmended;\n    decorator.applyAmendment = (target) => {\n        decorateAmended(target, target.key);\n    };\n    return decorator;\n}\n\n/**\n * Creates an amendment (and decorator) for the class instance member.\n *\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - A type of amended class.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - A type of the entity representing a member to amend.\n * @param amendments - Amendments to apply.\n *\n * @returns New class member amendment instance.\n */\nfunction AeMember(...amendments) {\n    return AeProp(AeMember$createHost, AeMember$hostClass, amendments);\n}\nconst AeMember$HostKind = {\n    pName: 'Property',\n    vDesc: key => `valueOf(${String(key)}`,\n};\nfunction AeMember$createHost({ amendedClass }) {\n    return {\n        kind: AeMember$HostKind,\n        cls: amendedClass,\n        host: amendedClass.prototype,\n    };\n}\nfunction AeMember$hostClass(proto) {\n    return proto.constructor;\n}\n\n/**\n * Amends a member (property) of the class.\n *\n * Applies the given amendments to the own property of the target class prototype.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TKey - A type of amended member key.\n * @typeParam TAmended - A type of the entity representing a member to amend.\n * @param decorated - Decorated class representation.\n * @param memberKey - A key of the member to amend.\n * @param amendments - Amendment to apply.\n */\nfunction amendMemberOf(decorated, memberKey, ...amendments) {\n    const amendment = AeMember(...amendments);\n    const proto = decorated.amendedClass.prototype;\n    const sourceDesc = Reflect.getOwnPropertyDescriptor(proto, memberKey);\n    const amendedDesc = amendment.decorateAmended(decorated, memberKey, sourceDesc);\n    if (amendedDesc && sourceDesc) {\n        // Redefine the property.\n        Reflect.defineProperty(proto, memberKey, amendedDesc);\n    }\n}\n\n/**\n * Creates a class amendment (and decorator) that amends its members.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TExtClass - A type of class extended by the amendment.\n * @typeParam TAmended - A type of the entity representing a class to amend.\n * @param def - A map of member amendments.\n *\n * @returns New class amendment instance.\n */\nfunction AeMembers(def) {\n    return AeClass(target => {\n        for (const key of Reflect.ownKeys(def)) {\n            const amendment = def[key];\n            if (amendment) {\n                amendMemberOf(target, key, amendment);\n            }\n        }\n    });\n}\n\n/**\n * Creates a class amendment (and decorator) that declares a pseudo-member of the target class.\n *\n * A pseudo-member does not alter the class prototype or instance. Instead, its value is read and written by the given\n * `accessor`.\n *\n * @typeParam TValue - Pseudo-member value type.\n * @typeParam TClass - A type of amended class.\n * @typeParam TUpdate - Pseudo-member update type accepted by its setter.\n * @typeParam TAmended - A type of the entity representing a pseudo-member.\n * @param accessor - Pseudo-member accessor.\n * @param amendments - Amendments to apply to pseudo-member.\n *\n * @returns New pseudo-member amendment.\n */\nfunction PseudoMember(accessor, ...amendments) {\n    return PseudoProp(PseudoMember$createHost, accessor, amendments);\n}\nconst PseudoMember$HostKind = {\n    pName: 'Pseudo-property',\n};\nfunction PseudoMember$createHost({ amendedClass }) {\n    return {\n        kind: PseudoMember$HostKind,\n        cls: amendedClass,\n        host: amendedClass.prototype,\n    };\n}\n\n/**\n * Creates an amendment (and decorator) for the static class member.\n *\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - A type of amended class.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - A type of the entity representing a static member to amend.\n * @param amendments - Amendments to apply.\n *\n * @returns - New static member amendment instance.\n */\nfunction AeStatic(...amendments) {\n    return AeProp(AeStatic$createHost, AeStatic$hostClass, amendments);\n}\nconst AeStatic$HostKind = {\n    pName: 'Static property',\n    vDesc: key => `staticOf(${String(key)}`,\n};\nfunction AeStatic$createHost({ amendedClass }) {\n    return {\n        kind: AeStatic$HostKind,\n        cls: amendedClass,\n        host: amendedClass,\n    };\n}\nfunction AeStatic$hostClass(classConstructor) {\n    return classConstructor;\n}\n\n/**\n * Amends a static member (static property) of the class.\n *\n * Applies the given amendments to the own property of the target class constructor.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TKey - A type of amended static member key.\n * @typeParam TAmended - A type of the entity representing a static member to amend.\n * @param decorated - Decorated class representation.\n * @param memberKey - A key of the member to amend.\n * @param amendments - Amendment to apply.\n */\nfunction amendStaticOf(decorated, memberKey, ...amendments) {\n    const amendment = AeStatic(...amendments);\n    const targetClass = decorated.amendedClass;\n    const sourceDesc = Reflect.getOwnPropertyDescriptor(targetClass, memberKey);\n    const amendedDesc = amendment.decorateAmended(decorated, memberKey, sourceDesc);\n    if (amendedDesc && sourceDesc) {\n        // Redefine the property.\n        Reflect.defineProperty(targetClass, memberKey, amendedDesc);\n    }\n}\n\n/**\n * Creates a class amendment (and decorator) that amends its static members.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TExtClass - A type of class extended by the amendment.\n * @typeParam TAmended - A type of the entity representing a class to amend.\n * @param def - A map of static member amendments.\n *\n * @returns New class amendment instance.\n */\nfunction AeStatics(def) {\n    return AeClass(target => {\n        for (const key of Reflect.ownKeys(def)) {\n            const amendment = def[key];\n            if (amendment) {\n                amendStaticOf(target, key, amendment);\n            }\n        }\n    });\n}\n\n/**\n * Creates a class amendment (and decorator) that declares a static pseudo-member of the target class.\n *\n * A static pseudo-member does not alter the class constructor. Instead, its value is read and written by the given\n * `accessor`.\n *\n * @typeParam TValue - Static pseudo-member value type.\n * @typeParam TClass - A type of amended class.\n * @typeParam TUpdate - Static pseudo-member update type accepted by its setter.\n * @typeParam TAmended - A type of the entity representing a static pseudo-member.\n * @param accessor - Static pseudo-member accessor.\n * @param amendments - Amendments to apply to static pseudo-member.\n *\n * @returns New static pseudo-member amendment.\n */\nfunction PseudoStatic(accessor, ...amendments) {\n    return PseudoProp(PseudoStatic$createHost, accessor, amendments);\n}\nconst PseudoStatic$HostKind = {\n    pName: 'Static pseudo-property',\n};\nfunction PseudoStatic$createHost({ amendedClass }) {\n    return {\n        kind: PseudoStatic$HostKind,\n        cls: amendedClass,\n        host: amendedClass,\n    };\n}\n\nexport { AeClass, AeMember, AeMembers, AeStatic, AeStatics, Amendable, PseudoMember, PseudoMember__symbol, PseudoStatic, allAmender, amend, amendMemberOf, amendStaticOf, amenderOf, isAmendatory, newAmendTarget, noopAmender };\n//# sourceMappingURL=amend.js.map\n","/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nclass Naming {\n    /**\n     * Converts the given qualified `name` into simple one accordingly to this naming schema.\n     *\n     * @param name Qualified name to convert.\n     * @param nsAlias Namespace aliaser to use.\n     */\n    name(name, nsAlias) {\n        if (typeof name === 'string') {\n            return name;\n        }\n        const [local, ns] = name;\n        return ns.name(nsAlias(ns), local, this);\n    }\n}\n\n/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\n/**\n * @internal\n */\nclass DefaultNaming extends Naming {\n    applyAlias(name, alias) {\n        return `${alias}-${name}`;\n    }\n}\n/**\n * Default naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nconst default__naming = ( /*#__PURE__*/new DefaultNaming());\n/**\n * HTML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nconst html__naming = ( /*#__PURE__*/new DefaultNaming());\n/**\n * @internal\n */\nclass XmlNaming extends Naming {\n    applyAlias(name, alias) {\n        return `${alias}:${name}`;\n    }\n}\n/**\n * XML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nconst xml__naming = ( /*#__PURE__*/new XmlNaming());\n/**\n * Element identifiers naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nconst id__naming = ( /*#__PURE__*/new XmlNaming());\n/**\n * @internal\n */\nclass CssNaming extends Naming {\n    applyAlias(name, alias) {\n        return `${name}@${alias}`;\n    }\n}\n/**\n * CSS classes naming scheme.\n *\n * Appends namespace alias as a name suffix separated by `@` sign.\n *\n * The result looks like `<name>@<alias>`.\n */\nconst css__naming = ( /*#__PURE__*/new CssNaming());\n\n/**\n * Namespace definition.\n *\n * Namespaces are identified by their URLs.\n */\nclass NamespaceDef {\n    /**\n     * Constructs new namespace definition.\n     *\n     * @param url  Unique namespace URL.\n     * @param aliases  Preferred namespace aliases. It is expected that each alias is an ASCII letter followed by\n     * any number of ASCII letters, digits, `-`, or `_` signs. Aliases starting with `xml` are reserved. Empty alias\n     * is reserved for {@link DEFAULT__NS default namespace}.\n     */\n    constructor(url, ...aliases) {\n        this.url = url;\n        this.aliases = aliases;\n    }\n    /**\n     * The most preferred namespace alias.\n     *\n     * By default this is the first preferred alias, or `ns` if there is no preferred aliases.\n     */\n    get alias() {\n        return this.aliases[0] || 'ns';\n    }\n    /**\n     * Converts a local `name` belonging to this namespace to simple one according to the given `naming` schema.\n     *\n     * Calls {@link Naming.applyAlias} by default.\n     *\n     * @param alias  Namespace alias to apply to the name.\n     * @param name  A name to convert.\n     * @param naming  Naming schema to use. {@link default__naming default naming schema} is used when omitted.\n     *\n     * @returns A simple name with this namespace alias applied.\n     */\n    name(alias, name, naming = default__naming) {\n        return naming.applyAlias(name, alias, this);\n    }\n}\n\n/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\n/**\n * @internal\n */\nclass DefaultNs extends NamespaceDef {\n    constructor() {\n        super('');\n    }\n    name(_alias, name) {\n        return name;\n    }\n}\n/**\n * Default namespace.\n *\n * This namespace is assumed for names without namespace specified.\n *\n * Its URL is empty. And it does not alter names, i.e. its {@link NamespaceDef.name} method returns the name as is.\n */\nconst DEFAULT__NS = ( /*#__PURE__*/new DefaultNs());\n\n/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\n/**\n * Checks whether the given `value` is a name+namespace tuple.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is an array consisting of exactly two elements, where the first element is a\n * non-empty string, and the second element is an instance of {@link NamespaceDef}. Or `false` otherwise.\n */\nfunction isNameAndNamespace(value) {\n    return Array.isArray(value)\n        && value.length === 2\n        && typeof value[0] === 'string'\n        && value[1] instanceof NamespaceDef;\n}\n/**\n * Checks whether the given `value` is a qualified name.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is a non-empty string or an array consisting of exactly two elements,\n * where the first element is a non-empty string, and the second element is an instance of {@link NamespaceDef}.\n * Or `false` otherwise.\n */\nfunction isQualifiedName(value) {\n    return typeof value === 'string' || isNameAndNamespace(value);\n}\n/**\n * Detects a namespace of the given qualified `name`\n *\n * @param name  Qualified name to detect a namespace of.\n *\n * @returns A namespace if the given `name` has it, or {@link DEFAULT__NS default namespace} otherwise.\n */\nfunction namespaceOf(name) {\n    return typeof name !== 'string' ? name[1] : DEFAULT__NS;\n}\n/**\n * Converts the given qualified `name` to local name and namespace tuple.\n *\n * @param name  Qualified name to convert.\n *\n * @returns The `name` itself if it has a namespace, or a tuple consisting of `name` and\n * {@link DEFAULT__NS default namespace} otherwise.\n */\nfunction nameAndNamespace(name) {\n    return typeof name !== 'string' ? name : [name, DEFAULT__NS];\n}\n/**\n * Checks whether two qualified names are equal to each other.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `true` if both names are equal, or `false` otherwise.\n */\nfunction namesEqual(first, second) {\n    if (typeof first === 'string') {\n        return typeof second === 'string' ? first === second : !second[1].url && second[0] === first;\n    }\n    const [firstName, { url: firstUrl }] = first;\n    if (typeof second === 'string') {\n        return !firstUrl && firstName === second;\n    }\n    return firstName === second[0] && firstUrl === second[1].url;\n}\n/**\n * Compares two qualified names.\n *\n * Names in default namespace considered less than other names. Namespaces are compared by their URLs.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `-1` if the `first` name is less than the `second` one, `0` if they are equal, or `1` if the `first` name\n * is greater than the `second` one.\n */\nfunction compareNames(first, second) {\n    if (typeof first === 'string') {\n        if (typeof second === 'string') {\n            return compareStrings(first, second);\n        }\n        if (!second[1].url) {\n            return compareStrings(first, second[0]);\n        }\n        return -1;\n    }\n    const [firstName, { url: firstUrl }] = first;\n    if (typeof second === 'string') {\n        if (!firstUrl) {\n            return compareStrings(firstName, second);\n        }\n        return 1;\n    }\n    return compareStrings(firstUrl, second[1].url) || compareStrings(firstName, second[0]);\n}\n/**\n * @internal\n */\nfunction compareStrings(first, second) {\n    return first < second ? -1 : first > second ? 1 : 0;\n}\n\n/**\n * Creates a namespace aliaser.\n *\n * The returned function tries to find a registered alias for the given namespace. If not found then tries to use one\n * of its preferred aliases. If all of them are reserved already for another namespaces, generates a new unique alias.\n *\n * @returns New instance of namespace aliaser.\n */\nfunction newNamespaceAliaser() {\n    const aliasesByNs = new Map();\n    const nsNumPerAlias = new Map();\n    return function nsAlias(ns) {\n        const found = aliasesByNs.get(ns.url);\n        if (found) {\n            return found;\n        }\n        const mostPreferred = ns.alias;\n        let nsNumRegistered = 0;\n        for (const preferred of [mostPreferred, ...ns.aliases]) {\n            const ids = nsNumPerAlias.get(preferred);\n            if (!ids) {\n                aliasesByNs.set(ns.url, preferred);\n                nsNumPerAlias.set(preferred, 1);\n                return preferred;\n            }\n            if (!nsNumRegistered) {\n                // Use the first one\n                nsNumRegistered = ids;\n            }\n        }\n        const generated = `${mostPreferred}${++nsNumRegistered}`;\n        aliasesByNs.set(ns.url, generated);\n        nsNumPerAlias.set(mostPreferred, nsNumRegistered);\n        return generated;\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\n/**\n * [MathML](https://www.w3.org/Math/) namespace definition.\n */\nconst MathML__NS = ( /*#__PURE__*/new NamespaceDef('http://www.w3.org/1998/Math/MathML', 'math', 'mathml'));\n/**\n * [SVG](https://www.w3.org/Graphics/SVG/) namespace definition.\n */\nconst SVG__NS = ( /*#__PURE__*/new NamespaceDef('http://www.w3.org/2000/svg', 'svg'));\n/**\n * [XHTML](https://www.w3.org/TR/xhtml1/) namespace definition.\n */\nconst XHTML__NS = ( /*#__PURE__*/new NamespaceDef('http://www.w3.org/1999/xhtml', 'xhtml'));\n/**\n * [XML](https://www.w3.org/XML/1998/namespace) namespace definition.\n *\n * It is always bound to `xml` alias.\n */\nconst XML__NS = ( /*#__PURE__*/new NamespaceDef('http://www.w3.org/XML/1998/namespace', 'xml'));\n/**\n * [XML Namespaces](https://www.w3.org/TR/xml-names/#ns-decl) namespace definition.\n *\n * It is always bound to `xmlns` alias and should never be declared.\n */\nconst XMLNS__NS = ( /*#__PURE__*/new NamespaceDef('http://www.w3.org/2000/xmlns/', 'xmlns'));\n/**\n * [XSL Transformations](https://www.w3.org/TR/1999/REC-xslt-19991116#xslt-namespace) namespace definition.\n */\nconst XSLT__NS = ( /*#__PURE__*/new NamespaceDef('http://www.w3.org/1999/XSL/Transform', 'xsl'));\n\nexport { DEFAULT__NS, MathML__NS, NamespaceDef, Naming, SVG__NS, XHTML__NS, XMLNS__NS, XML__NS, XSLT__NS, compareNames, css__naming, default__naming, html__naming, id__naming, isNameAndNamespace, isQualifiedName, nameAndNamespace, namesEqual, namespaceOf, newNamespaceAliaser, xml__naming };\n//# sourceMappingURL=namespace-aliaser.js.map\n","import { Supply, neverSupply } from '@proc7ts/supply';\nimport { noop } from '@proc7ts/primitives';\n\n/**\n * A key of {@link EventKeeper} method returning its {@link AfterEvent} instance.\n *\n * @category Core\n */\nconst AfterEvent__symbol = ( /*#__PURE__*/Symbol('after-event'));\n/**\n * Checks whether the given value implements an {@link EventKeeper} interface.\n *\n * @category Core\n * @typeParam TEvent - Expected event type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` contains an {@link AfterEvent__symbol} method, or `false` otherwise.\n */\nfunction isEventKeeper(value) {\n    return !!value\n        && (typeof value === 'object' || typeof value === 'function')\n        && typeof value[AfterEvent__symbol] === 'function';\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n * @param receiver - An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nfunction eventReceiver(receiver) {\n    let supply;\n    let receive;\n    if (typeof receiver === 'function') {\n        supply = new Supply();\n        receive = (_context, ...event) => receiver(...event);\n    }\n    else {\n        supply = receiver.supply || new Supply();\n        receive = (context, ...event) => {\n            if (!supply.isOff) {\n                // Supply cut off callback may be called before the receiver disabled.\n                // Such callback may send an event that should not be received.\n                receiver.receive(context, ...event);\n            }\n        };\n    }\n    // Disable receiver when event supply is cut off. But see the comment above.\n    // For function receiver this callback is always the first one.\n    supply.whenOff(() => receive = EventReceiver$doDonReceive);\n    return {\n        supply,\n        receive: (context, ...event) => receive(context, ...event),\n    };\n}\nfunction EventReceiver$doDonReceive(_context, ..._event) {\n    // Do not receive event.\n}\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @internal\n * @param receivers - An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nfunction receiveByEach(receivers) {\n    let send = sendNonRecurrent;\n    return (...event) => send(event);\n    function sendNonRecurrent(event) {\n        let actualReceivers = receivers;\n        const received = [];\n        send = (recurrent) => received.push(recurrent);\n        try {\n            for (;;) {\n                actualReceivers = processEvent(actualReceivers, event);\n                const recurrent = received.shift();\n                if (!recurrent) {\n                    break;\n                }\n                event = recurrent;\n            }\n        }\n        finally {\n            send = sendNonRecurrent;\n        }\n    }\n}\n/**\n * @internal\n */\nfunction processEvent(receivers, event) {\n    const recurrentReceivers = [];\n    for (const receiver of receivers) {\n        const idx = recurrentReceivers.length;\n        recurrentReceivers.push(receiver);\n        const context = {\n            onRecurrent(recurrentReceiver) {\n                recurrentReceivers[idx] = eventReceiver({\n                    supply: receiver.supply,\n                    receive(_context, ...recurrentEvent) {\n                        recurrentReceiver(...recurrentEvent);\n                    },\n                });\n            },\n        };\n        receiver.receive(context, ...event);\n    }\n    return recurrentReceivers;\n}\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an {@link EventSender} interface though. Use an {@link EventEmitter} if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link Supply.off cut off}.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nclass EventNotifier {\n    constructor() {\n        const rcs = this._rcs = new Set();\n        this.send = receiveByEach(rcs);\n        this.supply = new Supply(() => {\n            rcs.clear();\n            delete this._rcs;\n        });\n    }\n    /**\n     * The number of currently registered event receivers.\n     */\n    get size() {\n        return this._rcs ? this._rcs.size : 0;\n    }\n    /**\n     * Registers an event receiver.\n     *\n     * Receivers registered with this method will receive the {@link send emitted} events.\n     *\n     * @param receiver - A receiver of events to register.\n     *\n     * @returns A supply of events to the given `receiver`.\n     */\n    on(receiver) {\n        const generic = eventReceiver(receiver);\n        const supply = generic.supply.needs(this);\n        const receivers = this._rcs;\n        if (receivers && !supply.isOff) {\n            receivers.add(generic);\n            supply.whenOff(() => receivers.delete(generic));\n        }\n        return supply;\n    }\n}\n\n/**\n * A key of {@link EventSender} method returning its {@link OnEvent} instance.\n *\n * @category Core\n */\nconst OnEvent__symbol = ( /*#__PURE__*/Symbol('on-event'));\n/**\n * Checks whether the given value implements an {@link EventSender} interface.\n *\n * @category Core\n * @typeParam TEvent - Expected event type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` contains an {@link OnEvent__symbol} method, or `false` otherwise.\n */\nfunction isEventSender(value) {\n    return !!value\n        && (typeof value === 'object' || typeof value === 'function')\n        && typeof value[OnEvent__symbol] === 'function';\n}\n\n/**\n * An error indicating a failure to receive an expected event.\n *\n * This happens e.g. when receiver registered in {@link EventKeeper event keeper}, but the latter has no events to send.\n * This may happen when no fallback passed to {@link afterEventBy} function, while the given supplier did not send\n * any events.\n *\n * @category Core\n */\nclass NoEventsError extends TypeError {\n    /**\n     * Constructs an error.\n     *\n     * @param message - Error message.\n     */\n    constructor(message = 'No events to send') {\n        super(message);\n    }\n}\n\n/**\n * Creates an event sender targeted specific receiver.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n *\n * @param receiver - Target event receiver.\n *\n * @returns A function accepting events and sending them to target `receiver`.\n */\nfunction sendEventsTo(receiver) {\n    const generic = eventReceiver(receiver);\n    let send = receiveByEach([generic]);\n    generic.supply.whenOff(() => send = noop);\n    return (...event) => send(...event);\n}\n\n/**\n * @internal\n */\nfunction AfterEvent$noFallback() {\n    throw new NoEventsError();\n}\n\n/**\n * @internal\n */\nfunction digEvents(input, extract) {\n    return ({ supply, receive }) => {\n        let nestedSupply = neverSupply();\n        input({\n            supply,\n            receive: (_context, ...event) => {\n                const prevSupply = nestedSupply;\n                const extracted = extract(...event);\n                nestedSupply = extracted\n                    ? extracted({\n                        supply: new Supply(reason => {\n                            if (reason !== digEvents) {\n                                supply.off(reason);\n                            }\n                        }).needs(supply),\n                        receive,\n                    })\n                    : neverSupply();\n                prevSupply.off(digEvents);\n            },\n        });\n    };\n}\n\n/**\n * @internal\n */\nfunction OnEvent$do(...processors) {\n    return processors.reduce((arg, action) => action(arg), this);\n}\n\n/**\n * @internal\n */\nfunction OnEvent$supplier() {\n    return this;\n}\n\n/**\n * @internal\n */\nfunction onceEvent(supplier) {\n    return ({ supply, receive }) => {\n        supplier({\n            supply,\n            receive: (context, ...event) => {\n                receive(context, ...event);\n                supply.off();\n            },\n        });\n    };\n}\n\n/**\n * @internal\n */\nfunction OnEvent$then(onEvent, onCutOff) {\n    return new Promise((resolve, reject) => {\n        onceEvent(this)({\n            supply: onCutOff\n                ? new Supply(reason => {\n                    try {\n                        resolve(onCutOff(reason));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                })\n                : new Supply(reject),\n            receive: onEvent\n                ? (_ctx, ...event) => {\n                    try {\n                        resolve(onEvent(...event));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                }\n                : ((_ctx, event) => resolve(event)),\n        });\n    });\n}\n\n/**\n * @internal\n */\nfunction shareEvents(supplier) {\n    const sharer = new EventSharer(supplier);\n    return sharer.on.bind(sharer);\n}\nclass EventSharer extends EventNotifier {\n    constructor(supplier) {\n        super();\n        this.supplier = supplier;\n        this._on = this._onInit();\n    }\n    on(receiver) {\n        this._on.on(receiver);\n        return receiver.supply;\n    }\n    /**\n     * Initial dispatcher applied when there are no receivers.\n     */\n    _onInit() {\n        return {\n            on: receiver => {\n                const initialEvents = [];\n                const sharedSupply = new Supply(() => this._on = this._onInit());\n                const onFirst = this._on = this._onFirst(sharedSupply, initialEvents);\n                try {\n                    onFirst.on(receiver);\n                    this.supplier({\n                        supply: sharedSupply,\n                        receive: (_ctx, ...event) => this._on.dispatch(...event),\n                    });\n                }\n                finally {\n                    if (this._on === onFirst) {\n                        this._on = this._onNext(sharedSupply, initialEvents);\n                    }\n                }\n            },\n            dispatch: null, // Initial dispatcher never dispatches events\n        };\n    }\n    /**\n     * A dispatcher applied while the first receiver is still registering, but not registered yet.\n     *\n     * Records emitted events to dispatch them to all receivers.\n     */\n    _onFirst(sharedSupply, initialEvents) {\n        return {\n            on: receiver => this._addReceiver(receiver, sharedSupply, initialEvents),\n            dispatch: (...event) => {\n                // Record initial event.\n                initialEvents.push(event);\n                this.send(...event);\n            },\n        };\n    }\n    /**\n     * A dispatcher applied after the first receiver registered.\n     *\n     * Dispatches initial events to new receivers until new event received.\n     */\n    _onNext(sharedSupply, initialEvents) {\n        return {\n            on: receiver => this._addReceiver(receiver, sharedSupply, initialEvents),\n            dispatch: (...event) => {\n                // An event received after initial ones.\n                // Stop dispatching initial events.\n                initialEvents.length = 0;\n                this.send(...event);\n            },\n        };\n    }\n    _addReceiver(receiver, sharedSupply, initialEvents) {\n        sharedSupply.cuts(receiver);\n        super.on(receiver).whenOff(reason => {\n            if (!this.size) {\n                sharedSupply.off(reason);\n            }\n        });\n        if (initialEvents.length) {\n            // Dispatch initial events.\n            const dispatch = sendEventsTo(receiver);\n            initialEvents.forEach(event => dispatch(...event));\n        }\n    }\n}\n\n/**\n * @internal\n */\nfunction supplyEvents(supplier, required, dependentSupply) {\n    return (receiver) => {\n        if (dependentSupply) {\n            supplier({\n                supply: new Supply().needs(required).cuts(dependentSupply),\n                receive: receiver.receive,\n            });\n        }\n        else {\n            receiver.supply.needs(required);\n            supplier(receiver);\n        }\n    };\n}\n\n/**\n * @internal\n */\nfunction translateEvents(supplier, translate) {\n    return receiver => {\n        const dispatch = sendEventsTo(receiver);\n        supplier({\n            supply: receiver.supply,\n            receive: (_ctx, ...event) => {\n                translate(dispatch, ...event);\n            },\n        });\n    };\n}\n\n/**\n * @internal\n */\nfunction alwaysReceiveValue(value) {\n    return receiver => {\n        try {\n            sendEventsTo(receiver)(value);\n            receiver.supply.off();\n        }\n        catch (e) {\n            receiver.supply.off(e);\n        }\n    };\n}\n\n/**\n * @internal\n */\nfunction neverReceiveBecause(reason) {\n    return ({ supply }) => supply.off(reason);\n}\n/**\n * @internal\n */\nfunction neverReceive({ supply }) {\n    supply.off();\n}\n\nexport { AfterEvent$noFallback as A, EventNotifier as E, NoEventsError as N, OnEvent__symbol as O, OnEvent$supplier as a, OnEvent$do as b, OnEvent$then as c, AfterEvent__symbol as d, eventReceiver as e, sendEventsTo as f, digEvents as g, isEventSender as h, isEventKeeper as i, alwaysReceiveValue as j, neverReceiveBecause as k, supplyEvents as l, neverReceive as n, onceEvent as o, shareEvents as s, translateEvents as t };\n//# sourceMappingURL=_fun-events.base.js.map\n","import { noop, valueProvider, asis, arraysAreEqual, countArgs } from '@proc7ts/primitives';\nimport { Supply, neverSupply, isAlwaysSupply } from '@proc7ts/supply';\nimport { O as OnEvent__symbol, a as OnEvent$supplier, b as OnEvent$do, c as OnEvent$then, e as eventReceiver, A as AfterEvent$noFallback, d as AfterEvent__symbol, s as shareEvents, f as sendEventsTo, o as onceEvent, n as neverReceive, i as isEventKeeper, g as digEvents, E as EventNotifier, h as isEventSender, j as alwaysReceiveValue, k as neverReceiveBecause, t as translateEvents, l as supplyEvents } from './_fun-events.base.js';\nexport { d as AfterEvent__symbol, E as EventNotifier, N as NoEventsError, O as OnEvent__symbol, e as eventReceiver, i as isEventKeeper, h as isEventSender, f as sendEventsTo } from './_fun-events.base.js';\n\n/**\n * Converts a plain event receiver registration function to {@link OnEvent} sender.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param register - Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An {@link OnEvent} sender registering event receivers with the given `register` function.\n */\nfunction onEventBy(register) {\n    const onEvent = ((receiver) => {\n        const generic = eventReceiver(receiver);\n        const { supply } = generic;\n        if (!supply.isOff) {\n            try {\n                register(generic);\n            }\n            catch (error) {\n                supply.off(error);\n            }\n        }\n        return supply;\n    });\n    onEvent[OnEvent__symbol] = OnEvent$supplier;\n    onEvent.do = OnEvent$do;\n    onEvent.then = OnEvent$then;\n    return onEvent;\n}\n/**\n * Checks whether the given value is an {@link OnEvent} sender.\n *\n * @category Core\n * @typeParam TEvent - Expected event type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` has been created by {@link onEventBy} function or in compatible way,\n * or `false` otherwise.\n */\nfunction isOnEvent(value) {\n    return typeof value === 'function'\n        && value[OnEvent__symbol] === OnEvent$supplier\n        && value.do === OnEvent$do\n        && value.then === OnEvent$then;\n}\n\n/**\n * Converts a plain event receiver registration function to {@link AfterEvent} keeper with a fallback.\n *\n * The event constructed by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param register - Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n * @param cleanup - A function that will be called once all registered event supplies cut off.\n *\n * @returns An {@link AfterEvent} keeper registering event receivers with the given `register` function.\n */\nfunction afterEventBy(register, fallback = AfterEvent$noFallback, cleanup = AfterEvent$noCleanup) {\n    let lastEvent;\n    let numReceivers = 0;\n    const afterEvent = ((receiver) => {\n        let dest = noop;\n        const generic = eventReceiver(receiver);\n        if (generic.supply.isOff) {\n            return generic.supply;\n        }\n        const supply = new Supply(noop).needs(generic);\n        let reported = false;\n        ++numReceivers;\n        try {\n            register({\n                supply,\n                receive: (context, ...event) => {\n                    reported = true;\n                    lastEvent = event;\n                    dest(context, ...event);\n                },\n            });\n        }\n        catch (error) {\n            supply.off(error);\n        }\n        if (!supply.isOff || reported) {\n            if (!lastEvent) {\n                try {\n                    lastEvent = fallback();\n                }\n                catch (error) {\n                    supply.off(error);\n                }\n            }\n            if (lastEvent) {\n                generic.receive({\n                    onRecurrent(recurrent) {\n                        dest = (_context, ...event) => recurrent(...event);\n                    },\n                }, ...lastEvent);\n                dest = (context, ...event) => generic.receive(context, ...event);\n            }\n        }\n        return supply.whenOff(reason => {\n            if (!--numReceivers) {\n                lastEvent = undefined;\n            }\n            generic.supply.off(reason);\n            if (!numReceivers) {\n                cleanup(reason);\n            }\n        });\n    });\n    afterEvent[OnEvent__symbol] = OnEvent$supplier;\n    afterEvent.do = OnEvent$do;\n    afterEvent.then = OnEvent$then;\n    afterEvent[AfterEvent__symbol] = OnEvent$supplier;\n    return afterEvent;\n}\nfunction AfterEvent$noCleanup(_reason) {\n    // No-op `AfterEvent` cleanup\n}\n/**\n * Checks whether the given value is an {@link AfterEvent} keeper.\n *\n * @category Core\n * @typeParam TEvent - Expected event type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` has been created by {@link afterEventBy} function or in compatible way,\n * or `false` otherwise.\n */\nfunction isAfterEvent(value) {\n    return isOnEvent(value) && value[AfterEvent__symbol] === OnEvent$supplier;\n}\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeParam TSrcMap - A type of `sources` map.\n * @param sources - A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each source keeper. Each event in this map has the\n * same key as its source keeper in `sources`.\n */\nfunction afterAll(sources) {\n    const keys = Object.keys(sources);\n    const registerReceiver = (receiver) => {\n        const { supply } = receiver;\n        const dispatch = sendEventsTo(receiver);\n        let send = noop;\n        const result = {};\n        keys.forEach((key) => {\n            supply.needs(sources[key][AfterEvent__symbol]()((...event) => {\n                result[key] = event;\n                send();\n            }).needs(supply));\n        });\n        if (!supply.isOff) {\n            send = () => dispatch(result);\n        }\n    };\n    const latestEvent = () => {\n        const result = {};\n        keys.forEach((key) => onceEvent(sources[key][AfterEvent__symbol]())({\n            supply: new Supply(),\n            receive: (_ctx, ...event) => result[key] = event,\n        }));\n        return [result];\n    };\n    return afterEventBy(shareEvents(afterEventBy(registerReceiver, latestEvent)));\n}\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeParam TEvent - A type of events sent by each source.\n * @param sources - An array of source event keepers.\n *\n * @returns An event keeper sending events received from each source keeper. Each event item is an event tuple\n * originated from source keeper under its index in `sources` array.\n */\nfunction afterEach(...sources) {\n    const registerReceiver = (receiver) => {\n        const { supply } = receiver;\n        const dispatch = sendEventsTo(receiver);\n        let send = noop;\n        const result = [];\n        sources.forEach((source, index) => {\n            supply.needs(source[AfterEvent__symbol]()((...event) => {\n                result[index] = event;\n                send();\n            }).needs(supply));\n        });\n        if (!supply.isOff) {\n            send = () => dispatch(...result);\n        }\n    };\n    const latestEvent = () => {\n        const result = [];\n        sources.forEach(source => onceEvent(source[AfterEvent__symbol]())({\n            supply: new Supply(),\n            receive: (_ctx, ...event) => result.push(event),\n        }));\n        return result;\n    };\n    return afterEventBy(shareEvents(afterEventBy(registerReceiver, latestEvent)));\n}\n\n/**\n * An {@link AfterEvent} keeper that never sends any events.\n *\n * @category Core\n */\nconst afterNever = ( /*#__PURE__*/afterEventBy(neverReceive));\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param sender - An event sender.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper of events either originated from the given `sender`, or `initial` one.\n */\nfunction afterSent(sender, fallback) {\n    return afterEventBy(receiver => sender[OnEvent__symbol]()(receiver), fallback);\n}\n\nfunction afterSupplied(supplier, fallback) {\n    return isEventKeeper(supplier) ? supplier[AfterEvent__symbol]() : afterSent(supplier, fallback);\n}\n\n/**\n * Builds an {@link AfterEvent} keeper of the given `event`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param event - An event that will be sent to all receivers upon registration.\n *\n * @returns An {@link AfterEvent} keeper that always sends the given `event`.\n */\nfunction afterThe(...event) {\n    return afterEventBy(noop, valueProvider(event));\n}\n\nfunction afterValue(value) {\n    return isAfterEvent(value) ? value : afterThe(value);\n}\n\n/**\n * Creates an event processor that consumes incoming events.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming event type. This is a list of consumer function parameter types.\n * @param consume - A function consuming events. This function may return a {@link SupplyPeer peer of event supply},\n * e.g. when registers a nested event receiver. This supply will be cut off on new event, unless returned again.\n *\n * @returns A function accepting incoming event supplier and returning event supply that will stop consuming events once\n * cut off.\n */\nfunction consumeEvents(consume) {\n    return input => {\n        let consumerSupply = neverSupply();\n        // Do not use `.cuts()` here as `consumerSupply` is mutable\n        const supply = new Supply(reason => consumerSupply.off(reason));\n        input({\n            supply,\n            receive(_ctx, ...event) {\n                const prevSupply = consumerSupply;\n                try {\n                    consumerSupply = (consume(...event) || neverSupply()).supply;\n                }\n                finally {\n                    if (consumerSupply !== prevSupply) {\n                        prevSupply.off();\n                    }\n                }\n            },\n        });\n        return supply;\n    };\n}\n\n/**\n * A processor of events incoming from {@link AfterEvent} keeper that shares outgoing events supply among all registered\n * receivers.\n *\n * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n * event supplies do.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event keeper to share events from.\n *\n * @returns An {@link AfterEvent} keeper sharing a common supply of events.\n */\nfunction shareAfter(supplier) {\n    return afterEventBy(shareEvents(supplier));\n}\n\nlet deduplicateAfter$default;\nfunction deduplicateAfter(isSimilar, getCue) {\n    return isSimilar || getCue\n        ? deduplicateAfter$create(isSimilar, getCue)\n        : (deduplicateAfter$default || (deduplicateAfter$default = deduplicateAfter$create()));\n}\nfunction deduplicateAfter$create(isSimilar, getCue) {\n    const processor = deduplicateAfter_(isSimilar, getCue);\n    return input => shareAfter(processor(input));\n}\nlet deduplicateAfter_$default;\nfunction deduplicateAfter_(isSimilar, getCue) {\n    return isSimilar || getCue\n        ? deduplicateAfter_$create(isSimilar, getCue)\n        : (deduplicateAfter_$default || (deduplicateAfter_$default = deduplicateAfter_$create()));\n}\nconst deduplicateAfter$noPrior = { /* magic value meaning there is no cue */};\nfunction deduplicateAfter_$create(isSimilar = deduplicateAfter$isDuplicate, getCue = asis) {\n    return input => {\n        let prior = deduplicateAfter$noPrior;\n        return afterEventBy(({ supply, receive }) => input({\n            supply,\n            receive(ctx, ...nextEvent) {\n                const next = getCue(nextEvent);\n                if (prior === deduplicateAfter$noPrior || !isSimilar(prior, next)) {\n                    prior = next;\n                    receive(ctx, ...nextEvent);\n                }\n            },\n        }), undefined, _ => prior = deduplicateAfter$noPrior);\n    };\n}\nfunction deduplicateAfter$isDuplicate(prior, next) {\n    return arraysAreEqual(prior, next, Math.max(countArgs(prior), countArgs(next)));\n}\n\nfunction digAfter(extract, fallback) {\n    const processor = digAfter_(extract, fallback);\n    return input => shareAfter(processor(input));\n}\nfunction digAfter_(extract, fallback) {\n    const extractKeeper = (...events) => {\n        const extracted = extract(...events);\n        return extracted && afterSupplied(extracted);\n    };\n    return input => afterEventBy(digEvents(input, extractKeeper), fallback);\n}\n\n/**\n * Event emitter is a handy implementation of {@link OnEvent} sender.\n *\n * Extends {@link EventNotifier} by making its {@link EventNotifier.on} method implement an {@link OnEvent} interface.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nclass EventEmitter extends EventNotifier {\n    constructor() {\n        super(...arguments);\n        /**\n         * {@link OnEvent} sender of {@link send emitted} events.\n         *\n         * The `[OnEvent__symbol]` method is an alias of this one.\n         */\n        this.on = onEventBy(receiver => super.on(receiver));\n    }\n    [OnEvent__symbol]() {\n        return this.on;\n    }\n}\n\n/**\n * An {@link OnEvent} sender that never sends any events.\n *\n * @category Core\n */\nconst onNever = ( /*#__PURE__*/onEventBy(neverReceive));\n\n/**\n * Builds an {@link OnEvent} sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - An event supplier.\n *\n * @returns An {@link OnEvent} sender of events originated from the given `supplier`.\n */\nfunction onSupplied(supplier) {\n    return isEventSender(supplier) ? supplier[OnEvent__symbol]() : supplier[AfterEvent__symbol]();\n}\n\n/**\n * Builds an {@link OnEvent} sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param suppliers - Original event suppliers.\n *\n * @returns An {@link OnEvent} sender of all supplied events.\n */\nfunction onAny(...suppliers) {\n    if (!suppliers.length) {\n        return onNever;\n    }\n    return onEventBy(shareEvents(onEventBy(({ supply, receive }) => {\n        let remained = suppliers.length;\n        const removeSupplier = (reason) => {\n            if (!--remained) {\n                supply.off(reason);\n            }\n        };\n        suppliers.forEach(supplier => onSupplied(supplier)({\n            supply: new Supply(removeSupplier).needs(supply),\n            receive,\n        }));\n    })));\n}\n\n/**\n * Represents a promise as event sender.\n *\n * When the `promise` resolves successfully the resolved value is sent to registered event receivers. The events\n * supply is {@link Supply.off cut off} immediately after that without any reason specified.\n *\n * When the `promise` is rejected the events supply is {@link Supply.off cut off} with promise rejection reason.\n *\n * @category Core\n * @typeParam T - A type of value the promise is resolved to.\n * @param promise - The promise to represent as event sender.\n *\n * @returns An {@link OnEvent} sender of the given `promise` settlement event.\n */\nfunction onPromise(promise) {\n    let receive = (receiver) => {\n        promise.then(() => receive(receiver), () => receive(receiver));\n    };\n    promise.then(value => {\n        receive = alwaysReceiveValue(value);\n    }).catch(e => {\n        receive = neverReceiveBecause(e);\n    });\n    return onEventBy(receiver => receive(receiver));\n}\n\n/**\n * A processor of events incoming from {@link OnEvent} sender that shares outgoing events supply among all registered\n * receivers.\n *\n * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n * supplies do.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event sender to share events from.\n *\n * @returns An {@link OnEvent} sender sharing a common supply of events.\n */\nfunction shareOn(supplier) {\n    return onEventBy(shareEvents(supplier));\n}\n\n/**\n * Creates an event processor that extracts event senders from incoming events.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event supplier from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New event processor.\n */\nfunction digOn(extract) {\n    const processor = digOn_(extract);\n    return input => shareOn(processor(input));\n}\n/**\n * Creates an event processor that extracts event senders from incoming events, and does not share the outgoing events\n * supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event supplier from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New event processor.\n */\nfunction digOn_(extract) {\n    const extractSender = (...event) => {\n        const extracted = extract(...event);\n        return extracted && onSupplied(extracted);\n    };\n    return input => onEventBy(digEvents(input, extractSender));\n}\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event sender to another one.\n */\nfunction translateOn(translate) {\n    const mapper = translateOn_(translate);\n    return input => shareOn(mapper(input));\n}\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender, and does not share the\n * outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event sender to another one.\n */\nfunction translateOn_(translate) {\n    return input => onEventBy(translateEvents(input, translate));\n}\n\nfunction filterOn(test) {\n    const map = filterOn_(test);\n    return supplier => shareOn(map(supplier));\n}\nfunction filterOn_(// eslint-disable-line @typescript-eslint/naming-convention\ntest) {\n    return translateOn_((send, ...event) => test(...event) && send(...event));\n}\n\nfunction mapAfter(convert, fallback) {\n    const mapper = mapAfter_(convert, fallback);\n    return input => shareAfter(mapper(input));\n}\nfunction mapAfter_(// eslint-disable-line @typescript-eslint/naming-convention\nconvert, fallback) {\n    return input => afterEventBy(translateEvents(input, (send, ...event) => send(convert(...event))), fallback && (() => [fallback()]));\n}\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n *\n * @returns New event mapper.\n */\nfunction mapOn(convert) {\n    const mapper = mapOn_(convert);\n    return input => shareOn(mapper(input));\n}\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function, and does not share the outgoing events supply.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n *\n * @returns New event mapper.\n */\nfunction mapOn_(// eslint-disable-line @typescript-eslint/naming-convention\nconvert) {\n    return input => onEventBy(translateEvents(input, (send, ...event) => send(convert(...event))));\n}\n\n/**\n * A processor of the first event incoming from {@link AfterEvent} keeper.\n *\n * Cuts off the outgoing events supply after sending the first event.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event keeper to receive an event from.\n *\n * @returns New keeper of the first event.\n */\nfunction onceAfter(supplier) {\n    return afterEventBy(onceEvent(supplier));\n}\n\n/**\n * A processor of the first event incoming from {@link OnEvent} sender.\n *\n * Cuts off the outgoing event supply after sending the first event.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event sender to receive an event from.\n *\n * @returns New sender of the first event.\n */\nfunction onceOn(supplier) {\n    return onEventBy(onceEvent(supplier));\n}\n\n/**\n * A processor that asynchronously resolves incoming events and sends then in the order of their resolution.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved. The original\n * order of events is not preserved. Instead each resolved event is sent along with its index in original order.\n *\n * The resulting events supply is cut off immediately once unresolved events supply is cut off, or some of incoming\n * event promises rejected. In the latter case the rejection reason is used as a reason to cut off.\n *\n * @category Event Processing\n * @typeParam T - A type of values the promises resolve to.\n * @param from - A sender of events or promise-like instances resolved to ones.\n *\n * @returns New `OnEvent` sender of resolved events and their indices in original order starting from `1`.\n */\nfunction resolveOn(from) {\n    return onEventBy(receiver => {\n        const { supply } = receiver;\n        const dispatch = sendEventsTo(receiver);\n        let lastIndex = 0;\n        from({\n            supply,\n            receive(_ctx, promise) {\n                const index = ++lastIndex;\n                Promise.resolve()\n                    .then(() => promise)\n                    .then(event => dispatch(event, index), reason => supply.off(reason));\n            },\n        });\n    });\n}\n\n/**\n * Creates an event processor that passes events incoming from {@link OnEvent} sender until the `required` supply is\n * cut off.\n *\n * The outgoing events supply will be cut off once incoming event supply does, unless a second supply passed in.\n * In the latter case that supply will be cut off instead.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param required - A peer of required event supply. The returned processor does nothing when `alwaysSupply()`\n * specified.\n * @param dependentSupply - The supply to cut off on cutting off the incoming events supply.\n *\n * @returns New event mapper.\n */\nfunction supplyOn(required, dependentSupply) {\n    return isAlwaysSupply(required.supply)\n        ? asis\n        : (input) => onEventBy(supplyEvents(input, required, dependentSupply));\n}\n\n/**\n * A processor that asynchronously resolves incoming events and sends them in the order they are received.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved in the same\n * order as they have been received. Mat send events in batches, e.g. when events resolved out of order.\n *\n * The resulting events supply is cut off if some of incoming event promises rejected. In this case the rejection reason\n * is used as a reason to cut off. If incoming events supply is cut off, then the resulting event supply will be cut off\n * too, but only after all incoming events resolved and sent.\n *\n * @category Event Processing\n * @typeParam TEvent - Resolved event type.\n * @param from - A sender of events or promise-like instances resolved to ones.\n *\n * @returns New `OnEvent` sender of resolved events.\n */\nfunction resolveOnOrdered(from) {\n    return onEventBy(receiver => {\n        const { supply } = receiver;\n        const dispatch = sendEventsTo(receiver);\n        const sourceSupply = new Supply();\n        let numInProcess = 0;\n        const source = from.do(supplyOn(supply, sourceSupply), mapOn(event => {\n            ++numInProcess;\n            return event;\n        }));\n        let received = [];\n        let numSent = 1;\n        let numReceived = 0;\n        sourceSupply.whenOff(reason => {\n            if (!numInProcess) {\n                supply.off(reason);\n            }\n        });\n        resolveOn(source)({\n            supply,\n            receive(_ctx, event, index) {\n                const i = index - numSent;\n                received[i] = event;\n                ++numReceived;\n                if (numReceived > i) {\n                    let toSend;\n                    if (numReceived === received.length) {\n                        // Can send all received events\n                        toSend = received;\n                        received = [];\n                    }\n                    else {\n                        // Can send events up to `i`\n                        toSend = received.splice(0, i + 1);\n                    }\n                    numSent += toSend.length;\n                    numReceived -= toSend.length;\n                    numInProcess -= toSend.length;\n                    dispatch(...toSend);\n                    if (!numInProcess && sourceSupply.isOff) {\n                        supply.needs(sourceSupply);\n                    }\n                }\n            },\n        });\n    });\n}\n\n/**\n * Creates an event processor that passes events incoming from {@link AfterEvent} keeper until the `required` supply\n * is cut off.\n *\n * The outgoing events supply will be cut off once incoming event supply does, unless a second supply passed in.\n * In the latter case that supply will be cut off instead.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param required - A peer of required event supply. The returned processor does nothing when `alwaysSupply()`\n * specified.\n * @param dependentSupply - The supply to cut off on cutting off the incoming events supply.\n *\n * @returns New event mapper.\n */\nfunction supplyAfter(required, dependentSupply) {\n    return isAlwaysSupply(required.supply)\n        ? asis\n        : (input) => afterEventBy(supplyEvents(input, required, dependentSupply));\n}\n\nfunction translateAfter(translate, fallback) {\n    const mapper = translateAfter_(translate, fallback);\n    return input => shareAfter(mapper(input));\n}\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback, and does not\n * share the outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `translate` function. A receiver registration would lead to an error otherwise.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nfunction translateAfter_(translate, fallback) {\n    return input => afterEventBy(translateEvents(input, translate), fallback);\n}\n\nfunction valueAfter(valueOf, fallback) {\n    const mapper = valueAfter_(valueOf, fallback);\n    return input => shareAfter(mapper(input));\n}\nfunction valueAfter_(// eslint-disable-line @typescript-eslint/naming-convention\nvalueOf, fallback) {\n    return translateAfter_((send, ...event) => {\n        const value = valueOf(...event);\n        if (value != null && value !== false) {\n            send(value);\n        }\n    }, (fallback && (() => [fallback()])));\n}\n\n/**\n * Creates an event processor that sends the values of incoming events.\n *\n * Events are valued by provided `value` function. The `null`, `undefined`, and `false` values are dropped.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming event type.\n * @typeParam TValue - Event value type.\n * @param valueOf - Event value detector function. Accepts incoming event as parameters and returns either its value,\n * or `false`/`null`/`undefined` to ignore it.\n *\n * @returns New event processor.\n */\nfunction valueOn(valueOf) {\n    const mapper = valueOn_(valueOf);\n    return input => shareOn(mapper(input));\n}\n/**\n * Creates an event processor that sends the values of incoming events, and does not share the outgoing events supply.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming event type.\n * @typeParam TValue - Event value type.\n * @param valueOf - Event value detector function. Accepts incoming event as parameters and returns either its value,\n * or `false`/`null`/`undefined` to ignore it.\n *\n * @returns New event processor.\n */\nfunction valueOn_(// eslint-disable-line @typescript-eslint/naming-convention\nvalueOf) {\n    return translateOn_((send, ...event) => {\n        const value = valueOf(...event);\n        if (value != null && value !== false) {\n            send(value);\n        }\n    });\n}\n\nfunction statePath(path) {\n    return (Array.isArray(path) ? path : [path]);\n}\n\n/**\n * @internal\n */\nclass PathEntry {\n    constructor(_drop) {\n        this._drop = _drop;\n        this.emitter = new EventEmitter();\n        this._nested = new Map();\n        this.emitter.on((path, newValue, oldValue) => {\n            const key = path[0];\n            const nested = this._nested.get(key);\n            if (nested) {\n                nested.emitter.send(path.slice(1), newValue, oldValue);\n            }\n        });\n    }\n    on(receiver) {\n        const supply = this.emitter.on(receiver);\n        return new Supply(reason => {\n            supply.off(reason);\n            this._dropIfEmpty();\n        }).needs(supply);\n    }\n    nest(key, dontCreateMissing) {\n        const found = this._nested.get(key);\n        if (found || dontCreateMissing) {\n            return found;\n        }\n        const created = new PathEntry(() => this._remove(key));\n        this._nested.set(key, created);\n        return created;\n    }\n    done(reason) {\n        for (const nested of this._nested.values()) {\n            nested.done(reason);\n        }\n        this.emitter.supply.off(reason);\n    }\n    _remove(key) {\n        this._nested.delete(key);\n        this._dropIfEmpty();\n    }\n    _dropIfEmpty() {\n        if (!this._nested.size && this.emitter.size <= 1) {\n            this._drop();\n        }\n    }\n}\n/**\n * @internal\n */\nclass Trackers {\n    constructor() {\n        this._root = new PathEntry(noop);\n    }\n    on(path, receiver) {\n        return this._entry(path).on(receiver);\n    }\n    send(path, newValue, oldValue) {\n        this._root.emitter.send(path, newValue, oldValue);\n    }\n    done(path, reason) {\n        const entry = this._entry(path, true);\n        if (entry) {\n            entry.done(reason);\n        }\n    }\n    _entry(path, dontCreateMissing) {\n        let entry = this._root;\n        for (const key of path) {\n            const nested = entry.nest(key, dontCreateMissing);\n            if (!nested) {\n                return;\n            }\n            entry = nested;\n        }\n        return entry;\n    }\n}\n/**\n * @internal\n */\nclass SubStateTracker {\n    constructor(_trackers, _path) {\n        this._trackers = _trackers;\n        this._path = _path;\n        this.onUpdate = onEventBy(receiver => this._trackers.on(this._path, receiver));\n        this.update = (path, newValue, oldValue) => {\n            this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n        };\n    }\n    get _tracker() {\n        return this;\n    }\n    [OnEvent__symbol]() {\n        return this.onUpdate;\n    }\n    track(path) {\n        path = statePath(path);\n        if (!path.length) {\n            return this; // Path to itself.\n        }\n        return new SubStateTracker(this._trackers, [...this._path, ...path]);\n    }\n    done(reason) {\n        this._trackers.done(this._path, reason);\n    }\n}\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under {@link StatePath}.\n *\n * When node modified a {@link StateTracker.update} should be called. Then all state update receivers registered by\n * {@link StateTracker.onUpdate} will receive this update.\n *\n * @category State Tracking\n */\nclass StateTracker {\n    constructor() {\n        /**\n         * @internal\n         */\n        this._tracker = new SubStateTracker(new Trackers(), []);\n    }\n    /**\n     * {@link OnStateUpdate state updates sender}.\n     *\n     * A state update will be sent to it whenever an `update()` function is called.\n     *\n     * The `[OnEvent__symbol]` property is an alias of this one.\n     *\n     * @returns State updates sender.\n     */\n    get onUpdate() {\n        return this._tracker.onUpdate;\n    }\n    [OnEvent__symbol]() {\n        return this.onUpdate;\n    }\n    // noinspection JSCommentMatchesSignature\n    /**\n     * Updates the component state.\n     *\n     * All receivers registered with {@link onUpdate} will receive this update.\n     *\n     * @typeParam T - A type of changed value.\n     * @param key - Changed value key.\n     * @param newValue - New value.\n     * @param oldValue - Previous value.\n     */\n    get update() {\n        return this._tracker.update;\n    }\n    /**\n     * Starts tracking of partial state under the given path.\n     *\n     * @param path - A path to state part.\n     *\n     * @return New partial state tracker.\n     */\n    track(path) {\n        const subTracker = this._tracker.track(path);\n        return subTracker === this._tracker ? this : subTracker;\n    }\n    /**\n     * Unregisters updates receivers and cuts off their supplies.\n     *\n     * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n     *\n     * @param reason - An optional reason to stop tracking.\n     */\n    done(reason) {\n        this._tracker.done(reason);\n    }\n}\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an {@link EventSender} interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an {@link EventKeeper} interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeParam T - Tracked value type.\n */\nclass ValueTracker {\n    constructor() {\n        /**\n         * @internal\n         */\n        this._by = neverSupply();\n        /**\n         * {@link AfterEvent} keeper of current value.\n         *\n         * The `[AfterEvent__symbol]` property is an alias of this one.\n         *\n         * @returns Current value keeper.\n         */\n        this.read = afterEventBy(receiver => this.on(receiveNewValue(receiver)), () => [this.it]);\n    }\n    [OnEvent__symbol]() {\n        return this.on;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n    by(supplier, extract) {\n        const acceptValuesFrom = (sender) => {\n            const onValue = isEventKeeper(sender) ? sender[AfterEvent__symbol]() : sender[OnEvent__symbol]();\n            return onValue(value => this.it = value);\n        };\n        this.byNone();\n        if (!extract) {\n            const sender = supplier;\n            this._by = acceptValuesFrom(sender);\n        }\n        else {\n            const container = supplier;\n            this._by = onSupplied(container).do(consumeEvents((...event) => {\n                const sender = extract(...event);\n                if (sender) {\n                    return acceptValuesFrom(sender);\n                }\n                return;\n            }));\n        }\n        this._by.whenOff(() => this._by = neverSupply());\n        return this;\n    }\n    /**\n     * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n     *\n     * If the tracker is not bound then does nothing.\n     *\n     * @param reason - Arbitrary reason of unbinding the value.\n     *\n     * @returns `this` instance.\n     */\n    byNone(reason) {\n        this._by.off(reason);\n        return this;\n    }\n}\n/**\n * @internal\n */\nfunction receiveNewValue(valueReceiver) {\n    return {\n        supply: valueReceiver.supply,\n        receive(context, newValue) {\n            valueReceiver.receive({\n                onRecurrent(recurrentReceiver) {\n                    context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n                },\n            }, newValue);\n        },\n    };\n}\n\n/**\n * @internal\n */\nclass TrackedValue extends ValueTracker {\n    constructor(_it) {\n        super();\n        this._it = _it;\n        this._on = new EventEmitter();\n    }\n    get supply() {\n        return this._on.supply;\n    }\n    get on() {\n        return this._on.on;\n    }\n    get it() {\n        return this._it;\n    }\n    set it(value) {\n        const oldValue = this._it;\n        if (oldValue !== value) {\n            this._it = value;\n            this._on.send(value, oldValue);\n        }\n    }\n}\nfunction trackValue(initial) {\n    return new TrackedValue(initial);\n}\nfunction trackValueBy(supplier, extract) {\n    return trackValue().by(supplier, extract);\n}\n\n/**\n * Synchronizes tracked values with each other.\n *\n * Any change to any of the added tracked values would update all the others.\n *\n * @category Value Tracking\n */\nclass ValueSync extends ValueTracker {\n    constructor(initial) {\n        super();\n        /**\n         * @internal\n         */\n        this._on = new EventEmitter();\n        this._it = initial;\n    }\n    get on() {\n        return this._on.on;\n    }\n    get supply() {\n        return this._on.supply;\n    }\n    get it() {\n        return this._it;\n    }\n    set it(value) {\n        const old = this.it;\n        if (old !== value) {\n            this._it = value;\n            this._on.send(value, old);\n        }\n    }\n    sync(first, second, third) {\n        let syncWithTracker = (tracker) => syncTrackers(this, tracker);\n        let source;\n        let extract;\n        if (typeof first === 'string') {\n            if (first === 'in') {\n                syncWithTracker = tracker => syncTrackers(tracker, this);\n            }\n            source = second;\n            extract = third;\n        }\n        else {\n            source = first;\n            extract = second;\n        }\n        const extractTracker = extract;\n        if (!extractTracker) {\n            return syncWithTracker(source);\n        }\n        const supplier = source;\n        return (isEventKeeper(supplier) ? afterSupplied(supplier) : onSupplied(supplier)).do(consumeEvents((...event) => {\n            const tracker = extractTracker(...event);\n            return tracker && syncWithTracker(tracker);\n        }));\n        function syncTrackers(tracker1, tracker2) {\n            const supply1 = tracker1.read(value => {\n                tracker2.it = value;\n            });\n            const supply2 = tracker2.on(value => {\n                tracker1.it = value;\n            });\n            return new Supply(reason => {\n                supply2.off(reason);\n                supply1.off(reason);\n            }).needs(supply1).needs(supply2);\n        }\n    }\n}\n\nexport { EventEmitter, StateTracker, ValueSync, ValueTracker, afterAll, afterEach, afterEventBy, afterNever, afterSent, afterSupplied, afterThe, afterValue, consumeEvents, deduplicateAfter, deduplicateAfter_, digAfter, digAfter_, digOn, digOn_, filterOn, filterOn_, isAfterEvent, isOnEvent, mapAfter, mapAfter_, mapOn, mapOn_, onAny, onEventBy, onNever, onPromise, onSupplied, onceAfter, onceOn, resolveOn, resolveOnOrdered, shareAfter, shareOn, statePath, supplyAfter, supplyOn, trackValue, trackValueBy, translateAfter, translateAfter_, translateOn, translateOn_, valueAfter, valueAfter_, valueOn, valueOn_ };\n//# sourceMappingURL=fun-events.js.map\n","import { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { OnEvent__symbol, onEventBy, eventReceiver } from '@proc7ts/fun-events';\n\n/**\n * @internal\n * @hidden\n */\nconst OnDomEvent$sample = ( /*#__PURE__*/onEventBy(noop));\n/**\n * Converts a plain DOM event listener registration function to {@link OnDomEvent} sender.\n *\n * @typeParam TEvent - Supported DOM event type.\n * @param register - A generic DOM event listener registration function.\n *\n * @returns An {@link OnDomEvent} sender registering event listeners with the given `register` function.\n */\nfunction onDomEventBy(register) {\n    const onDomEvent = ((listener, opts) => {\n        const receiver = eventReceiver(listener);\n        const { supply } = receiver;\n        if (!supply.isOff) {\n            register(receiver, opts);\n        }\n        return supply;\n    });\n    onDomEvent[OnEvent__symbol] = OnDomEvent$sample[OnEvent__symbol];\n    onDomEvent.do = OnDomEvent$sample.do;\n    onDomEvent.then = OnDomEvent$sample.then;\n    return onDomEvent;\n}\n\n/**\n * @internal\n * @hidden\n */\nconst OnDomEvent$context = {\n    onRecurrent: noop,\n};\n/**\n * DOM event dispatcher can be used to register event listeners of particular event types and dispatch events.\n */\nclass DomEventDispatcher {\n    /**\n     * Constructs DOM event dispatcher for the given event target.\n     *\n     * @param target - Event target to construct event dispatcher for.\n     */\n    constructor(target) {\n        this.supply = new Supply();\n        this._target = target;\n    }\n    /**\n     * Returns a sender of DOM events of the given `type`.\n     *\n     * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n     * But, in contrast, it allows to register the same listener many times.\n     *\n     * The {@link Supply event supply} returned upon event listener registration unregisters it with\n     * `EventTarget.removeEventListener()` once {@link Supply.off cut off}.\n     *\n     * @typeParam TEvent - Supported DOM event type.\n     * @param type - DOM event type name.\n     *\n     * @returns {@link OnDomEvent} sender of DOM events of the given `type`.\n     */\n    on(type) {\n        return onDomEventBy((listener, opts) => {\n            const { supply } = listener;\n            supply.needs(this);\n            if (!supply.isOff) {\n                // Create unique DOM listener instance\n                const domListener = event => listener.receive(OnDomEvent$context, event);\n                this._target.addEventListener(type, domListener, opts);\n                listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n            }\n        });\n    }\n    /**\n     * Dispatches the given DOM event to event target.\n     *\n     * Calls `EventTarget.dispatchEvent()` method.\n     *\n     * @param event - An event to dispatch.\n     *\n     * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n     * invoked, or `false` otherwise. Also returns `false` when {@link supply} is cut off.\n     */\n    dispatch(event) {\n        return !this.supply.isOff && this._target.dispatchEvent(event);\n    }\n}\n\n/**\n * Creates an {@link OnDomEvent} sender that enables event capturing by default.\n *\n * This corresponds to specifying `true` or `{ capture: true }` as a second argument to\n * `EventTarget.addEventListener()`.\n *\n * @typeParam TEvent - DOM event type.\n * @param supplier - DOM events sender.\n *\n * @returns DOM events sender.\n */\nfunction captureDomEvents(supplier) {\n    return onDomEventBy((listener, opts) => {\n        if (opts == null) {\n            return supplier(listener, true);\n        }\n        if (typeof opts === 'object' && opts.capture == null) {\n            return supplier(listener, { ...opts, capture: true });\n        }\n        return supplier(listener, opts);\n    });\n}\n\n/**\n * Creates a DOM events processor that enables or disables default DOM event handlers.\n *\n * @typeParam TEvent - DOM event type.\n * @param enable - Whether to enable default handlers. `true` to enable (default value, corresponds to specifying\n * `{ passive: true }` as a second argument to `EventTarget.addEventListener()`), or `false` to disable\n * (causes listeners to invoke an `Event.preventDefault()` method prior to event handling).\n *\n * @returns {@link OnDomEvent} mapper function.\n */\nfunction handleDomEvents(enable = true) {\n    return enable ? listenDomEventsPassively : preventDefaultDomEventHandler;\n}\n/**\n * @internal\n * @hidden\n */\nfunction listenDomEventsPassively(supplier) {\n    return onDomEventBy((listener, opts) => {\n        if (opts == null) {\n            return supplier(listener, { passive: true });\n        }\n        if (typeof opts === 'boolean') {\n            return supplier(listener, { capture: opts, passive: true });\n        }\n        if (opts.passive == null) {\n            return supplier(listener, { ...opts, passive: true });\n        }\n        return supplier(listener, opts);\n    });\n}\n/**\n * @internal\n * @hidden\n */\nfunction preventDefaultDomEventHandler(supplier) {\n    return onDomEventBy((listener, opts) => {\n        const receiver = eventReceiver(listener);\n        return supplier({\n            supply: receiver.supply,\n            receive(context, event) {\n                event.preventDefault();\n                receiver.receive(context, event);\n            },\n        }, opts);\n    });\n}\n\n/**\n * Creates an {@link OnDomEvent} sender preventing other listeners of the same event from being called.\n *\n * Causes listeners to invoke an [Event.stopImmediatePropagation()] method prior to event handing.\n *\n * [Event.stopImmediatePropagation()]: https://developer.mozilla.org/en-US/docs/Web/API/Event/stopImmediatePropagation\n *\n * @typeParam TEvent - DOM event type.\n * @param supplier - DOM events sender.\n *\n * @returns DOM events sender.\n */\nfunction interceptDomEvents(supplier) {\n    return onDomEventBy((listener, opts) => {\n        const receiver = eventReceiver(listener);\n        return supplier({\n            supply: receiver.supply,\n            receive(context, event) {\n                event.stopImmediatePropagation();\n                receiver.receive(context, event);\n            },\n        }, opts);\n    });\n}\n\n/**\n * Creates an {@link OnDomEvent} sender preventing further propagation of events in the capturing and bubbling phases.\n *\n * Causes listeners to invoke an [Event.stopPropagation()] method prior to event handing.\n *\n * [Event.stopPropagation()]: https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation\n *\n * @typeParam TEvent - DOM event type.\n * @param supplier - DOM events sender.\n *\n * @returns DOM events sender.\n */\nfunction stopDomEvents(supplier) {\n    return onDomEventBy((listener, opts) => {\n        const receiver = eventReceiver(listener);\n        return supplier({\n            supply: receiver.supply,\n            receive(context, event) {\n                event.stopPropagation();\n                receiver.receive(context, event);\n            },\n        }, opts);\n    });\n}\n\nexport { DomEventDispatcher, captureDomEvents, handleDomEvents, interceptDomEvents, onDomEventBy, stopDomEvents };\n//# sourceMappingURL=dom-events.js.map\n","import { supplyAfter, trackValue, afterThe, digAfter_, afterEach, isAfterEvent, translateAfter, translateAfter_, shareAfter, digAfter, afterEventBy, mapAfter_, AfterEvent__symbol, onEventBy } from '@proc7ts/fun-events';\nimport { isPresent, noop, valueProvider, setOfElements, isDefined } from '@proc7ts/primitives';\nimport { mapIt, overIterator, itsElements, overElementsOf, filterIt, valueIt } from '@proc7ts/push-iterator';\nimport { Supply, neverSupply } from '@proc7ts/supply';\nimport { ContextKey, ContextSeedKey, ContextSupply, isContextual, Contextual__symbol, ContextKeyError, ContextKey__symbol, ContextBuilder__symbol } from './context-values.js';\n\n/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason - Context destruction reason.\n */\nfunction contextDestroyed(reason = new TypeError('Context destroyed')) {\n    return () => {\n        throw reason;\n    };\n}\n\n/**\n * @internal\n */\nconst flatUpSources = (\n/*#__PURE__*/ translateAfter((send, ...sources) => send(...itsElements(overElementsOf(...sources)))));\n/**\n * @internal\n */\nclass ContextUpSeeder {\n    constructor() {\n        this._providers = trackValue([new Map()]);\n    }\n    provide(provider) {\n        const [providers] = this._providers.it;\n        const supply = new Supply();\n        providers.set(supply, provider);\n        this._providers.it = [providers];\n        return supply.whenOff(() => {\n            const [providers] = this._providers.it;\n            providers.delete(supply);\n            this._providers.it = [providers];\n        });\n    }\n    seed(context, initial = afterThe()) {\n        return this.combine(initial, upSrcKeepers(context, this._providers));\n    }\n    isEmpty() {\n        return false;\n    }\n    combine(first, second) {\n        return afterEach(first, second).do(flatUpSources);\n    }\n}\n/**\n * @internal\n */\nfunction upSrcKeepers(context, providersTracker) {\n    return providersTracker.read.do(digAfter_(([providers]) => !providers.size\n        ? afterThe()\n        : afterEach(...mapIt(mapIt(overIterator(() => providers.values()), prov => prov(context)), toUpSrcKeeper))), flatUpSources);\n}\n/**\n * @internal\n */\nfunction toUpSrcKeeper(src) {\n    return isAfterEvent(src)\n        ? src\n        : (src != null ? afterThe(src) : afterThe());\n}\n/**\n * @internal\n */\nclass ContextSeed$UpKey extends ContextSeedKey {\n    get upKey() {\n        return this;\n    }\n    seeder() {\n        return new ContextUpSeeder();\n    }\n}\n/**\n * @internal\n */\nclass ContextUpKey$UpKey extends ContextKey {\n    constructor(_key, grow) {\n        super(_key.name + ':up');\n        this._key = _key;\n        this.grow = slot => {\n            const value = slot.fillBy(grow);\n            if (value != null) {\n                slot.insert(value.do(supplyAfter(slot.context.get(ContextSupply))));\n            }\n        };\n    }\n    get seedKey() {\n        return this._key.seedKey;\n    }\n    get upKey() {\n        return this;\n    }\n}\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts a {@link ContextUpKey.Source} instances as source values.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nclass ContextUpKey extends ContextKey {\n    /**\n     * Constructs simple context value key.\n     *\n     * @param name - Human-readable key name.\n     * @param seedKey - Value seed key. A new one will be constructed when omitted.\n     */\n    constructor(name, { seedKey, } = {}) {\n        super(name);\n        this.seedKey = seedKey || new ContextSeed$UpKey(this);\n    }\n    /**\n     * Creates a key of context value containing an `AfterEvent` keeper of updates to the value of this key.\n     *\n     * @typeParam TUpdate - Context value update type.\n     * @param grow - A function that grows an updates keeper of context value out of its seed.\n     *\n     * @returns New updates keeper key.\n     */\n    createUpKey(grow) {\n        return new ContextUpKey$UpKey(this, grow);\n    }\n}\n\n/**\n * Creates an event processor that {@link applyContextTo} applies context to values and their {@link Contextual\n * contextual references} incoming from {@link AfterEvent} keeper.\n *\n * This function is applicable to updatable context value {@link ContextUpKey.Source sources} potentially containing\n * contextual references.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param context - A context to apply.\n *\n * @returns A mapping function of `AfterEvent` keeper of values, their contextual references, or `null`/`undefined`\n * elements to `AfterEvent` keeper of resolved values.\n */\nfunction applyContextAfter(context) {\n    const processor = applyContextAfter_(context);\n    return source => shareAfter(processor(source));\n}\n/**\n * Creates an event processor that {@link applyContextTo} applies context to values and their {@link Contextual\n * contextual references} incoming from {@link AfterEvent} keeper, and does not share the outgoing events supply.\n *\n * This function is applicable to updatable context value {@link ContextUpKey.Source sources} potentially containing\n * contextual references to resolve the latter before providing to context.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param context - A context to apply.\n *\n * @returns A mapping function of `AfterEvent` keeper of values, their contextual references, or `null`/`undefined`\n * elements to `AfterEvent` keeper of resolved values.\n */\nfunction applyContextAfter_(context) {\n    return translateAfter_((send, ...values) => send(...filterIt(mapIt(values, (value) => isContextual(value)\n        ? value[Contextual__symbol](context)\n        : value), isPresent)));\n}\n\n/**\n * Converts an `AfterEvent` keeper of values or their {@link Contextual contextual references} to context value\n * {@link ContextValueProvider provider} of `AfterEvent` keeper of resolved values.\n *\n * This function is applicable to updatable context value {@link ContextUpKey.Source sources} potentially containing\n * contextual references to resolve the latter before providing to context.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param source - An `AfterEvent` keeper of values, their contextual references, or `null`/`undefined` elements.\n *\n * @returns Context value provider.\n */\nfunction applyContextUp(source) {\n    return context => applyContextAfter(context)(source);\n}\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an {@link ContextKeyError}.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nclass FnContextKey extends ContextUpKey {\n    /**\n     * Constructs updatable context function key.\n     *\n     * @param name - Human-readable key name.\n     * @param seedKey - Value seed key. A new one will be constructed when omitted.\n     * @param byDefault - Constructs a default function to call. If unspecified then the default function would raise\n     * an error.\n     */\n    constructor(name, { seedKey, byDefault = noop, } = {}) {\n        super(name, seedKey);\n        this.byDefault = (context, key) => byDefault(context, key)\n            || (() => {\n                throw new ContextKeyError(this);\n            });\n        this.upKey = this.createUpKey(slot => slot.insert(slot.seed.do(digAfter((...fns) => {\n            if (fns.length) {\n                return afterThe(fns[fns.length - 1]);\n            }\n            if (slot.hasFallback && slot.or) {\n                return slot.or;\n            }\n            return afterThe(this.byDefault(slot.context, this));\n        }))));\n    }\n    grow(slot) {\n        let delegated;\n        slot.context.get(this.upKey, slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined)(fn => delegated = fn).whenOff(reason => delegated = contextDestroyed(reason));\n        slot.insert((...args) => delegated(...args));\n    }\n}\n\n/**\n * Multiple updatable context values key.\n *\n * The associated value is an `AfterEvent` keeper of the source values. It is always present, even though\n * the array can be empty.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TSrc - Source value type.\n */\nclass MultiContextUpKey extends ContextUpKey {\n    /**\n     * Constructs multiple updatable context value key.\n     *\n     * @param name - Human-readable key name.\n     * @param seedKey - Value seed key. A new one will be constructed when omitted.\n     * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n     * value.\n     */\n    constructor(name, { seedKey, byDefault = noop, } = {}) {\n        super(name, seedKey);\n        this.byDefault = byDefault;\n    }\n    get upKey() {\n        return this;\n    }\n    grow(slot) {\n        const value = slot.seed.do(digAfter((...sources) => {\n            if (sources.length) {\n                // Sources present. Use them.\n                return afterThe(...sources);\n            }\n            // Sources absent. Attempt to detect the backup value.\n            let backup;\n            if (slot.hasFallback) {\n                backup = slot.or;\n            }\n            else {\n                const defaultValue = this.byDefault(slot.context, this);\n                backup = defaultValue != null ? afterThe(...defaultValue) : afterThe();\n            }\n            if (backup) {\n                return backup; // Backup value found.\n            }\n            // Backup value is absent. Construct an error response.\n            return afterEventBy(({ supply }) => {\n                supply.off(new ContextKeyError(this));\n            });\n        }));\n        slot.insert(value.do(supplyAfter(slot.context.get(ContextSupply))));\n    }\n}\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an {@link ContextKeyError} error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TValue - Context value type.\n */\nclass SingleContextUpKey extends ContextUpKey {\n    /**\n     * Constructs single updatable context value key.\n     *\n     * @param name - Human-readable key name.\n     * @param seedKey - Value seed key. A new one will be constructed when omitted.\n     * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n     * value.\n     */\n    constructor(name, { seedKey, byDefault = noop, } = {}) {\n        super(name, seedKey);\n        this.byDefault = byDefault;\n    }\n    get upKey() {\n        return this;\n    }\n    grow(slot) {\n        const value = slot.seed.do(digAfter((...sources) => {\n            if (sources.length) {\n                // Sources present. Take the last one.\n                return afterThe(sources[sources.length - 1]);\n            }\n            // Sources absent. Attempt to detect a backup value.\n            let backup;\n            if (slot.hasFallback) {\n                backup = slot.or;\n            }\n            else {\n                const defaultValue = this.byDefault(slot.context, this);\n                if (defaultValue != null) {\n                    backup = afterThe(defaultValue);\n                }\n            }\n            if (backup) {\n                return backup; // Backup value found.\n            }\n            // Backup value is absent. Construct an error response.\n            return afterEventBy(({ supply }) => {\n                supply.off(new ContextKeyError(this));\n            });\n        }));\n        slot.insert(value.do(supplyAfter(slot.context.get(ContextSupply))));\n    }\n}\n\n/**\n * An error indicating context module dependency load failure.\n */\nclass ContextModuleDependencyError extends Error {\n    /**\n     * Constructs context module dependency load error.\n     *\n     * @param module - A module failed to load.\n     * @param reasons - An array of dependency/reason pairs caused the load failure.\n     * @param message - An error message.\n     */\n    constructor(module, reasons = [], message = contextModuleDependencyErrorMessage(module, reasons)) {\n        super(message);\n        this.module = module;\n        this.reasons = reasons;\n        this.message = message;\n    }\n}\n/**\n * @internal\n */\nfunction contextModuleDependencyErrorMessage(module, dependencies) {\n    const reasons = dependencies.reduce((out, [dep, reason]) => {\n        if (out) {\n            out += ', ';\n        }\n        else {\n            out = ': ';\n        }\n        if (reason !== undefined) {\n            out += `${dep} failed to load (${reason})`;\n        }\n        else {\n            out += `${dep} not loaded`;\n        }\n        return out;\n    }, '');\n    return `Failed to load ${module}${reasons}`;\n}\n\n/**\n * @internal\n */\nclass ContextModuleUsage {\n    constructor(context, module) {\n        this.module = module;\n        this._useCounter = 0;\n        this._impl = trackValue();\n        this._rev = trackValue({\n            status: {\n                module: this.module,\n                provided: false,\n                used: false,\n                settled: false,\n                ready: false,\n            },\n            supply: neverSupply(),\n        });\n        const contextSupply = context.get(ContextSupply);\n        contextSupply.cuts(this._impl);\n        contextSupply.cuts(this._rev);\n        this._impl.read(module => {\n            const prevSupply = this._rev.it.supply;\n            if (module) {\n                this._load(module);\n            }\n            prevSupply.off();\n        });\n    }\n    createHandle() {\n        const read = this._rev.read.do(mapAfter_(({ status }) => status));\n        const handle = {\n            read,\n            [AfterEvent__symbol]: valueProvider(read),\n            use: (user) => this._use(handle, user),\n        };\n        return handle;\n    }\n    setup(context, registry) {\n        this._setup = () => {\n            const rev = this._rev.it;\n            const { status: { module }, supply } = rev;\n            if (module !== this.module) {\n                // Load implementation module instead.\n                // The implementation module expected to be provided already.\n                context.get(module).use(supply).read({\n                    supply,\n                    receive: (_ctx, { settled, ready, error }) => {\n                        this._updateStatus(rev, settled, ready, error);\n                    },\n                });\n            }\n            else {\n                loadContextModule(context, registry, rev)\n                    .then(({ whenReady }) => {\n                    this._updateStatus(rev, true, false);\n                    return whenReady;\n                })\n                    .then(() => this._updateStatus(rev, true, true))\n                    .catch(error => rev.supply.off(error));\n            }\n        };\n    }\n    implementBy(impl) {\n        this._impl.by(impl);\n    }\n    _updateStatus(rev, settled, ready, error) {\n        // Ensure updating the correct revision.\n        if (this._rev.it.supply !== rev.supply) {\n            // If revision changed, then drop the obsolete one.\n            rev.supply.off();\n        }\n        else {\n            this._rev.it = rev = {\n                status: {\n                    module: rev.status.module,\n                    provided: rev.status.provided,\n                    used: true,\n                    settled,\n                    ready,\n                    error,\n                },\n                supply: rev.supply,\n            };\n        }\n    }\n    _load(module) {\n        const supply = new Supply(noop).needs(this._rev).whenOff(error => {\n            const rev = this._rev.it;\n            if (rev.supply === supply) {\n                this._rev.it = {\n                    status: {\n                        ...this._rev.it.status,\n                        provided: false,\n                        settled: false,\n                        ready: false,\n                        error,\n                    },\n                    supply,\n                };\n            }\n        });\n        const used = !!this._useCounter;\n        this._rev.it = {\n            status: {\n                module,\n                provided: true,\n                used,\n                settled: false,\n                ready: false,\n            },\n            supply,\n        };\n        if (used) {\n            this._setup();\n        }\n    }\n    _use(handle, user) {\n        const supply = new Supply(noop);\n        if (user) {\n            supply.needs(user);\n        }\n        const read = handle.read.do(supplyAfter(supply));\n        const use = {\n            ...handle,\n            read,\n            whenSettled: ContextModule$Use$when(read, isContextModuleSettled),\n            whenReady: ContextModule$Use$when(read, isContextModuleReady),\n            supply,\n        };\n        if (!supply.isOff) {\n            supply.whenOff(error => {\n                if (!--this._useCounter) {\n                    const rev = this._rev.it;\n                    this._rev.it = {\n                        status: {\n                            ...rev.status,\n                            used: false,\n                            settled: false,\n                            ready: false,\n                            error,\n                        },\n                        supply: new Supply(noop).off(error),\n                    };\n                    rev.supply.off(error);\n                }\n            });\n            if (!this._useCounter++) {\n                // Mark the module used and set it up.\n                const rev = this._rev.it;\n                this._rev.it = {\n                    status: {\n                        ...rev.status,\n                        used: true,\n                    },\n                    supply: rev.supply,\n                };\n                this._setup();\n            }\n        }\n        return use;\n    }\n}\n/**\n * @internal\n */\nasync function loadContextModule(context, registry, { status: { module }, supply }) {\n    const moduleInit = new ContextModuleInit(module);\n    await module.setup({\n        module,\n        supply,\n        get(request) {\n            return context.get(request);\n        },\n        provide(spec) {\n            return registry.provide(spec).needs(supply);\n        },\n        initBy(init) {\n            moduleInit.initBy(init);\n        },\n    });\n    return moduleInit;\n}\nclass ContextModuleInit {\n    constructor(_module) {\n        this._module = _module;\n        this._whenDone = Promise.resolve();\n        this.whenReady = new Promise(resolve => this._ready = resolve);\n    }\n    initBy(init) {\n        const rev = this._whenDone = this._whenDone\n            .then(init)\n            .finally(() => this._done(rev));\n    }\n    _done(rev) {\n        if (this._whenDone === rev) {\n            this._ready(rev);\n            this.initBy = _init => {\n                throw new TypeError(`${this._module} initialized already, and does not accept new initializers`);\n            };\n        }\n    }\n}\nfunction ContextModule$Use$when(status, test) {\n    return onEventBy(receiver => status({\n        supply: receiver.supply,\n        receive: (context, status) => {\n            if (test(status)) {\n                receiver.receive(context, status);\n                receiver.supply.off();\n            }\n            else if (status.error) {\n                receiver.supply.off(status.error);\n            }\n        },\n    }));\n}\nfunction isContextModuleSettled({ settled }) {\n    return settled;\n}\nfunction isContextModuleReady({ ready }) {\n    return ready;\n}\n\n/**\n * @internal\n */\nclass ContextModuleKey extends ContextUpKey {\n    constructor(name, _module) {\n        super(name);\n        this._module = _module;\n    }\n    get upKey() {\n        return this;\n    }\n    grow(slot) {\n        const usage = new ContextModuleUsage(slot.context, this._module);\n        slot.insert(usage.createHandle());\n        slot.setup(({ context, registry }) => usage.setup(context, registry));\n        usage.implementBy(implementContextModule(this._module, slot.seed));\n    }\n}\n/**\n * @internal\n */\nfunction implementContextModule(module, impls) {\n    return impls.do(mapAfter_((...candidates) => {\n        let impl;\n        for (let i = candidates.length - 1; i >= 0; --i) {\n            impl = candidates[i];\n            if (impl !== module) {\n                break;\n            }\n        }\n        return impl;\n    }));\n}\n\n/**\n * @internal\n */\nconst ContextModule$impl__symbol = ( /*#__PURE__*/Symbol('ContextModule.impl'));\n/**\n * @internal\n */\nclass ContextModule$ {\n    constructor(module, name, options) {\n        this.name = name;\n        this.options = options;\n        this.key = new ContextModuleKey(`${name}:module`, module);\n        const { needs, has, setup } = options;\n        this.has = setOfElements(has).add(module);\n        this.needs = setOfElements(needs);\n        this._setup = setup ? setup.bind(options) : noop;\n    }\n    replace(module, registry, supply) {\n        for (const replaced of module.has) {\n            if (replaced !== module) {\n                registry.provide({ a: replaced, is: module }).needs(supply);\n            }\n        }\n    }\n    async setup(setup) {\n        const deps = contextModuleDeps(setup);\n        // Await for module dependencies to be settled.\n        if (!await loadContextModuleDeps(setup, deps, whenContextModuleSettled)) {\n            return;\n        }\n        setup.initBy(async () => {\n            // Initialize module dependencies.\n            await loadContextModuleDeps(setup, deps, whenContextModuleReady);\n        });\n        await this._setup(setup);\n    }\n}\nfunction contextModuleDeps(setup) {\n    const { module, supply } = setup;\n    return itsElements(valueIt(module.needs, dep => dep !== module\n        && setup.provide(dep).needs(supply)\n        && {\n            dep,\n            use: setup.get(dep).use(setup),\n        }));\n}\nfunction loadContextModuleDeps(setup, deps, whenLoaded) {\n    const { module, supply } = setup;\n    const notLoaded = valueProvider(false);\n    const whenDone = supply.whenDone().then(notLoaded, notLoaded);\n    return Promise.race([\n        whenDone,\n        Promise\n            .all(deps\n            .map(({ dep, use }) => whenLoaded(use).then(noop, error => [dep, error])))\n            .then((results) => {\n            const failures = results.filter(isDefined);\n            return failures.length\n                ? new ContextModuleDependencyError(module, failures) // Prevent unhandled promise rejection\n                : true;\n        }),\n    ]).then(result => {\n        if (typeof result !== 'boolean') {\n            // Fail to load module if at leas one of its dependencies failed.\n            return Promise.reject(result);\n        }\n        return result;\n    });\n}\nfunction whenContextModuleSettled(use) {\n    return use.whenSettled;\n}\nfunction whenContextModuleReady(use) {\n    return use.whenReady;\n}\n\n/**\n * Context module.\n *\n * Modules intended to extend the context dynamically.\n *\n * The module is a context value reference that can be used to provide module instance and access its\n * {@link ContextModule.Handle handle}.\n *\n * Usage example:\n * ```typescript\n * // Construct new module.\n * const myModule = new ContextModule('my module', {\n *   setup(setup) {\n *     // Provide the values\n *     setup.provide({ a: Foo, is: 'foo' });\n *   },\n * });\n *\n * // Load the module\n * const myModuleSupply = contextRegistry.provide(myModule);\n *\n * // Start using the module\n * const myModuleUse = await context.get(myModule).use();\n *\n * // Await for the module to load\n * await myModuleUse.whenReady;\n *\n * // Access the value provided by module.\n * console.log(context.get(Foo));\n *\n * // Stop using the module\n * myModuleUse.supply.off();\n *\n * // Unload the module declaration.\n * myModuleSupply.off();\n * ```\n */\nclass ContextModule {\n    /**\n     * Constructs context module.\n     *\n     * @param name - Human-readable module name.\n     * @param options - Module construction options.\n     */\n    constructor(name, options = {}) {\n        this[ContextModule$impl__symbol] = new ContextModule$(this, name, options);\n    }\n    /**\n     * A key of context module.\n     */\n    get [ContextKey__symbol]() {\n        return this[ContextModule$impl__symbol].key;\n    }\n    /**\n     * Human-readable module name.\n     */\n    get name() {\n        return this[ContextModule$impl__symbol].name;\n    }\n    /**\n     * The modules this one requires.\n     *\n     * Assigned by {@link ContextModule.Options.needs} option.\n     */\n    get needs() {\n        return this[ContextModule$impl__symbol].needs;\n    }\n    /**\n     * The modules this one provides.\n     *\n     * Assigned by {@link ContextModule.Options.has} option.\n     *\n     * Always contains the module itself.\n     */\n    get has() {\n        return this[ContextModule$impl__symbol].has;\n    }\n    /**\n     * Provides this module and {@link has module replacements}.\n     */\n    [ContextBuilder__symbol](registry) {\n        const supply = registry.provide({ a: this, is: this });\n        this[ContextModule$impl__symbol].replace(this, registry, supply);\n        return supply;\n    }\n    /**\n     * Sets up the module.\n     *\n     * This method is called when loading the module. It is used e.g. to provide more values for the context.\n     *\n     * By default:\n     *\n     * 1. Satisfies module {@link needs dependencies} by setting them up.\n     *\n     *    The dependency considered satisfied when it is {@link ContextModule.Status.settled settled}.\n     *\n     * 2. {@link ContextModule.Setup.initBy Initializes} the module by initializing the dependencies.\n     *\n     *    The dependency considered initialized when it is {@link ContextModule.Status.ready ready for use}.\n     *\n     * 3. Performs the module setup by invoking the {@link ContextModule.Options.setup} method.\n     *\n     * @param setup - Context module setup.\n     *\n     * @returns A promise resolved when the module is set up asynchronously.\n     */\n    setup(setup) {\n        return this[ContextModule$impl__symbol].setup(setup);\n    }\n    toString() {\n        return `ContextModule(${this.name})`;\n    }\n}\n\nexport { ContextModule, ContextModuleDependencyError, ContextUpKey, FnContextKey, MultiContextUpKey, SingleContextUpKey, applyContextAfter, applyContextAfter_, applyContextUp, contextDestroyed };\n//# sourceMappingURL=context-values.updatable.js.map\n","/**\n * Returns a document of the given DOM node.\n *\n * @param node - Source node.\n *\n * @returns Either an `ownerDocument`, or a node itself if it is a document.\n */\nfunction nodeDocument(node) {\n    return node.ownerDocument || node;\n}\n\n/**\n * Checks whether the given DOM node is an [element](https://developer.mozilla.org/en-US/docs/Web/API/Element).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Element`, or `false` everything else.\n */\nfunction isElementNode(node) {\n    return node.nodeType === 1 /* Node.ELEMENT_NODE */;\n}\n/**\n * Checks whether the given DOM node is an [attribute](https://developer.mozilla.org/en-US/docs/Web/API/Attr).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Attr`, or `false` everything else.\n */\nfunction isAttributeNode(node) {\n    return node.nodeType === 2 /* Node.ATTRIBUTE_NODE */;\n}\n/**\n * Checks whether the given DOM node is a [text](https://developer.mozilla.org/en-US/docs/Web/API/Text).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Text`, or `false` everything else.\n */\nfunction isTextNode(node) {\n    return node.nodeType === 3 /* Node.TEXT_NODE */;\n}\n/**\n * Checks whether the given DOM node is a [CDATA section](https://developer.mozilla.org/en-US/docs/Web/API/CDATASection).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `CDATASection`, or `false` everything else.\n */\nfunction isCDATASectionNode(node) {\n    return node.nodeType === 4 /* Node.CDATA_SECTION_NODE */;\n}\n/**\n * Checks whether the given DOM node is a [processing instruction](https://developer.mozilla.org/en-US/docs/Web/API/ProcessingInstruction).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `ProcessingInstruction`, or `false` everything else.\n */\nfunction isProcessingInstructionNode(node) {\n    return node.nodeType === 7 /* Node.PROCESSING_INSTRUCTION_NODE */;\n}\n/**\n * Checks whether the given DOM node is a [comment](https://developer.mozilla.org/en-US/docs/Web/API/Comment).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Comment`, or `false` everything else.\n */\nfunction isCommentNode(node) {\n    return node.nodeType === 8 /* Node.COMMENT_NODE */;\n}\n/**\n * Checks whether the given DOM node is a [document](https://developer.mozilla.org/en-US/docs/Web/API/Document).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Document`, or `false` everything else.\n */\nfunction isDocumentNode(node) {\n    return node.nodeType === 9 /* Node.DOCUMENT_NODE */;\n}\n/**\n * Checks whether the given DOM node is a [document type](https://developer.mozilla.org/en-US/docs/Web/API/DocumentType).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `DocumentType`, or `false` everything else.\n */\nfunction isDocumentTypeNode(node) {\n    return node.nodeType === 10 /* Node.DOCUMENT_TYPE_NODE */;\n}\n/**\n * Checks whether the given DOM node is a [document fragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `DocumentFragment`, or `false` everything else.\n */\nfunction isDocumentFragmentNode(node) {\n    return node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */;\n}\n/**\n * Checks whether the given DOM node is a [shadow root](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot).\n *\n * Note that shadow root is a kind of {@link isDocumentFragmentNode document fragment}.\n *\n * @param node - A node to check.\n *\n * @returns `true` for `ShadowRoot`, or `false` everything else.\n */\nfunction isShadowRootNode(node) {\n    return isDocumentFragmentNode(node) && !!node.host;\n}\n\nfunction importNode(from, to, beforeOrImport, importContent = importNodeContent) {\n    let before;\n    if (typeof beforeOrImport === 'function') {\n        importContent = beforeOrImport;\n        before = null;\n    }\n    else {\n        before = beforeOrImport || null;\n    }\n    const doc = nodeDocument(to);\n    if (isElementNode(from)) {\n        const elementClone = doc.createElement(from.tagName.toLowerCase());\n        from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)));\n        importContent(from, elementClone);\n        to.insertBefore(elementClone, before);\n        return elementClone;\n    }\n    const nodeClone = doc.importNode(from, false);\n    to.insertBefore(nodeClone, before);\n    return nodeClone;\n}\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from - The node which contents to import.\n * @param to - The node to append imported nodes to.\n */\nfunction importNodeContent(from, to) {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < from.childNodes.length; ++i) {\n        importNode(from.childNodes[i], to);\n    }\n}\n\n/**\n * Finds a host element of the given DOM node. I.e. an enclosing element.\n *\n * Crosses shadow DOM bounds.\n *\n * @param node - Target element.\n *\n * @returns Either parent element of the given node, or `undefined` when not found.\n */\nfunction nodeHost(node) {\n    const { parentNode } = node;\n    return parentNode && isElementNode(parentNode) && parentNode\n        || node.getRootNode().host // Inside shadow DOM?\n        || undefined;\n}\n\n/**\n * Returns an owner window of the given DOM node.\n *\n * @param node - Source node.\n *\n * @returns Either a `defaultView` of the {@link nodeDocument node document}, or `window` instance if there is no one.\n */\nfunction nodeWindow(node) {\n    return nodeDocument(node).defaultView || window;\n}\n\n/**\n * Removes all child nodes from the given one.\n *\n * @param node - DOM node to remove the content of.\n */\nfunction removeNodeContent(node) {\n    node.textContent = null;\n}\n\nexport { importNode, importNodeContent, isAttributeNode, isCDATASectionNode, isCommentNode, isDocumentFragmentNode, isDocumentNode, isDocumentTypeNode, isElementNode, isProcessingInstructionNode, isShadowRootNode, isTextNode, nodeDocument, nodeHost, nodeWindow, removeNodeContent };\n//# sourceMappingURL=dom-primitives.js.map\n","import { Supply } from '@proc7ts/supply';\nimport { nodeWindow } from '@frontmeans/dom-primitives';\n\n/**\n * Creates a render schedule mapped from another one.\n *\n * The mapped schedule may support a render execution of another type.\n *\n * @typeParam TFromExecution - A type of render shot execution context supported by original schedule.\n * @typeParam TToExecution - A type of render shot execution context supported by mapped schedule.\n * @param schedule - A schedule to map from.\n * @param execute - Executes a render shot in mapped execution context.\n *\n * @returns Mapped render schedule instance.\n */\nfunction mapRenderSchedule(schedule, execute) {\n    return shot => schedule((fromExec) => {\n        let toExec;\n        const draft = {\n            postpone(postponed) {\n                fromExec.postpone(_exec => postponed(toExec));\n            },\n        };\n        execute(fromExec, draft, exec => shot(toExec = exec));\n    });\n}\n\nconst RenderScheduleConfig = {\n    /**\n     * Constructs a configuration of render schedule by its options.\n     *\n     * @param options - Render scheduler options the configuration should be base on.\n     *\n     * @returns Render schedule configuration.\n     */\n    by(options = {}) {\n        let win;\n        const { error = console.error } = options;\n        return {\n            get node() {\n                return options.node;\n            },\n            get window() {\n                return win || (win = options.window || (options.node ? nodeWindow(options.node) : window));\n            },\n            error,\n        };\n    },\n};\n\n/**\n * Creates an abortable render schedule.\n *\n * @typeParam TExecution - A type of supported render shot execution context.\n * @typeParam TOptions - A type of accepted render schedule options.\n * @param scheduler - A render scheduler to schedule rendering by.\n * @param supply - Schedule supply. Once cut off, stops rendering in all schedules created by new scheduler.\n * A new supply will be created if omitted.\n *\n * @returns New abortable render scheduler instance.\n */\nfunction newAbortableRenderScheduler(scheduler, supply = new Supply()) {\n    const abortableScheduler = ((options) => {\n        const scheduleSupply = (options === null || options === void 0 ? void 0 : options.supply) || new Supply();\n        scheduleSupply.needs(supply);\n        let execute = (exec, draft, shot) => shot({\n            ...exec,\n            ...draft,\n            supply: scheduleSupply,\n        });\n        let schedule = mapRenderSchedule(scheduler(options), (exec, draft, shot) => execute(exec, draft, shot));\n        const abortableSchedule = ((shot) => schedule(shot));\n        abortableSchedule.supply = scheduleSupply;\n        scheduleSupply.whenOff(reason => {\n            execute = AbortableRenderSchedule$doNotExecute;\n            schedule = AbortableRenderSchedule$abort(reason, options);\n        });\n        return abortableSchedule;\n    });\n    abortableScheduler.supply = supply;\n    return abortableScheduler;\n}\nfunction AbortableRenderSchedule$abort(reason, options) {\n    const { error } = RenderScheduleConfig.by(options);\n    return _shot => {\n        error('Rendering aborted', reason);\n    };\n}\nfunction AbortableRenderSchedule$doNotExecute(_exec, _draft, _shot) {\n    // Do not execute in aborted schedule\n}\n\nconst RenderQ__symbol = ( /*#__PURE__*/Symbol('render-q'));\nclass RenderQ {\n    constructor(q, ref) {\n        this.q = q;\n        this.schedule = this.doSchedule;\n        this.ref = ref || [this, this];\n        this.execute = q.recur ? this.execRecurring : this.execNonRecurring;\n    }\n    static by(queue, ref) {\n        return queue[RenderQ__symbol]\n            || (queue[RenderQ__symbol] = new RenderQ(queue, ref));\n    }\n    add(shot) {\n        this.q.add(shot);\n    }\n    doSchedule(config) {\n        // At most one execution at a time.\n        this.schedule = RenderQ$doNotSchedule;\n        const postponed = [];\n        const execution = {\n            get config() {\n                return config;\n            },\n            postpone(shot) {\n                postponed.unshift(shot);\n            },\n        };\n        this.q.schedule(() => {\n            const next = this.reset();\n            const done = () => {\n                // Activate next queue.\n                this.ref[1] = this.ref[0];\n                // Schedule postponed shots (in reverse order).\n                postponed.forEach(shot => this.q.add(shot));\n                // Recurrently postponed shots are executed immediately after their initiators.\n                execution.postpone = shot => this.q.post(shot);\n                // Execute postponed shots.\n                this.exec(execution);\n                next.resume();\n            };\n            next.suspend();\n            this.execute(execution, done);\n        });\n    }\n    exec(execution) {\n        for (;;) {\n            const shot = this.q.pull();\n            if (!shot) {\n                break;\n            }\n            shot(execution);\n        }\n    }\n    execNonRecurring(execution, done) {\n        this.exec(execution);\n        done();\n    }\n    execRecurring(execution, done) {\n        const execute = () => {\n            this.exec(execution);\n            if (!this.q.recur(execute)) {\n                done();\n            }\n        };\n        execute();\n    }\n    reset() {\n        // Update next queue. Current queue remains active\n        return this.ref[0] = RenderQ.by(this.q.reset(), this.ref);\n    }\n    suspend() {\n        this.schedule = config => {\n            // Remember execution to schedule.\n            // It will be scheduled on resume.\n            this.scheduled = config;\n            // No need to remember more than one execution to schedule.\n            this.schedule = RenderQ$doNotSchedule;\n        };\n    }\n    resume() {\n        if (this.scheduled) {\n            // There is an execution to schedule.\n            this.doSchedule(this.scheduled);\n        }\n        else {\n            // Resume normal execution scheduling.\n            this.schedule = this.doSchedule;\n        }\n    }\n}\nfunction RenderQ$doNotSchedule(_config) {\n    // Do not schedule.\n}\n/**\n * Builds custom render scheduler.\n *\n * @param options - Render scheduler options.\n *\n * @returns New render scheduler.\n */\nfunction customRenderScheduler(options) {\n    return (scheduleOptions) => {\n        const config = RenderScheduleConfig.by(scheduleOptions);\n        const queueRef = RenderQ.by(options.newQueue(config)).ref;\n        let enqueued = [];\n        return (shot) => {\n            const [lastQueue, , executed] = enqueued;\n            const [nextQueue, activeQueue] = queueRef;\n            let queue = lastQueue || activeQueue;\n            if ((lastQueue === activeQueue && !executed) || lastQueue === nextQueue) {\n                // Replace the shot in active queue, unless executed already.\n                // Replace the shot in the next queue unconditionally.\n                enqueued[1] = shot;\n            }\n            else {\n                // Add to active queue if no shot executed in this schedule yet, or the queue recurrent.\n                // Add to the next queue otherwise.\n                const nextEnqueued = enqueued = [\n                    queue = !executed || queue.q.recur ? activeQueue : nextQueue,\n                    shot,\n                ];\n                queue.add((execution) => {\n                    nextEnqueued[2] = true; // Switch to the next queue.\n                    try {\n                        nextEnqueued[1]({\n                            get config() {\n                                return config;\n                            },\n                            postpone(postponed) {\n                                execution.postpone(postponed);\n                            },\n                        });\n                    }\n                    catch (e) {\n                        config.error(e);\n                    }\n                });\n            }\n            queue.schedule(config);\n        };\n    };\n}\n\nconst RenderQueue = {\n    /**\n     * Builds the default implementation of render queue.\n     *\n     * @param options - Render queue options.\n     *\n     * @returns New render queue.\n     */\n    by(options) {\n        const { schedule, recur } = options;\n        let { replace = RenderQueue$doNotReplace } = options;\n        let scheduled = [];\n        let executed = scheduled;\n        let scheduleRecurrent;\n        if (recur) {\n            scheduleRecurrent = task => {\n                if (!scheduled.length) {\n                    // No recurrent shots.\n                    // The upcoming shots are non-recurrent.\n                    scheduled = executed;\n                    return false;\n                }\n                executed = scheduled;\n                scheduled = [];\n                recur(task);\n                return true;\n            };\n            const replaceQueue = replace;\n            replace = next => {\n                scheduled = [];\n                replaceQueue(next);\n            };\n        }\n        return {\n            add(shot) {\n                scheduled.push(shot);\n            },\n            post(shot) {\n                scheduled.unshift(shot);\n            },\n            pull() {\n                return executed.shift();\n            },\n            schedule,\n            recur: scheduleRecurrent,\n            reset() {\n                const next = RenderQueue.by(options);\n                replace(next);\n                return next;\n            },\n        };\n    },\n};\nfunction RenderQueue$doNotReplace(_replacement) {\n    // Do not replace queue\n}\n\n/**\n * @internal\n */\nconst animationRenderQueues = ( /*#__PURE__*/new WeakMap());\n/**\n * A render scheduler that executes scheduled render shots within animation frame.\n *\n * Utilizes [requestAnimationFrame()] function for that.\n *\n * The render shots scheduled by different schedules created for the same window are all executed in the same animation\n * frame. The {@link RenderExecution.postpone postponed} render shots are executed only after all scheduled ones\n * complete.\n *\n * [requestAnimationFrame()]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n */\nconst animationRenderScheduler = ( /*#__PURE__*/customRenderScheduler({\n    newQueue({ window }) {\n        const existing = animationRenderQueues.get(window);\n        if (existing) {\n            return existing;\n        }\n        const newQueue = RenderQueue.by({\n            schedule: task => window.requestAnimationFrame(task),\n            replace: replacement => animationRenderQueues.set(window, replacement),\n        });\n        animationRenderQueues.set(window, newQueue);\n        return newQueue;\n    },\n}));\n\nfunction asyncRenderQueue$schedule(task) {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    Promise.resolve().then(task);\n}\nlet asyncRenderQueue = ( /*#__PURE__*/RenderQueue.by({\n    schedule: asyncRenderQueue$schedule,\n    recur: asyncRenderQueue$schedule,\n    replace: replacement => asyncRenderQueue = replacement,\n}));\n/**\n * A render scheduler that executes scheduled render shots asynchronously.\n *\n * Recurrent render shots are also executed asynchronously.\n */\nconst asyncRenderScheduler = ( /*#__PURE__*/customRenderScheduler({\n    newQueue: () => asyncRenderQueue,\n}));\n\n/**\n * Creates a render scheduler that delegates scheduling to the given one.\n *\n * @typeParam TExecution - A type of supported render shot execution context.\n * @typeParam TOptions - A type of accepted render schedule options.\n * @param scheduler - A render scheduler to schedule rendering by.\n *\n * @returns New delegating render scheduler instance.\n */\nfunction newDelegateRenderScheduler(scheduler) {\n    const result = ((options) => {\n        let usedScheduler = scheduler;\n        let schedule = scheduler(options);\n        return shot => {\n            if (usedScheduler !== scheduler) {\n                usedScheduler = scheduler;\n                schedule = scheduler(options);\n            }\n            schedule(shot);\n        };\n    });\n    result.scheduleBy = newScheduler => {\n        scheduler = newScheduler;\n        return result;\n    };\n    return result;\n}\n\n/**\n * Render scheduler that executes render shots immediately.\n *\n * @param options\n */\nconst immediateRenderScheduler = (options) => {\n    const config = RenderScheduleConfig.by(options);\n    return (shot) => {\n        const postponed = [];\n        const execution = {\n            get config() {\n                return config;\n            },\n            postpone(shot) {\n                postponed.push(shot);\n            },\n        };\n        execute(shot);\n        for (;;) {\n            const last = postponed.pop();\n            if (!last) {\n                break;\n            }\n            execute(last);\n        }\n        function execute(shot) {\n            try {\n                shot(execution);\n            }\n            catch (e) {\n                config.error(e);\n            }\n        }\n    };\n};\n\n/**\n * Creates new render scheduler that executes scheduled render shots on request.\n *\n * A {@link ManualRenderScheduler.render} method should be called to execute scheduled render shots.\n *\n * @returns New manual render scheduler.\n */\nfunction newManualRenderScheduler() {\n    const emptyTask = () => false;\n    let pendingTask = emptyTask;\n    let queue = RenderQueue.by({\n        // Called at most once until reset\n        schedule: task => pendingTask = () => {\n            task();\n            return true;\n        },\n        replace: replacement => {\n            pendingTask = emptyTask;\n            queue = replacement;\n        },\n    });\n    const scheduler = customRenderScheduler({\n        newQueue: () => queue,\n    });\n    scheduler.render = () => pendingTask();\n    return scheduler;\n}\n\n/**\n * @internal\n */\nfunction noopRenderSchedule(_shot) {\n    // Do not schedule\n}\n\n/**\n * A render scheduler that neither schedules, nor executes render shots.\n */\nconst noopRenderScheduler = _options => noopRenderSchedule;\n\n/**\n * @internal\n */\nlet immediateRenderQueue = ( /*#__PURE__*/RenderQueue.by({\n    schedule: task => task(),\n    replace: replacement => immediateRenderQueue = replacement,\n}));\n/**\n * A render scheduler that schedules render shots for immediate execution.\n *\n * In contrast to {@link immediateRenderScheduler} this one utilizes {@link RenderQueue render queue}. So it acts\n * similarly to other schedulers, such as {@link animationRenderScheduler}. In particular, it adds recurrent\n * render shots to render queue instead of executing them immediately.\n */\nconst queuedRenderScheduler = ( /*#__PURE__*/customRenderScheduler({\n    newQueue: () => immediateRenderQueue,\n}));\n\n/**\n * @internal\n */\nlet defaultRenderScheduler = animationRenderScheduler;\n/**\n * Assigns or resets the default render scheduler.\n *\n * An {@link animationRenderScheduler animation frame render scheduler} is used bu default.\n *\n * @param scheduler - New default render scheduler. {@link animationRenderScheduler animation frame render scheduler}\n * will be used if `null`, `undefined`, or omitted.\n *\n * @returns New default render scheduler.\n */\nfunction setRenderScheduler(scheduler) {\n    return defaultRenderScheduler = scheduler || animationRenderScheduler;\n}\n/**\n * Constructs {@link RenderSchedule render schedule} using {@link setRenderScheduler default render scheduler}.\n *\n * @param options - Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\nfunction newRenderSchedule(options) {\n    return defaultRenderScheduler(options);\n}\n\nexport { RenderQueue, RenderScheduleConfig, animationRenderScheduler, asyncRenderScheduler, customRenderScheduler, immediateRenderScheduler, mapRenderSchedule, newAbortableRenderScheduler, newDelegateRenderScheduler, newManualRenderScheduler, newRenderSchedule, noopRenderScheduler, queuedRenderScheduler, setRenderScheduler };\n//# sourceMappingURL=render-scheduler.js.map\n","import { newNamespaceAliaser, css__naming, NamespaceDef } from '@frontmeans/namespace-aliaser';\nimport { Supply } from '@proc7ts/supply';\nimport { isDocumentNode, nodeHost, isElementNode, removeNodeContent } from '@frontmeans/dom-primitives';\nimport { onEventBy, onceOn, AfterEvent__symbol, afterThe, trackValue, EventEmitter, translateAfter_ } from '@proc7ts/fun-events';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { newRenderSchedule, queuedRenderScheduler } from '@frontmeans/render-scheduler';\n\nlet DrekContext$registrar = DrekContext$autoRegister;\n/**\n * @internal\n */\nfunction DrekContext$register(context) {\n    DrekContext$registrar(context);\n}\n/**\n * @internal\n */\nfunction DrekContext$setRegistrar(registrar) {\n    const priorRegistrar = DrekContext$registrar;\n    DrekContext$registrar = registrar;\n    return priorRegistrar === DrekContext$autoRegister\n        ? () => {\n            DrekContext$registrar = priorRegistrar;\n            return DrekContext$dontRegister;\n        }\n        : () => DrekContext$registrar = priorRegistrar;\n}\nfunction DrekContext$dontRegister(_context) {\n    // Do not auto-register the context already failed to lift.\n}\nlet DrekContext$autoRegistrar = DrekContext$autoRegisterFirst;\nfunction DrekContext$autoRegister(context) {\n    DrekContext$autoRegistrar(context);\n}\nfunction DrekContext$autoRegisterFirst(context) {\n    const registered = [context];\n    DrekContext$autoRegistrar = DrekContext$createAutoRegistrar(registered);\n    Promise.resolve().then(() => {\n        DrekContext$autoRegistrar = DrekContext$autoRegisterFirst;\n        for (const context of registered) {\n            context.lift();\n        }\n    }).catch(console.error);\n}\nfunction DrekContext$createAutoRegistrar(registered) {\n    return context => registered.push(context);\n}\n\n/**\n * Executes a DOM builder function and then {@link DrekContext.lift lifts} all unrooted rendering contexts created by\n * it.\n *\n * This helps to track a {@link DrekContext.whenConnected document connection} or {@link DrekContext.whenSettled\n * settlement} of any unrooted rendering contexts that created before its node added to document or\n * {@link DrekFragment rendered fragment}. This may happen e.g. when the rendering context {@link drekContextOf\n * accessed} from inside a custom element constructor when calling `document.createElement('custom-element')`.\n *\n * @typeParam TResult - DOM builder result type.\n * @param builder - A DOM builder function to call.\n *\n * @returns The value returned from DOM `builder` function.\n */\nfunction drekBuild(builder) {\n    const registered = [];\n    const resetRegistrar = DrekContext$setRegistrar(context => registered.push(context));\n    try {\n        return builder();\n    }\n    finally {\n        const registrar = resetRegistrar();\n        for (const context of registered) {\n            const lifted = context.lift();\n            if (lifted === context) {\n                // Not lifted.\n                // Try next time.\n                registrar(context);\n            }\n        }\n    }\n}\n\n/**\n * @internal\n */\nconst DrekPlacement$Status__symbol = ( /*#__PURE__*/Symbol('DrekPlacement.status'));\n/**\n * @internal\n */\nclass DrekPlacement$Status {\n    constructor(placement) {\n        this.placement = placement;\n    }\n    onceConnected() {\n        return (this.onceConnected = valueProvider(this.placement.readStatus.do(DrekPlacement$once(({ connected }) => connected))))();\n    }\n    whenConnected() {\n        return (this.whenConnected = valueProvider(this.onceConnected().do(onceOn)))();\n    }\n}\nfunction DrekPlacement$once(test) {\n    return input => onEventBy(receiver => {\n        let value = false;\n        input({\n            supply: receiver.supply,\n            receive(eventCtx, ...status) {\n                const newValue = test(...status);\n                if (newValue || value !== newValue) {\n                    value = newValue;\n                    receiver.receive(eventCtx, ...status);\n                }\n            },\n        });\n    });\n}\n\n/**\n * A rendered content placement.\n *\n * @typeParam TStatus - A type of the tuple containing a rendered content status as its first element.\n */\nclass DrekPlacement {\n    constructor() {\n        this[DrekPlacement$Status__symbol] = new DrekPlacement$Status(this);\n    }\n    /**\n     * An alias of {@link readStatus}.\n     *\n     * @returns An `AfterEvent` keeper of content placement status.\n     */\n    [AfterEvent__symbol]() {\n        return this.readStatus;\n    }\n    /**\n     * An `OnEvent` sender of placed content connection event.\n     *\n     * The registered receiver is called when placed content is {@link DrekContentStatus.connected connected}.\n     * If connected already the receiver is called immediately.\n     */\n    get onceConnected() {\n        return this[DrekPlacement$Status__symbol].onceConnected();\n    }\n    /**\n     * An `OnEvent` sender of single placed content connection event.\n     *\n     * The registered receiver is called when placed content is {@link DrekContentStatus.connected connected}.\n     * If connected already the receiver is called immediately.\n     *\n     * In contrast to {@link onceConnected}, cuts off the event supply after sending the first event.\n     */\n    get whenConnected() {\n        return this[DrekPlacement$Status__symbol].whenConnected();\n    }\n}\n\n/**\n * Document rendering context.\n *\n * Can be obtained by {@link drekContextOf} function, or {@link DrekFragment.innerContext provided} by rendered\n * fragment.\n *\n * There are three kinds of rendering contexts:\n *\n * 1. Document rendering context.\n *\n *    Such context is always available in document and returned by {@link drekContextOf} function for any DOM node\n *    connected to the document.\n *\n * 2. Fragment content rendering context.\n *\n *    It is created for each rendered fragment and is available via {@link DrekFragment.innerContext} property.\n *    The {@link drekContextOf} function returns this context for fragment's {@link DrekContext.content content},\n *    as well as for each DOM node added to it.\n *\n * 3. Unrooted rendering context.\n *\n *    When a DOM node is neither connected to a document, nor part of a rendered fragment's {@link DrekFragment.content\n *    content}, the {@link drekContextOf} function creates an unrooted context for the [root node] of that node.\n *\n *    Unrooted context tracks a {@link whenConnected document connection} and {@link whenSettled settlement}\n *    semi-automatically. A {@link lift} method can be used to forcibly update them.\n *\n *    Semi-automatic tracking means that each time an unrooted context {@link drekContextOf created}, it is registered\n *    for automatic lifting. The lifting happens either asynchronously, or synchronously right before the\n *    {@link drekBuild} function exit.\n *\n *    Alternatively, a {@link drekLift} function can be used to lift a context of the [root node] after adding it to\n *    another one.\n *\n * [root node]: https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode\n *\n * @typeParam TStatus - A type of the tuple containing a context content status as its first element.\n */\nclass DrekContext extends DrekPlacement {\n    /**\n     * An `OnEvent` sender of a settlement event.\n     *\n     * Such event can be sent by {@link DrekFragment.settle rendered fragment}.\n     *\n     * The same as {@link whenConnected} by default.\n     *\n     * Cuts off the event supply after sending the first event.\n     */\n    get whenSettled() {\n        return this.whenConnected;\n    }\n}\n\n/**\n * @internal\n */\nconst DrekContext__symbol = ( /*#__PURE__*/Symbol('DrekContext'));\n/**\n * @internal\n */\nclass DrekContext$State {\n    constructor({ nsAlias, scheduler }) {\n        this._nsAlias = nsAlias;\n        this.nsAlias = ns => this._nsAlias(ns);\n        this._scheduler = scheduler;\n        this.scheduler = options => {\n            let scheduler = this._scheduler;\n            let schedule = scheduler(options);\n            return shot => {\n                if (scheduler !== this._scheduler) {\n                    scheduler = this._scheduler;\n                    schedule = scheduler(options);\n                }\n                return schedule(shot);\n            };\n        };\n    }\n    set({ nsAlias, scheduler }) {\n        this._nsAlias = nsAlias;\n        this._scheduler = scheduler;\n    }\n}\n\n/**\n * @internal\n */\nfunction DrekContext$ofDocument(document) {\n    const existing = document[DrekContext__symbol];\n    if (existing) {\n        return existing;\n    }\n    const state = new DrekContext$State({\n        nsAlias: newNamespaceAliaser(),\n        scheduler: newRenderSchedule,\n    });\n    const view = document.defaultView || window;\n    const scheduler = (options) => state.scheduler({\n        window: view,\n        ...options,\n    });\n    const readStatus = afterThe({ connected: true });\n    class DrekContext$OfDocument extends DrekContext {\n        get fragment() {\n            return;\n        }\n        get window() {\n            return view;\n        }\n        get document() {\n            return document;\n        }\n        get nsAlias() {\n            return state.nsAlias;\n        }\n        get scheduler() {\n            return scheduler;\n        }\n        get readStatus() {\n            return readStatus;\n        }\n        lift() {\n            return this;\n        }\n        update({ nsAlias = state._nsAlias, scheduler = state._scheduler, }) {\n            state.set({ nsAlias, scheduler });\n            return this;\n        }\n    }\n    return document[DrekContext__symbol] = new DrekContext$OfDocument();\n}\n\n/**\n * @internal\n */\nfunction DrekContext$ofRootNode(root) {\n    return isDocumentNode(root) ? DrekContext$ofDocument(root) : DrekContext$unrooted(root);\n}\nfunction DrekContext$unrooted(root) {\n    const existing = root[DrekContext__symbol];\n    if (existing) {\n        return existing.lift();\n    }\n    const status = trackValue({ connected: false });\n    const settled = new EventEmitter();\n    let derivedCtx = DrekContext$ofDocument(root.ownerDocument /* Not a document, so `ownerDocument` is set */);\n    const scheduler = new DrekContext$State(derivedCtx);\n    let getFragment = () => derivedCtx.fragment;\n    let lift = (ctx) => {\n        const newRoot = root.getRootNode({ composed: true });\n        if (newRoot === root) {\n            return ctx;\n        }\n        const lifted = DrekContext$ofRootNode(newRoot);\n        root[DrekContext__symbol] = undefined;\n        getFragment = () => lifted.fragment;\n        scheduler.set(lifted);\n        lifted.whenSettled(status => settled.send(status)).cuts(settled);\n        status.by(lifted);\n        lift = _ctx => lifted;\n        derivedCtx = lifted;\n        return lifted;\n    };\n    class DrekContext$Unrooted extends DrekContext {\n        get fragment() {\n            return getFragment();\n        }\n        get window() {\n            return derivedCtx.window;\n        }\n        get document() {\n            return derivedCtx.document;\n        }\n        get nsAlias() {\n            return derivedCtx.nsAlias;\n        }\n        get scheduler() {\n            return scheduler.scheduler;\n        }\n        get readStatus() {\n            return status.read;\n        }\n        get whenSettled() {\n            return settled.on;\n        }\n        lift() {\n            return lift(this);\n        }\n    }\n    const context = root[DrekContext__symbol] = new DrekContext$Unrooted();\n    DrekContext$register(context);\n    return context;\n}\n\nfunction drekContextOf(node) {\n    for (;;) {\n        const root = node.getRootNode({ composed: true });\n        if (root === node) {\n            return DrekContext$ofRootNode(node);\n        }\n        node = root;\n    }\n}\n\nconst DrekCssClasses__symbol = ( /*#__PURE__*/Symbol('DrekCssClasses'));\nfunction drekCssClassesOf(element) {\n    return element[DrekCssClasses__symbol]\n        || (element[DrekCssClasses__symbol] = new DrekCssClasses$(element));\n}\nclass DrekCssClasses$ {\n    constructor(_element) {\n        this._element = _element;\n        this._uses = new Map();\n        this._context = drekContextOf(_element);\n    }\n    add(className, user) {\n        return this._add(this._context, className, user);\n    }\n    _add({ nsAlias, scheduler, }, className, user) {\n        const supply = user ? user.supply : new Supply();\n        if (supply.isOff) {\n            return supply;\n        }\n        const name = css__naming.name(className, nsAlias);\n        const schedule = scheduler({ node: this._element });\n        const use = this._use(name);\n        const render = () => {\n            if (use.n) {\n                if (!use.s) {\n                    this._element.classList.add(name);\n                    use.s = 1;\n                }\n            }\n            else {\n                if (use.s && !use.i) { // Do not remove the class if it present initially.\n                    this._element.classList.remove(name);\n                    use.s = 0;\n                }\n                this._uses.delete(name);\n            }\n        };\n        if (use.n === 1) {\n            schedule(render);\n        }\n        return supply.whenOff(() => {\n            if (!--use.n) {\n                schedule(render);\n            }\n        });\n    }\n    _use(name) {\n        let use = this._uses.get(name);\n        if (use) {\n            ++use.n;\n        }\n        else {\n            if (this._element.classList.contains(name)) {\n                use = {\n                    i: 1,\n                    n: 1,\n                    s: 1,\n                };\n            }\n            else {\n                use = {\n                    i: 0,\n                    n: 1,\n                    s: 0,\n                };\n            }\n            this._uses.set(name, use);\n        }\n        return use;\n    }\n    has(className) {\n        return this._has(this._context, className);\n    }\n    _has({ nsAlias }, className) {\n        const name = css__naming.name(className, nsAlias);\n        const use = this._uses.get(name);\n        return use\n            ? !!use.n || !!use.i\n            : this._element.classList.contains(name);\n    }\n    renderIn(context) {\n        return context !== this._context\n            ? {\n                add: className => this._add(context, className),\n                has: className => this._has(context, className),\n                renderIn: newContext => this.renderIn(newContext),\n            }\n            : this;\n    }\n}\n\n/**\n * Creates a rendering context based on another one.\n *\n * @typeParam TStatus - A type of the tuple containing a context content status as its first element.\n * @param base - Base rendering context.\n * @param update - Context update.\n *\n * @returns Updated rendering context, or the `base` one if nothing to update.\n */\nfunction deriveDrekContext(base, update = {}) {\n    const { nsAlias: initialNsAlias = base.nsAlias, scheduler: initialScheduler = base.scheduler, } = update;\n    if (initialNsAlias === base.nsAlias && initialScheduler === base.scheduler) {\n        return base;\n    }\n    const state = new DrekContext$State({\n        nsAlias: initialNsAlias,\n        scheduler: initialScheduler,\n    });\n    let lift = (derived) => {\n        const lifted = base.lift();\n        if (lifted === base) {\n            return derived;\n        }\n        state.set(lifted);\n        lift = _derived => lifted;\n        return lifted;\n    };\n    class DrekContext$Derived extends DrekContext {\n        get fragment() {\n            return base.fragment;\n        }\n        get window() {\n            return base.window;\n        }\n        get document() {\n            return base.document;\n        }\n        get nsAlias() {\n            return state.nsAlias;\n        }\n        get scheduler() {\n            return state.scheduler;\n        }\n        get readStatus() {\n            return base.readStatus;\n        }\n        lift() {\n            return lift(this);\n        }\n    }\n    return new DrekContext$Derived();\n}\n\n/**\n * Finds a host element of the given DOM node with respect to rendering targets.\n *\n * Crosses shadow DOM and {@link DrekFragment rendered fragment} bounds. In the latter case returns a\n * {@link DrekTarget.host rendering target host} instead of the document fragment.\n *\n * @param node - Target DOM element.\n *\n * @returns Either parent element of the given node, or `undefined` when not found.\n */\nfunction drekHost(node) {\n    var _a, _b;\n    const host = nodeHost(node);\n    if (host) {\n        return host;\n    }\n    const parent = node.parentNode || node;\n    const renderHost = (_b = (_a = parent[DrekContext__symbol]) === null || _a === void 0 ? void 0 : _a.fragment) === null || _b === void 0 ? void 0 : _b.target.host;\n    return !renderHost || isElementNode(renderHost)\n        ? renderHost\n        : drekHost(renderHost);\n}\n\nfunction drekLift(node) {\n    var _a;\n    (_a = node[DrekContext__symbol]) === null || _a === void 0 ? void 0 : _a.lift();\n    return node;\n}\n\n/**\n * Default Drek namespace definition.\n */\nconst Drek__NS = ( /*#__PURE__*/new NamespaceDef('https://frontmeans.github.io/ns/drek', 'drek'));\n\n/**\n * @internal\n */\nconst DrekFragment$Context__symbol = ( /*#__PURE__*/Symbol('DrekFragment.context'));\n/**\n * @internal\n */\nclass DrekFragment$Context extends DrekContext {\n    constructor(_fragment, _target, _content, nsAlias, scheduler) {\n        super();\n        this._fragment = _fragment;\n        this._target = _target;\n        this._content = _content;\n        this._status = trackValue([{ connected: false, withinFragment: 'added' }]);\n        this._settled = new EventEmitter();\n        this._rendered = new EventEmitter();\n        this._getFragment = () => _fragment;\n        this._lift = this;\n        this.readStatus = this._status.read.do(translateAfter_((send, status) => send(...status)));\n        this._state = new DrekContext$State({ nsAlias, scheduler });\n        this.scheduler = this._createSchedule.bind(this);\n        this.whenConnected((...status) => {\n            // `whenSettled` is the same as `whenConnected` now.\n            this._whenSettled = this.whenConnected;\n            // Send a settlement event one last time.\n            this._settled.send(...status);\n        });\n    }\n    static attach(fragment, target, { nsAlias = target.context.nsAlias, scheduler = queuedRenderScheduler, content, }) {\n        if (!content) {\n            content = target.context.document.createDocumentFragment();\n        }\n        else if (content.getRootNode({ composed: true }) !== content) {\n            throw new TypeError('Not a standalone DocumentFragment');\n        }\n        else if (content[DrekContext__symbol]) {\n            throw new TypeError('Can not render content of another fragment');\n        }\n        return content[DrekContext__symbol] = new DrekFragment$Context(fragment, target, content, nsAlias, scheduler);\n    }\n    get fragment() {\n        return this._getFragment();\n    }\n    get window() {\n        return this._target.context.window;\n    }\n    get document() {\n        return this._target.context.document;\n    }\n    get nsAlias() {\n        return this._state.nsAlias;\n    }\n    get whenSettled() {\n        return this._whenSettled || (this._whenSettled = this._settled.on.do(onceOn));\n    }\n    lift() {\n        return this._lift;\n    }\n    _settle() {\n        this.scheduler()(_ => {\n            this._settled.send(...this._status.it);\n        });\n    }\n    _render() {\n        // Make the `.lift()` method return the target context.\n        this._lift = this._target.context;\n        // Signal the rendering started.\n        this._status.it = [{ connected: false, withinFragment: 'rendered' }];\n        const schedule = this._state._scheduler();\n        this._state.set(this._target.context);\n        schedule(({ postpone }) => {\n            // Await for all scheduled shots to render.\n            postpone(() => {\n                this._target.context.scheduler()(() => {\n                    // Place the rendered content within target's scheduler.\n                    const placement = this._target.placeContent(this._content);\n                    // Update target fragment.\n                    this._getFragment = () => placement.fragment;\n                    // Reset the inner context.\n                    this._content[DrekContext__symbol] = this._fragment[DrekFragment$Context__symbol] = new DrekFragment$Context(this._fragment, this._target, this._content, this.nsAlias, this.scheduler);\n                    // Derive the status from the target context.\n                    this._status.by(placement, (...status) => afterThe(status));\n                    // Send `whenRendered` event.\n                    this._rendered.send(placement);\n                });\n            });\n        });\n        return this;\n    }\n    _whenRendered() {\n        return (this._whenRendered = valueProvider(this._rendered.on.do(onceOn)))();\n    }\n    _createSchedule(options = {}) {\n        const schedule = this._state.scheduler({\n            ...options,\n            window: this.window,\n        });\n        return shot => schedule(execution => shot(this._createExecution(execution)));\n    }\n    _createExecution(execution) {\n        const fragmentExecution = {\n            ...execution,\n            fragment: this._fragment,\n            content: this._content,\n            postpone(postponed) {\n                execution.postpone(_execution => postponed(fragmentExecution));\n            },\n        };\n        return fragmentExecution;\n    }\n}\n\n/**\n * A fragment of DOM tree, which content is to be {@link DrekTarget.placeContent placed} to the document once rendered.\n *\n * Provides separate {@link DrekContext rendering context} for its nodes.\n *\n * @typeParam TStatus - A type of the tuple containing a rendered content status as its first element.\n */\nclass DrekFragment {\n    /**\n     * Construct rendered fragment.\n     *\n     * @param target - Rendering target to place the\n     * @param options - Fragment rendering options.\n     */\n    constructor(target, options = {}) {\n        this[DrekFragment$Context__symbol] = DrekFragment$Context.attach(this, target, options);\n    }\n    /**\n     * Rendering target.\n     *\n     * When the fragment is {@link render rendered}, the rendered content is placed to this target.\n     */\n    get target() {\n        return this[DrekFragment$Context__symbol]._target;\n    }\n    /**\n     * Inner rendering context of the fragment.\n     *\n     * This context as available to the {@link content} nodes.\n     *\n     * This context updated each time the fragment is {@link render rendered}.\n     */\n    get innerContext() {\n        return this[DrekFragment$Context__symbol];\n    }\n    /**\n     * The content of the fragment.\n     */\n    get content() {\n        return this[DrekFragment$Context__symbol]._content;\n    }\n    /**\n     * An `OnEvent` sender of fragment rendering event.\n     *\n     * Sends a fragment content {@link DrekTarget.placeContent placement} to {@link target} when the fragment is actually\n     * {@link render rendered}.\n     *\n     * Cuts off the event supply after sending the first event.\n     */\n    get whenRendered() {\n        return this[DrekFragment$Context__symbol]._whenRendered();\n    }\n    /**\n     * Settles previously rendered content.\n     *\n     * A {@link whenSettled} event sender notifies its receivers once settled.\n     *\n     * @returns `this` instance.\n     */\n    settle() {\n        this[DrekFragment$Context__symbol]._settle();\n        return this;\n    }\n    /**\n     * Renders this fragment by {@link DrekTarget.placeContent placing} its {@link DrekFragmentRenderExecution.content\n     * content} to {@link target rendering target}.\n     *\n     * Once rendered the fragment {@link content} becomes empty and can be reused. Its rendering context is updated.\n     *\n     * @returns Content {@link DrekTarget.placeContent placement} to {@link target}.\n     */\n    render() {\n        return this[DrekFragment$Context__symbol]._render();\n    }\n}\n\n/**\n * Creates a rendering target that appends content to parent node.\n *\n * @param host - A node to append content to.\n * @param context - Custom rendering context. Defaults to `host` node context.\n *\n * @returns Rendering target.\n */\nfunction drekAppender(host, context = drekContextOf(host)) {\n    return {\n        context,\n        host,\n        placeContent(content) {\n            host.appendChild(content);\n            return context;\n        }\n    };\n}\n\n/**\n * Creates a rendering target that charges rendered content prior to placing it to another target.\n *\n * @typeParam TStatus - A tuple type reflecting a content {@link DrekContentStatus placement status}.\n * @param target - Rendering target of charged content.\n * @param spec - Content charging options.\n *\n * @returns Rendering target.\n */\nfunction drekCharger(target, spec) {\n    const charger = DrekCharger$custom(target, spec);\n    return {\n        context: target.context,\n        host: target.host,\n        placeContent(content) {\n            return charger.charge(content, target);\n        },\n    };\n}\nfunction DrekCharger$custom(target, spec) {\n    if (typeof spec === 'function') {\n        return DrekCharger$custom(target, spec(target));\n    }\n    if (typeof spec === 'string') {\n        return DrekCharger$commentWrapper(target, spec);\n    }\n    if (spec) {\n        return spec;\n    }\n    return DrekCharger$commentWrapper(target, Math.random().toString(32).substr(2));\n}\nfunction DrekCharger$commentWrapper({ context: { document } }, rem) {\n    let wrapContent = (content, target) => {\n        const start = document.createComment(` [[ ${rem} [[ `);\n        const end = document.createComment(` ]] ${rem} ]] `);\n        let placement;\n        wrapContent = (content, _target) => {\n            const range = document.createRange();\n            range.setStartAfter(start);\n            range.setEndBefore(end);\n            range.deleteContents();\n            range.insertNode(content);\n            return placement;\n        };\n        const fragment = document.createDocumentFragment();\n        fragment.append(start, content, end);\n        return placement = target.placeContent(fragment);\n    };\n    return {\n        charge: (content, target) => wrapContent(content, target),\n    };\n}\n\n/**\n * Creates a rendering target that inserts content to parent node at particular position.\n *\n * @param host - A node to insert content to.\n * @param before - A child node of `host` one to insert the content before, or `null` to append it as the last child\n * of `host` node.\n * @param context - Custom rendering context. Defaults to `host` node context.\n *\n * @returns Rendering target.\n */\nfunction drekInserter(host, before, context = drekContextOf(host)) {\n    return {\n        context,\n        host,\n        placeContent(content) {\n            host.insertBefore(content, before);\n            return context;\n        }\n    };\n}\n\n/**\n * Creates a rendering target that replaces content of the `host` node.\n *\n * @param host - A node to replace the content of.\n * @param context - Custom rendering context. Defaults to `host` node context.\n *\n * @returns Rendering target.\n */\nfunction drekReplacer(host, context = drekContextOf(host)) {\n    return {\n        context,\n        host,\n        placeContent(content) {\n            removeNodeContent(host);\n            host.appendChild(content);\n            return context;\n        },\n    };\n}\n\nexport { DrekContext, DrekFragment, DrekPlacement, Drek__NS, deriveDrekContext, drekAppender, drekBuild, drekCharger, drekContextOf, drekCssClassesOf, drekHost, drekInserter, drekLift, drekReplacer };\n//# sourceMappingURL=drek.js.map\n","import { noop, valueProvider } from '@proc7ts/primitives';\nimport { alwaysSupply, Supply } from '@proc7ts/supply';\n\n/**\n * An error indicating the work is already done.\n */\nclass WorkDoneError extends TypeError {\n    /**\n     * Constructs a work done error.\n     *\n     * @param workload - A workload the work is done for.\n     * @param work - The work already done, if any.\n     * @param reason - The reason of work failure, or `undefined` if the work completed successfully.\n     * @param message - Custom error message.\n     */\n    constructor(workload, work, reason, message = workload.workName(work) + (reason !== undefined\n        ? ` already terminated (${reason})`\n        : ' already done')) {\n        super(message);\n        this.workload = workload;\n        this.work = work;\n        this.reason = reason;\n    }\n}\n\n/**\n * A workload able to perform a work within a workbench.\n *\n * The work specific to workload is represented by work instances. Such instances are available in {@link Workbench.work\n * workbench} and can be used e.g. to run workload-specific tasks.\n *\n * The same workload instance can be used in different workbenches.\n *\n * @typeParam TWork - A work type performed by this workload.\n */\nclass Workload {\n    /**\n     * Constructs a workload.\n     *\n     * @param name - Human-readable workload name.\n     * @param allocator - A work allocator specific to constructed workload.\n     */\n    constructor(name, allocator) {\n        this.name = name;\n        this.allocator = allocator;\n    }\n    /**\n     * Builds a human-readable name of the work performed by this workload.\n     *\n     * This is used e.g. to construct a default error message for {@link WorkDoneError}.\n     *\n     * @param _work - Target work.\n     *\n     * @returns A string containing work name.\n     */\n    workName(_work) {\n        return `The work of ${this.name}`;\n    }\n    toString() {\n        return `Workload(${this.name})`;\n    }\n}\n\n/**\n * @internal\n */\nclass OrderedTasks {\n    constructor(_allotment) {\n        this._allotment = _allotment;\n        this._queues = new Map();\n    }\n    runAfter(workload, task) {\n        let queue = this._queues.get(workload);\n        if (!queue) {\n            queue = new TaskQueue(this._allotment);\n            this._queues.set(workload, queue);\n        }\n        return queue.enqueue(task);\n    }\n}\nclass TaskQueue {\n    constructor(_allotment) {\n        this._allotment = _allotment;\n        /**\n         * Enqueued tasks.\n         *\n         * The subsequent tasks are waiting for preceding ones. The very first one is always running.\n         */\n        this._tasks = [];\n    }\n    enqueue(task) {\n        return new Promise(resolve => {\n            const entry = {\n                task,\n                run: () => {\n                    resolve(this._allotment.run(task).finally(() => {\n                        // Remove from the queue.\n                        this._tasks.shift();\n                        // Run next.\n                        this._runNext();\n                    }));\n                },\n            };\n            this._tasks.push(entry);\n            if (this._tasks.length === 1) {\n                // The first task is just enqueued.\n                // Run it immediately, as there is nothing to wait for.\n                this._runNext();\n            }\n        });\n    }\n    _runNext() {\n        const [first] = this._tasks;\n        if (first) {\n            first.run();\n        }\n    }\n}\n\n/**\n * @internal\n */\nclass WorkOrdering extends Workload {\n    constructor() {\n        super('ordering', {\n            start(allotment) {\n                return new OrderedTasks(allotment);\n            },\n        });\n    }\n}\nWorkOrdering.$ = new WorkOrdering();\n\nclass WorkStage extends Workload {\n    constructor(name, allocator = {}) {\n        super(name, {\n            start(allotment) {\n                const { workbench, workload, supply } = allotment;\n                const runner = new WorkStageRunner(allotment, allocator);\n                return {\n                    workbench,\n                    stage: workload,\n                    supply,\n                    async run(task) {\n                        return await runner.run(this, task);\n                    },\n                };\n            },\n        });\n    }\n    workName(_work) {\n        return `The ${this.name} stage`;\n    }\n    toString() {\n        return `WorkStage(${this.name})`;\n    }\n}\nclass WorkStageRunner {\n    constructor(allotment, allocator) {\n        this.allotment = allotment;\n        this.allocator = allocator;\n        this._whenTaskDone = Promise.resolve();\n        const { supply } = allotment;\n        this._whenAllDone = new Promise(resolve => this._end = resolve)\n            .then(() => supply.off())\n            .catch(error => supply.off(error));\n        supply.whenOff(reason => {\n            if (reason === undefined) {\n                this._end();\n            }\n            else {\n                this._end(Promise.reject(reason));\n            }\n            // Stop accepting new tasks.\n            this.run = (work, _task) => Promise.reject(new WorkDoneError(allotment.workload, work, reason));\n        });\n    }\n    run(work, task) {\n        const promise = this._start(work).then(() => this.allotment.run(task));\n        this._addTask(promise);\n        return promise;\n    }\n    _addTask(taskPromise) {\n        const taskDone = this._whenTaskDone = Promise.all([\n            this._whenTaskDone,\n            taskPromise.catch(noop),\n        ]);\n        taskDone.finally(() => {\n            if (taskDone === this._whenTaskDone) {\n                this._end(taskDone);\n            }\n        });\n    }\n    _start(work) {\n        let whenStarted = this._awaitDeps();\n        if (this.allocator.start) {\n            whenStarted = whenStarted.then(async () => {\n                await this.allocator.start(work);\n            });\n        }\n        // Start only once!\n        this._start = valueProvider(whenStarted);\n        this._addTask(whenStarted);\n        return whenStarted;\n    }\n    _awaitDeps() {\n        const deps = [];\n        const addDep = (dep) => {\n            deps.push(new Promise(resolve => {\n                this.allotment\n                    .workbench\n                    .work(WorkOrdering.$)\n                    .runAfter(dep, () => {\n                    resolve();\n                    return this._whenAllDone;\n                })\n                    .catch(noop);\n            }));\n        };\n        const { after } = this.allocator;\n        if (after) {\n            addDep(after);\n        }\n        addDep(this.allotment.workload);\n        return Promise.all(deps);\n    }\n}\n\n/**\n * @internal\n */\nconst Workbench$impl__symbol = ( /*#__PURE__*/Symbol('Workbench.impl'));\n/**\n * @internal\n */\nclass Workbench$ {\n    constructor(workbench, options) {\n        this.workbench = workbench;\n        this._works = new Map();\n        const { supply = alwaysSupply(), run } = options;\n        this.supply = new Supply(reason => {\n            // Reject new work.\n            this.work = workload => {\n                throw new WorkDoneError(workload, undefined, reason, 'The workbench is stopped');\n            };\n        }).as(supply);\n        this._run = run ? run.bind(options) : Workbench$run;\n    }\n    work(workload) {\n        if (this._works.has(workload)) {\n            return this._works.get(workload);\n        }\n        let ensureWorking = noop;\n        const runWorkTask = async (work, task) => {\n            const result = await this._run(task, work, workload);\n            ensureWorking();\n            return result;\n        };\n        const supply = new Supply().needs(this.supply);\n        let setWork;\n        let work;\n        let runTask;\n        const whenWork = new Promise(resolve => {\n            setWork = newWork => {\n                work = newWork;\n                this._works.set(workload, newWork);\n                runTask = async (task) => await runWorkTask(newWork, task);\n                resolve(newWork);\n                return newWork;\n            };\n        });\n        runTask = async (task) => await runWorkTask(await whenWork, task);\n        supply.whenOff(reason => {\n            runTask = ensureWorking = () => {\n                throw new WorkDoneError(workload, work, reason);\n            };\n            this._works.delete(workload);\n        });\n        return setWork(workload.allocator.start({\n            workbench: this.workbench,\n            workload,\n            supply,\n            async run(task) {\n                return await runTask(task);\n            },\n        }));\n    }\n}\nasync function Workbench$run(task, _work, _workload) {\n    return await task();\n}\n\n/**\n * A workbench for coordinated {@link Workload workloads}.\n *\n * Performs a work by running tasks specific to each kind of workload.\n */\nclass Workbench {\n    /**\n     * Constructs a workbench.\n     *\n     * @param options - Constructed workbench options.\n     */\n    constructor(options = {}) {\n        this[Workbench$impl__symbol] = new Workbench$(this, options);\n    }\n    /**\n     * Workbench supply.\n     *\n     * Once cut off the workbench terminates all current works, and no longer accepts new ones.\n     */\n    get supply() {\n        return this[Workbench$impl__symbol].supply;\n    }\n    /**\n     * Obtains a work of the given workload.\n     *\n     * Caches the work previously obtained work of the same workload, until the work is {@link Workload.Allotment.supply\n     * disposed}. Creates a new work instance after that.\n     *\n     * @typeParam TWork - A work type.\n     * @param workload - Target workload.\n     *\n     * @returns A work instance.\n     */\n    work(workload) {\n        return this[Workbench$impl__symbol].work(workload);\n    }\n}\n\nexport { WorkDoneError, WorkStage, Workbench, Workload };\n//# sourceMappingURL=workbench.js.map\n","/**\n * @packageDocumentation\n * @module @frontmeans/httongue\n */\n/**\n * Decodes URL component.\n *\n * In contrast to standard [decodeURIComponent] function this one decodes `+` signs as spaces.\n *\n * [decodeURIComponent]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent\n *\n * @param url - URL component to decode.\n *\n * @returns Decoded URL component.\n */\nfunction decodeURLComponent(url) {\n    return decodeURIComponent(url.replace(/\\+/g, ' '));\n}\n\n/**\n * @packageDocumentation\n * @module @frontmeans/httongue\n */\n/**\n * Escapes CSS identifier accordingly to the rules defined for [CSS.escape()](https://drafts.csswg.org/cssom/#the-css.escape%28%29-method)\n * utility method.\n *\n * Can be applied to CSS values as well, although it escapes characters that don't strictly need to be escaped.\n * A {@link escapeCSSVal} is a better alternative for that.\n *\n * @param text - A text to escape.\n *\n * @returns A string safe to be used as CSS identifier, e.g. as CSS selector.\n */\nfunction escapeCSS(text) {\n    const len = text.length;\n    const first = text.charCodeAt(0);\n    let out = '';\n    let i = 0;\n    if (first === 0x2d) {\n        // If the first character is a \"-\" (U+002D)\n        const second = text.charCodeAt(1);\n        // ... and the second character is in the range [0-9] (U+0030 to U+0039).\n        if (second > 0x2f && second < 0x3a) {\n            // then '-' followed by the character escaped as code point.\n            out += `-\\\\${second.toString(16)} `;\n            i = 2;\n        }\n        else {\n            out = '-';\n            i = 1;\n        }\n        if (len === 1) {\n            // ... and there is no second character, then the escaped character.\n            return '\\\\-';\n        }\n    }\n    else if (first > 0x2f && first < 0x3a) {\n        // If the first character is in the range [0-9] (U+0030 to U+0039),\n        // then the character escaped as code point.\n        out += `\\\\${first.toString(16)} `;\n        i = 1;\n    }\n    for (; i < len; ++i) {\n        const c = text.charCodeAt(i);\n        if (\n        // Is in range [a-z] (U+0061 to U+007A),\n        (c > 0x60 && c < 0x7b)\n            // or is \"-\" (U+002D),\n            || c === 0x2d\n            // or is \"_\" (U+005F)\n            || c === 0x5f\n            // or is in range [0-9] (U+0030 to U+0039),\n            || (c > 0x2f && c < 0x3a)\n            // or is in range [A-Z] (U+0041 to U+005A)\n            || (c > 0x40 && c < 0x5b)) {\n            // then the character itself.\n            out += text[i];\n        }\n        else if (c > 0x7e) {\n            out += c === 0x7f\n                // If the character is U+007F\n                // then the character escaped as code point.\n                ? `\\\\${c.toString(16)} `\n                // If the character is greater than or equal to U+0080,\n                // then the character itself\n                : text[i];\n        }\n        else if (c < 0x20) {\n            out += c\n                // If the character is in the range [\\1-\\1f] (U+0001 to U+001F)\n                // then the character escaped as code point.\n                ? `\\\\${c.toString(16)} `\n                // If the character is NULL (U+0000)\n                // then the REPLACEMENT CHARACTER (U+FFFD).\n                : '\\uFFFD';\n        }\n        else {\n            // Otherwise, the escaped character.\n            out += `\\\\${text[i]}`;\n        }\n    }\n    return out;\n}\n\n/**\n * @packageDocumentation\n * @module @frontmeans/httongue\n */\n/**\n * Escapes CSS value to be included into CSS string.\n *\n * Escapes accordingly to [serialize a string] algorithm.\n *\n * [serialize a string]: https://drafts.csswg.org/cssom/#serialize-a-string\n *\n * @param text - A text to escape.\n *\n * @returns A string safe to be included into CSS value, e.g. within CSS string.\n */\nfunction escapeCSSVal(text) {\n    let out = '';\n    const len = text.length;\n    for (let i = 0; i < len; ++i) {\n        const c = text.charCodeAt(i);\n        out += c < 0x20 || c === 0x7f\n            ? (c\n                // If the character is in the range [\\1-\\1f] (U+0001 to U+001F),\n                // the character escaped as code point.\n                ? `\\\\${c.toString(16)} `\n                // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).;\n                : '\\uFFFD')\n            : (c === 0x22 || c === 0x5c\n                // If the character is '\"' (U+0022) or \"\\\" (U+005C),\n                // the escaped character.\n                ? `\\\\${text[i]}`\n                // Otherwise, the character itself.\n                : text[i]);\n    }\n    return out;\n}\n\n/**\n * @internal\n */\nconst xmlPredef = {\n    '\"': '&#34;',\n    '&': '&amp;',\n    '\\'': '&#39;',\n    '<': '&lt;',\n    '>': '&gt;',\n};\n/**\n * @internal\n */\nfunction replaceXMLPredef(char) {\n    return xmlPredef[char];\n}\n\n/**\n * @packageDocumentation\n * @module @frontmeans/httongue\n */\n/**\n * Replaces XML-unsafe characters with corresponding [predefined XML entities](https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML).\n *\n * Uses the shortest possible entities representation. I.e. `&#34;` instead of `&quot;`, and `&#39;' instead of\n * `&apos;`.\n *\n * @param text - A text to escape.\n *\n * @returns XML-safe text.\n */\nfunction escapeXML(text) {\n    return text.replace(/[&<>'\"]/g, replaceXMLPredef);\n}\n\n/**\n * @internal\n */\nconst uppercasePattern = /[A-Z]+/g;\n/**\n * @internal\n */\nfunction toHyphenLower(letters, offset, str) {\n    const lowerCase = letters.toLowerCase();\n    if ((lowerCase.length > 1) && (offset + lowerCase.length < str.length)) {\n        // More than one subsequent upper-case letters, unless at the end of the string.\n        return `-${lowerCase.slice(0, -1)}-${lowerCase.slice(-1)}`;\n    }\n    return '-' + lowerCase;\n}\n/**\n * @internal\n */\nconst hyphenateCSSName$cache = ( /*#__PURE__*/new Map());\n\n/**\n * @packageDocumentation\n * @module @frontmeans/httongue\n */\n/**\n * Hyphenates a camel-cased name.\n *\n * Applicable to CSS property names.\n *\n * Converts:\n *\n * - `backgroundColor` to `background-color`.\n *\n *    Uppercase letters converted to lower case and prepended by hyphen,\n *\n * - `MozTransition` to `-moz-transition`.\n *\n *   The very first uppercase letter is prepended by hyphen too.\n *\n * - `MSTransition` to `-ms-transition`.\n *\n *   Subsequent upper-case letters converted to lower case. The first and the last ones prepended by hyphen.\n *\n * - `someURL` to `some-url`\n *\n *   Subsequent upper-case letters in the very end of the string converted to lower case and prepended by hyphen.\n *\n * - `color` to `color`.\n *\n *   All lower-case names remain as is.\n *\n * - `padding-left` to `padding-left`\n *\n *   Hyphens remain in place.\n *\n * @param name - Camel-cased name to hyphenate.\n *\n * @returns Hyphenated name.\n */\nfunction hyphenateName(name) {\n    return name.replace(uppercasePattern, toHyphenLower);\n}\n/**\n * De-capitalizes a camel-cased name and hyphenates it.\n *\n * Calls {@link hyphenateName}, then removes the leading hyphen.\n *\n * Thus, e.g. `MozTransition` would be converted to `moz-transition` rather to `-moz-transition`.\n *\n * @param name - Camel-cased name to hyphenate.\n *\n * @returns Hyphenated name.\n */\nfunction hyphenateDecapName(name) {\n    const hyphenated = hyphenateName(name);\n    return hyphenated.startsWith('-') ? hyphenated.substr(1) : hyphenated;\n}\n/**\n * Hyphenates a camel-cased CSS property key.\n *\n * Applicable to the names of `HTMLElement.style` properties, including vendor-specific ones.\n *\n * Calls {@link hyphenateName}, then replaces `ms-` prefix with `-ms-` one. Other vendor-specific prefixes are\n * capitalized, so the hyphen prefix is added already.\n *\n * Caches hyphenated names for the sake of speed.\n *\n * @param name - Camel-cased CSS property name to hyphenate.\n *\n * @returns Hyphenated CSS property name.\n */\nfunction hyphenateCSSName(name) {\n    const found = hyphenateCSSName$cache.get(name);\n    if (found) {\n        return found;\n    }\n    let hyphenated = hyphenateName(name);\n    if (hyphenated.startsWith('ms-')) {\n        hyphenated = '-' + hyphenated;\n    }\n    hyphenateCSSName$cache.set(name, hyphenated);\n    return hyphenated;\n}\n\nexport { decodeURLComponent, escapeCSS, escapeCSSVal, escapeXML as escapeHTML, escapeXML, hyphenateCSSName, hyphenateDecapName, hyphenateName };\n//# sourceMappingURL=httongue.js.map\n","import { SingleContextKey, ContextValues, ContextKey__symbol, ContextRegistry, SimpleContextKey } from '@proc7ts/context-values';\nimport { hasOwnProperty, superClassOf, elementOrArray, extendSetOfElements, setOfElements, mergeFunctions, noop, valueProvider, asis, newPromiseResolver, valueByRecipe } from '@proc7ts/primitives';\nimport { amend, allAmender, AeClass, newAmendTarget, isAmendatory, AeMember } from '@proc7ts/amend';\nimport { Supply, neverSupply } from '@proc7ts/supply';\nimport { isQualifiedName, html__naming, newNamespaceAliaser, NamespaceDef } from '@frontmeans/namespace-aliaser';\nimport { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { ContextUpKey, ContextModule, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { digAfter, afterThe, statePath, trackValue, mapAfter, digOn_, onceOn, AfterEvent__symbol, onEventBy, supplyOn, EventEmitter, valueOn, onAny, mapAfter_, filterOn_, translateOn, mapOn_, valueOn_, onPromise, StateTracker, ValueTracker, isEventSender, onSupplied, translateOn_ } from '@proc7ts/fun-events';\nimport { asyncRenderScheduler, newRenderSchedule } from '@frontmeans/render-scheduler';\nimport { nodeDocument } from '@frontmeans/dom-primitives';\nimport { drekContextOf, drekBuild } from '@frontmeans/drek';\nimport { Workbench, WorkStage } from '@proc7ts/workbench';\nimport { hyphenateDecapName } from '@frontmeans/httongue';\n\n/**\n * @internal\n */\nconst BootstrapContext__key = ( /*#__PURE__*/new SingleContextKey('bootstrap-context'));\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to {@link FeatureDef.init} method so that the feature can configure\n * itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nclass BootstrapContext extends ContextValues {\n    /**\n     * A key of bootstrap context value containing the bootstrap context itself.\n     */\n    static get [ContextKey__symbol]() {\n        return BootstrapContext__key;\n    }\n}\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @typeParam TValue - Context value type.\n * @typeParam TKey - Context key type.\n * @param provide - A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nfunction bootstrapDefault(provide) {\n    return (context, key) => {\n        const bootstrapContext = context.get(BootstrapContext);\n        return context === bootstrapContext\n            ? provide(bootstrapContext, key)\n            : bootstrapContext.get(key);\n    };\n}\n\n/**\n * @category Utility\n */\nclass MetaAccessor {\n    constructor(symbol) {\n        this.symbol = symbol;\n    }\n    own(type, receiver) {\n        return hasOwnProperty(type, this.symbol)\n            ? Reflect.get(type, this.symbol, receiver)\n            : undefined;\n    }\n    of(type, receiver = type) {\n        const ownDef = this.own(type, receiver);\n        const superType = superClassOf(type);\n        const superDef = superType && this.of(superType, receiver);\n        return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n    }\n    define(type, metas) {\n        const prevMeta = this.own(type);\n        const newMeta = this.merge(prevMeta ? [prevMeta, ...metas] : metas);\n        Reflect.defineProperty(type, this.symbol, {\n            configurable: true,\n            value: newMeta,\n        });\n        return type;\n    }\n}\n\n/**\n * @internal\n */\nfunction mergeInitMethods(target1, method1, target2, method2) {\n    const m1 = method1 && method1.bind(target1);\n    const m2 = method2 && method2.bind(target2);\n    if (!m2) {\n        return m1;\n    }\n    if (!m1) {\n        return m2;\n    }\n    return async (...args) => {\n        await m1(...args);\n        await m2(...args);\n    };\n}\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nconst FeatureDef__symbol = ( /*#__PURE__*/Symbol('FeatureDef'));\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor {\n    constructor() {\n        super(FeatureDef__symbol);\n    }\n    merge(defs) {\n        return defs.reduce((prev, def) => ({\n            needs: elementOrArray(extendSetOfElements(setOfElements(prev.needs), def.needs)),\n            has: elementOrArray(extendSetOfElements(setOfElements(prev.has), def.has)),\n            setup: mergeInitMethods(prev, prev.setup, def, def.setup),\n            init: mergeInitMethods(prev, prev.init, def, def.init),\n        }), {});\n    }\n}\n/**\n * @internal\n */\nconst featureMeta = ( /*#__PURE__*/new FeatureMeta());\n/**\n * @category Core\n */\nconst FeatureDef = {\n    /**\n     * Extracts feature definition options from its type.\n     *\n     * @param featureType - Target feature class constructor.\n     *\n     * @returns Feature definition options. May be empty when there is no feature definition found in the given\n     * `featureType`.\n     */\n    of(featureType) {\n        return featureMeta.of(amend(featureType)) || {};\n    },\n    /**\n     * Merges multiple feature definition options.\n     *\n     * @param defs - Feature definition options to merge.\n     *\n     * @returns Merged feature definition options.\n     */\n    merge(...defs) {\n        return featureMeta.merge(defs);\n    },\n    /**\n     * Defines a feature.\n     *\n     * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n     *\n     * @typeParam TClass - Feature type.\n     * @param featureType - Feature class constructor.\n     * @param defs - Feature definitions.\n     *\n     * @returns The `type` instance.\n     */\n    define(featureType, ...defs) {\n        return featureMeta.define(featureType, defs);\n    },\n};\n\n/**\n * Creates a feature class amendment (and decorator).\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to {@link bootstrapComponents} function or referenced by other features.\n *\n * This is an alternative to direct call to {@link FeatureDef.define} method.\n *\n * @category Core\n * @typeParam TClass - Amended feature class type.\n * @typeParam TAmended - Amended feature entity type.\n * @param amendments - Feature definitions or amendments to apply.\n *\n * @returns Feature class amendment and decorator.\n */\nfunction Feature(...amendments) {\n    const amender = Feature$toAmender(amendments);\n    return AeClass(baseTarget => {\n        let result = {};\n        amender(newAmendTarget({\n            base: {\n                ...baseTarget,\n                featureDef: {},\n            },\n            amend(_base, request = {}) {\n                const { featureDef: defRequest = {}, ...baseRequest } = request;\n                const createBaseTarget = baseTarget.amend(baseRequest);\n                const featureDef = result = FeatureDef.merge(result, defRequest);\n                return () => ({\n                    ...createBaseTarget(),\n                    featureDef,\n                });\n            },\n        }));\n        FeatureDef.define(baseTarget.amendedClass, result);\n    });\n}\nfunction Feature$toAmender(amendments) {\n    const featureDefs = [];\n    const featureAmendments = [];\n    for (const amendment of amendments) {\n        if (isFeatureAmendment(amendment)) {\n            featureAmendments.push(amendment);\n        }\n        else {\n            featureDefs.push(amendment);\n        }\n    }\n    if (featureDefs.length) {\n        featureAmendments.push(FeatureDef$toAmender(featureDefs));\n    }\n    return allAmender(featureAmendments);\n}\nfunction isFeatureAmendment(amendment) {\n    return typeof amendment === 'function' || isAmendatory(amendment);\n}\nfunction FeatureDef$toAmender(defs) {\n    return ({ amend }) => amend({\n        featureDef: FeatureDef.merge(...defs),\n    });\n}\n\n/**\n * @internal\n */\nconst FeatureContext__key = ( /*#__PURE__*/new SingleContextKey('feature-context'));\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nclass FeatureContext extends BootstrapContext {\n    /**\n     * A key of feature context value containing the feature context itself.\n     */\n    static get [ContextKey__symbol]() {\n        return FeatureContext__key;\n    }\n    whenDefined(componentType) {\n        return this.get(BootstrapContext).whenDefined(componentType);\n    }\n    load(feature, user) {\n        return this.get(BootstrapContext).load(feature, user ? new Supply().needs(this).needs(user) : this);\n    }\n}\n\n/**\n * @internal\n */\nconst BootstrapWorkbench = ( /*#__PURE__*/new SingleContextKey('bootstrap-workbench', {\n    byDefault: bootstrapDefault(() => new Workbench()),\n}));\n/**\n * @internal\n */\nconst featureSetupStage = ( /*#__PURE__*/new WorkStage('feature setup'));\n/**\n * @internal\n */\nconst featureInitStage = ( /*#__PURE__*/new WorkStage('feature init', { after: featureSetupStage }));\n/**\n * @internal\n */\nconst componentDefStage = ( /*#__PURE__*/new WorkStage('component definition', { after: featureInitStage }));\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nconst ComponentDef__symbol = ( /*#__PURE__*/Symbol('ComponentDef'));\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor {\n    constructor() {\n        super(ComponentDef__symbol);\n    }\n    merge(defs) {\n        return defs.reduce((prev, meta) => {\n            const def = this.meta(meta);\n            return ({\n                ...prev,\n                ...def,\n                setup: mergeFunctions(prev.setup, def.setup),\n                define: mergeFunctions(prev.define, def.define),\n                feature: prev.feature\n                    ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n                    : def.feature,\n            });\n        }, {});\n    }\n    meta(source) {\n        if (isQualifiedName(source)) {\n            return { name: source };\n        }\n        return source;\n    }\n}\n/**\n * @internal\n */\nconst componentMeta = ( /*#__PURE__*/new ComponentMeta());\n/**\n * @category Core\n */\nconst ComponentDef = {\n    /**\n     * Extracts component definition options from its type.\n     *\n     * @typeParam T - A type of component.\n     * @param componentType - Target component class constructor.\n     *\n     * @returns Component definition options. May be empty if there is not definition attached to component type.\n     */\n    of(componentType) {\n        return componentMeta.of(amend(componentType)) || {};\n    },\n    /**\n     * Merges multiple component definition options.\n     *\n     * @typeParam T - A type of component.\n     * @param defs - Component definition options to merge.\n     *\n     * @returns Merged component definition options.\n     */\n    merge(...defs) {\n        return componentMeta.merge(defs);\n    },\n    /**\n     * Defines a component.\n     *\n     * Either assigns new or extends existing component definition and stores it under {@link ComponentDef__symbol} key.\n     *\n     * Each component can be passed directly to {@link bootstrapComponents} function or added as a requirement\n     * of another feature.\n     *\n     * @typeParam TClass - A type of component class.\n     * @param componentType - Component class constructor.\n     * @param defs - Component definitions.\n     *\n     * @returns The `type` instance.\n     */\n    define(componentType, ...defs) {\n        return componentMeta.define(componentType, defs);\n    },\n};\n\n/**\n * Creates a component class amendment (and decorator).\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with {@link FeatureContext.define} method or used as a feature, e.g. passed to\n * {@link bootstrapComponents} function, or added to {@link FeatureDef.needs} property of another feature.\n *\n * This is an alternative to direct call to {@link ComponentDef.define} method.\n *\n * @category Core\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component entity type.\n * @param amendments - Component definitions, qualified name od component's element, or amendments to apply.\n *\n * @returns Component class amendment and decorator.\n */\nfunction Component(...amendments) {\n    const amender = Component$toAmender(amendments);\n    return Feature(baseTarget => {\n        let result = {};\n        amender(newAmendTarget({\n            base: {\n                ...baseTarget,\n                componentDef: {},\n            },\n            amend(_base, request = {}) {\n                const { componentDef: defRequest = {}, ...baseRequest } = request;\n                const createBaseTarget = baseTarget.amend(baseRequest);\n                const componentDef = result = ComponentDef.merge(result, defRequest);\n                return () => ({\n                    ...createBaseTarget(),\n                    componentDef,\n                });\n            },\n        }));\n        ComponentDef.define(baseTarget.amendedClass, result);\n    });\n}\nfunction Component$toAmender(amendments) {\n    const componentDefs = [];\n    const componentAmendments = [];\n    for (const amendment of amendments) {\n        if (isComponentAmendment(amendment)) {\n            componentAmendments.push(amendment);\n        }\n        else {\n            componentDefs.push(amendment);\n        }\n    }\n    if (componentDefs.length) {\n        componentAmendments.push(ComponentDef$toAmender(componentDefs));\n    }\n    return allAmender(componentAmendments);\n}\nfunction isComponentAmendment(amendment) {\n    return typeof amendment === 'function' || isAmendatory(amendment);\n}\nfunction ComponentDef$toAmender(defs) {\n    return ({ amend }) => amend({\n        componentDef: ComponentDef.merge(...defs),\n    });\n}\n\n/**\n * @internal\n */\nconst ComponentContext__key = ( /*#__PURE__*/new SingleContextKey('component-context'));\n\n/**\n * @internal\n */\nconst ComponentEventDispatcher__key = ( /*#__PURE__*/new SingleContextKey('component-event-dispatcher', {\n    byDefault(values) {\n        const context = values.get(ComponentContext__key);\n        const dispatcher = new DomEventDispatcher(context.element);\n        dispatcher.supply.needs(context);\n        return {\n            dispatch(event) {\n                return dispatcher.dispatch(event);\n            },\n            on(type) {\n                return dispatcher.on(type);\n            },\n        };\n    },\n}));\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nconst ContentRoot = ( /*#__PURE__*/new SingleContextKey('content-root', {\n    byDefault(ctx) {\n        return ctx.get(ComponentContext__key).element;\n    },\n}));\n\n/**\n * @internal\n */\nclass StateUpdaterKey extends ContextUpKey {\n    constructor() {\n        super('state-updater');\n        this.upKey = this.createUpKey(slot => slot.insert(slot.seed.do(digAfter((...fns) => {\n            if (fns.length) {\n                const combined = fns.reduce((prev, fn) => mergeFunctions(fn, prev), noop);\n                return afterThe((path, newValue, oldValue) => combined(statePath(path), newValue, oldValue));\n            }\n            if (slot.hasFallback && slot.or) {\n                return slot.or;\n            }\n            return afterThe(noop);\n        }))));\n    }\n    grow(slot) {\n        let delegated;\n        slot.context.get(this.upKey, slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined)(fn => delegated = fn).whenOff(() => delegated = noop);\n        slot.insert((path, newValue, oldValue) => delegated(path, newValue, oldValue));\n    }\n}\n/**\n * A key of component context value containing a component {@link StateUpdater state updater} function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Does nothing by default and after component destruction.\n *\n * When multiple state updaters provided, they all will be called on each state update, in reverse order.\n *\n * @category Core\n */\nconst StateUpdater = ( /*#__PURE__*/new StateUpdaterKey());\n\n/**\n * A key of component instance method returning its component context.\n *\n * @category Core\n */\nconst ComponentContext__symbol = ( /*#__PURE__*/Symbol('ComponentContext'));\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * {@link BootstrapSetup.perComponent} and {@link DefinitionSetup.perComponent} methods.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nclass ComponentContext extends ContextValues {\n    constructor() {\n        super();\n        this.updateState = (key, newValue, oldValue) => {\n            this.get(StateUpdater)(key, newValue, oldValue);\n        };\n    }\n    /**\n     * A key of component context value containing the component context instance itself.\n     */\n    static get [ContextKey__symbol]() {\n        return ComponentContext__key;\n    }\n    /**\n     * Extracts component context from the given component instance.\n     *\n     * @param component - Target component instance.\n     *\n     * @return Component context reference returned by {@link ComponentContext__symbol} method.\n     *\n     * @throws TypeError  When the given `component` does not contain component context reference.\n     */\n    static of(component) {\n        if (typeof component[ComponentContext__symbol] !== 'function') {\n            throw new TypeError(`No component context found in ${String(component)}`);\n        }\n        return component[ComponentContext__symbol]();\n    }\n    /**\n     * Component content root.\n     *\n     * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n     */\n    get contentRoot() {\n        return this.get(ContentRoot);\n    }\n    /**\n     * Returns DOM event producer for the given event type.\n     *\n     * Retrieves an event producer from {@link ComponentEventDispatcher component event dispatcher} available in this\n     * context.\n     *\n     * @typeParam TEvent - DOM event type.\n     * @param type - An event type to listen for.\n     *\n     * @returns A producer of DOM event events of the given type.\n     */\n    on(type) {\n        return this.get(ComponentEventDispatcher__key).on(type);\n    }\n    /**\n     * Dispatches an event to component element.\n     *\n     * Dispatches using a {@link ComponentEventDispatcher component event dispatcher} available in this context.\n     *\n     * @param event - An event to dispatch.\n     */\n    dispatchEvent(event) {\n        this.get(ComponentEventDispatcher__key).dispatch(event);\n    }\n}\n\n/**\n * A key of component context value containing component event dispatcher.\n *\n * @category Core\n */\nconst ComponentEventDispatcher = ComponentEventDispatcher__key;\n\n/**\n * Creates an amendment (and decorator) for the component instance member.\n *\n * @category Core\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - Amended component member entity type.\n * @param amendments - Amendments to apply.\n *\n * @returns New component member amendment instance.\n */\nfunction ComponentMember(...amendments) {\n    return AeMember(Component(allAmender(amendments)));\n}\n\nconst ComponentSlot$empty = {\n    get: noop,\n    unbind: noop,\n    rebind: noop,\n    drop: noop,\n};\n/**\n * @internal\n */\nclass ComponentSlot$ {\n    constructor() {\n        this._provider = trackValue(ComponentSlot$empty);\n        this.read = this._provider.read.do(mapAfter(provider => provider.get()));\n        this.whenReady = this.read.do(digOn_(ctx => ctx && ctx.whenReady), onceOn);\n    }\n    get context() {\n        return this._provider.it.get();\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n    bind(context) {\n        this._provider.it.drop();\n        this._provider.it = ComponentSlot$known(this, context);\n    }\n    bindBy(binder) {\n        this._provider.it.drop();\n        this._provider.it = ComponentSlot$bound(this, binder);\n    }\n    unbind() {\n        this._provider.it.unbind();\n    }\n    rebind() {\n        return this.context || this._provider.it.rebind();\n    }\n}\nfunction ComponentSlot$known(slot, context) {\n    context.supply.whenOff(() => {\n        if (slot.context === context) {\n            slot.unbind();\n        }\n    });\n    const get = () => context;\n    return {\n        get,\n        unbind() {\n            slot._provider.it = ComponentSlot$empty;\n        },\n        rebind: get,\n        drop: noop,\n    };\n}\nfunction ComponentSlot$bound(slot, binder) {\n    let supply = neverSupply();\n    let getContext = noop;\n    const get = () => getContext();\n    const newSupply = () => supply = new Supply(() => {\n        getContext = noop;\n    });\n    let bind = (context) => {\n        getContext = valueProvider(context);\n        context.supply.whenOff(() => {\n            if (slot.context === context) {\n                slot.unbind();\n            }\n        });\n        return newSupply();\n    };\n    const drop = () => {\n        bind = _ => neverSupply();\n        supply.off();\n    };\n    const unbind = () => {\n        supply.off();\n        slot._provider.it = {\n            get,\n            unbind,\n            rebind,\n            drop,\n        };\n    };\n    const bindContext = () => binder({\n        bind: context => bind(context),\n    });\n    getContext = () => {\n        bindContext();\n        // Subsequent bind calls update the component provider\n        bind = context => {\n            supply.off();\n            getContext = valueProvider(context);\n            slot._provider.it = {\n                get,\n                unbind,\n                rebind,\n                drop,\n            };\n            return newSupply();\n        };\n        return getContext();\n    };\n    const rebind = () => {\n        bindContext();\n        return getContext();\n    };\n    return {\n        get,\n        unbind,\n        rebind,\n        drop,\n    };\n}\n\n/**\n * A key of component element property containing a reference to component slot.\n *\n * @category Core\n */\nconst ComponentSlot__symbol = ( /*#__PURE__*/Symbol('ComponentSlot'));\n/**\n * @category Core\n */\nconst ComponentSlot = {\n    /**\n     * Accesses a component slot of the given element. Attaches a new slot if necessary.\n     *\n     * @param element - Target element.\n     *\n     * @returns A component slot instance attached to the element.\n     */\n    of(element) {\n        const found = element[ComponentSlot__symbol];\n        if (found) {\n            return found;\n        }\n        return element[ComponentSlot__symbol] = new ComponentSlot$();\n    },\n};\n\nconst BootstrapContextRegistry__key = (\n/*#__PURE__*/ new SingleContextKey('bootstrap-context-registry'));\n/**\n * @internal\n */\nclass BootstrapContextRegistry extends ContextRegistry {\n    constructor() {\n        super();\n        this.provide({ a: BootstrapContextRegistry, is: this });\n        this.values = this.newValues();\n    }\n    static get [ContextKey__symbol]() {\n        return BootstrapContextRegistry__key;\n    }\n    static create() {\n        return new BootstrapContextRegistry();\n    }\n}\n\nconst PerComponentRegistry = (\n/*#__PURE__*/ new SingleContextKey('per-component-registry', {\n    byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n}));\n/**\n * @internal\n */\nclass ComponentContextRegistry extends ContextRegistry {\n}\n\n/**\n * @internal\n */\nconst PerDefinitionRegistry = (\n/*#__PURE__*/ new SingleContextKey('per-definition-registry', {\n    byDefault: bootstrapDefault(bsContext => new DefinitionContextRegistry(bsContext)),\n}));\n/**\n * @internal\n */\nclass DefinitionContextRegistry extends ContextRegistry {\n}\n\n/**\n * @internal\n */\nfunction onPostDefSetup(componentType, supply) {\n    const { on } = postDefSetup(componentType);\n    return onEventBy(receiver => {\n        on({\n            supply: receiver.supply.needs(supply),\n            receive(ctx, setup) {\n                const whenReady = setup.whenReady.do(supplyOn(supply));\n                const whenComponent = setup.whenComponent.do(supplyOn(supply));\n                receiver.receive(ctx, {\n                    get componentType() {\n                        return setup.componentType;\n                    },\n                    get whenReady() {\n                        return whenReady;\n                    },\n                    get whenComponent() {\n                        return whenComponent;\n                    },\n                    perDefinition(spec) {\n                        return setup.perDefinition(spec).needs(supply);\n                    },\n                    perComponent(spec) {\n                        return setup.perComponent(spec).needs(supply);\n                    },\n                });\n            },\n        });\n    });\n}\nconst PostDefSetup__symbol = ( /*#__PURE__*/Symbol('PostDefSetup'));\n/**\n * @internal\n */\nfunction postDefSetup(componentType) {\n    if (hasOwnProperty(componentType, PostDefSetup__symbol)) {\n        return componentType[PostDefSetup__symbol];\n    }\n    const tracker = trackValue();\n    const emitter = new EventEmitter();\n    const onSetup = tracker.read.do(valueOn(asis));\n    const on = onAny(onSetup, emitter);\n    const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n    if (superType) {\n        const superPostDefSetup = postDefSetup(superType);\n        on(setup => superPostDefSetup.send(setup));\n    }\n    const result = {\n        on,\n        send(setup) {\n            emitter.send(setup);\n        },\n        setup(setup) {\n            tracker.it = setup;\n        },\n    };\n    Reflect.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n    return result;\n}\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nconst BootstrapWindow = ( /*#__PURE__*/new SingleContextKey('window', {\n    byDefault() {\n        return window;\n    },\n}));\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of {@link BootstrapWindow}.\n *\n * @category Core\n */\nconst BootstrapRoot = ( /*#__PURE__*/new SingleContextKey('bootstrap-root', {\n    byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n    },\n}));\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nconst DefaultNamespaceAliaser = (\n/*#__PURE__*/ new SingleContextKey('default-namespace-aliaser'));\n\n/**\n * @internal\n */\nclass RenderScheduler$Key extends ContextUpKey {\n    constructor(name, byDefault) {\n        super(name);\n        this.upKey = this.createUpKey(slot => slot.insert(slot.seed.do(digAfter((...fns) => {\n            if (fns.length) {\n                return afterThe(RenderScheduler$adopt(slot.context, fns[fns.length - 1]));\n            }\n            if (slot.hasFallback && slot.or) {\n                return slot.or;\n            }\n            return afterThe(RenderScheduler$adopt(slot.context, byDefault));\n        }))));\n    }\n    grow(slot) {\n        const { context } = slot;\n        const bsContext = context.get(BootstrapContext);\n        if (context !== bsContext) {\n            return slot.insert(bsContext.get(this, slot.hasFallback ? slot : undefined));\n        }\n        let delegated;\n        context.get(this.upKey, slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined)(scheduler => delegated = RenderScheduler$adopt(context, scheduler));\n        slot.insert((...args) => delegated(...args));\n    }\n}\nfunction RenderScheduler$adopt(context, scheduler) {\n    return (options = {}) => scheduler({\n        ...options,\n        window: options.window || context.get(BootstrapWindow),\n    });\n}\n\n/**\n * A key of bootstrap context value containing {@link DefaultPreRenderScheduler} instance.\n *\n * Uses asynchronous `RenderScheduler` (`asyncRenderScheduler`) for {@link BootstrapWindow bootstrap window} by default.\n *\n * @category Core\n */\nconst DefaultPreRenderScheduler = (\n/*#__PURE__*/ new RenderScheduler$Key('default-pre-render-scheduler', asyncRenderScheduler));\n\n/**\n * A key of bootstrap context value containing {@link DefaultRenderScheduler} instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window} by default.\n *\n * @category Core\n */\nconst DefaultRenderScheduler = (\n/*#__PURE__*/ new RenderScheduler$Key('default-render-scheduler', newRenderSchedule));\n\n/**\n * A key of bootstrap context value containing {@link DocumentRenderKit} instance.\n *\n * @category Core\n */\nconst DocumentRenderKit = (\n/*#__PURE__*/ new SingleContextKey('document-render-kit', {\n    byDefault: bootstrapDefault(DocumentRenderKit$create),\n}));\nfunction DocumentRenderKit$create(bsContext) {\n    const docs = new WeakMap();\n    const initDoc = (doc) => {\n        if (!docs.get(doc)) {\n            docs.set(doc, 1);\n            drekContextOf(doc).update({\n                nsAlias: bsContext.get(DefaultNamespaceAliaser),\n                scheduler: bsContext.get(DefaultRenderScheduler),\n            });\n        }\n    };\n    return {\n        contextOf(node) {\n            initDoc(nodeDocument(node));\n            return drekContextOf(node);\n        },\n    };\n}\n\n/**\n * @internal\n */\nconst DefinitionContext__symbol = ( /*#__PURE__*/Symbol('DefinitionContext'));\n/**\n * @internal\n */\nfunction definitionContextOf(componentType) {\n    if (!hasOwnProperty(componentType, DefinitionContext__symbol)) {\n        throw new TypeError(`Component is not defined: ${componentType}`);\n    }\n    return componentType[DefinitionContext__symbol];\n}\n\n/**\n * @internal\n */\nconst CustomElements__key = ( /*#__PURE__*/new SingleContextKey('custom-elements', {\n    byDefault: bootstrapDefault(createCustomElements),\n}));\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nclass CustomElements {\n    /**\n     * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n     * elements.\n     *\n     * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n     */\n    static get [ContextKey__symbol]() {\n        return CustomElements__key;\n    }\n}\n/**\n * @internal\n */\nfunction createCustomElements(bsContext) {\n    const customElements = bsContext.get(BootstrapWindow).customElements;\n    const nsAlias = bsContext.get(DefaultNamespaceAliaser);\n    class CustomElements$ extends CustomElements {\n        define(componentTypeOrName, elementType) {\n            if (isQualifiedName(componentTypeOrName)) {\n                customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n                return;\n            }\n            const defContext = definitionContextOf(componentTypeOrName);\n            const { tagName, extend } = defContext.elementDef;\n            if (!tagName) {\n                componentResolver(componentTypeOrName).resolve(undefined);\n                return; // Anonymous component.\n            }\n            if (extend && extend.name) {\n                customElements.define(tagName, elementType, {\n                    extends: extend.name,\n                });\n            }\n            else {\n                customElements.define(tagName, elementType);\n            }\n        }\n        whenDefined(componentTypeOrName) {\n            if (isQualifiedName(componentTypeOrName)) {\n                return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n            }\n            const defContext = definitionContextOf(componentTypeOrName);\n            const { name } = defContext.elementDef;\n            if (!name) {\n                return componentResolver(componentTypeOrName).promise();\n            }\n            return customElements.whenDefined(html__naming.name(name, nsAlias));\n        }\n    }\n    return new CustomElements$();\n}\n/**\n * @internal\n */\nconst ComponentResolver__symbol = ( /*#__PURE__*/Symbol('ComponentResolver'));\n/**\n * @internal\n */\nfunction componentResolver(componentType) {\n    if (hasOwnProperty(componentType, ComponentResolver__symbol)) {\n        return componentType[ComponentResolver__symbol];\n    }\n    return componentType[ComponentResolver__symbol] = newPromiseResolver();\n}\n\n/**\n * @internal\n */\nconst DefinitionContext__key = ( /*#__PURE__*/new SingleContextKey('definition-context'));\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * {@link BootstrapSetup.perDefinition} and {@link DefinitionSetup.perDefinition} methods. All {@link BootstrapContext}\n * values are available too.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nclass DefinitionContext extends ContextValues {\n    /**\n     * A key of definition context value containing the definition context itself.\n     */\n    static get [ContextKey__symbol]() {\n        return DefinitionContext__key;\n    }\n}\n\n/**\n * A key of bootstrap context value containing an element naming service instance.\n */\nconst ElementNaming = ( /*#__PURE__*/new SingleContextKey('element-naming', {\n    byDefault: bootstrapDefault(newElementNaming),\n}));\nfunction newElementNaming(bsContext) {\n    const bsWindow = bsContext.get(BootstrapWindow);\n    const nsAlias = bsContext.get(DefaultNamespaceAliaser);\n    return {\n        elementOf(componentType) {\n            const { name, extend } = ComponentDef.of(componentType);\n            let tagName;\n            const elementExtend = {\n                get type() {\n                    return extend && extend.type || bsWindow.HTMLElement;\n                },\n                get name() {\n                    return extend && extend.name;\n                },\n            };\n            return {\n                get name() {\n                    return name;\n                },\n                get tagName() {\n                    return tagName || (name && (tagName = html__naming.name(name, nsAlias)));\n                },\n                get extend() {\n                    return elementExtend;\n                },\n            };\n        },\n    };\n}\n\nconst ComponentConstructor__symbol = ( /*#__PURE__*/Symbol('newComponent'));\n/**\n * @internal\n */\nfunction newComponent(context) {\n    const componentType = context.componentType;\n    if (!componentType[ComponentConstructor__symbol]) {\n        componentType[ComponentConstructor__symbol] = newComponentConstructor(componentType);\n    }\n    return componentType[ComponentConstructor__symbol](context);\n}\nfunction newComponentConstructor(componentType) {\n    // Component context reference specific to component class.\n    const context__symbol = Symbol('ComponentContext');\n    let defaultContext;\n    componentType.prototype[ComponentContext__symbol] = function () {\n        return this[context__symbol] || (this[context__symbol] = defaultContext);\n    };\n    return function (context) {\n        const prevContext = defaultContext;\n        // Ensure the component context is available in component constructor.\n        defaultContext = context;\n        try {\n            const component = new this(context);\n            component[context__symbol] = context;\n            return component;\n        }\n        finally {\n            defaultContext = prevContext;\n        }\n    };\n}\n\n/**\n * @internal\n */\nclass ComponentStatus {\n    constructor(_ctx) {\n        this._ctx = _ctx;\n        this._val = trackValue(0 /* Building */);\n        this._canSettle = 0;\n    }\n    get supply() {\n        return this._val.supply;\n    }\n    read() {\n        return (this.read = valueProvider(this._val.read.do(mapAfter_(valueProvider(this._ctx)))))();\n    }\n    isReady() {\n        return !!this._val.it && !this._val.supply.isOff;\n    }\n    onceReady() {\n        return (this.onceReady = valueProvider(this.read().do(ComponentStatus$once(({ ready }) => ready))))();\n    }\n    whenReady() {\n        return (this.whenReady = valueProvider(this.onceReady().do(onceOn)))();\n    }\n    isSettled() {\n        return this._val.it >= 2 /* Settled */ && !this._val.supply.isOff;\n    }\n    onceSettled() {\n        return (this.onceSettled = valueProvider(this.read().do(ComponentStatus$once(({ settled }) => settled))))();\n    }\n    whenSettled() {\n        return (this.whenSettled = valueProvider(this.onceSettled().do(onceOn)))();\n    }\n    isConnected() {\n        return this._val.it >= 3 /* Connected */ && !this._val.supply.isOff;\n    }\n    onceConnected() {\n        return (this.onceConnected = valueProvider(this.read().do(\n        // Filtering is enough, as there is no status after \"connected\"\n        filterOn_(({ connected }) => connected))))();\n    }\n    whenConnected() {\n        return (this.whenConnected = valueProvider(this.onceConnected().do(onceOn)))();\n    }\n    ready() {\n        this._val.it = 1 /* Ready */;\n    }\n    settle() {\n        if (this._canSettle && this._val.it < 2 /* Settled */) {\n            // Prevent settling until exiting custom element constructor\n            this._val.it = 2 /* Settled */;\n        }\n    }\n    connect() {\n        this._val.it = 3 /* Connected */;\n    }\n    create() {\n        this._canSettle = 1; // Can settle now\n    }\n}\nfunction ComponentStatus$once(test) {\n    return input => onEventBy(receiver => {\n        let value = false;\n        input({\n            supply: receiver.supply,\n            receive(eventCtx, componentCtx) {\n                const newValue = test(componentCtx);\n                if (newValue && !value) {\n                    value = newValue;\n                    receiver.receive(eventCtx, componentCtx);\n                }\n            },\n        });\n    });\n}\n\n/**\n * @internal\n */\nclass ComponentContext$ extends ComponentContext {\n    constructor(_definitionContext, element) {\n        super();\n        this._definitionContext = _definitionContext;\n        this.element = element;\n        const registry = _definitionContext._newComponentRegistry();\n        registry.provide({ a: ComponentContext, is: this });\n        this.get = registry.newValues().get;\n        this._status = new ComponentStatus(this);\n        this.supply.whenOff(() => {\n            delete this.component[ComponentContext__symbol];\n            this._component = componentDestroyed;\n        });\n    }\n    get componentType() {\n        return this._definitionContext.componentType;\n    }\n    get component() {\n        return this._component();\n    }\n    get supply() {\n        return this._status.supply;\n    }\n    get ready() {\n        return this._status.isReady();\n    }\n    get onceReady() {\n        return this._status.onceReady();\n    }\n    get whenReady() {\n        return this._status.whenReady();\n    }\n    get settled() {\n        return this._status.isSettled();\n    }\n    get onceSettled() {\n        return this._status.onceSettled();\n    }\n    get whenSettled() {\n        return this._status.whenSettled();\n    }\n    get connected() {\n        return this._status.isConnected();\n    }\n    get onceConnected() {\n        return this._status.onceConnected();\n    }\n    get whenConnected() {\n        return this._status.whenConnected();\n    }\n    get readStatus() {\n        return this._status.read();\n    }\n    _component() {\n        throw new TypeError('Component is not constructed yet. Consider to use a `whenReady()` callback');\n    }\n    settle() {\n        this._status.settle();\n    }\n    _createComponent() {\n        const whenComponent = this._definitionContext._whenComponent;\n        let lastRev = 0;\n        whenComponent.readNotifier.do(onceOn)(notifier => lastRev = notifier(this, lastRev));\n        this.whenConnected(() => {\n            whenComponent.readNotifier({\n                supply: new Supply().needs(this),\n                receive: (_, notifier) => {\n                    lastRev = notifier(this, lastRev);\n                },\n            });\n        });\n        this._definitionContext._elementBuilder.components.send(this);\n        const component = newComponent(this);\n        this._component = valueProvider(component);\n        this._status.ready();\n        return this;\n    }\n    _connect() {\n        this._status.connect();\n    }\n    _created() {\n        this._status.create();\n    }\n}\n/**\n * @internal\n */\nclass ComponentContext$Mounted extends ComponentContext$ {\n    get mounted() {\n        return true;\n    }\n}\nfunction componentDestroyed() {\n    throw new TypeError('Component destroyed already');\n}\n\nclass ComponentContext$Custom extends ComponentContext$ {\n    get mounted() {\n        return false;\n    }\n}\n/**\n * @internal\n */\nfunction customElementType(defContext) {\n    const { elementDef } = defContext;\n    const renderKit = defContext.get(DocumentRenderKit);\n    class CustomElement$ extends elementDef.extend.type {\n        constructor() {\n            super();\n            const slot = ComponentSlot.of(this);\n            // Ignore immediate settlement, as is typically leads to DOM manipulations prohibited inside constructor.\n            let settle = noop;\n            slot.bindBy(({ bind }) => {\n                const context = new ComponentContext$Custom(defContext, this);\n                const supply = bind(context);\n                context._createComponent();\n                context._created();\n                context.supply.needs(supply).whenOff(() => {\n                    renderKit.contextOf(this).whenSettled(_ => settle());\n                });\n            });\n            renderKit.contextOf(this).whenSettled(_ => settle());\n            // Assume settlement happens after constructor completion.\n            settle = () => slot.rebind().settle();\n        }\n        connectedCallback() {\n            var _a;\n            (_a = super.connectedCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n            ComponentSlot.of(this).rebind()._connect();\n        }\n        disconnectedCallback() {\n            var _a;\n            ComponentSlot.of(this).context.supply.off();\n            (_a = super.disconnectedCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n    }\n    return CustomElement$;\n}\n\nclass WhenComponent {\n    constructor() {\n        const currentRev = trackValue(0);\n        const created = new EventEmitter();\n        this.onCreated = onEventBy(receiver => {\n            const receiverRev = currentRev.it + 1;\n            created.on({\n                supply: receiver.supply,\n                receive: (eventContext, componentContext, notifiedRev) => {\n                    if (notifiedRev < receiverRev) {\n                        // Notify only receivers added after the last notification\n                        receiver.receive({\n                            onRecurrent(recurrentReceiver) {\n                                eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                            },\n                        }, componentContext);\n                    }\n                },\n            });\n            ++currentRev.it;\n        });\n        this.readNotifier = currentRev.read.do(mapAfter_(rev => (context, notifiedRev) => {\n            created.send(context, notifiedRev);\n            return rev;\n        }));\n    }\n}\n\n/**\n * @internal\n */\nclass DefinitionContext$ extends DefinitionContext {\n    constructor(_bsContext, _elementBuilder, componentType) {\n        var _a, _b;\n        super();\n        this._bsContext = _bsContext;\n        this._elementBuilder = _elementBuilder;\n        this.componentType = componentType;\n        this._whenComponent = new WhenComponent();\n        this._ready = trackValue(false);\n        this._whenReady = this._ready.read.do(translateOn((send, ready) => ready && send()));\n        this._def = ComponentDef.of(componentType);\n        this.elementDef = _bsContext.get(ElementNaming).elementOf(componentType);\n        const definitionContextRegistry = new DefinitionContextRegistry(_bsContext.get(PerDefinitionRegistry).seeds());\n        definitionContextRegistry.provide({ a: DefinitionContext, is: this });\n        this.get = definitionContextRegistry.newValues().get;\n        const parentPerComponentRegistry = _bsContext.get(PerComponentRegistry).append(seedKey => this.get(seedKey));\n        this._perComponentRegistry = new ComponentContextRegistry(parentPerComponentRegistry.seeds());\n        this.whenReady = this._whenReady.do(mapOn_(valueProvider(this)), onceOn);\n        const definitionSetup = {\n            get componentType() {\n                return componentType;\n            },\n            whenReady: this.whenReady,\n            whenComponent: this.whenComponent,\n            perDefinition: spec => definitionContextRegistry.provide(spec),\n            perComponent: spec => this._perComponentRegistry.provide(spec),\n        };\n        (_b = (_a = this._def).setup) === null || _b === void 0 ? void 0 : _b.call(_a, definitionSetup);\n        postDefSetup(componentType).setup(definitionSetup);\n    }\n    get elementType() {\n        return this._elementType();\n    }\n    get whenComponent() {\n        return this._whenComponent.onCreated;\n    }\n    mountTo(element) {\n        const context = new ComponentContext$Mounted(this, element);\n        ComponentSlot.of(element).bind(context);\n        context._createComponent();\n        const drekContext = context.get(DocumentRenderKit).contextOf(element);\n        drekContext.whenSettled(_ => context.settle()).needs(context);\n        drekContext.whenConnected(_ => context._connect()).needs(context);\n        context._created();\n        return context;\n    }\n    perComponent(spec) {\n        return this._perComponentRegistry.provide(spec);\n    }\n    _newComponentRegistry() {\n        return new ComponentContextRegistry(this._perComponentRegistry.seeds());\n    }\n    _elementType() {\n        throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n    }\n    _define() {\n        var _a, _b;\n        (_b = (_a = this._def).define) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n        this._elementBuilder.definitions.send(this);\n        this._elementType = valueProvider(customElementType(this));\n        this.componentType[DefinitionContext__symbol] = this;\n        this._ready.it = true;\n    }\n}\n\n/**\n * @internal\n */\nconst ElementBuilder = ( /*#__PURE__*/new SingleContextKey('element-builder', {\n    byDefault: bootstrapDefault(newElementBuilder),\n}));\nfunction newElementBuilder(bsContext) {\n    return {\n        definitions: new EventEmitter(),\n        components: new EventEmitter(),\n        buildElement(componentType) {\n            const definitionContext = new DefinitionContext$(bsContext, this, componentType);\n            definitionContext._define();\n            return definitionContext;\n        },\n    };\n}\n\n/**\n * @internal\n */\nclass ComponentRegistry {\n    constructor(_setup) {\n        this._setup = _setup;\n        this._components = undefined;\n    }\n    define(componentType) {\n        if (this._components) {\n            this._components.push(componentType);\n        }\n        else {\n            this._components = [componentType];\n            this._defineAll(this._components);\n        }\n    }\n    _defineAll(components) {\n        const workbench = this._setup.get(BootstrapWorkbench);\n        const whenDefined = workbench.work(componentDefStage).run(() => {\n            const customElements = this._setup.get(CustomElements);\n            const elementBuilder = this._setup.get(ElementBuilder);\n            components.forEach(componentType => {\n                const defContext = elementBuilder.buildElement(componentType);\n                customElements.define(componentType, defContext.elementType);\n            });\n            this._components = undefined;\n        });\n        this._setup.initBy(valueProvider(whenDefined));\n    }\n}\n\n/**\n * @internal\n */\nclass FeatureContext$ extends FeatureContext {\n    constructor(feature, _setup) {\n        super();\n        this.feature = feature;\n        this._setup = _setup;\n        this._bsContext = _setup.get(BootstrapContext);\n        const handle = _setup.get(_setup.module);\n        const registry = new ContextRegistry(this._bsContext);\n        registry.provide({ a: FeatureContext, is: this });\n        this.get = registry.newValues().get;\n        this.whenReady = handle.read.do(valueOn_(({ ready }) => ready && this), onceOn);\n        this._componentRegistry = new ComponentRegistry(this._setup);\n    }\n    get supply() {\n        return this._setup.supply;\n    }\n    get onDefinition() {\n        return this._onDefinition\n            || (this._onDefinition = this._setup.get(ElementBuilder).definitions.on.do(supplyOn(this)));\n    }\n    get onComponent() {\n        return this._onComponent\n            || (this._onComponent = this._setup.get(ElementBuilder).components.on.do(supplyOn(this)));\n    }\n    provide(spec) {\n        return this._bsContext.get(BootstrapContextRegistry).provide(spec).needs(this);\n    }\n    perDefinition(spec) {\n        return this._bsContext.get(PerDefinitionRegistry).provide(spec).needs(this);\n    }\n    perComponent(spec) {\n        return this._bsContext.get(PerComponentRegistry).provide(spec).needs(this);\n    }\n    setupDefinition(componentType) {\n        return onPostDefSetup(componentType, this.supply);\n    }\n    define(componentType) {\n        this._componentRegistry.define(componentType);\n    }\n}\n\nconst FeatureModule__symbol = ( /*#__PURE__*/Symbol('FeatureModule'));\n/**\n * @internal\n */\nclass FeatureModule extends ContextModule {\n    constructor(feature) {\n        super(feature.name, FeatureModule$options(feature));\n        this.feature = feature;\n    }\n    static of(feature) {\n        if (hasOwnProperty(feature, FeatureModule__symbol)) {\n            return feature[FeatureModule__symbol];\n        }\n        return feature[FeatureModule__symbol] = new FeatureModule(feature);\n    }\n    async setup(setup) {\n        const workbench = setup.get(BootstrapWorkbench);\n        await workbench.work(featureSetupStage).run(() => super.setup(setup));\n    }\n}\nfunction FeatureModule$options(feature) {\n    const def = featureDef(feature);\n    const has = [];\n    const needs = [];\n    for (const replaced of setOfElements(def.has)) {\n        has.push(FeatureModule.of(replaced));\n    }\n    for (const required of setOfElements(def.needs)) {\n        needs.push(FeatureModule.of(required));\n    }\n    return {\n        needs,\n        has,\n        async setup(setup) {\n            var _a;\n            const workbench = setup.get(BootstrapWorkbench);\n            const featureContext = new FeatureContext$(feature, setup);\n            if (def.init) {\n                const whenInit = workbench.work(featureInitStage).run(async () => {\n                    await def.init(featureContext);\n                });\n                setup.initBy(valueProvider(whenInit));\n            }\n            await ((_a = def.setup) === null || _a === void 0 ? void 0 : _a.call(def, featureContext));\n        },\n    };\n}\nfunction featureDef(featureType) {\n    let def = FeatureDef.of(featureType);\n    if (ComponentDef__symbol in featureType) {\n        def = FeatureDef.merge(def, {\n            init(context) {\n                context.define(featureType);\n            },\n        });\n        const { feature } = ComponentDef.of(featureType);\n        if (feature) {\n            def = FeatureDef.merge(def, feature);\n        }\n    }\n    return def;\n}\n\n/**\n * @internal\n */\nconst WhenDefined__symbol = ( /*#__PURE__*/Symbol('WhenDefined'));\n/**\n * @internal\n */\nfunction whenDefined(bsContext, componentType) {\n    if (hasOwnProperty(componentType, WhenDefined__symbol)) {\n        return componentType[WhenDefined__symbol];\n    }\n    const result = onPromise(Promise.resolve(bsContext.whenReady)\n        .then(() => bsContext.get(CustomElements).whenDefined(componentType))\n        .then(() => definitionContextOf(componentType)));\n    return componentType[WhenDefined__symbol] = result;\n}\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features - Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nfunction bootstrapComponents(...features) {\n    const bootstrapContextRegistry = BootstrapContextRegistry.create();\n    const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n    const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n    bootstrapContext.load(feature)\n        .read\n        .do(valueOn_(({ ready }) => ready), onceOn)\n        .then(complete)\n        .catch(console.error);\n    return bootstrapContext;\n}\n/**\n * @internal\n */\nfunction bootstrapFeature(needs) {\n    return FeatureDef.define(class BootstrapFeature {\n    }, { needs });\n}\n/**\n * @internal\n */\nfunction initBootstrap(bootstrapContextRegistry) {\n    const stage = trackValue(0 /* Init */);\n    const values = bootstrapContextRegistry.values;\n    class BootstrapContext$ extends BootstrapContext {\n        constructor() {\n            super();\n            this.get = values.get;\n            this.whenReady = stage.read.do(valueOn(bsStage => !!bsStage && this), onceOn);\n            bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n            bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n        }\n        whenDefined(componentType) {\n            return whenDefined(this, componentType);\n        }\n        load(feature, user) {\n            const module = FeatureModule.of(feature);\n            const supply = bootstrapContextRegistry.provide(module);\n            if (user) {\n                supply.needs(user);\n            }\n            else {\n                user = supply;\n            }\n            const use = this.get(module).use(user);\n            const read = FeatureRef$read(feature, use);\n            return {\n                read,\n                whenReady: read.do(valueOn_(status => status.ready && status), onceOn),\n                [AfterEvent__symbol]: valueProvider(read),\n                supply,\n            };\n        }\n    }\n    const bootstrapContext = new BootstrapContext$();\n    return {\n        bootstrapContext,\n        complete() {\n            stage.it = 1 /* Ready */;\n        },\n    };\n}\nfunction FeatureRef$read(feature, use) {\n    const status = trackValue({ feature, ready: false });\n    use.read(({ module, ready }) => {\n        const feature = module.feature;\n        const lastStatus = status.it;\n        if (!lastStatus || lastStatus.feature !== feature || lastStatus.ready !== ready) {\n            status.it = {\n                feature,\n                ready,\n            };\n        }\n    }).needs(use);\n    status.supply.needs(use);\n    return status.read;\n}\n\n/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nconst AttributePath__root = ( /*#__PURE__*/Symbol('attribute'));\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name - Target attribute name.\n *\n * @return Attribute state path.\n */\nfunction attributePathTo(name) {\n    return [AttributePath__root, name];\n}\n\n/**\n * @internal\n */\nfunction attributeStateUpdate(name, updateState = true) {\n    if (updateState === false) {\n        return noop;\n    }\n    if (updateState === true || typeof updateState === 'function') {\n        const path = attributePathTo(name);\n        const update = updateState === true ? updateAttributeState : updateState;\n        return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n    }\n    return (component, newValue, oldValue) => updateAttributeState(component, updateState, newValue, oldValue);\n}\nfunction updateAttributeState(component, path, newValue, oldValue) {\n    ComponentContext.of(component).updateState(path, newValue, oldValue);\n}\n\n/**\n * @internal\n */\nfunction parseAttributeDescriptor(target, propertyKey, def) {\n    let name;\n    let change;\n    if (typeof def === 'string') {\n        name = hyphenateDecapName(def);\n        change = attributeStateUpdate(name);\n    }\n    else {\n        if (def && def.name) {\n            name = hyphenateDecapName(def.name);\n        }\n        else if (typeof propertyKey !== 'string') {\n            throw new TypeError('Attribute name is required as property key is not a string: '\n                + `${target.constructor.name}.prototype.${String(propertyKey)}`);\n        }\n        else {\n            name = hyphenateDecapName(propertyKey);\n        }\n        change = attributeStateUpdate(name, def && def.updateState);\n    }\n    return { name, change };\n}\n\n/**\n * A key of component definition context value containing {@link AttributeRegistry attribute registry}.\n *\n * @category Feature\n */\nconst AttributeRegistry = (\n/*#__PURE__*/ new SingleContextKey('attribute-registry', {\n    byDefault(context) {\n        return new AttributeRegistry$(context.get(DefinitionContext));\n    },\n}));\n/**\n * @internal\n */\nclass AttributeRegistry$ {\n    constructor(_context) {\n        this._context = _context;\n        this.attrs = new Map();\n        _context.whenReady(({ elementType }) => this.define(elementType));\n        _context.whenComponent(context => {\n            if (context.mounted) {\n                // Mount element attributes\n                this.mount(context);\n            }\n        });\n    }\n    declareAttribute({ name, change }) {\n        this.attrs.set(name, mergeFunctions(this.attrs.get(name), change));\n    }\n    define(elementType) {\n        const { attrs } = this;\n        if (!attrs.size) {\n            return; // No attributes defined\n        }\n        Reflect.defineProperty(elementType, 'observedAttributes', {\n            configurable: true,\n            enumerable: true,\n            value: observedAttributes(elementType, [...attrs.keys()]),\n        });\n        Reflect.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n            configurable: true,\n            enumerable: true,\n            value: attributeChangedCallback(elementType, attrs),\n        });\n    }\n    mount(context) {\n        const { element } = context;\n        const { attrs } = this;\n        const attributeFilter = [...attrs.keys()];\n        if (!attributeFilter.length) {\n            return; // No attributes defined\n        }\n        const MutationObserver = this._context.get(BootstrapWindow).MutationObserver;\n        const observer = new MutationObserver(records => records.forEach(record => {\n            const attributeName = record.attributeName;\n            return attrs.get(attributeName)(context.component, element.getAttribute(attributeName), record.oldValue);\n        }));\n        observer.observe(element, {\n            attributes: true,\n            attributeFilter,\n            attributeOldValue: true,\n        });\n    }\n}\n/**\n * @internal\n */\nfunction observedAttributes(elementType, attrs) {\n    const alreadyObserved = elementType.observedAttributes;\n    if (Array.isArray(alreadyObserved)) {\n        const newAttrs = new Set(alreadyObserved);\n        attrs.forEach(attr => newAttrs.add(attr));\n        attrs = [...newAttrs];\n    }\n    return attrs;\n}\n/**\n * @internal\n */\nfunction attributeChangedCallback(elementType, attrs) {\n    const prevCallback = elementType.prototype.attributeChangedCallback;\n    if (!prevCallback) {\n        return function (name, oldValue, newValue) {\n            ComponentSlot.of(this).whenReady(({ component }) => {\n                attrs.get(name)(component, newValue, oldValue);\n            });\n        };\n    }\n    return function (name, oldValue, newValue) {\n        const attrChanged = attrs.get(name);\n        if (attrChanged) {\n            ComponentSlot.of(this).whenReady(({ component }) => attrChanged(component, newValue, oldValue));\n        }\n        else {\n            prevCallback.call(this, name, oldValue, newValue);\n        }\n    };\n}\n\n/**\n * Creates an amendment (and decorator) of component property that accesses custom element's attribute.\n *\n * The amended property accesses corresponding attribute on read, and updates it on setting. `null` value corresponds\n * to absent attribute. Setting to `null` or `undefined` removes corresponding attribute.\n *\n * @category Feature\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Attribute definition or just an attribute name (either _camelCase_ or _dash-style_).\n *\n * @return New component property amendment.\n */\nfunction Attribute(def) {\n    return ComponentMember(({ amendedClass, key, set: setValue, amend, }) => {\n        const { name, change } = parseAttributeDescriptor(amendedClass.prototype, key, def);\n        amend({\n            componentDef: {\n                define(defContext) {\n                    defContext.get(AttributeRegistry).declareAttribute({\n                        name,\n                        change(component, newValue, oldValue) {\n                            setValue(component, newValue);\n                            change(component, newValue, oldValue);\n                        },\n                    });\n                },\n            },\n            get(component) {\n                return ComponentContext.of(component).element.getAttribute(name);\n            },\n            set(component, newValue) {\n                const { element } = ComponentContext.of(component);\n                if (newValue != null) {\n                    element.setAttribute(name, newValue);\n                }\n                else {\n                    element.removeAttribute(name);\n                }\n                setValue(component, newValue);\n            },\n        });\n    });\n}\n\n/**\n * Creates a component method amendment (and decorator) for custom element attribute {@link AttributeDef.ChangeMethod\n * change callback}.\n *\n * Example:\n * ```TypeScript\n * @Component('my-component')\n * class MyComponent {\n *\n *   @AttributeChanged('my-attribute')\n *   myAttributeChanged(newValue: string, oldValue: string | null) {\n *     console.log(`my-attribute value changed from ${oldValue} to ${newValue}`);\n *   }\n *\n * }\n * ```\n *\n * @category Feature\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Attribute definition or just an attribute name.\n *\n * @return New component method amendment.\n */\nfunction AttributeChanged(def) {\n    return ComponentMember(({ amendedClass, get, key, amend }) => {\n        const { name, change } = parseAttributeDescriptor(amendedClass.prototype, key, def);\n        amend({\n            componentDef: {\n                define(defContext) {\n                    defContext.get(AttributeRegistry).declareAttribute({\n                        name,\n                        change(component, newValue, oldValue) {\n                            const callback = get(component);\n                            callback.call(component, newValue, oldValue);\n                            change(component, newValue, oldValue);\n                        },\n                    });\n                },\n            },\n        });\n    });\n}\n\n/**\n * Creates a component amendment (and decorator) that declares supported attributes of component's element.\n *\n * @category Feature\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component entity type.\n * @param items - Attributes definition options.\n *\n * @returns New component amendment and decorator.\n */\nfunction Attributes(...items) {\n    return Component({\n        define(defContext) {\n            const registry = defContext.get(AttributeRegistry);\n            for (const item of items) {\n                if (typeof item === 'string') {\n                    const name = hyphenateDecapName(item);\n                    registry.declareAttribute({\n                        name,\n                        change: attributeStateUpdate(name),\n                    });\n                }\n                else {\n                    for (const [key, updateState] of Object.entries(item)) {\n                        const name = hyphenateDecapName(key);\n                        registry.declareAttribute({\n                            name,\n                            change: attributeStateUpdate(name, updateState),\n                        });\n                    }\n                }\n            }\n        },\n    });\n}\n\nclass ComponentStateKey extends SimpleContextKey {\n    constructor() {\n        super('component-state');\n    }\n    grow(slot) {\n        const provided = slot.seed();\n        let state;\n        if (provided != null) {\n            state = provided;\n            slot.insert(state);\n        }\n        else if (slot.hasFallback) {\n            return;\n        }\n        else {\n            state = new ComponentState();\n            slot.context.get(ComponentContext).supply.whenOff(reason => state.done(reason));\n            slot.insert(state);\n        }\n        slot.setup(({ registry }) => {\n            registry.provide({ a: StateUpdater, is: state.update });\n        });\n    }\n}\n/**\n * @internal\n */\nconst ComponentState__key = ( /*#__PURE__*/new ComponentStateKey());\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nclass ComponentState extends StateTracker {\n    static get [ContextKey__symbol]() {\n        return ComponentState__key;\n    }\n}\n\n/**\n * A path to sub-state containing component state properties.\n *\n * Thus a property state path is always something like `[StatePropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nconst StatePropertyPath__root = ( /*#__PURE__*/Symbol('StateProperty'));\n/**\n * Constructs a named component property state path.\n *\n * @category Feature\n * @typeParam TKey - Target property key type.\n * @param key - Target property key.\n *\n * @return DOM property state path.\n */\nfunction statePropertyPathTo(key) {\n    return [StatePropertyPath__root, key];\n}\n\n/**\n * @internal\n */\nfunction statePropertyUpdate(propertyKey, updateState = true) {\n    if (updateState === true || typeof updateState === 'function') {\n        const path = statePropertyPathTo(propertyKey);\n        const update = updateState === true ? updateStatePropertyState : updateState;\n        return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n    }\n    return (component, newValue, oldValue) => {\n        if (newValue !== oldValue) {\n            ComponentContext.of(component).updateState(updateState, newValue, oldValue);\n        }\n    };\n}\nfunction updateStatePropertyState(component, path, newValue, oldValue) {\n    if (newValue !== oldValue) {\n        ComponentContext.of(component).updateState(path, newValue, oldValue);\n    }\n}\n\n/**\n * Creates an amendment (and decorator) of component member representing a property of component state.\n *\n * Once such property updated, the component state is {@link ComponentContext.updateState also updated}.\n *\n * @category Feature\n * @typeParam TValue - Amended member value type\n * @typeParam TClass - Amended component class type.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Custom element property definition.\n *\n * @returns New component member decorator.\n */\nfunction StateProperty({ updateState } = {}) {\n    return ComponentMember(({ key, get, set, amend }) => {\n        if (updateState !== false) {\n            const update = statePropertyUpdate(key, updateState);\n            amend({\n                get,\n                set(component, newValue) {\n                    const oldValue = get(component);\n                    set(component, newValue);\n                    update(component, newValue, oldValue);\n                },\n            });\n        }\n    });\n}\n\nclass StatePropertyTracker extends ValueTracker {\n    constructor(_context, key, path) {\n        super();\n        this._context = _context;\n        this.supply = new Supply();\n        this._key = key;\n        this.on = _context.get(ComponentState).track(path).onUpdate.do(translateOn((send, _path, newValue, oldValue) => send(newValue, oldValue)), supplyOn(this));\n    }\n    get it() {\n        return this._context.component[this._key];\n    }\n    set it(value) {\n        if (!this.supply.isOff) {\n            this._context.component[this._key] = value;\n        }\n    }\n}\n/**\n * Creates a tracker of component state value.\n *\n * @category Feature\n * @typeParam T - A type of state property value.\n * @param context - Target component context.\n * @param key - Property key.\n * @param path - Property state path.\n *\n * @returns New state property value tracker.\n */\nfunction trackStateProperty(context, key, path = statePropertyPathTo(key)) {\n    return new StatePropertyTracker(context, key, path);\n}\n\nclass AttributeTracker extends ValueTracker {\n    constructor(_context, _name, path) {\n        super();\n        this._context = _context;\n        this._name = _name;\n        this.supply = new Supply();\n        this.on = this._context.get(ComponentState).track(path).onUpdate.do(translateOn((send, _path, newValue, oldValue) => send(newValue, oldValue)), supplyOn(this));\n    }\n    get it() {\n        return this._context.element.getAttribute(this._name);\n    }\n    set it(value) {\n        if (!this.supply.isOff) {\n            if (value == null) {\n                this._context.element.removeAttribute(this._name);\n            }\n            else {\n                this._context.element.setAttribute(this._name, value);\n            }\n        }\n    }\n}\n/**\n * Creates a tracker of custom element's attribute value.\n *\n * Requires attribute to be defined. E.g. with {@link Attribute @Attribute}, {@link AttributeChanged @AttributeChanged},\n * or {@link Attributes @Attributes} decorator.\n *\n * @category Feature\n * @param context - Target component context.\n * @param name - Attribute name.\n * @param path - Custom attribute state path.\n *\n * @returns New attribute value tracker.\n */\nfunction trackAttribute(context, name, path = attributePathTo(name)) {\n    return new AttributeTracker(context, name, path);\n}\n\n/**\n * @internal\n */\nfunction domPropertyDescriptor(amended, { propertyKey: key = amended.key, configurable = amended.configurable, enumerable = amended.enumerable, writable = amended.writable, }) {\n    const componentMemberKey = amended.key;\n    const descriptor = {\n        configurable,\n        enumerable,\n        get: function () {\n            var _a;\n            return (_a = ComponentSlot.of(this).rebind()) === null || _a === void 0 ? void 0 : _a.component[componentMemberKey];\n        },\n        set: writable\n            ? function (value) {\n                ComponentSlot.of(this).whenReady(({ component, }) => component[componentMemberKey] = value);\n            }\n            : undefined,\n    };\n    return { key, descriptor };\n}\n\n/**\n * A key of component definition context value containing {@link DomPropertyRegistry DOM property registry}.\n *\n * @category Feature\n */\nconst DomPropertyRegistry = (\n/*#__PURE__*/ new SingleContextKey('dom-property-registry', {\n    byDefault(context) {\n        return new DomPropertyRegistry$(context.get(DefinitionContext));\n    },\n}));\n/**\n * @internal\n */\nclass DomPropertyRegistry$ {\n    constructor(defContext) {\n        this.props = new Map();\n        defContext.whenReady(({ elementType }) => this.define(elementType));\n        defContext.whenComponent(context => {\n            if (context.mounted) {\n                // Mount element properties\n                this.mount(context);\n            }\n        });\n    }\n    declareDomProperty({ key, descriptor }) {\n        this.props.set(key, descriptor);\n    }\n    define(elementType) {\n        const prototype = elementType.prototype;\n        this.props.forEach((desc, key) => {\n            Reflect.defineProperty(prototype, key, desc);\n        });\n    }\n    mount({ element }) {\n        this.props.forEach((desc, key) => {\n            Reflect.defineProperty(element, key, desc);\n        });\n    }\n}\n\n/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nconst DomPropertyPath__root = ( /*#__PURE__*/Symbol('DomProperty'));\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @typeParam TKey - Property key type.\n * @param key - Target property key.\n *\n * @return DOM property state path.\n */\nfunction domPropertyPathTo(key) {\n    return [DomPropertyPath__root, key];\n}\n\n/**\n * @internal\n */\nfunction domPropertyUpdate(propertyKey, updateState = true) {\n    if (updateState === true || typeof updateState === 'function') {\n        const path = domPropertyPathTo(propertyKey);\n        const update = updateState === true ? updateDomPropertyState : updateState;\n        return (component, newValue, oldValue) => update(component, path, newValue, oldValue);\n    }\n    return (component, newValue, oldValue) => {\n        if (newValue !== oldValue) {\n            ComponentContext.of(component).updateState(updateState, newValue, oldValue);\n        }\n    };\n}\nfunction updateDomPropertyState(component, path, newValue, oldValue) {\n    if (newValue !== oldValue) {\n        ComponentContext.of(component).updateState(path, newValue, oldValue);\n    }\n}\n\n/**\n * Creates component member amendment (and decorator) that declares a property to add to component's element.\n *\n * The value of declared element's property will be read from and written to decorated member.\n *\n * By default does not update component state if property value didn't change.\n *\n * @category Feature\n * @typeParam TValue - Amended member value type\n * @typeParam TClass - Amended component class type.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Custom element property definition.\n *\n * @returns New component member decorator.\n */\nfunction DomProperty(def = {}) {\n    return ComponentMember((target) => {\n        const { key, get, amend } = target;\n        let { set } = target;\n        const domDescriptor = domPropertyDescriptor(target, def);\n        if (def.updateState !== false) {\n            const updateState = domPropertyUpdate(key, def.updateState);\n            const setValue = set;\n            set = (component, newValue) => {\n                const oldValue = get(component);\n                setValue(component, newValue);\n                updateState(component, newValue, oldValue);\n            };\n        }\n        amend({\n            componentDef: {\n                define(defContext) {\n                    defContext.get(DomPropertyRegistry).declareDomProperty(domDescriptor);\n                },\n            },\n            get,\n            set,\n        });\n    });\n}\n\n/**\n * @internal\n */\nclass DomPropertyTracker extends ValueTracker {\n    constructor(_context, key, _path) {\n        super();\n        this._context = _context;\n        this._path = _path;\n        this.supply = new Supply();\n        this._key = key;\n        this.on = this._context.get(ComponentState).track(this._path).onUpdate.do(translateOn((send, _path, newValue, oldValue) => send(newValue, oldValue)), supplyOn(this));\n    }\n    get it() {\n        return this._context.element[this._key];\n    }\n    set it(value) {\n        if (!this.supply.isOff) {\n            this._context.element[this._key] = value;\n        }\n    }\n}\n/**\n * Creates a tracker of custom element's DOM property value.\n *\n * Requires property to be defined. E.g. with {@link DomProperty @DomProperty} decorator.\n *\n * @category Feature\n * @typeParam T - A type of DOM property value.\n * @param context - Target component context.\n * @param key - Property key.\n * @param path - Custom property state path.\n *\n * @returns New DOM property value tracker.\n */\nfunction trackDomProperty(context, key, path = domPropertyPathTo(key)) {\n    return new DomPropertyTracker(context, key, path);\n}\n\n/**\n * A root path to sub-states updates to which will be ignored by default.\n *\n * This can be used to create sub-states that won't trigger rendering occasionally, but only when requested explicitly.\n *\n * @category Feature\n */\nconst RenderPath__root = ( /*#__PURE__*/Symbol('render'));\n/**\n * @category Feature\n */\nconst RenderDef = {\n    /**\n     * Builds a trigger issuing rendering updates.\n     *\n     * @param context - Rendered component context.\n     * @param spec - Rendering specifier.\n     *\n     * @returns `OnEvent` sender that sends an event each time the rendering required.\n     */\n    trigger(context, spec = {}) {\n        const { on = [] } = spec;\n        if ((typeof on === 'object' || typeof on === 'function') && isEventSender(on)) {\n            return onSupplied(on).do(supplyOn(context));\n        }\n        const trigger = context\n            .get(ComponentState)\n            .track(on)\n            .onUpdate.do(supplyOn(context));\n        if (Array.isArray(on) && !on.length) {\n            return trigger.do(translateOn_((send, path) => path[0] !== RenderPath__root && send()));\n        }\n        return trigger;\n    },\n};\n\n/**\n * @internal\n */\nclass ComponentRenderCtl$ {\n    constructor(_context) {\n        this._context = _context;\n        const { element } = _context;\n        this._scheduler = _context.get(DocumentRenderKit).contextOf(element).scheduler;\n    }\n    renderBy(renderer, def) {\n        return new ComponentRenderer$State(this, renderer, def).render();\n    }\n    preRenderBy(preRenderer, def) {\n        return new ComponentPreRenderer$State(this, preRenderer, def).render();\n    }\n}\nclass ComponentRenderer$BaseState {\n    constructor(_ctl, _renderer, def = {}) {\n        this._ctl = _ctl;\n        this._renderer = _renderer;\n        this._status = 1 /* Pending */;\n        this._spec = valueByRecipe(def, _ctl._context);\n    }\n    render() {\n        const context = this._ctl._context;\n        const trigger = RenderDef.trigger(context, this._spec);\n        let schedule = shot => {\n            schedule = this._createSchedule();\n            schedule(shot);\n        };\n        const whenConnected = this._spec.when === 'connected';\n        const startRendering = () => this._status /* there is an update to render */\n            && this._scheduleRenderer(schedule);\n        const onUpdate = whenConnected\n            ? () => context.connected && this._scheduleRenderer(schedule)\n            : () => context.settled && this._scheduleRenderer(schedule);\n        this._supply = trigger(onUpdate)\n            .needs(context)\n            .whenOff(() => this._cancel(schedule));\n        (whenConnected ? context.whenConnected : context.whenSettled)(startRendering);\n        return this._supply;\n    }\n    _scheduleRenderer(schedule) {\n        this._status = 2 /* Scheduled */;\n        schedule(execution => this._render(execution));\n    }\n    _createSchedule() {\n        return this._scheduleBy(this._ctl._scheduler);\n    }\n    _scheduleBy(scheduler) {\n        const node = this._ctl._context.element;\n        const schedule = scheduler({ ...this._spec, node });\n        return shot => schedule(execution => drekBuild(() => shot(execution)));\n    }\n    _render(execution) {\n        const rendererExecution = this._createExecution(execution);\n        this._status = 0 /* Complete */;\n        do {\n            const currentRenderer = this._renderer;\n            currentRenderer(rendererExecution);\n            if (this._renderer === currentRenderer) {\n                this._over();\n                break; // The renderer is not updated. Current renderer execution is over.\n            }\n        } while (this._status >= 0); // The rendering could be cancelled by the renderer itself.\n    }\n    _over() {\n        // Renderer execution is over.\n    }\n    _cancel(schedule) {\n        if (this._status === 2 /* Scheduled */) { // Scheduled, but not rendered yet.\n            schedule(noop);\n        }\n        this._status = -1 /* Cancelled */;\n    }\n}\nclass ComponentRenderer$State extends ComponentRenderer$BaseState {\n    _createExecution(execution) {\n        const rendererExecution = {\n            ...execution,\n            postpone(postponed) {\n                execution.postpone(() => postponed(rendererExecution));\n            },\n            supply: this._supply,\n            renderBy: (renderer) => {\n                this._renderer = renderer;\n            },\n        };\n        return rendererExecution;\n    }\n}\nconst ComponentPreRenderer$done = {};\nclass ComponentPreRenderer$State extends ComponentRenderer$BaseState {\n    constructor() {\n        super(...arguments);\n        this._nextRenderer = null;\n    }\n    render() {\n        this._preSupply = new Supply();\n        super.render().needs(this._preSupply).whenOff(reason => {\n            if (reason === ComponentPreRenderer$done) {\n                // Pre-rendering is over.\n                // Delegate to component renderer.\n                this._preSupply.as(this._ctl.renderBy(this._nextRenderer));\n            }\n            else {\n                // Pre-rendering aborted.\n                this._preSupply.off(reason);\n            }\n        });\n        return this._preSupply;\n    }\n    _createSchedule() {\n        const preScheduler = this._ctl._context.get(DefaultPreRenderScheduler);\n        return this._scheduleBy(preScheduler);\n    }\n    _over() {\n        if (this._nextRenderer) {\n            // Signal the pre-rendering is over.\n            this._supply.off(ComponentPreRenderer$done);\n        }\n    }\n    _createExecution(execution) {\n        const preRendererExecution = {\n            ...execution,\n            postpone: postponed => {\n                execution.postpone(() => {\n                    postponed(preRendererExecution);\n                    this._over();\n                });\n            },\n            supply: this._preSupply,\n            renderBy: (renderer) => {\n                this._renderer = renderer;\n                this._nextRenderer = renderer;\n            },\n            preRenderBy: (preRenderer) => {\n                this._renderer = preRenderer;\n            },\n        };\n        return preRendererExecution;\n    }\n}\n\n/**\n * A key of component context value containing {@link ComponentRenderCtl component render control}.\n *\n * @category Feature\n */\nconst ComponentRenderCtl = (\n/*#__PURE__*/ new SingleContextKey('component-render-ctl', {\n    byDefault(values) {\n        const context = values.get(ComponentContext);\n        return new ComponentRenderCtl$(context);\n    },\n}));\n\n/**\n * @internal\n */\nfunction ComponentRenderScheduler$create(context) {\n    const renderCtl = context.get(ComponentRenderCtl);\n    return (opts = {}) => {\n        const recentShot = trackValue(noop);\n        const renderer = execution => {\n            recentShot.it(execution);\n        };\n        renderCtl.renderBy(renderer, { ...opts, on: recentShot.on });\n        return (shot) => {\n            recentShot.it = execution => shot(execution); // Ensure render shot always updated\n        };\n    };\n}\n/**\n * A key of component context value containing {@link ComponentRenderScheduler component render scheduler}.\n *\n * @category Feature\n */\nconst ComponentRenderScheduler = (\n/*#__PURE__*/ new SingleContextKey('component-render-scheduler', {\n    byDefault: ComponentRenderScheduler$create,\n}));\n\n/**\n * Creates a {@link ComponentPreRenderer component pre-renderer} method amendment (and decorator).\n *\n * Enables pre-rendering with {@link ComponentRenderCtl.preRenderBy component render control}.\n *\n * The decorated method accepts a {@link ComponentPreRendererExecution component rendering context} as its only\n * parameter.\n *\n * @category Feature\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Non-mandatory render definition.\n *\n * @returns New component method amendment.\n */\nfunction PreRender(def) {\n    return ComponentMember(({ get, amend }) => amend({\n        componentDef: {\n            define(defContext) {\n                defContext.whenComponent(context => {\n                    context.whenReady(() => {\n                        const { component } = context;\n                        const preRenderer = get(component).bind(component);\n                        context.get(ComponentRenderCtl).preRenderBy(preRenderer, def);\n                    });\n                });\n            },\n        },\n    }));\n}\n\n/**\n * Creates a {@link ComponentRenderer component renderer} method amendment (and decorator).\n *\n * Enables rendering with {@link ComponentRenderCtl.renderBy component render control}.\n *\n * The decorated method accepts a {@link ComponentRendererExecution component rendering context} as its only parameter.\n *\n * @category Feature\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Non-mandatory render definition.\n *\n * @returns New component method amendment.\n */\nfunction Render(def) {\n    return ComponentMember(({ get, amend }) => amend({\n        componentDef: {\n            define(defContext) {\n                defContext.whenComponent(context => {\n                    context.whenReady(() => {\n                        const { component } = context;\n                        const renderer = get(component).bind(component);\n                        context.get(ComponentRenderCtl).renderBy(renderer, def);\n                    });\n                });\n            },\n        },\n    }));\n}\n\n/**\n * A key of component context value containing a shadow content root instance.\n *\n * This is only available when the component is decorated with {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Feature\n */\nconst ShadowContentRoot = (\n/*#__PURE__*/ new SingleContextKey('shadow-content-root'));\n\n/**\n * A key of component context value containing a shadow root builder instance.\n *\n * @category Feature\n */\nconst ShadowRootBuilder = (\n/*#__PURE__*/ new FnContextKey('shadow-root-builder', {\n    byDefault() {\n        return attachShadow;\n    },\n}));\nfunction attachShadow(context, init) {\n    return shadowRootOf(context.element, init);\n}\nfunction shadowRootOf(element, init) {\n    const existing = element.shadowRoot;\n    if (existing) {\n        // Shadow root already attached. Using it.\n        return existing;\n    }\n    if ('attachShadow' in element) {\n        return element.attachShadow(init);\n    }\n    return; // Unable to attach shadow root.\n}\n\n/**\n * @internal\n */\nconst defaultShadowContentDef = { mode: 'open' };\n/**\n * Creates a component amendment (and decorator) that attaches shadow root to decorated component instance.\n *\n * @category Feature\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component entity type.\n * @param def - Shadow content root definition. Uses `mode: 'open'` by default.\n *\n * @returns New component amendment and decorator.\n */\nfunction AttachShadow(def = defaultShadowContentDef) {\n    return Component({\n        setup(setup) {\n            setup.perComponent({\n                a: ShadowContentRoot,\n                by(ctx) {\n                    return ctx.get(ShadowRootBuilder)(ctx, def);\n                },\n            });\n            setup.perComponent({\n                a: ContentRoot,\n                by(context) {\n                    return context.get(ShadowContentRoot, { or: null });\n                },\n            });\n        },\n    });\n}\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nconst Wesib__NS = ( /*#__PURE__*/new NamespaceDef('https://wesib.github.io/ns', 'b', 'wesib'));\n\nexport { AttachShadow, Attribute, AttributeChanged, AttributePath__root, AttributeRegistry, Attributes, BootstrapContext, BootstrapRoot, BootstrapWindow, Component, ComponentContext, ComponentContext__symbol, ComponentDef, ComponentDef__symbol, ComponentEventDispatcher, ComponentMember, ComponentRenderCtl, ComponentRenderScheduler, ComponentSlot, ComponentSlot__symbol, ComponentState, ContentRoot, CustomElements, DefaultNamespaceAliaser, DefaultPreRenderScheduler, DefaultRenderScheduler, DefinitionContext, DocumentRenderKit, DomProperty as DomMethod, DomProperty, DomPropertyPath__root, DomPropertyRegistry, ElementNaming, Feature, FeatureContext, FeatureDef, FeatureDef__symbol, MetaAccessor, PreRender, Render, RenderDef, RenderPath__root, ShadowContentRoot, ShadowRootBuilder, StateProperty, StatePropertyPath__root, StateUpdater, Wesib__NS, attributePathTo, bootstrapComponents, bootstrapDefault, domPropertyPathTo, statePropertyPathTo, trackAttribute, trackDomProperty, trackStateProperty };\n//# sourceMappingURL=wesib.js.map\n","import { ContextUpKey, contextDestroyed, FnContextKey, applyContextAfter } from '@proc7ts/context-values/updatable';\nimport { digAfter, afterThe, onSupplied, onEventBy, EventEmitter, onceOn, trackValue, isAfterEvent, translateAfter, deduplicateAfter_, afterAll, digAfter_, translateAfter_, deduplicateAfter, afterEventBy, sendEventsTo, shareAfter, afterValue, AfterEvent__symbol, trackValueBy } from '@proc7ts/fun-events';\nimport { BootstrapWindow, bootstrapDefault, ComponentContext, ComponentRenderCtl, DefaultPreRenderScheduler, ComponentMember, DefaultNamespaceAliaser, BootstrapContext, ComponentSlot } from '@wesib/wesib';\nimport { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { Supply } from '@proc7ts/supply';\nimport { DrekFragment, drekCharger, drekAppender } from '@frontmeans/drek';\nimport { SingleContextKey, ContextKey__symbol, applyContextTo, ContextBuilder__symbol, Contextual__symbol, isContextual } from '@proc7ts/context-values';\nimport { valueByRecipe, lazyValue, arrayOfElements, valueRecipe, noop, valueProvider, valuesProvider } from '@proc7ts/primitives';\nimport { nodeHost } from '@frontmeans/dom-primitives';\nimport { html__naming } from '@frontmeans/namespace-aliaser';\nimport { allAmender, newAmendTarget } from '@proc7ts/amend';\n\nclass FetchAgentKey extends ContextUpKey {\n    constructor(name) {\n        super(name);\n        this.upKey = this.createUpKey(slot => slot.insert(slot.seed.do(digAfter((...agents) => {\n            if (agents.length) {\n                return afterThe(combineFetchAgents(agents));\n            }\n            if (slot.hasFallback && slot.or) {\n                return slot.or;\n            }\n            return afterThe(defaultFetchAgent);\n        }))));\n    }\n    grow(slot) {\n        let delegated;\n        slot.context.get(this.upKey, slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined)(agent => delegated = agent).whenOff(reason => delegated = contextDestroyed(reason));\n        slot.insert((next, request) => delegated(next, request));\n    }\n}\nfunction defaultFetchAgent(next, request) {\n    return next(request);\n}\nfunction combineFetchAgents(agents) {\n    return (next, request) => {\n        const fetch = (agentIdx, agentRequest) => {\n            const agent = agents[agentIdx];\n            if (!agent) {\n                return next(agentRequest);\n            }\n            return onSupplied(agent((nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest), agentRequest));\n        };\n        return fetch(0, request);\n    };\n}\n\n/**\n * A key of context value containing an {@link HttpFetchAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nconst HttpFetchAgent = (\n/*#__PURE__*/ new FetchAgentKey('http-fetch-agent'));\n\nconst HttpFetchAborted = {};\n/**\n * @internal\n */\nfunction newHttpFetch(context) {\n    const window = context.get(BootstrapWindow);\n    const agent = context.get(HttpFetchAgent);\n    return (input, init) => agent(fetch, new Request(input, init));\n    function fetch(request) {\n        return onEventBy(receiver => {\n            const responseEmitter = new EventEmitter();\n            let supply;\n            if ('AbortController' in window) {\n                const abortController = new window.AbortController();\n                const { signal } = abortController;\n                supply = new Supply(reason => {\n                    if (reason === HttpFetchAborted) {\n                        abortController.abort();\n                    }\n                });\n                receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n                responseEmitter.on({\n                    supply,\n                    receive(ctx, response) {\n                        receiver.receive(ctx, response);\n                    },\n                });\n                const customSignal = request.signal;\n                if (customSignal) {\n                    new DomEventDispatcher(customSignal)\n                        .on('abort')\n                        .do(onceOn)(() => abortController.abort());\n                    if (customSignal.aborted) {\n                        abortController.abort();\n                    }\n                }\n                request = new Request(request, { signal });\n            }\n            else {\n                supply = responseEmitter.on(receiver);\n            }\n            window.fetch(request)\n                .then(response => {\n                responseEmitter.send(response);\n                supply.off();\n            })\n                .catch(reason => supply.off(reason));\n        });\n    }\n}\n\n/**\n * A key of bootstrap context value containing an {@link HttpFetch} instance.\n */\nconst HttpFetch = (\n/*#__PURE__*/ new FnContextKey('http-fetch', {\n    byDefault: bootstrapDefault(newHttpFetch),\n}));\n\n/**\n * A key of component context value containing {@link FragmentRenderCtl fragment render control}.\n */\nconst FragmentRenderCtl = (\n/*#__PURE__*/ new SingleContextKey('fragment-render-ctl', {\n    byDefault(context) {\n        return new FragmentRenderCtl$(context.get(ComponentContext));\n    },\n}));\nconst RenderFragment$done = {};\nclass FragmentRenderCtl$ {\n    constructor(_context) {\n        this._context = _context;\n    }\n    renderFragmentBy(renderer, def = {}) {\n        const spec = valueByRecipe(def, this._context);\n        const doRenderFragment = spec.settle === false\n            ? RenderFragment$justRender\n            : RenderFragment$settleThenRender;\n        const renderFragment = (fragment, retainContent) => {\n            if (!retainContent) {\n                doRenderFragment(fragment);\n            }\n        };\n        const { target = RenderFragment$defaultTarget } = spec;\n        const getTarget = lazyValue(() => target(this._context));\n        const renderCtl = this._context.get(ComponentRenderCtl);\n        const scheduler = this._context.get(DefaultPreRenderScheduler);\n        const supply = new Supply();\n        const renderSupply = renderCtl.preRenderBy(preExec => {\n            const fragment = new DrekFragment(getTarget(), { scheduler });\n            let retainContent = false;\n            const exec = {\n                ...preExec,\n                supply,\n                fragment,\n                content: fragment.content,\n                postpone(postponed) {\n                    preExec.postpone(() => postponed(exec));\n                },\n                renderBy(renderer) {\n                    preExec.renderBy(renderExec => {\n                        renderExec.renderBy(renderer);\n                    });\n                },\n                retainContent(retain = true) {\n                    retainContent = retain;\n                },\n                done() {\n                    preExec.renderBy(({ supply }) => {\n                        renderSupply.as(supply).off(RenderFragment$done);\n                    });\n                },\n            };\n            renderer(exec);\n            renderFragment(fragment, retainContent);\n        }, spec).needs(supply).whenOff(reason => {\n            if (reason !== RenderFragment$done) {\n                supply.off(reason);\n            }\n        });\n        return supply;\n    }\n}\nfunction RenderFragment$defaultTarget({ contentRoot }) {\n    return drekCharger(drekAppender(contentRoot));\n}\nfunction RenderFragment$settleThenRender(fragment) {\n    const { innerContext } = fragment;\n    const { window } = innerContext;\n    innerContext.scheduler()(() => {\n        window.customElements.upgrade(fragment.content);\n    });\n    fragment.settle();\n    fragment.render();\n}\nfunction RenderFragment$justRender(fragment) {\n    fragment.render();\n}\n\n/**\n * Creates a {@link RenderFragmentDef.Method fragment renderer method} amendment (amd decorator).\n *\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Non-mandatory rendering definition.\n *\n * @returns New component method amendment.\n */\nfunction RenderFragment(def) {\n    return ComponentMember(({ key, get, amend }) => amend({\n        componentDef: {\n            define(defContext) {\n                defContext.whenComponent(context => {\n                    context.whenReady(() => {\n                        const { component } = context;\n                        const renderer = get(component).bind(component);\n                        context.get(FragmentRenderCtl).renderFragmentBy(renderer, RenderFragment$def(context, key, def));\n                    });\n                });\n            },\n        },\n    }));\n}\nfunction RenderFragment$def(context, key, def = {}) {\n    const spec = valueByRecipe(def, context);\n    const { target = ({ contentRoot }) => drekCharger(drekAppender(contentRoot), RenderFragment$defaultRem(key)) } = spec;\n    return { ...spec, target };\n}\nfunction RenderFragment$defaultRem(key) {\n    const rem = String(key);\n    return rem.startsWith('render') ? rem.substr(6) : rem;\n}\n\n/**\n * A key of {@link ShareRef component share reference} property containing a {@link Share component\n * share} instance.\n */\nconst Share__symbol = ( /*#__PURE__*/Symbol('Share'));\n/**\n * Checks whether the given value is a {@link ShareRef component share reference}.\n *\n * @typeParam T - Shared value type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the value has a {@link Share__symbol} property, or `false` otherwise.\n */\nfunction isShareRef(value) {\n    return !!value\n        && (typeof value === 'object' || typeof value === 'function')\n        && !!value[Share__symbol];\n}\n\nconst ShareRegistry__key = ( /*#__PURE__*/new SingleContextKey('share-registry', {\n    byDefault: bootstrapDefault(bsContext => new ShareRegistry(bsContext.get(DefaultNamespaceAliaser))),\n}));\n/**\n * @internal\n */\nclass ShareRegistry {\n    constructor(nsAlias) {\n        this.nsAlias = nsAlias;\n        this._sharers = new Map();\n    }\n    static get [ContextKey__symbol]() {\n        return ShareRegistry__key;\n    }\n    addSharer(share, componentType, elementName, supply) {\n        let sharers = this._sharers.get(share);\n        if (!sharers) {\n            sharers = Sharers$new();\n            this._sharers.set(share, sharers);\n            Sharers$addSharer(sharers, componentType, supply);\n            Sharers$addName(sharers, elementName, supply);\n        }\n        else {\n            Sharers$addSharer(sharers, componentType, supply);\n            Sharers$addName(sharers, elementName, supply);\n            sharers.it = { ...sharers.it };\n        }\n    }\n    sharers(share) {\n        let sharers = this._sharers.get(share);\n        if (!sharers) {\n            sharers = Sharers$new();\n            this._sharers.set(share, sharers);\n        }\n        return sharers;\n    }\n}\nfunction Sharers$new() {\n    return trackValue({ names: new Map(), sharers: new Map() });\n}\nfunction Sharers$addName(tracker, name, supply) {\n    if (!name) {\n        return;\n    }\n    const sharers = tracker.it;\n    const counter = sharers.names.get(name) || 0;\n    sharers.names.set(name, counter + 1);\n    supply.whenOff(() => {\n        const counter = sharers.names.get(name) - 1;\n        if (counter > 0) {\n            sharers.names.set(name, counter);\n        }\n        else {\n            sharers.names.delete(name);\n        }\n        tracker.it = { ...sharers };\n    });\n}\nfunction Sharers$addSharer(tracker, componentType, supply) {\n    const sharers = tracker.it;\n    const counter = sharers.sharers.get(componentType) || 0;\n    sharers.sharers.set(componentType, counter + 1);\n    supply.whenOff(() => {\n        const counter = sharers.sharers.get(componentType) - 1;\n        if (counter > 0) {\n            sharers.sharers.set(componentType, counter);\n        }\n        else {\n            sharers.sharers.delete(componentType);\n        }\n        tracker.it = { ...sharers };\n    });\n}\n\n/**\n * @internal\n */\nclass ShareKey extends ContextUpKey {\n    constructor(name, _share) {\n        super(`${name}:share`);\n        this._share = _share;\n    }\n    get upKey() {\n        return this;\n    }\n    grow(slot) {\n        slot.insert(slot.seed.do(digAfter((...values) => this._share.selectValue(...values))));\n    }\n}\n\n/**\n * @internal\n */\nconst Share$impl__symbol = ( /*#__PURE__*/Symbol('Share.impl'));\n/**\n * @internal\n */\nclass Share$ {\n    constructor(_share, name, options) {\n        this._share = _share;\n        this.name = name;\n        this.key = new ShareKey(name, _share);\n        this._aliases = arrayOfElements(options.as).map(alias => alias[Share__symbol]);\n    }\n    addSharer(defContext, options = {}) {\n        const { local, name = defContext.elementDef.name } = options;\n        const registry = defContext.get(BootstrapContext).get(ShareRegistry);\n        const supply = new Supply();\n        const { componentType } = defContext;\n        const elementName = local\n            ? undefined\n            : name && html__naming.name(name, registry.nsAlias).toLowerCase();\n        registry.addSharer(this._share, componentType, elementName, supply);\n        for (const alias of this._aliases) {\n            registry.addSharer(alias, componentType, elementName, supply);\n        }\n        return supply;\n    }\n    shareValue(registrar) {\n        registrar.shareAs(this._share);\n        const priorityOffset = registrar.priority + 1;\n        this._aliases.forEach((alias, index) => {\n            alias.shareValue(registrar.withPriority(priorityOffset + index));\n        });\n    }\n}\n\n/**\n * A key of the {@link SharedValue.Detailed detailed shared value descriptor} containing the\n * {@link SharedValue.Details shared value details}.\n */\nconst SharedValue__symbol = ( /*#__PURE__*/Symbol('SharedValue'));\nconst SharedValue = {\n    /**\n     * Checks whether the given value shared by component is has details.\n     *\n     * @typeParam T - Shared value type.\n     * @param value - Shared value to check.\n     *\n     * @returns `true` if the given value is an object implementing a {@link SharedValue.Detailed} interface.\n     */\n    hasDetails(value) {\n        return !!value\n            && typeof value === 'object'\n            && typeof value[SharedValue__symbol] === 'object';\n    },\n};\n\n/**\n * @internal\n */\nfunction SharedValue$ContextBuilder(share, provider) {\n    return {\n        [ContextBuilder__symbol]: registry => {\n            const registrar = share.createRegistrar(registry, provider);\n            share.shareValue(registrar);\n            return registrar.supply;\n        },\n    };\n}\n/**\n * @internal\n */\nfunction SharedValue$Registrar(registry, provider) {\n    return SharedValue$BoundRegistrar(registry, SharedValue$bindProvider(provider));\n}\nfunction SharedValue$BoundRegistrar(registry, provider) {\n    const { priority, supply, provide } = provider;\n    return {\n        priority,\n        supply,\n        shareAs: (alias, newPriority = priority) => {\n            newPriority = Math.max(0, newPriority);\n            registry.provide({\n                a: alias[Share__symbol],\n                by: newPriority\n                    ? SharedValue$detailedProvider(provide, newPriority)\n                    : SharedValue$bareProvider(provide),\n            }).as(supply);\n        },\n        withPriority: newPriority => SharedValue$BoundRegistrar(registry, { ...provider, priority: Math.max(0, newPriority) }),\n    };\n}\nfunction SharedValue$bindProvider(provider) {\n    const priority = provider.priority ? Math.max(0, provider.priority) : 0;\n    const { supply = new Supply() } = provider;\n    return {\n        priority,\n        supply,\n        provide: (context) => {\n            const value = provider.provide(context);\n            if (isAfterEvent(value)) {\n                return value.do(applyContextAfter(context));\n            }\n            return applyContextTo(value)(context);\n        },\n    };\n}\nfunction SharedValue$bareProvider(provider) {\n    return context => {\n        const value = provider(context);\n        if (isAfterEvent(value)) {\n            return value.do(translateAfter((send, value) => value !== undefined ? send(value) : send()));\n        }\n        return value;\n    };\n}\nfunction SharedValue$detailedProvider(provider, priority) {\n    return context => ({\n        [SharedValue__symbol]: {\n            priority,\n            get: () => provider(context),\n        },\n    });\n}\n\n/**\n * A kind of the value a component shares with the nested ones.\n *\n * The sharing implies the following:\n *\n * - The sharer component {@link addSharer registers} its element name as the one bound to sharer.\n * - The sharer component {@link shareValue provides} an (updatable) shared value within its context.\n * - The consumer component {@link valueFor obtains} the shared value by searching the parent element with a sharer\n *   bound to it.\n *\n * A share instance is used as an identifier in all these steps.\n *\n * A {@link Shared @Shared} component property decorator may be used to automate this.\n *\n * @typeParam T - Shared value type.\n */\nclass Share {\n    /**\n     * Constructs new component share.\n     *\n     * @param name - A human-readable name of the share.\n     * @param options - Constructed share options.\n     */\n    constructor(name, options = {}) {\n        this[Share$impl__symbol] = new Share$(this, name, options);\n    }\n    /**\n     * Refers to itself.\n     */\n    get [Share__symbol]() {\n        return this;\n    }\n    /**\n     * A human-readable name of the name.\n     */\n    get name() {\n        return this[Share$impl__symbol].name;\n    }\n    /**\n     * A key of the sharer component context value containing an `AfterEvent` keeper of the shared value.\n     */\n    get [ContextKey__symbol]() {\n        return this[Share$impl__symbol].key;\n    }\n    /**\n     * Registers a sharer component.\n     *\n     * The registration is necessary for consumers to be able to find the element bound to sharer by that element's name.\n     *\n     * @param defContext - The definition context of the sharer component.\n     * @param options - Value sharing options.\n     *\n     * @returns Sharer registration supply. Revokes the sharer registration once cut off.\n     */\n    addSharer(defContext, options) {\n        return this[Share$impl__symbol].addSharer(defContext, options);\n    }\n    /**\n     * Shares a value by providing it for the sharer component context.\n     *\n     * @param registrar - Shared value registrar.\n     *\n     * @return A builder of shared value for component context.\n     */\n    shareValue(registrar) {\n        this[Share$impl__symbol].shareValue(registrar);\n    }\n    /**\n     * Creates a shared value registrar that shares a value created by the given provider.\n     *\n     * @typeParam TSharer - Sharer component type.\n     * @param registry - Target component context registry.\n     * @param provider - Shared value provider.\n     *\n     * @returns New shared value registrar.\n     */\n    createRegistrar(registry, provider) {\n        return SharedValue$Registrar(registry, provider);\n    }\n    /**\n     * Locates a shared value for the consuming component.\n     *\n     * Searches among parent elements for the one bound to the sharer component, then obtains the shared value from\n     * the sharer's context.\n     *\n     * @param consumer - Consumer component context.\n     * @param options - Location options.\n     *\n     * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n     */\n    valueFor(consumer, options = {}) {\n        const { host = nodeHost, local } = options;\n        const sharers = consumer.get(BootstrapContext).get(ShareRegistry).sharers(this);\n        const status = consumer.readStatus.do(deduplicateAfter_((a, b) => a === b, Share$consumerStatus));\n        return afterAll({\n            sharers,\n            status,\n        }).do(digAfter_(({ sharers: [sharers] }) => {\n            if (local) {\n                if (sharers.sharers.has(consumer.componentType)) {\n                    return Share$sharedValue(this, consumer);\n                }\n                if (local === true) {\n                    return afterThe();\n                }\n            }\n            let element = host(consumer.element);\n            while (element) {\n                if (sharers.names.has(element.tagName.toLowerCase())) {\n                    return ComponentSlot.of(element).read.do(digAfter_(sharer => sharer ? Share$sharedValue(this, sharer) : afterThe()));\n                }\n                element = host(element);\n            }\n            return afterThe();\n        }), deduplicateAfter());\n    }\n    /**\n     * Selects a shared value among candidates.\n     *\n     * It is especially useful when the value shared by multiple sharers.\n     *\n     * By default:\n     *\n     * - Prefers bare value.\n     * - Prefers the value from {@link SharedValue.Detailed detailed specifier} with higher priority\n     *   (i.e. lesser {@link SharedValue.Details.priority priority value}).\n     * - Prefers the value declared last.\n     *\n     * @param values - The values shared by sharers. May contain a {@link SharedValue.Detailed detailed value\n     * specifiers} in addition to pure values.\n     *\n     * @returns An `AfterEvent` keeper of selected value, if present.\n     */\n    selectValue(...values) {\n        let selected;\n        for (let i = values.length - 1; i >= 0; --i) {\n            const value = values[i];\n            if (!SharedValue.hasDetails(value)) {\n                return afterThe(value);\n            }\n            const details = value[SharedValue__symbol];\n            if (!selected || selected.priority > details.priority) {\n                selected = details;\n            }\n        }\n        if (!selected) {\n            return afterThe();\n        }\n        return afterEventBy(receiver => {\n            const value = selected.get();\n            if (isAfterEvent(value)) {\n                value(receiver);\n            }\n            else {\n                sendEventsTo(receiver)(value);\n            }\n        }).do(shareAfter);\n    }\n}\nfunction Share$consumerStatus([{ settled, connected }]) {\n    return connected ? 2 : settled ? 1 : 0;\n}\nfunction Share$sharedValue(share, sharer) {\n    return sharer.get(share).do(translateAfter_((send, value) => value ? send(value, sharer) : send()));\n}\n\nfunction shareLocator(locator, defaultSpec = {}) {\n    if (isShareRef(locator)) {\n        const share = locator[Share__symbol];\n        return (consumer, options = {}) => {\n            const { host = defaultSpec.host, local = defaultSpec.local } = options;\n            return share.valueFor(consumer, { host, local });\n        };\n    }\n    if (typeof locator === 'function') {\n        const { host: hostByDefault = nodeHost, local: localByDefault = false, share: shareByDefault, } = defaultSpec;\n        return (consumer, options = {}) => {\n            const { share = shareByDefault, host = hostByDefault, local = localByDefault, } = options;\n            return locator(consumer, { share, host, local });\n        };\n    }\n    const { share: shareRef = defaultSpec.share, host: hostByDefault = defaultSpec.host, local: localByDefault = defaultSpec.local, } = locator || {};\n    const share = shareRef[Share__symbol];\n    return (consumer, options = {}) => {\n        const { host = hostByDefault, local = localByDefault } = options;\n        return share.valueFor(consumer, { host, local });\n    };\n}\n\nconst Shareable$Internals__symbol = ( /*#__PURE__*/Symbol('Shareable.internals'));\n/**\n * Abstract implementation of value shareable by component.\n *\n * Shareable instance contains a {@link body} that become usable only when bound to sharer component.\n *\n * @typeParam TBody - Shareable body type.\n * @typeParam TSharer - Sharer component type.\n */\nclass Shareable {\n    /**\n     * Constructs shareable instance.\n     *\n     * @param body - Either shareable body, or its provider.\n     */\n    constructor(body) {\n        this[Shareable$Internals__symbol] = new Shareable$Internals(this, body);\n    }\n    /**\n     * Converts shareable body or its provider to provider that always returns an `AfterEvent` keeper of shareable body.\n     *\n     * @typeParam TBody - Shareable body type.\n     * @typeParam TSharer - Sharer component type.\n     * @param body - Either shareable body, or its provider.\n     *\n     * @returns Shareable body provider.\n     */\n    static provider(body) {\n        const provider = valueRecipe(body);\n        return context => afterValue(provider(context));\n    }\n    /**\n     * Sharer component context.\n     *\n     * Accessing it throws an exception until bound to sharer.\n     */\n    get sharer() {\n        return this[Shareable$Internals__symbol].sharer();\n    }\n    /**\n     * An `AfterEvent` keeper of shareable body.\n     *\n     * An `[AfterEvent__symbol]` method always returns this value.\n     */\n    get read() {\n        return this[Shareable$Internals__symbol].get().read;\n    }\n    /**\n     * Binds this shareable instance to sharer component.\n     *\n     * @param sharer - Sharer component context.\n     *\n     * @returns `this` instance.\n     */\n    [Contextual__symbol](sharer) {\n        this[Shareable$Internals__symbol].bind(sharer);\n        return this;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n    /**\n     * Shareable body.\n     *\n     * Accessing is throws an exception until bound to sharer.\n     */\n    get body() {\n        return this[Shareable$Internals__symbol].get().it;\n    }\n}\nclass Shareable$Internals {\n    constructor(_source, body) {\n        this._source = _source;\n        this._get = Shareable.provider(body);\n    }\n    sharer() {\n        this._notBound();\n    }\n    get() {\n        this._notBound();\n    }\n    bind(sharer) {\n        this.bind = noop;\n        this.sharer = valueProvider(sharer);\n        this.get = () => {\n            const tracker = trackValueBy(this._get(sharer));\n            this.get = valueProvider(tracker);\n            return tracker;\n        };\n    }\n    _notBound() {\n        throw new TypeError(`${String(this._source)} is not properly shared yet`);\n    }\n}\n\n/**\n * @internal\n */\nclass ShareAccessor {\n    constructor(target, component) {\n        this._get = target.get.bind(undefined, component);\n        this._set = target.writable ? target.set.bind(undefined, component) : noop;\n        this._ctx = ComponentContext.of(component);\n        const value = this._get();\n        let dynSync = false;\n        if (isAfterEvent(value)) {\n            dynSync = true;\n            this.val = trackValueBy(value);\n        }\n        else {\n            this.val = trackValue(value);\n        }\n        this.val.supply.needs(this._ctx);\n        // Bind to context as the very first operation\n        this.val.read(value => isContextual(value) && value[Contextual__symbol](this._ctx));\n        if (dynSync) {\n            this._syncDyn();\n        }\n        else {\n            this._syncVal();\n        }\n    }\n    get() {\n        return (this._valSupply ? this.val.it : this.val.read);\n    }\n    set(value) {\n        if (isAfterEvent(value)) {\n            this.val.by(value);\n            this._syncDyn();\n        }\n        else {\n            this.val.it = value;\n            this._syncVal();\n        }\n    }\n    _syncVal() {\n        if (!this._valSupply) {\n            this._valSupply = this.val.read(value => this._set(value));\n        }\n    }\n    _syncDyn() {\n        if (this._valSupply) {\n            this._valSupply.off();\n            this._valSupply = undefined;\n            this._set(this.val.read);\n        }\n    }\n}\n\n/**\n * Converts arbitrary {@link TargetShare target component share} to its detailed {@link TargetShare.Spec specifier}.\n *\n * @typeParam T - Share value type.\n * @param target\n */\nfunction targetShare(target) {\n    return isShareRef(target) ? { share: target } : target;\n}\n\n/**\n * Creates an amendment (and decorator) of component member that {@link Share shares} its value.\n *\n * The amended member should contain either a static value, or its `AfterEvent` keeper.\n *\n * Applies current component context to {@link Contextual} shared values.\n *\n * @typeParam T - Shared value type.\n * @typeParam TClass - A type of decorated component class.\n * @param share - Target component share.\n * @param amendments - Amendments to apply.\n *\n * @returns New shared member amendment.\n */\nfunction Shared(share, ...amendments) {\n    const { share: { [Share__symbol]: share$default }, local: localShare$default = false } = targetShare(share);\n    return ComponentMember(baseTarget => {\n        const accessorKey = Symbol(`${String(baseTarget.key)}:shared`);\n        let lastTarget = baseTarget;\n        const accessorOf = (component) => component[accessorKey]\n            || (component[accessorKey] = new ShareAccessor(lastTarget, component));\n        const getShared = (component) => accessorOf(component).val.read;\n        const lastAmender = (target) => {\n            lastTarget = target;\n            target.amend({\n                get: component => accessorOf(component).get(),\n                set: target.writable\n                    ? (component, value) => accessorOf(component).set(value)\n                    : undefined,\n                componentDef: {\n                    setup(setup) {\n                        setup.perComponent(SharedValue$ContextBuilder(target.share, {\n                            provide: context => context.onceReady.do(digAfter_(({ component }) => accessorOf(component).val, valuesProvider())),\n                        }));\n                    },\n                    define(defContext) {\n                        target.share.addSharer(defContext, { local: target.localShare });\n                    },\n                },\n            });\n        };\n        allAmender([...amendments, lastAmender])(newAmendTarget({\n            base: {\n                ...baseTarget,\n                share: share$default,\n                localShare: localShare$default,\n                getShared,\n            },\n            amend(base, request = {}) {\n                const { share = base.share, localShare = base.localShare, getShared: $getShared, ...baseRequest } = request;\n                const createBaseTarget = baseTarget.amend(baseRequest);\n                return () => ({\n                    ...createBaseTarget(),\n                    share,\n                    localShare,\n                    getShared,\n                });\n            },\n        }));\n    });\n}\n\nexport { FetchAgentKey, FragmentRenderCtl, HttpFetch, HttpFetchAgent, RenderFragment, Share, Share__symbol, Shareable, Shared, SharedValue, SharedValue__symbol, isShareRef, shareLocator, targetShare };\n//# sourceMappingURL=wesib.generic.js.map\n","/**\n * A `Set` implementation that keeps a delta of changes made to it.\n *\n * @typeParam T  A type of elements of delta set.\n */\nclass DeltaSet extends Set {\n    /**\n     * Constructs new delta set.\n     *\n     * @param values  An iterable of elements be add to constructed delta set. Or `null` to add nothing.\n     */\n    constructor(values) {\n        super();\n        this._added = new Set(values);\n        this._removed = new Set();\n        this._added.forEach(value => this.add(value));\n    }\n    /**\n     * Appends a new element with a specified value to the end of this delta set. Unless the set contains this element\n     * already.\n     *\n     * Records element addition and forgets its removal unless the set contains it already.\n     *\n     * @param value  The value of the element to add.\n     *\n     * @returns `this` delta set.\n     */\n    add(value) {\n        if (!this.has(value)) {\n            this._added.add(value);\n            this._removed.delete(value);\n            super.add(value);\n        }\n        return this;\n    }\n    /**\n     * Removes the specified element from this delta set.\n     *\n     * Records element removal and forgets its addition if removal succeed.\n     *\n     * @param value  The value of the element to remove.\n     *\n     * @returns `true` if element removed successfully; or `false` if this set did not contain the element.\n     */\n    delete(value) {\n        if (super.delete(value)) {\n            this._added.delete(value);\n            this._removed.add(value);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Removes all elements from this delta set.\n     *\n     * Records all elements removal and forgets all elements additions.\n     */\n    clear() {\n        this._added.clear();\n        this.forEach(value => this._removed.add(value));\n        super.clear();\n    }\n    /**\n     * Applies changes to this delta set.\n     *\n     * First removes elements to `remove`. Then appends elements to `add`.\n     *\n     * Records all changes made.\n     *\n     * @param add  An iterable of elements to add.\n     * @param remove  An iterable of elements to remove.\n     *\n     * @returns `this` delta set.\n     */\n    delta(add, remove = []) {\n        deltaSetDeltaReceiver(this)(add, remove);\n        return this;\n    }\n    /**\n     * Replays the changes made to this set in target receiver.\n     *\n     * @param receiver  A receiver of changes delta. E.g. another `Set`.\n     *\n     * @returns `this` delta set.\n     */\n    redelta(receiver) {\n        const receive = typeof receiver === 'function' ? receiver : deltaSetDeltaReceiver(receiver);\n        receive([...this._added], [...this._removed]);\n        return this;\n    }\n    /**\n     * Forgets all changes made to this set.\n     *\n     * Does not alter the set contents.\n     *\n     * @returns `this` delta set.\n     */\n    undelta() {\n        this._added.clear();\n        this._removed.clear();\n        return this;\n    }\n}\n/**\n * @internal\n */\nfunction deltaSetDeltaReceiver(receiver) {\n    return (add, remove) => {\n        for (const removed of remove) {\n            receiver.delete(removed);\n        }\n        for (const added of add) {\n            receiver.add(added);\n        }\n    };\n}\n\nexport { DeltaSet };\n//# sourceMappingURL=delta-set.js.map\n","import { valueProvider, noop, isPresent, arrayOfElements, asis, valuesProvider, isDefined } from '@proc7ts/primitives';\nimport { NamespaceDef, newNamespaceAliaser, isQualifiedName, css__naming } from '@frontmeans/namespace-aliaser';\nimport { newRenderSchedule } from '@frontmeans/render-scheduler';\nimport { AfterEvent__symbol, trackValue, mapAfter_, ValueTracker, EventEmitter, OnEvent__symbol, mapAfter, digAfter, afterAll, translateAfter, translateOn, afterSupplied, isEventKeeper, supplyAfter, afterThe, afterEach, afterSent, mapOn, digAfter_, onceAfter, afterEventBy, shareAfter, EventNotifier } from '@proc7ts/fun-events';\nimport { Supply, neverSupply } from '@proc7ts/supply';\nimport { overElementsOf, filterArray, itsReduction, itsElements, itsEach, overEntries, mapIt, overIterator, PushIterator__symbol, iteratorOf, mapArray, flatMapIt, overNone, overArray, flatMapArray, filterIt, itsEvery, valueArray, reverseArray } from '@proc7ts/push-iterator';\nimport { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { DeltaSet } from '@proc7ts/delta-set';\n\nconst nullInAspect$ = {\n    instance: null,\n    convertTo: noop,\n};\n/**\n * Creates an aspect applied to control with `null` instance value.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n *\n * @returns Applied input aspect.\n */\nfunction nullInAspect() {\n    return nullInAspect$;\n}\n/**\n * Creates an aspect applied to control with known instance.\n *\n * An instance remains as is when converted to another control.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam instance - Known aspect instance type.\n *\n * @returns Applied input aspect.\n */\nfunction knownInAspect(instance) {\n    return {\n        instance,\n        convertTo(_target) {\n            return this;\n        },\n    };\n}\n/**\n * Creates an aspect applied to control with known inconvertible instance.\n *\n * When converted to another control with the same value, an aspect instance remains as is.\n *\n * When converted to another control with another value, an aspect instance replaced by `null`.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n * @param control - Target control to apply an aspect to.\n * @param aspectKey - Applied aspect key.\n * @param instance - Known aspect instance type. Defaults to `null`.\n *\n * @returns Applied input aspect.\n */\nfunction inconvertibleInAspect(control, aspectKey, instance = null) {\n    return builtInAspect$(control, aspectKey, valueProvider(null), instance);\n}\n/**\n * Creates an aspect applied to control with built instance.\n *\n * When converted to another control with the same value, an aspect instance remains as is.\n *\n * When converted to another control with another value, an aspect instance is built again with original control\n * passed to the builder as a second parameter.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n * @param control - Target control to apply an aspect to.\n * @param aspectKey - Applied aspect key.\n * @param build - Aspect instance builder function. Accepts target control and optionally an original one as parameters.\n *\n * @returns Applied input aspect.\n */\nfunction builtInAspect(control, aspectKey, build) {\n    return builtInAspect$(control, aspectKey, build);\n}\nfunction builtInAspect$(control, aspectKey, build, instance, origin) {\n    if (instance === undefined) {\n        instance = build(control, origin);\n    }\n    return {\n        instance,\n        convertTo(target) {\n            return builtInAspect$(target, aspectKey, build, undefined, control);\n        },\n        attachTo(target) {\n            return builtInAspect$(target, aspectKey, build, control.aspect(aspectKey) || build(target));\n        },\n    };\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nconst InAspect__symbol = ( /*#__PURE__*/Symbol('in-aspect'));\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nconst InputAspects__NS = ( /*#__PURE__*/new NamespaceDef('https://surol.github.io/input-aspects/ns', 'inasp', 'input-aspects'));\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect = {\n    applyTo() {\n        return knownInAspect(newNamespaceAliaser());\n    },\n};\n/**\n * @category Aspect\n */\nconst InNamespaceAliaser = {\n    get [InAspect__symbol]() {\n        return InNamespaceAliaser__aspect;\n    },\n    /**\n     * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n     *\n     * @typeParam TValue - Converted control value type.\n     * @param nsAlias - Target namespace aliaser.\n     *\n     * @returns Input control aspect converter.\n     */\n    to(nsAlias) {\n        return {\n            applyAspect(aspect) {\n                return aspect === InNamespaceAliaser__aspect\n                    ? knownInAspect(nsAlias)\n                    : undefined;\n            },\n        };\n    },\n};\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect = {\n    applyTo() {\n        return knownInAspect(newRenderSchedule);\n    },\n};\n/**\n * @category Aspect\n */\nconst InRenderScheduler = {\n    get [InAspect__symbol]() {\n        return InRenderScheduler__aspect;\n    },\n    /**\n     * Creates input control aspect converter that assigns the given render scheduler to converted control.\n     *\n     * @typeParam TValue - Converted control value type.\n     * @param scheduler - Target DOM render scheduler.\n     *\n     * @returns Input control aspect converter.\n     */\n    to(scheduler) {\n        return {\n            applyAspect(aspect) {\n                return aspect === InRenderScheduler__aspect\n                    ? knownInAspect(scheduler)\n                    : undefined;\n            },\n        };\n    },\n};\n\nconst InRole__aspect = {\n    applyTo(control) {\n        return {\n            instance: new InControlRole(control),\n            convertTo: noop,\n        };\n    },\n};\n/**\n * A role of input control.\n *\n * Contains arbitrary named roles. A special role `'default'` considered active when no other roles activated.\n *\n * Roles may be used to conditionally activate other input aspects of the control.\n *\n * @typeParam TValue - Input value type.\n */\nclass InRole {\n    static get [InAspect__symbol]() {\n        return InRole__aspect;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n}\nclass InRole$Active {\n    constructor(roles) {\n        this.roles = roles;\n        this._activate = noop;\n        this.active = {\n            [Symbol.iterator]() {\n                return roles.keys();\n            },\n            has(role) {\n                return roles.has(role);\n            },\n        };\n    }\n    static create() {\n        const result = new InRole$Active(new Map());\n        result.add('default', true);\n        return result;\n    }\n    modify() {\n        const result = new InRole$Active(this.roles);\n        result._defaultSupply = this._defaultSupply;\n        return result;\n    }\n    add(role, isDefault) {\n        const named = this.roles.get(role);\n        if (named) {\n            // Already active.\n            ++named.active;\n            return;\n        }\n        const supply = new Supply();\n        this.roles.set(role, {\n            active: 1,\n            supply,\n        });\n        if (isDefault) {\n            this._defaultSupply = supply.whenOff(() => {\n                const toRemove = this.roles.get(role);\n                if (!--toRemove.active) {\n                    this.roles.delete(role);\n                }\n            });\n        }\n        else {\n            const defaultSupply = this._defaultSupply;\n            this.activateBy(() => defaultSupply.off());\n        }\n        return supply;\n    }\n    remove(role, reason) {\n        const named = this.roles.get(role);\n        if (--named.active) {\n            // Still active.\n            return;\n        }\n        this.roles.delete(role);\n        this.activateBy(() => named.supply.off(reason));\n    }\n    activateBy(activator) {\n        const prevActivator = this._activate;\n        this._activate = () => {\n            prevActivator();\n            activator();\n        };\n    }\n    activate() {\n        const activator = this._activate;\n        this._activate = noop;\n        activator();\n    }\n}\nclass InControlRole extends InRole {\n    constructor(_control) {\n        super();\n        this._control = _control;\n        this._active = trackValue(InRole$Active.create());\n        this._activators = new Map();\n        this._active.on(active => active.activate());\n        this._active.supply.needs(_control);\n        this.read = this._active.read.do(mapAfter_(({ active }) => active));\n    }\n    add(role) {\n        const active = this._active.it.modify();\n        this._add(active, role);\n        this._active.it = active;\n        return new Supply(reason => {\n            const active = this._active.it.modify();\n            active.remove(role, reason);\n            if (!active.roles.size) {\n                // No more active roles left.\n                // Enable `default` role.\n                this._add(active, 'default', true);\n            }\n            this._active.it = active;\n        });\n    }\n    when(role, activator) {\n        let activators = this._activators.get(role);\n        if (!activators) {\n            activators = new Map();\n            this._activators.set(role, activators);\n        }\n        const supply = new Supply().needs(this._control);\n        activators.set(supply, (control, role, active) => activator(control, role, active).supply.needs(supply));\n        supply.whenOff(() => {\n            activators.delete(supply);\n            if (!activators.size) {\n                this._activators.delete(role);\n            }\n        });\n        const named = this._active.it.roles.get(role);\n        if (named) {\n            // The role already active.\n            // Issue activator immediately.\n            named.supply.cuts(activator(this._control, role, this._active.it.active));\n        }\n        return supply;\n    }\n    _add(active, role, isDefault = false) {\n        const activatedSupply = active.add(role, isDefault);\n        if (activatedSupply) {\n            // Role activated\n            const activators = this._activators.get(role);\n            if (activators) {\n                // Issue activators\n                for (const activator of activators.values()) {\n                    activatedSupply.cuts(activator(this._control, role, this._active.it.active));\n                }\n            }\n        }\n    }\n}\n\n/**\n * @internal\n */\nfunction isAspectKey(value) {\n    return InAspect__symbol in value;\n}\n\n/**\n * @internal\n */\nconst noopInConversion = {\n    applyAspect(_aspect) {\n        return;\n    },\n};\n/**\n * @internal\n */\nfunction noopInConverter() {\n    return noopInConversion;\n}\n\nfunction intoConvertedBy(valueOrAspectConverter, ...converters) {\n    if (!valueOrAspectConverter) {\n        return noopInConverter;\n    }\n    const converter = inConverter(valueOrAspectConverter);\n    if (!converters.length) {\n        return converter;\n    }\n    const aspectConverters = converters.map(inConverter);\n    return (from, to) => {\n        const conversion = converter(from, to);\n        const conversions = overElementsOf([conversion], filterArray(aspectConverters.map(acf => acf(from, to)), isPresent));\n        const applyAspect = itsReduction(conversions, (prev, cv) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect(aspect))\n            : prev, noop);\n        if ( /*#__INLINE__*/isInAspectConversion(conversion)) {\n            return {\n                applyAspect,\n            };\n        }\n        return {\n            set: conversion.set.bind(conversion),\n            get: conversion.get.bind(conversion),\n            applyAspect,\n        };\n    };\n}\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeParam TValue - Input value type.\n * @param aspects - Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nfunction intoConvertedAspects(aspects) {\n    return aspects\n        ? intoConvertedBy(...arrayOfElements(aspects))\n        : intoConvertedBy();\n}\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion - Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nfunction isInAspectConversion(conversion) {\n    return !conversion.set;\n}\nfunction inConverter(converter) {\n    return typeof converter === 'function' ? converter : valueProvider(converter);\n}\n\n/**\n * @internal\n */\nconst InBuilder$Impl__symbol = ( /*#__PURE__*/Symbol('InBuilder.impl'));\n/**\n * @internal\n */\nclass InBuilder$Impl {\n    constructor() {\n        this._aspectsByKey = new Map();\n        this._commonAspects = undefined;\n        this._setup = undefined;\n    }\n    addAspect(aspect, converter) {\n        const prev = this._aspectsByKey.get(aspect);\n        this._aspectsByKey.set(aspect, prev ? intoConvertedBy(prev, converter) : intoConvertedBy(converter));\n    }\n    addAspects(aspects) {\n        this._commonAspects = this._commonAspects\n            ? intoConvertedBy(this._commonAspects, ...aspects)\n            : intoConvertedBy(...aspects);\n    }\n    setup(setup) {\n        const prev = this._setup;\n        if (prev) {\n            this._setup = control => {\n                prev(control);\n                setup(control);\n            };\n        }\n        else {\n            this._setup = setup;\n        }\n    }\n    build(factory) {\n        const control = factory({ aspects: this._aspects() });\n        // Control setup\n        if (this._setup) {\n            control.setup(this._setup);\n        }\n        return control;\n    }\n    _aspects() {\n        if (this._aspectsByKey.size) {\n            const byKey = intoConvertedByKey(this._aspectsByKey);\n            return this._commonAspects ? intoConvertedBy(byKey, this._commonAspects) : byKey;\n        }\n        return this._commonAspects;\n    }\n}\nfunction intoConvertedByKey(byKey) {\n    return (from, to) => ({\n        applyAspect(aspect) {\n            const converter = byKey.get(aspect);\n            return converter && converter(from, to).applyAspect(aspect);\n        },\n    });\n}\n\nvar _a;\n/**\n * User input control builder.\n *\n * @category Control\n * @typeParam TControl - Control type.\n * @typeParam TValue - Input value type.\n */\nclass InBuilder {\n    constructor() {\n        /**\n         * @internal\n         */\n        this[_a] = new InBuilder$Impl();\n    }\n    /**\n     * Registers an aspect to add to the built control.\n     *\n     * @param aspectKey - A key of aspect to add.\n     * @param converter - An aspect converter to the built control from the {@link inValueOf same-valued one}.\n     *\n     * @returns `this` builder instance.\n     */\n    addAspect(aspectKey, converter) {\n        this[InBuilder$Impl__symbol].addAspect(aspectKey[InAspect__symbol], converter);\n        return this;\n    }\n    /**\n     * Registers arbitrary aspects to add to the built control.\n     *\n     * These aspects always applied after {@link addAspect concrete} ones.\n     *\n     * @param aspects - Input aspects to add. These are aspect converters to the built control from the {@link inValueOf\n     * same-valued one}.\n     *\n     * @returns `this` builder instance.\n     */\n    addAspects(...aspects) {\n        if (aspects.length) {\n            this[InBuilder$Impl__symbol].addAspects(aspects);\n        }\n        return this;\n    }\n    setup(aspectKeyOrSetup, aspectSetup) {\n        if (isAspectKey(aspectKeyOrSetup)) {\n            this[InBuilder$Impl__symbol].setup(control => control.setup(aspectKeyOrSetup, aspectSetup));\n        }\n        else {\n            this[InBuilder$Impl__symbol].setup(aspectKeyOrSetup);\n        }\n        return this;\n    }\n    /**\n     * Builds control.\n     *\n     * @param factory - Control factory.\n     *\n     * @returns New user input control constructed by the given `factory` and set up with configured aspects and setup\n     * procedures.\n     */\n    build(factory) {\n        return this[InBuilder$Impl__symbol].build(factory);\n    }\n}\n_a = InBuilder$Impl__symbol;\n\n/**\n * @internal\n */\nconst InControl$Aspects__symbol = ( /*#__PURE__*/Symbol('InControl.aspects'));\n/**\n * @internal\n */\nclass InControl$Aspects {\n    constructor(control, aspects) {\n        this.control = control;\n        this.aspects = aspects;\n        this._byKey = new Map();\n    }\n    aspect(aspect) {\n        const applied = this._byKey.get(aspect);\n        if (applied) {\n            // Aspect applied already.\n            // Return it.\n            return applied;\n        }\n        const application = this.control._applyAspect(aspect)\n            || aspect.applyTo(this.control);\n        this._byKey.set(aspect, application);\n        return application;\n    }\n}\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nclass InControl extends ValueTracker {\n    /**\n     * Constructs user input control.\n     *\n     * @param aspects - Input aspects applied by default. These are aspect converters to constructed control from the\n     * {@link inValueOf same-valued one}.\n     */\n    constructor({ aspects, } = {}) {\n        super();\n        const aspectList = arrayOfElements(aspects);\n        this[InControl$Aspects__symbol] = new InControl$Aspects(this, aspectList.length\n            ? intoConvertedAspects(aspectList)(inValueOf(this), this)\n            : noopInConversion);\n    }\n    /**\n     * Retrieves an aspect instance applied to this control.\n     *\n     * If the given `aspect` is not applied yet, then applies it first.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspectKey - A key of aspect to apply to this control.\n     *\n     * @returns An applied aspect instance.\n     */\n    aspect(aspectKey) {\n        return this[InControl$Aspects__symbol].aspect(aspectKey[InAspect__symbol]).instance;\n    }\n    setup(aspectKeyOrSetup, aspectSetup) {\n        if (isAspectKey(aspectKeyOrSetup)) {\n            aspectSetup(this.aspect(aspectKeyOrSetup), this);\n        }\n        else {\n            aspectKeyOrSetup(this);\n        }\n        return this;\n    }\n    convert(by, ...and) {\n        return new InControl$Converted(this, intoConvertedBy(by, ...and));\n    }\n    /**\n     * Applies the given aspect to this control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n     * `InAspect.applyTo()` method).\n     */\n    _applyAspect(aspect) {\n        return this[InControl$Aspects__symbol].aspects.applyAspect(aspect);\n    }\n}\n/**\n * @internal\n */\nclass InControl$SameValued extends InControl {\n    constructor(_control) {\n        super();\n        this._control = _control;\n    }\n    get supply() {\n        return this._supply || (this._supply = new Supply(noop).needs(this._control));\n    }\n    get it() {\n        return this._control.it;\n    }\n    set it(value) {\n        this._control.it = value;\n    }\n    get on() {\n        return this._control.on;\n    }\n}\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @param control - Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nfunction inValueOf(control) {\n    return new InControl$SameValued(control);\n}\nclass InControl$Converted extends InControl {\n    constructor(src, by) {\n        super();\n        this._on = new EventEmitter();\n        this.supply = new Supply().needs(src);\n        let lastRev = 0;\n        let backward;\n        const conversion = by(src, this);\n        let set;\n        let get;\n        let convertAspect;\n        if ( /*#__INLINE__*/isInAspectConversion(conversion)) {\n            set = asis;\n            get = asis;\n            convertAspect = (aspect) => {\n                const fallback = src[InControl$Aspects__symbol].aspect(aspect);\n                return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n            };\n        }\n        else {\n            set = conversion.set;\n            get = conversion.get;\n            convertAspect = (aspect) => {\n                const fallback = src[InControl$Aspects__symbol].aspect(aspect);\n                return fallback.convertTo(this);\n            };\n        }\n        this._applyAspect = aspect => { var _a; return ((_a = conversion.applyAspect) === null || _a === void 0 ? void 0 : _a.call(conversion, aspect)) || convertAspect(aspect); };\n        this._it = trackValue([set(src.it), 0]);\n        this._it.supply.needs(this.supply);\n        this._it.on(([newValue], [oldValue]) => {\n            if (newValue !== oldValue) {\n                this._on.send(newValue, oldValue);\n            }\n        }).cuts(this._on);\n        src.on(value => {\n            if (value !== backward) {\n                this._it.it = [set(value), ++lastRev];\n            }\n        }).cuts(this);\n        this._it.on(([value, rev]) => {\n            if (rev !== lastRev) {\n                lastRev = rev;\n                backward = get(value);\n                try {\n                    src.it = backward;\n                }\n                finally {\n                    backward = undefined;\n                }\n            }\n        });\n    }\n    get it() {\n        return this._it.it[0];\n    }\n    set it(value) {\n        const [prevValue, prevRev] = this._it.it;\n        if (value !== prevValue) {\n            this._it.it = [value, prevRev + 1];\n        }\n    }\n    get on() {\n        return this._on.on;\n    }\n}\n\n/**\n * @internal\n */\nconst InContainer__aspect = {\n    applyTo(control) {\n        return inconvertibleInAspect(control, InContainer);\n    },\n};\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nclass InContainer extends InControl {\n    static get [InAspect__symbol]() {\n        return InContainer__aspect;\n    }\n    _applyAspect(aspect) {\n        return aspect === InContainer__aspect\n            ? inconvertibleInAspect(this, InContainer, this)\n            : super._applyAspect(aspect);\n    }\n}\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nclass InContainerControls {\n    [OnEvent__symbol]() {\n        return this.on;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n}\n\n/**\n * @internal\n */\nconst InParents__aspect = {\n    applyTo(control) {\n        return knownInAspect(new InControlParents(control));\n    },\n};\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nclass InParents {\n    static get [InAspect__symbol]() {\n        return InParents__aspect;\n    }\n    [OnEvent__symbol]() {\n        return this.on;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n}\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n    constructor(_control) {\n        super();\n        this._control = _control;\n        this._map = new Map();\n        this._on = new EventEmitter();\n        this._on.supply.needs(this._control);\n        const allParents = () => ({\n            [Symbol.iterator]: () => this._map.keys(),\n        });\n        this.read = this.on.do(mapAfter(allParents, allParents));\n    }\n    add(entry) {\n        const existingSupply = this._map.get(entry);\n        if (existingSupply) {\n            // Parent entry already added. Doing nothing\n            return existingSupply;\n        }\n        // Adding new entry\n        const supply = new Supply(() => {\n            this._map.delete(entry);\n            this._on.send([], [entry]);\n        });\n        this._map.set(entry, supply);\n        this._on.send([entry], []);\n        return supply\n            .needs(this._control)\n            .needs(entry.parent);\n    }\n    get on() {\n        return this._on.on;\n    }\n}\n\n/**\n * @internal\n */\nconst InElement__aspect = {\n    applyTo(control) {\n        return inconvertibleInAspect(control, InElement);\n    },\n};\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nclass InElement extends InControl {\n    static get [InAspect__symbol]() {\n        return InElement__aspect;\n    }\n    _applyAspect(aspect) {\n        return aspect === InElement__aspect\n            ? inconvertibleInAspect(this, InElement, this)\n            : super._applyAspect(aspect);\n    }\n}\n\n/**\n * @internal\n */\nconst InMode__aspect = {\n    applyTo(control) {\n        return builtInAspect(control, InMode, ctrl => new InControlMode(ctrl));\n    },\n};\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nclass InMode {\n    static get [InAspect__symbol]() {\n        return InMode__aspect;\n    }\n    [OnEvent__symbol]() {\n        return this.on;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n    /**\n     * Checks whether control in the given `mode` has data to submit.\n     *\n     * @param mode - Input control mode to check.\n     *\n     * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n     */\n    static hasData(mode) {\n        return mode !== 'off' && mode[0] !== '-';\n    }\n    /**\n     * Unregisters all receivers.\n     *\n     * @param reason - Optional reason.\n     *\n     * @returns `this` instance.\n     */\n    done(reason) {\n        this.own.supply.off(reason);\n        return this;\n    }\n}\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker {\n    constructor(element) {\n        super();\n        this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n    }\n    get supply() {\n        return this._tracker.supply;\n    }\n    get it() {\n        return this._tracker.it;\n    }\n    set it(value) {\n        switch (value) {\n            case 'off':\n            case 'ro':\n            case '-on':\n            case '-ro':\n                break;\n            default:\n                value = 'on'; // Correct the value.\n        }\n        this._tracker.it = value;\n    }\n    get on() {\n        return this._tracker.on;\n    }\n}\n/**\n * @internal\n */\nclass DerivedInModes {\n    constructor() {\n        this._all = new Set();\n        this._on = new EventEmitter();\n        const sources = afterSent(this._on.on.do(mapOn(() => this._all)), valuesProvider(this._all));\n        this.read = sources.do(digAfter_((set) => afterEach(...set)), mapAfter(mergeInModes));\n    }\n    add(source) {\n        const supply = new Supply(() => {\n            this._all.delete(source);\n            this._on.send();\n        });\n        this._all.add(source);\n        this._on.send();\n        return supply;\n    }\n}\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n    constructor(_control) {\n        super();\n        this._control = _control;\n        this._derived = new DerivedInModes();\n        const element = _control.aspect(InElement);\n        this.own = new OwnModeTracker(element);\n        this.own.supply.needs(_control);\n        this.derive(_control.aspect(InParents).read.do(digAfter(parentsInMode)));\n        let last = 'on';\n        this.read = afterAll({\n            derived: this._derived.read,\n            own: this.own,\n        }).do(translateAfter((send, { derived: [derived], own: [own], }) => {\n            let next;\n            if (own === 'off' || derived === 'off') {\n                next = 'off';\n            }\n            else {\n                let off = false;\n                if (own[0] === '-') {\n                    off = true;\n                    own = own.substring(1);\n                }\n                if (derived[0] === '-') {\n                    off = true;\n                    derived = derived.substring(1);\n                }\n                next = derived === 'ro' ? 'ro' : own;\n                if (off) {\n                    next = '-' + next;\n                }\n            }\n            if (last !== next) {\n                send(last = next);\n            }\n        }, valuesProvider(last)));\n        let lastUpdate = 'on';\n        this.on = this.read.do(translateOn((send, value) => {\n            const old = lastUpdate;\n            if (old !== value) {\n                send(lastUpdate = value, old);\n            }\n        }));\n        if (element) {\n            this.read(value => applyInMode(element.element, value));\n        }\n    }\n    derive(source) {\n        return this._derived.add(afterSupplied(isEventKeeper(source) ? source : source(this._control)).do(supplyAfter(this._control))).needs(this._control);\n    }\n}\n/**\n * @internal\n */\nfunction initialInMode(element) {\n    return element.getAttribute('disabled') != null\n        ? 'off'\n        : (element.getAttribute('readonly') != null ? 'ro' : 'on');\n}\n/**\n * @internal\n */\nfunction applyInMode(element, value) {\n    switch (value) {\n        case 'off':\n            element.setAttribute('disabled', '');\n            break;\n        case 'ro':\n        case '-ro':\n            // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n            element.setAttribute('disabled', '');\n            element.removeAttribute('disabled');\n            element.setAttribute('readonly', '');\n            break;\n        default:\n            // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n            element.setAttribute('disabled', '');\n            element.removeAttribute('disabled');\n            // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n            element.setAttribute('readonly', '');\n            element.removeAttribute('readonly');\n    }\n}\n/**\n * @internal\n */\nfunction parentsInMode(parents) {\n    const parentList = itsElements(parents);\n    if (!parentList.length) {\n        return afterThe('on');\n    }\n    const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n    return afterEach(...parentModes).do(mapAfter(mergeInModes));\n}\n/**\n * @internal\n * @param modes\n */\nfunction mergeInModes(...modes) {\n    return inModeValue(...overElementsOf(...modes));\n}\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes - Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nfunction inModeValue(...modes) {\n    let ro = false;\n    let off = false;\n    for (const mode of modes) {\n        switch (mode) {\n            case 'off':\n                return 'off';\n            case 'ro':\n                ro = true;\n                break;\n            case '-on':\n                off = true;\n                break;\n            case '-ro':\n                off = true;\n                ro = true;\n                break;\n        }\n    }\n    return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n\n/**\n * @internal\n */\nconst InData__aspect = {\n    applyTo(control) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return builtInAspect(control, InData, (ctrl) => afterAll({\n            value: ctrl,\n            mode: ctrl.aspect(InMode),\n        }).do(mapAfter(({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? value\n            : undefined)));\n    },\n};\n/**\n * @category Aspect\n */\nconst InData = {\n    get [InAspect__symbol]() {\n        return InData__aspect;\n    },\n};\n\n/**\n * @internal\n */\nconst InGroup__aspect = {\n    applyTo(control) {\n        return inconvertibleInAspect(control, InGroup);\n    },\n};\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nclass InGroup extends InContainer {\n    static get [InAspect__symbol]() {\n        return InGroup__aspect;\n    }\n    _applyAspect(aspect) {\n        return aspect === InGroup__aspect\n            ? inconvertibleInAspect(this, InGroup, this)\n            : super._applyAspect(aspect);\n    }\n}\n/**\n * Input group controls.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nclass InGroupControls extends InContainerControls {\n    /**\n     * Removes input control with the given key.\n     *\n     * Calling this method is the same as calling `set(key, undefined)`\n     *\n     * @param key - A key of input control to remove. I.e. corresponding model property key.\n     */\n    remove(key) {\n        this.set(key, undefined);\n    }\n}\n/**\n * @internal\n */\nconst inControlReplacedReason$1 = {};\n/**\n * @internal\n */\nclass InGroupSnapshot {\n    constructor(_map) {\n        this._map = _map;\n        this._it = mapIt(overIterator(() => this._map.values()), ([control]) => control);\n        this._entriesIt = mapIt(this._map, ([key, [control]]) => [key, control]);\n    }\n    get(key) {\n        const entry = this._map.get(key);\n        return entry && entry[0];\n    }\n    [Symbol.iterator]() {\n        return this[PushIterator__symbol]();\n    }\n    [PushIterator__symbol](accept) {\n        return this._it[PushIterator__symbol](accept);\n    }\n    entries() {\n        return iteratorOf(this._entriesIt);\n    }\n}\n/**\n * @internal\n */\nclass InGroupMap {\n    constructor(_controls) {\n        this._controls = _controls;\n        this._supply = new Supply();\n        this._map = new Map();\n    }\n    set(key, control, added, removed) {\n        const replaced = this._map.get(key);\n        let supply;\n        if (control) {\n            supply = new Supply();\n            const entry = this.newEntry(key, control, supply);\n            let sendUpdate = true;\n            if (replaced) {\n                if (replaced[0] === control) {\n                    // Do not send update when replacing control with itself\n                    sendUpdate = false;\n                }\n                else {\n                    removed.push([key, replaced]);\n                }\n            }\n            if (sendUpdate) {\n                this.modify().set(key, entry);\n                added.push([key, entry]);\n            }\n            else {\n                this._map.set(key, entry);\n            }\n        }\n        else {\n            supply = neverSupply();\n            if (replaced) {\n                removed.push([key, replaced]);\n                this.modify().delete(key);\n            }\n        }\n        if (replaced) {\n            replaced[1].off(inControlReplacedReason$1);\n        }\n        return supply;\n    }\n    newEntry(key, control, supply) {\n        return [\n            control,\n            new Supply(reason => {\n                if (reason !== inControlReplacedReason$1) {\n                    this._controls.remove(key);\n                }\n            })\n                .needs(this._supply)\n                .needs(supply)\n                .whenOff(reason => supply.off(reason === inControlReplacedReason$1 ? undefined : reason)),\n        ];\n    }\n    modify() {\n        if (this._shot) {\n            const map = new Map();\n            itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n            this._shot = undefined;\n            this._map = map;\n        }\n        return this._map;\n    }\n    snapshot() {\n        return this._shot || (this._shot = new InGroupSnapshot(this._map));\n    }\n    clear() {\n        const added = [];\n        const removed = [];\n        itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n        return removed;\n    }\n}\n/**\n * @internal\n */\nclass InGroupControlControls extends InGroupControls {\n    constructor(_group) {\n        super();\n        this._group = _group;\n        this._updates = new EventEmitter();\n        const applyModelToControls = (model) => {\n            this.read.do(onceAfter)(snapshot => {\n                const withValues = new Set();\n                itsEach(overEntries(model), ([key, value]) => {\n                    withValues.add(key);\n                    const control = snapshot.get(key);\n                    if (control) {\n                        control.it = value;\n                    }\n                });\n                itsEach(snapshot.entries(), ([key, control]) => {\n                    if (!withValues.has(key)) {\n                        control.it = undefined;\n                    }\n                });\n            });\n        };\n        this._map = new InGroupMap(this);\n        this.on = this._updates.on.do(translateOn((send, added, removed) => send(added.map(controlEntryToGroupEntry), removed.map(controlEntryToGroupEntry))));\n        const takeSnapshot = this._map.snapshot.bind(this._map);\n        this.read = this._updates.on.do(mapAfter(takeSnapshot, takeSnapshot));\n        this._map._supply.needs(_group.read(applyModelToControls));\n    }\n    set(keyOrControls, newControl) {\n        const group = this._group;\n        const added = [];\n        const removed = [];\n        let supply;\n        if (typeof keyOrControls === 'object') {\n            supply = new Supply();\n            itsEach(overEntries(keyOrControls), ([key, value]) => {\n                this._map.set(key, value, added, removed).needs(supply);\n            });\n        }\n        else {\n            supply = this._map.set(keyOrControls, newControl, added, removed);\n        }\n        if (added.length || removed.length) {\n            this._updates.send(added, removed);\n            if (added.length) {\n                applyControlsToModel();\n            }\n        }\n        return supply;\n        function applyControlsToModel() {\n            let newModel;\n            added.forEach((keyAndEntry) => {\n                const [key, [control, supply]] = keyAndEntry;\n                control.aspect(InParents).add({ parent: group }).as(supply);\n                const value = control.it;\n                if (newModel) {\n                    newModel[key] = value;\n                }\n                else {\n                    const model = group.it;\n                    if (model[key] !== value) {\n                        newModel = { ...model, [key]: value };\n                    }\n                }\n            });\n            if (newModel) {\n                group.it = newModel;\n            }\n            added.forEach((keyAndEntry) => {\n                const [key, [control, supply]] = keyAndEntry;\n                control.read.do(supplyAfter(supply))(value => {\n                    if (group.it[key] !== value) {\n                        group.it = {\n                            ...group.it,\n                            [key]: value,\n                        };\n                    }\n                }).cuts(supply);\n            });\n        }\n    }\n    clear() {\n        const removed = this._map.clear();\n        if (removed.length) {\n            this._updates.send([], removed);\n        }\n    }\n}\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry([key, [control]]) {\n    return [key, control];\n}\n/**\n * @internal\n */\nclass InGroupControl extends InGroup {\n    constructor(model, opts) {\n        super(opts);\n        this._model = trackValue(model);\n        this.controls = new InGroupControlControls(this);\n        this.supply.whenOff(() => this.controls.clear());\n    }\n    get supply() {\n        return this._model.supply;\n    }\n    get it() {\n        return this._model.it;\n    }\n    set it(value) {\n        this._model.it = value;\n    }\n    get on() {\n        return this._model.on;\n    }\n    _applyAspect(aspect) {\n        if (aspect === InData[InAspect__symbol]) {\n            return {\n                instance: inGroupData(this),\n                convertTo: noop,\n            };\n        }\n        return super._applyAspect(aspect);\n    }\n}\n/**\n * @internal\n */\nfunction inGroupData(group) {\n    return afterAll({\n        cs: group.controls,\n        model: group,\n        mode: group.aspect(InMode),\n    }).do(digAfter_(readInGroupData));\n}\n/**\n * @internal\n */\nfunction readInGroupData({ cs: [controls], model: [model], mode: [mode], }) {\n    if (!InMode.hasData(mode)) {\n        return afterThe();\n    }\n    const csData = {};\n    itsEach(controls.entries(), ([key, control]) => {\n        csData[key] = control.aspect(InData);\n    });\n    return afterAll(csData).do(mapAfter(controlsData => {\n        const data = { ...model };\n        itsEach(overEntries(controlsData), (keyAndControlData) => {\n            const [key, [controlData]] = keyAndControlData;\n            data[key] = controlData;\n        });\n        return data;\n    }));\n}\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n * @param model - Initial model of the group.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nfunction inGroup(model, { aspects, } = {}) {\n    return new InGroupControl(model, { aspects });\n}\n\n/**\n * @internal\n */\nclass InValueControl extends InControl {\n    constructor(initial, opts) {\n        super(opts);\n        this._it = trackValue(initial);\n    }\n    get supply() {\n        return this._it.supply;\n    }\n    get it() {\n        return this._it.it;\n    }\n    set it(value) {\n        this._it.it = value;\n    }\n    get on() {\n        return this._it.on;\n    }\n}\n/**\n * Constructs simple input control.\n *\n * This control does not handle actual user input. Instead, it maintains the value set programmatically.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @param initial - Initial input value.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @returns New input control.\n */\nfunction inValue(initial, { aspects, } = {}) {\n    return new InValueControl(initial, { aspects });\n}\n\n/**\n * @internal\n */\nconst InList__aspect = {\n    applyTo(control) {\n        return inconvertibleInAspect(control, InList);\n    },\n};\n/**\n * An indexed list of input controls.\n *\n * Nested controls can be added and removed via `controls` property.\n *\n * List value (called model) is an array object formed by nested control values. The item property value is the one\n * of the control with the same index, if present. When model is updated corresponding controls are also updated.\n *\n * List is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TItem - Model item type.\n */\nclass InList extends InContainer {\n    static get [InAspect__symbol]() {\n        return InList__aspect;\n    }\n    _applyAspect(aspect) {\n        return aspect === InList__aspect\n            ? inconvertibleInAspect(this, InList, this)\n            : super._applyAspect(aspect);\n    }\n}\n/**\n * Input list controls.\n *\n * @category Control\n * @typeParam TItem - Model item type.\n */\nclass InListControls extends InContainerControls {\n    /**\n     * Sets input control with the given index.\n     *\n     * Replaces existing control if already present.\n     *\n     * @param index - An index of input control to set. I.e. corresponding model item index.\n     * @param control - Input control to add.\n     *\n     * @returns A supply of just added control that removes it once cut off.\n     */\n    set(index, control) {\n        return this.splice(index, 1, control);\n    }\n    /**\n     * Inserts input controls at the given position.\n     *\n     * @param index - An index to insert controls at.\n     * @param controls - Input controls to add after the last one.\n     *\n     * @returns A supply of just inserted controls that removes them once cut off. Cut off supply when no controls\n     * inserted.\n     */\n    insert(index, ...controls) {\n        return this.splice(index, 0, ...controls);\n    }\n    /**\n     * Removes input controls starting at the given index.\n     *\n     * @param start - An index of the first control to remove.\n     * @param end - An index of the control next to the last one to remove. Only one control will be removed if omitted.\n     */\n    remove(start, end) {\n        this.splice(start, end == null ? 1 : end - start);\n    }\n    /**\n     * Removes all input controls.\n     */\n    clear() {\n        this.splice(0);\n    }\n}\n/**\n * @internal\n */\nclass InListSnapshot {\n    constructor(_entries) {\n        this._entries = _entries;\n        this._it = mapArray(this._entries, ([control]) => control);\n        this._entriesIt = overIterator(() => iteratorOf(this._entries.map(([entry], index) => [index, entry])));\n    }\n    get length() {\n        return this._entries.length;\n    }\n    [Symbol.iterator]() {\n        return this[PushIterator__symbol]();\n    }\n    [PushIterator__symbol](accept) {\n        return this._it[PushIterator__symbol](accept);\n    }\n    entries() {\n        return iteratorOf(this._entriesIt);\n    }\n    item(index) {\n        const entry = this._entries[index];\n        return entry && entry[0];\n    }\n}\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n/**\n * @internal\n */\nclass InListEntries {\n    constructor(_controls, initial) {\n        this._controls = _controls;\n        this._supply = new Supply();\n        this._entries = initial.map(control => inListEntry(this, control));\n    }\n    splice(start, deleteCount, controls, added, removed) {\n        let supply = controls.length > 1 ? new Supply() : undefined;\n        const modify = () => {\n            if (this._shot) {\n                this._shot = undefined;\n                this._entries = this._entries.slice();\n            }\n            return this._entries;\n        };\n        const extracted = deleteCount == null\n            ? modify().splice(start)\n            : modify().splice(start, deleteCount, ...controls.map((control, index) => {\n                const entry = inListEntry(this, control);\n                added.push([start + index, entry]);\n                if (supply) {\n                    entry[1].needs(supply);\n                }\n                else {\n                    supply = entry[1];\n                }\n                return entry;\n            }));\n        removed.push(...extracted.map((entry, index) => {\n            entry[1].off(inControlReplacedReason);\n            return [start + index, entry];\n        }));\n        if (!supply) {\n            return neverSupply();\n        }\n        const result = new Supply();\n        supply.needs(result).whenOff(reason => result.off(reason !== inControlReplacedReason ? reason : undefined));\n        return result;\n    }\n    snapshot() {\n        return this._shot || (this._shot = new InListSnapshot(this._entries));\n    }\n}\n/**\n * @internal\n */\nfunction inListEntry(entries, control) {\n    const entry = [\n        control,\n        new Supply(reason => {\n            if (reason !== inControlReplacedReason) {\n                entries._controls.remove(entries._entries.findIndex(e => e === entry));\n            }\n        }).needs(entries._supply),\n    ];\n    return entry;\n}\n/**\n * @internal\n */\nfunction readControlValue(controls, [control, supply]) {\n    control.aspect(InParents).add({ parent: controls._list }).as(supply);\n    control.read({\n        supply,\n        receive: (_ctx, value) => {\n            const index = controls._entries._entries.findIndex(([ctrl]) => ctrl === control);\n            const model = controls._list.it;\n            if (model[index] !== value) {\n                const newModel = controls._list.it.slice();\n                newModel[index] = control.it;\n                controls._list.it = newModel;\n            }\n        },\n    });\n}\n/**\n * @internal\n */\nclass InListControlControls extends InListControls {\n    constructor(_list) {\n        super();\n        this._list = _list;\n        this._updates = new EventEmitter();\n        this._entries = new InListEntries(this, inListControlsByModel(_list.it, 0));\n        const applyModelToControls = {\n            receive: (context, model) => {\n                context.onRecurrent(noop);\n                const entries = this._entries._entries;\n                model.forEach((item, index) => {\n                    const entry = entries[index];\n                    if (entry) {\n                        entry[0].it = item;\n                    }\n                });\n                if (model.length < entries.length) {\n                    // Remove controls without values in model\n                    this.splice(model.length);\n                }\n                else if (model.length > entries.length) {\n                    // Create missing value controls\n                    this.add(...inListControlsByModel(model, entries.length));\n                }\n            },\n        };\n        this._entries._supply.needs(_list.read(applyModelToControls))\n            .needs(this._list)\n            .cuts(this._updates);\n        this.on = this._updates.on.do(translateOn((send, added, removed) => send(added.map(toInListEntry), removed.map(toInListEntry))));\n        const takeSnapshot = this._entries.snapshot.bind(this._entries);\n        this.read = this._updates.on.do(mapAfter(takeSnapshot, takeSnapshot));\n        this._entries._entries.forEach(entry => readControlValue(this, entry));\n    }\n    add(...controls) {\n        return this.splice(this._entries._entries.length, 0, ...controls);\n    }\n    splice(start, deleteCount, ...controls) {\n        const list = this._list;\n        const added = [];\n        const removed = [];\n        const supply = this._entries.splice(start, deleteCount, controls, added, removed);\n        if (added.length || removed.length) {\n            const updated = list.it.slice();\n            updated.splice(start, removed.length, ...added.map(([, [control]]) => control.it));\n            list.it = updated;\n            this._updates.send(added, removed);\n            added.forEach(([, entry]) => readControlValue(this, entry));\n        }\n        return supply;\n    }\n}\n/**\n * @internal\n */\nfunction inListControlsByModel(model, start) {\n    const controls = [];\n    for (let i = start; i < model.length; ++i) {\n        controls.push(inValue(model[i]));\n    }\n    return controls;\n}\n/**\n * @internal\n */\nfunction toInListEntry([key, [control]]) {\n    return [key, control];\n}\n/**\n * @internal\n */\nclass InListControl extends InList {\n    constructor(model, opts) {\n        super(opts);\n        this._model = trackValue(model);\n        this.controls = new InListControlControls(this);\n        this.supply.whenOff(() => this.controls.clear());\n    }\n    get supply() {\n        return this._model.supply;\n    }\n    get it() {\n        return this._model.it;\n    }\n    set it(value) {\n        this._model.it = value;\n    }\n    get on() {\n        return this._model.on;\n    }\n    _applyAspect(aspect) {\n        if (aspect === InData[InAspect__symbol]) {\n            return {\n                instance: inListData(this),\n                convertTo: noop,\n            };\n        }\n        return super._applyAspect(aspect);\n    }\n}\n/**\n * @internal\n */\nfunction inListData(list) {\n    return afterAll({\n        cs: list.controls,\n        mode: list.aspect(InMode),\n    }).do(digAfter_(readInListData));\n}\n/**\n * @internal\n */\nfunction readInListData({ cs: [controls], mode: [mode], }) {\n    if (!InMode.hasData(mode)) {\n        return afterThe();\n    }\n    const csData = mapIt(controls, control => control.aspect(InData));\n    return afterEach(...csData).do(mapAfter((...controlsData) => controlsData.map(([d]) => d).filter(isDefined)));\n}\n/**\n * Constructs input controls list.\n *\n * @category Control\n * @typeParam TItem - Model item type.\n * @param model - Initial model of the list.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nfunction inList(model, { aspects, } = {}) {\n    return new InListControl(model, { aspects });\n}\n\n/**\n * Creates a converter that converts an input control to the one replacing `undefined` value with fallback one.\n *\n * Treats `null` values as `undefined`. Despite the signature does not allow nulls they are often used instead.\n * E.g. when receiving JSON from server.\n *\n * @category Converter\n * @typeParam TValue - Input value type.\n * @param fallback - A fallback value that is used instead of original one when `undefined` (or`null`) is assigned\n * to converted control.\n */\nfunction intoFallback(fallback) {\n    return () => ({\n        set: asis,\n        get(value) {\n            return value != null ? value : fallback;\n        },\n    });\n}\n\n/**\n * @internal\n */\nconst RequireNothing$ = ( /*#__PURE__*/afterThe());\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nfunction requireNothing() {\n    return RequireNothing$;\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validator - Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nfunction inValidator(validator) {\n    if (isEventKeeper(validator)) {\n        return valueProvider(afterSupplied(validator));\n    }\n    if (typeof validator === 'function') {\n        return control => afterSupplied(validator(control));\n    }\n    return control => control.read.do(translateAfter(send => send(...arrayOfElements(validator.validate(control)))));\n}\n\nconst dontRemove = {};\n/**\n * @internal\n */\nclass InValidationMessages {\n    constructor(control) {\n        const emitter = new EventEmitter();\n        const validators = new Map();\n        const validatorMessages = new Map();\n        // Sends validation messages\n        let send = noop;\n        // Validates using the given validator\n        let validate = noop;\n        this._messages = afterEventBy(receiver => {\n            // Validation messages supply\n            const resultSupply = afterSupplied(emitter, valuesProvider())(receiver).whenOff(() => {\n                send = noop; // Disable message sending\n                validate = noop; // Disable validation\n            });\n            // Enable validation using the given validator\n            validate = (validator, validatorSupply) => {\n                const supply = validator((...messages) => {\n                    if (messages.length) {\n                        // Replace messages reported by validator.\n                        validatorMessages.set(validator, messages);\n                    }\n                    else if (!validatorMessages.delete(validator)) {\n                        // Nothing removed. No need to send messages\n                        return;\n                    }\n                    send(); // Send all messages.\n                })\n                    .needs(validatorSupply)\n                    .whenOff(reason => {\n                    if (reason !== dontRemove) {\n                        validatorSupply.off(reason);\n                    }\n                    if (validatorMessages.delete(validator)) {\n                        // Send all messages only if the removed validator reported some messages earlier\n                        send();\n                    }\n                });\n                resultSupply.whenOff(() => supply.off(dontRemove));\n            };\n            // Enable each validator\n            itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n            // Enable message sending\n            send = () => {\n                emitter.send(...allMessages());\n            };\n            // Send messages if present already\n            if (validatorMessages.size) {\n                send();\n            }\n        }).do(shareAfter, supplyAfter(control));\n        this.from = validator => {\n            const source = inValidator(validator)(control);\n            const validatorSupply = new Supply(() => {\n                validators.delete(source);\n            });\n            validators.set(source, validatorSupply);\n            validate(source, validatorSupply); // Start validation using validator\n            return validatorSupply.needs(control);\n        };\n        function allMessages() {\n            return flatMapIt(validatorMessages.values());\n        }\n    }\n    [AfterEvent__symbol]() {\n        return this._messages;\n    }\n}\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validators - Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nfunction requireAll(...validators) {\n    const numValidators = validators.length;\n    if (numValidators === 1) {\n        return validators[0];\n    }\n    if (!numValidators) {\n        return requireNothing;\n    }\n    return (control) => {\n        const messages = new InValidationMessages(control);\n        validators.forEach(validator => messages.from(validator));\n        return messages;\n    };\n}\n\n/**\n * Creates input validator that applies requirements on input text length.\n *\n * Ignores empty input. Reports too short values with `incomplete` and `tooShort` message codes. Reports too long values\n * with `invalid` and `tooLong` message codes.\n *\n * @category Validation\n * @param min - Required minimum length. Not checked if omitted.\n * @param max - Required maximum length. Not checked if omitted.\n *\n * @returns Element validator applicable to text input control.\n */\nfunction requireLength(min, max) {\n    return {\n        validate({ it: { length } }) {\n            if (length) {\n                if (min && length < min) {\n                    return { incomplete: 'tooShort', tooShort: min };\n                }\n                if (max != null && length > max) {\n                    return { invalid: 'tooLong', tooLong: max };\n                }\n            }\n            return;\n        },\n    };\n}\n\n/**\n * @internal\n */\nconst InValidation__aspect = {\n    applyTo(control) {\n        return builtInAspect(control, InValidation, (ctrl, origin) => {\n            const validation = new InControlValidation(ctrl);\n            if (origin) {\n                validation.by(origin.aspect(InValidation).read.do(translateAfter((send, result) => send(...result.messages()))));\n            }\n            return validation;\n        });\n    },\n};\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nclass InValidation {\n    /**\n     * Input validation aspect.\n     */\n    static get [InAspect__symbol]() {\n        return InValidation__aspect;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n}\n/**\n * @internal\n */\nconst noInValidationErrors = {\n    get ok() {\n        return true;\n    },\n    messages() {\n        return [];\n    },\n    has() {\n        return false;\n    },\n    hasBut() {\n        return false;\n    },\n    [Symbol.iterator]() {\n        return overNone();\n    },\n    [PushIterator__symbol](_accept) {\n        return overNone();\n    },\n};\n/**\n * @internal\n */\nclass InValidationErrors {\n    constructor(messages) {\n        this._byCode = new Map();\n        this._all = [];\n        this._it = overArray(this._all);\n        messages.forEach(message => {\n            let nonEmpty = false;\n            itsEach(overEntries(message), ([code, codePresent]) => {\n                if (codePresent) {\n                    nonEmpty = true;\n                    const prev = this._byCode.get(code);\n                    if (prev) {\n                        prev.push(message);\n                    }\n                    else {\n                        this._byCode.set(code, [message]);\n                    }\n                }\n            });\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (nonEmpty) {\n                this._all.push(message);\n            }\n        });\n    }\n    get ok() {\n        return !this._all.length;\n    }\n    messages(code) {\n        return code == null ? this._all : this._byCode.get(code) || [];\n    }\n    has(code) {\n        return code == null || this._byCode.has(code);\n    }\n    hasBut(...codes) {\n        return this._all.some(message => codes.every(code => !message[code]));\n    }\n    [Symbol.iterator]() {\n        return this[PushIterator__symbol]();\n    }\n    [PushIterator__symbol](accept) {\n        return this._it[PushIterator__symbol](accept);\n    }\n}\nfunction inValidationResult(...messages) {\n    return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n/**\n * @internal\n */\nclass InControlValidation extends InValidation {\n    constructor(control) {\n        super();\n        this._messages = new InValidationMessages(control);\n        this.read = afterSupplied(this._messages).do(mapAfter(inValidationResult));\n        const container = control.aspect(InContainer);\n        if (container) {\n            this._messages.from(nestedInValidationMessages(container));\n        }\n    }\n    by(...validators) {\n        return this._messages.from(requireAll(...validators));\n    }\n}\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container) {\n    return container.controls.read.do(digAfter_(controls => afterEach(...mapIt(controls, control => control.aspect(InValidation)))), translateAfter((send, ...results) => send(...flatMapArray(results, ([result]) => result))));\n}\n\n/**\n * Constructs input validator that filters validation messages from the given `validators` according to their codes.\n *\n * The validation messages reported by `validators` are filtered according to the following rules:\n * - If at least one message with `missing` code is reported, then strip out the ones with `incomplete` and `invalid`\n *   codes, except the ones with `despiteMissing` code.\n * - Otherwise, if at least one message with `incomplete` code is reported, then strip out the ones with `invalid`\n *   code, except the ones with `despiteIncomplete` code.\n * - Otherwise report all messages.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validators - Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators` and filters their output.\n */\nfunction requireNeeded(...validators) {\n    const validate = inValidator(requireAll(...validators));\n    return (control) => validate(control).do(translateAfter(nextRequireNeededMessages));\n}\n/**\n * @internal\n */\nfunction nextRequireNeededMessages(send, ...messages) {\n    const result = inValidationResult(...messages);\n    let filtered = result;\n    if (result.has('missing')) {\n        filtered = filterIt(result, \n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        message => !message.incomplete && !message.invalid || message.despiteMissing);\n    }\n    else if (result.has('incomplete')) {\n        filtered = filterIt(result, \n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        message => !message.invalid || message.despiteIncomplete);\n    }\n    return send(...filtered);\n}\n\nfunction requirePresent(control) {\n    return control\n        ? control.read.do(translateAfter((send, value) => value ? send() : send({ missing: 'missing' })))\n        : requirePresent;\n}\n\n/**\n * Creates input validator that applies requirements to numeric value range.\n *\n * Ignores NaN input. Reports too small values with `invalid` and `tooSmall` message codes. Reports too large values\n * with `invalid` and `tooLarge` message codes.\n *\n * @category Validation\n * @param min - Minimum allowed value, inclusive. Not checked if omitted.\n * @param max - Maximum allowed value, inclusive. Not checked if omitted.\n *\n * @returns Element validator applicable to numeric input control.\n */\nfunction requireRange(min, max) {\n    return {\n        validate({ it }) {\n            if (!isNaN(it)) {\n                if (min != null && it < min) {\n                    return { invalid: 'tooSmall', tooSmall: min };\n                }\n                if (max != null && it > max) {\n                    return { invalid: 'tooLarge', tooLarge: max };\n                }\n            }\n            return;\n        },\n    };\n}\n\n/**\n * @category Converter\n */\nconst InParser = {\n    /**\n     * Creates input control converter out of input text parser.\n     *\n     * @typeParam TValue - Parsed input value type.\n     * @param parser - A parser to convert.\n     *\n     * @returns An input control converter that parses and formats text input.\n     */\n    converter(parser) {\n        return (from, to) => {\n            const [parse, format = String] = parser(from, to);\n            const parseValidator = new EventEmitter();\n            to.aspect(InValidation).by(afterSupplied(parseValidator, valuesProvider()));\n            return {\n                set(text) {\n                    const errorList = [];\n                    const parserErrors = {\n                        report(...errors) {\n                            errorList.push(...errors);\n                        },\n                    };\n                    const result = parse(text, parserErrors);\n                    parseValidator.send(...errorList);\n                    return result;\n                },\n                get(value) {\n                    const text = String(format(value));\n                    parseValidator.send();\n                    return text;\n                },\n            };\n        };\n    },\n};\n/**\n * Creates text input control converter that parses and formats input text with the given functions.\n *\n * @category Converter\n * @typeParam TValue - Parsed input value type.\n * @param parse - Text parser function. Accepts input text and parse errors as its parameters and returns parsed value.\n * @param format - Text formatter. Accepts value is its only parameter and returns formatted text. Standard to string\n * conversion is used if omitted.\n *\n * @returns New input converter.\n */\nfunction intoParsedBy(parse, format) {\n    return InParser.converter(valueProvider([parse, format]));\n}\n\n/**\n * @internal\n */\nconst notInteger = 'notInteger';\nfunction intoInteger(radixOrFrom = 10, optTo) {\n    if (typeof radixOrFrom !== 'number') {\n        return intoInteger()(radixOrFrom, optTo);\n    }\n    return InParser.converter((_from, to) => [\n        (text, errors) => {\n            const result = parseInt(text, radixOrFrom);\n            if (isNaN(result)) {\n                errors.report({ invalid: notInteger, NaN: notInteger, notInteger });\n            }\n            return result;\n        },\n        value => (to.it = Math.floor(value)).toString(radixOrFrom),\n    ]);\n}\n\nfunction intoTrimmed(_from, to) {\n    if (!to) {\n        return intoTrimmed;\n    }\n    return {\n        set(value) {\n            return value.trim();\n        },\n        get(value) {\n            return to.it = value.trim();\n        },\n    };\n}\n\n/**\n * @internal\n */\nconst InSubmit__aspect = {\n    applyTo(control) {\n        return builtInAspect(control, InSubmit, ctrl => new InControlSubmit(ctrl));\n    },\n};\n/**\n * Input submit error.\n *\n * Contains submit messages as validation result.\n *\n * @category Aspect\n */\nclass InSubmitError extends Error {\n    /**\n     * Constructs input submit error.\n     *\n     * @param errors - Input submit error messages. A `submit` code will be added to each of them, unless already present.\n     */\n    constructor(...errors) {\n        super();\n        this.errors = inValidationResult(...errors.map(message => message.submit ? message : { ...message, submit: true }));\n    }\n}\n/**\n * Input submit rejection error.\n *\n * Raised if submit is not ready or in process already.\n *\n * @category Aspect\n */\nclass InSubmitRejectedError extends InSubmitError {\n    /**\n     * Constructs input submit rejection error.\n     *\n     * @param reason - A reason code.\n     */\n    constructor(reason) {\n        super({ submit: 'rejected', rejected: reason, [reason]: true });\n    }\n}\n/**\n * Input submit aspect.\n *\n * Allows to submit {@link InData input data} and reports submit status.\n *\n * Implements an `EventKeeper` interface by sending submit status flags to registered receivers.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nclass InSubmit {\n    static get [InAspect__symbol]() {\n        return InSubmit__aspect;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n}\nclass InControlSubmit extends InSubmit {\n    constructor(_control) {\n        super();\n        this._control = _control;\n        this._flags = trackValue({ submitted: false, busy: false });\n        this._errors = trackValue([]);\n        this.read = afterAll({\n            flags: this._flags,\n            data: this._control.aspect(InData),\n            messages: this._control.aspect(InValidation),\n        }).do(supplyAfter(this._control), mapAfter(({ flags: [flags], data: [data], messages: [messages], }) => ({\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            ready: data !== undefined && (messages.ok || itsEvery(messages, message => message.submit)),\n            submitted: flags.submitted,\n            busy: flags.busy,\n        })));\n        const validation = _control.aspect(InValidation);\n        validation.by(this._errors.read.do(translateAfter((send, messages) => send(...messages))));\n    }\n    async submit(submitter) {\n        if (this._control.supply.isOff) {\n            throw new InSubmitRejectedError('noInput');\n        }\n        if (this._flags.it.busy) {\n            throw new InSubmitRejectedError('busy');\n        }\n        const submit = this;\n        const control = this._control;\n        let errors;\n        this._flags.it = { ...this._flags.it, submitted: true, busy: true };\n        try {\n            if (this._errors.it.length) {\n                this._errors.it = [];\n            }\n            return await submitter(await submitData(), control);\n        }\n        catch (error) {\n            errors = toInSubmitMessages(error);\n            throw error;\n        }\n        finally {\n            this._flags.it = { ...this._flags.it, busy: false };\n            if (errors) {\n                this._errors.it = errors;\n            }\n        }\n        async function submitData() {\n            const { data: [d], flags: [{ ready }] } = await afterAll({\n                data: control.aspect(InData),\n                flags: submit,\n            });\n            return ready\n                ? d\n                : Promise.reject(new InSubmitRejectedError('notReady'));\n        }\n    }\n    reset() {\n        const flags = this._flags.it;\n        if (flags.submitted) {\n            this._flags.it = { ...flags, submitted: false };\n        }\n        if (this._errors.it.length) {\n            this._errors.it = [];\n        }\n    }\n}\n/**\n * @internal\n */\nfunction toInSubmitMessages(error) {\n    if (error instanceof InSubmitError) {\n        return [...error.errors];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    return [{ submit: error }];\n}\n\n/**\n * Creates an {@link InMode input mode} source depending on the given `form` control status.\n *\n * This can be applied e.g. to {@link InSubmitButton submit button}, to {@link InFormElement form element},\n * or to input controls. The defaults best suit the latter.\n *\n * @category Aspect\n * @param form - Form control the evaluated mode depends on. Should not be the same as the target control!\n * @param notReady - Input mode to set when submit is not ready. E.g. when input is invalid.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param invalid - Input mode to set when submit is not ready _and_ the form is submitted.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param busy - Input mode to set while submitting. `ro` (read-only) by default. An `off` (disabled) value is a better\n * choice for submit button.\n *\n * @returns A source of input mode.\n */\nfunction inModeByForm(form, { notReady = 'on', invalid = 'on', busy = 'ro', } = {}) {\n    const submit = form.aspect(InSubmit);\n    return submit.read.do(mapAfter(flags => inModeValue(flags.busy ? busy : 'on', flags.ready ? 'on' : (flags.submitted ? invalid : notReady))));\n}\n\n/**\n * Creates an {@link InMode input mode} source depending on control's {@link InValidation validity}.\n *\n * This can be applied to form control to prevent submission of invalid input.\n *\n * @category Aspect\n * @param invalid - Input mode to set when the input is invalid. `-on` (not submittable) by default. This\n * should not be set to disabled, as the latter would make it impossible to fix input errors.\n * @param ignore - Ignored message codes. If all validation messages have this code the form is not marked as invalid.\n * `submit` by default, as this code intended to be server-side.\n *\n * @returns A source of input mode.\n */\nfunction inModeByValidity({ invalid = '-on', ignore = 'submit', } = {}) {\n    return control => control.aspect(InValidation).read.do(mapAfter(validity => validity.hasBut(...(typeof ignore === 'string' ? [ignore] : ignore)) ? invalid : 'on'));\n}\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nclass AbstractInElement extends InElement {\n    /**\n     * Constructs HTML input element control.\n     *\n     * @param element - HTML input element the constructed control is based on.\n     * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n     * from the {@link inValueOf same-valued one}.\n     * @param get - Input value getter.\n     * @param set - Input value setter.\n     */\n    constructor(element, { aspects, get, set, }) {\n        super({ aspects });\n        this.element = element;\n        this._input = new EventEmitter();\n        const self = this;\n        this._get = get;\n        this._set = set;\n        this._value = this.it;\n        const doUpdate = this._update = (value, oldValue) => update({ value }, oldValue);\n        this.events = new DomEventDispatcher(element);\n        this.events.supply.needs(this);\n        this.listenForInput(input => update(input, this._value));\n        this.on = this._input.on.do(translateOn((send, { value: newValue }, oldValue) => newValue !== oldValue && send(newValue, oldValue)));\n        this.input = this._input.on.do(mapAfter(asis, () => ({ value: this.it })));\n        function update(input, oldValue) {\n            for (;;) {\n                self._value = input.value;\n                // Corrections are value updates performed by update event receivers\n                // The last correction is recorded and sent later, when all receivers receive current update\n                let correction;\n                // Record corrections\n                self._update = (newValue, old) => {\n                    // Corrections retain the event instance\n                    correction = [{ ...input, value: newValue }, old];\n                };\n                try {\n                    self._input.send(input, oldValue);\n                }\n                finally {\n                    self._update = doUpdate;\n                }\n                if (!correction) {\n                    break; // No more corrections\n                }\n                // Apply last correction\n                // noinspection JSUnusedAssignment\n                [input, oldValue] = correction;\n            }\n        }\n    }\n    get supply() {\n        return this._input.supply;\n    }\n    get it() {\n        return this._get();\n    }\n    set it(value) {\n        const oldValue = this.it;\n        if (value !== oldValue) {\n            this._set(value);\n            this._update(this._get(), oldValue);\n        }\n    }\n    /**\n     * Enables reaction to input input.\n     *\n     * By default listens for `input` and `change` events.\n     *\n     * @param update - Updates current value by user input and sends update event. This function is to be called by\n     * input event listeners.\n     */\n    listenForInput(update) {\n        const onInput = (event) => update({ value: this.it, event });\n        this.events.on('input')(onInput);\n        this.events.on('change')(onInput);\n    }\n}\n\nfunction inCheckbox(element, { checked = true, unchecked = false, intermediate = undefined, aspects, } = {}) {\n    return new AbstractInElement(element, {\n        get() {\n            return this.element.intermediate\n                ? intermediate\n                : this.element.checked ? checked : unchecked;\n        },\n        set(value) {\n            this.element.checked = value === checked;\n            this.element.intermediate = value !== checked && value !== unchecked;\n        },\n        aspects,\n    });\n}\n\n/**\n * @internal\n */\nclass InRadioControl extends AbstractInElement {\n    constructor(element, { checked = true, aspects, } = {}) {\n        super(element, {\n            aspects,\n            get() {\n                return this.element.checked ? checked : undefined;\n            },\n            set(value) {\n                this.element.checked = value === checked;\n            },\n        });\n    }\n    _applyAspect(aspect) {\n        if (aspect === InMode[InAspect__symbol]) {\n            return applyRadioInMode(this);\n        }\n        return super._applyAspect(aspect);\n    }\n}\n/**\n * @internal\n */\nfunction applyRadioInMode(radio) {\n    const { instance: mode } = InMode[InAspect__symbol].applyTo(radio);\n    mode.derive(radio.read.do(mapAfter(value => value !== undefined ? 'on' : '-on')));\n    return knownInAspect(mode);\n}\nfunction inRadio(element, values) {\n    return new InRadioControl(element, values);\n}\n\n/**\n * @internal\n */\nclass InRadioGroupControl extends InControl {\n    constructor(_buttons, { unchecked, aspects, } = {}) {\n        super({ aspects });\n        this._buttons = _buttons;\n        this._unchecked = unchecked;\n        const read = afterAll(_buttons).do(mapAfter(values => checkedInValue(values, unchecked)));\n        this._it = trackValue(unchecked).by(read);\n        this._it.on(value => {\n            itsEach(overEntries(_buttons), ([key, button]) => {\n                button.it = value === key || undefined;\n            });\n        });\n    }\n    get supply() {\n        return this._it.supply;\n    }\n    get it() {\n        return this._it.it;\n    }\n    set it(value) {\n        this._it.it = value != null && this._buttons[value] ? value : this._unchecked;\n    }\n    get on() {\n        return this._it.on;\n    }\n}\n/**\n * @internal\n */\nfunction checkedInValue(values, unchecked) {\n    let checked = unchecked;\n    itsEvery(overEntries(values), ([key, [value]]) => {\n        if (value === undefined) {\n            return true;\n        }\n        checked = key;\n        return false;\n    });\n    return checked;\n}\nfunction inRadioGroup(buttons, values) {\n    return new InRadioGroupControl(buttons, values);\n}\n\n/**\n * Creates input control for the given select element.\n *\n * The value of this control is an array of selected option values. This is particularly useful for `<select multiple>`\n * elements. Consider to use `inText()` for single-selects.\n *\n * @category Control\n * @param element - Target select element.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New select input control instance.\n */\nfunction inSelect(element, { aspects, } = {}) {\n    return new AbstractInElement(element, {\n        aspects,\n        get() {\n            return itsElements(valueArray(this.element.options, option => option.selected && option.value));\n        },\n        set(value) {\n            const selected = new Set(value);\n            // Iterate in reverse order to ensure the first matching option is selected\n            // when `multiple` attribute isn't set.\n            itsEach(reverseArray(this.element.options), option => option.selected = selected.has(option.value));\n        },\n    });\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element - Target text input element.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nfunction inText(element, { aspects, } = {}) {\n    return new AbstractInElement(element, {\n        get() {\n            return this.element.value;\n        },\n        set(value) {\n            this.element.value = value;\n        },\n        aspects,\n    });\n}\n\n/**\n * @internal\n */\nconst InFocus__aspect = {\n    applyTo(control) {\n        return builtInAspect(control, InFocus, ctrl => {\n            const element = ctrl.aspect(InElement);\n            return element && new InControlFocus(element);\n        });\n    },\n};\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when {@link InElement} aspect is absent.\n *\n * @category Aspect\n */\nclass InFocus extends ValueTracker {\n    static get [InAspect__symbol]() {\n        return InFocus__aspect;\n    }\n}\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n    constructor(inElement) {\n        super();\n        const { element, events } = inElement;\n        const owner = element.getRootNode\n            ? element.getRootNode()\n            : element.ownerDocument;\n        this._it = trackValue(owner.activeElement === element);\n        this.supply.needs(inElement);\n        events.on('focus')(() => this._it.it = true);\n        events.on('blur')(() => this._it.it = false);\n        this.on({\n            receive(ctx, newValue) {\n                ctx.onRecurrent(noop);\n                if (newValue) {\n                    element.focus();\n                }\n                else {\n                    element.blur();\n                }\n            },\n        });\n    }\n    get supply() {\n        return this._it.supply;\n    }\n    get it() {\n        return this._it.it;\n    }\n    set it(value) {\n        this._it.it = value;\n    }\n    get on() {\n        return this._it.on;\n    }\n}\n\n/**\n * @internal\n */\nconst InStatus__aspect = {\n    applyTo(control) {\n        return builtInAspect(control, InStatus, ctrl => {\n            const container = ctrl.aspect(InContainer);\n            return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n        });\n    },\n};\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nclass InStatus {\n    static get [InAspect__symbol]() {\n        return InStatus__aspect;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n}\n/**\n * @internal\n */\nconst defaultInStatusFlags = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n};\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n    constructor(control) {\n        super();\n        this._flags = trackValue(defaultInStatusFlags);\n        this._flags.supply.needs(control);\n        this._flags.by(elementInStatusFlags(this._flags, control));\n    }\n    get read() {\n        return this._flags.read;\n    }\n    markTouched(touched = true) {\n        const flags = this._flags.it;\n        if (!touched) {\n            if (flags.touched) {\n                // Try to reset touched.\n                // Still touched if in focus. Not edited anyway.\n                this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n            }\n        }\n        else if (!flags.touched) {\n            // Do not modify if already touched.\n            this._flags.it = { ...flags, touched };\n        }\n        return this;\n    }\n    markEdited(edited = true) {\n        const flags = this._flags.it;\n        if (edited) {\n            if (!flags.edited) {\n                // Touched if edited\n                this._flags.it = { ...flags, touched: true, edited };\n            }\n        }\n        else if (flags.edited) {\n            // Assume not edited\n            this._flags.it = { ...flags, edited };\n        }\n        return this;\n    }\n}\n/**\n * @internal\n */\nfunction elementInStatusFlags(origin, control) {\n    const element = control.aspect(InElement);\n    const focus = control.aspect(InFocus);\n    return afterAll({\n        hasFocus: focus || afterThe(false),\n        edited: element ? element.input.do(mapAfter(({ event }) => !!event)) : afterThe(false),\n    }).do(mapAfter(({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited)));\n}\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags, hasFocus, edited) {\n    if (hasFocus) {\n        flags = { ...flags, hasFocus, touched: true };\n    }\n    else {\n        flags = { ...flags, hasFocus };\n    }\n    if (edited) {\n        flags = { ...flags, edited, touched: true };\n    }\n    return flags;\n}\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n    constructor(_container) {\n        super();\n        this._container = _container;\n        this.read = containerInStatusFlags(this._container);\n    }\n    markEdited(edited) {\n        this._container.controls.read.do(onceAfter)(snapshot => itsEach(snapshot, control => control.aspect(InStatus).markEdited(edited)));\n        return this;\n    }\n    markTouched(touched) {\n        this._container.controls.read.do(onceAfter)(snapshot => itsEach(snapshot, control => control.aspect(InStatus).markTouched(touched)));\n        return this;\n    }\n}\n/**\n * @internal\n */\nfunction containerInStatusFlags(container) {\n    return container.controls.read.do(supplyAfter(container), digAfter_((snapshot) => afterEach(...inControlStatuses(snapshot))), mapAfter(combineInStatusFlags));\n}\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot) {\n    return mapIt(snapshot, c => c.aspect(InStatus));\n}\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags) {\n    const result = {\n        hasFocus: false,\n        touched: false,\n        edited: false,\n    };\n    itsEach(flags, (([{ hasFocus, touched, edited }]) => {\n        if (touched) {\n            result.touched = true;\n        }\n        if (hasFocus) {\n            result.hasFocus = result.touched = true;\n        }\n        if (edited) {\n            result.edited = result.touched = true;\n        }\n    }));\n    return result;\n}\n\n/**\n * Creates form element control.\n *\n * @category Control\n * @param element - HTML element to create control for.\n * @param options - Form element control options.\n *\n * @returns New form element control.\n */\nfunction inFormElement(element, options) {\n    const { form, aspects, modes } = options;\n    const control = new AbstractInElement(element, {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n    });\n    control.supply.needs(form);\n    return control.setup(InMode, mode => mode.derive(inModeByForm(form, modes)));\n}\n\n/**\n * Creates submit button control.\n *\n * @category Control\n * @param element - Submit button element to create control for.\n * @param options - Submit button control options.\n *\n * @returns New submit button control.\n */\nfunction inSubmitButton(element, options) {\n    const { form, aspects, modes: { notReady = 'on', invalid = 'off', busy = 'off' } = {} } = options;\n    const control = new AbstractInElement(element, {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n    });\n    control.supply.needs(form);\n    control.setup(InMode, mode => mode.derive(inModeByForm(form, { notReady, invalid, busy })));\n    return control;\n}\n\n/**\n * @internal\n */\nconst InStyledElement__aspect = {\n    applyTo(control) {\n        const element = control.aspect(InElement);\n        return element ? knownInAspect(element.element) : nullInAspect();\n    },\n};\n/**\n * @category Aspect\n */\nconst InStyledElement = {\n    get [InAspect__symbol]() {\n        return InStyledElement__aspect;\n    },\n    /**\n     * Creates input control aspect converter that assigns the given styled element to converted control.\n     *\n     * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n     * element wrappers (such as `form-group` in Bootstrap).\n     *\n     * @typeParam TValue - Converted control value type.\n     * @param element - A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n     *\n     * @returns Input control aspect converter.\n     */\n    to(element = null) {\n        return {\n            applyAspect(aspect) {\n                return aspect === InStyledElement__aspect\n                    ? knownInAspect(element)\n                    : undefined;\n            },\n        };\n    },\n};\n\n/**\n * @internal\n */\nconst InCssClasses__aspect = {\n    applyTo(control) {\n        return {\n            instance: new InControlCssClasses(control),\n            convertTo: noop,\n        };\n    },\n};\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nclass InCssClasses {\n    static get [InAspect__symbol]() {\n        return InCssClasses__aspect;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n}\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = ( /*#__PURE__*/Symbol('reason'));\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason) {\n    return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n    constructor(_control) {\n        super();\n        this._control = _control;\n        this._sources = trackValue([new Map()]);\n        _control.supply.whenOff(reason => this.done(reason));\n        this.read = this._sources.read.do(supplyAfter(this._control), digAfter_(([sources]) => afterEach(...sources.keys())), mapAfter_((...classes) => {\n            const result = {};\n            classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n            return result;\n        }));\n        this.track = afterEventBy(receiver => {\n            receiver.supply.needs(this._control);\n            const classes = new DeltaSet();\n            const emitter = new EventNotifier();\n            let classesSent = false;\n            const sendClasses = () => {\n                classesSent = true;\n                classes.redelta((add, remove) => emitter.send(add, remove)).undelta();\n            };\n            emitter.on(receiver);\n            return this.read(map => {\n                const remove = new Set(classes);\n                const add = [];\n                itsEach(filterIt(overEntries(map), ([, flag]) => !!flag), ([name]) => {\n                    if (!remove.delete(name)) {\n                        add.push(name);\n                    }\n                });\n                if (!classesSent || add.length || remove.size) {\n                    classes.delta(add, remove);\n                    sendClasses();\n                }\n            });\n        });\n        const element = _control.aspect(InStyledElement);\n        if (element) {\n            this.applyTo(element, this.schedule);\n        }\n    }\n    get schedule() {\n        return this._schedule || (this._schedule = controlSchedule(this._control, this._control.aspect(InStyledElement)));\n    }\n    specs(source) {\n        return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n    }\n    resolve(source) {\n        const nsAlias = this._control.aspect(InNamespaceAliaser);\n        return this.specs(source).do(mapAfter((...names) => {\n            const result = {};\n            names.forEach(name => {\n                if (isQualifiedName(name)) {\n                    result[css__naming.name(name, nsAlias)] = true;\n                }\n                else {\n                    mergeInCssClassesMap(name, result);\n                }\n            });\n            return result;\n        }));\n    }\n    add(source) {\n        const inSupply = this._control.supply;\n        if (inSupply.isOff) {\n            return inSupply;\n        }\n        const classesSupply = new Supply();\n        const src = afterEventBy(receiver => {\n            const supply = this.resolve(source)({\n                receive(context, ...event) {\n                    receiver.receive(context, ...event);\n                },\n            });\n            receiver.supply.whenOff(reason => {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n            });\n            classesSupply.needs(supply).whenOff(reason => {\n                if (isUnsubscribeReason(reason)) {\n                    supply.off(reason[UnsubscribeReason__symbol]);\n                }\n            });\n        }).do(shareAfter);\n        const [sources] = this._sources.it;\n        sources.set(src, classesSupply);\n        classesSupply.whenOff(reason => {\n            if (!isUnsubscribeReason(reason)) {\n                sources.delete(src);\n                this._sources.it = [sources];\n            }\n        });\n        this._sources.it = [sources];\n        return classesSupply.needs(inSupply);\n    }\n    applyTo(element, schedule = controlSchedule(this._control, element)) {\n        const { classList } = element;\n        const classes = new DeltaSet();\n        const updateClasses = () => {\n            classes.redelta((add, remove) => {\n                classList.remove(...remove);\n                classList.add(...add);\n            }).undelta();\n        };\n        return this.track((add, remove) => {\n            classes.delta(add, remove);\n            schedule(updateClasses);\n        }).whenOff(() => {\n            if (classes.size) {\n                classes.clear();\n                schedule(updateClasses);\n            }\n        });\n    }\n    done(reason) {\n        itsEach(this._sources.it[0].values(), supply => supply.off(reason));\n        this._sources.supply.off(reason);\n        return this;\n    }\n}\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map, result) {\n    itsEach(overEntries(map), ([name, flag]) => {\n        if (flag != null) {\n            result[name] = flag;\n        }\n    });\n}\n/**\n * @internal\n */\nfunction controlSchedule(control, node) {\n    return control.aspect(InRenderScheduler)({ node });\n}\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark - Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input aspects namespace} is used by default.\n * @param when - {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nfunction inCssError({ mark, when, } = {}) {\n    let hasError;\n    if (!when) {\n        hasError = defaultInCssHasError;\n    }\n    else if (Array.isArray(when)) {\n        hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n    }\n    else {\n        hasError = errors => errors.has(when);\n    }\n    return control => control.aspect(InValidation).read.do(translateAfter((send, errors) => hasError(errors) ? send(...inCssErrorMarks(mark)) : send()));\n}\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors) {\n    return !errors.ok;\n}\n/**\n * @internal\n */\nconst defaultInCssErrorMarks = [['has-error', InputAspects__NS]];\n/**\n * @internal\n */\nfunction inCssErrorMarks(mark) {\n    if (!mark) {\n        return defaultInCssErrorMarks;\n    }\n    const marks = arrayOfElements(mark);\n    return marks.length ? marks : defaultInCssErrorMarks;\n}\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `has-focus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns - A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nfunction inCssInfo({ ns = InputAspects__NS, } = {}) {\n    return (control) => {\n        const cls = (name) => [name, ns];\n        return afterAll({\n            md: control.aspect(InMode),\n            vl: control.aspect(InValidation),\n            st: control.aspect(InStatus),\n        }).do(translateAfter((send, { md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n            const names = [];\n            if (!InMode.hasData(mode)) {\n                names.push(cls('disabled'));\n            }\n            if (mode === 'ro' || mode === '-ro') {\n                names.push(cls('readonly'));\n            }\n            if (!valid.ok) {\n                names.push(cls('invalid'));\n            }\n            if (valid.has('missing')) {\n                names.push(cls('missing'));\n            }\n            if (valid.has('incomplete')) {\n                names.push(cls('incomplete'));\n            }\n            if (hasFocus) {\n                names.push(cls('has-focus'));\n            }\n            if (touched) {\n                names.push(cls('touched'));\n            }\n            if (edited) {\n                names.push(cls('edited'));\n            }\n            send(...names);\n        }));\n    };\n}\n\nexport { AbstractInElement, InAspect__symbol, InBuilder, InContainer, InContainerControls, InControl, InCssClasses, InData, InElement, InFocus, InGroup, InGroupControls, InList, InListControls, InMode, InNamespaceAliaser, InParents, InParser, InRenderScheduler, InRole, InStatus, InStyledElement, InSubmit, InSubmitError, InSubmitRejectedError, InValidation, InputAspects__NS, builtInAspect, inCheckbox, inCssError, inCssInfo, inFormElement, inGroup, inList, inModeByForm, inModeByValidity, inModeValue, inRadio, inRadioGroup, inSelect, inSubmitButton, inText, inValidationResult, inValidator, inValue, inValueOf, inconvertibleInAspect, intoConvertedAspects, intoConvertedBy, intoFallback, intoInteger, intoParsedBy, intoTrimmed, isInAspectConversion, knownInAspect, nullInAspect, requireAll, requireLength, requireNeeded, requireNothing, requirePresent, requireRange };\n//# sourceMappingURL=input-aspects.js.map\n","import { AfterEvent__symbol, mapAfter, supplyAfter, digAfter_, afterValue, deduplicateAfter_, digAfter, afterThe, afterAll, consumeEvents } from '@proc7ts/fun-events';\nimport { noop, valueRecipe, asis, valuesProvider, lazyValue, arrayOfElements } from '@proc7ts/primitives';\nimport { Shareable, Share, Share__symbol, shareLocator, Shared } from '@wesib/generic';\nimport { InNamespaceAliaser, knownInAspect, InRenderScheduler, InBuilder, InGroup, inFormElement, InAspect__symbol, inconvertibleInAspect, nullInAspect, InRole, inCssInfo, InCssClasses, inCssError, inModeByValidity, InMode, InParents } from '@frontmeans/input-aspects';\nimport { ContextKey__symbol, ContextSupply, Contextual__symbol, ContextBuilder__symbol } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { DefaultNamespaceAliaser, ComponentRenderScheduler, FeatureDef__symbol, ComponentMember } from '@wesib/wesib';\nimport { neverSupply, Supply } from '@proc7ts/supply';\nimport { handleDomEvents } from '@frontmeans/dom-events';\nimport { isAmendatory, allAmender, newAmendTarget } from '@proc7ts/amend';\nimport { itsEach } from '@proc7ts/push-iterator';\n\n/**\n * @internal\n */\nconst DefaultFormPreset = {\n    setupField({ sharer, control }) {\n        DefaultFormPreset$setup(sharer, control);\n    },\n    setupForm({ sharer, control, element }) {\n        DefaultFormPreset$setup(sharer, control);\n        DefaultFormPreset$setup(sharer, element);\n    },\n};\nfunction DefaultFormPreset$setup(sharer, builder) {\n    const nsAliaser = sharer.get(DefaultNamespaceAliaser);\n    const renderScheduler = sharer.get(ComponentRenderScheduler);\n    builder\n        .addAspect(InNamespaceAliaser, {\n        applyAspect(_aspect) {\n            return knownInAspect(nsAliaser);\n        },\n    }).addAspect(InRenderScheduler, {\n        applyAspect(_aspect) {\n            return knownInAspect(renderScheduler);\n        },\n    });\n}\n\nclass FormPresetKey extends ContextUpKey {\n    constructor() {\n        super('form-preset');\n    }\n    get upKey() {\n        return this;\n    }\n    grow(slot) {\n        slot.insert(new FormPreset(slot.seed.do(mapAfter((...specs) => FormPreset.combine(...specs, DefaultFormPreset)), supplyAfter(slot.context.get(ContextSupply)))));\n    }\n}\nconst FormPreset__key = ( /*#__PURE__*/new FormPresetKey());\nconst FormPreset$rules__symbol = ( /*#__PURE__*/Symbol('FormPreset.rules'));\n/**\n * Form controls preset.\n *\n * Any number of presets can be {@link FormPreset.Spec specified} in component context to be applies to forms\n * and fields. They would be combined into single preset available in component context.\n */\nclass FormPreset {\n    /**\n     * Constructs form preset.\n     *\n     * @param rules - An `AfterEvent` keeper of form preset {@link FormPreset.Rules rules}.\n     */\n    constructor(rules) {\n        this.rules = rules;\n        rules(rules => {\n            this[FormPreset$rules__symbol] = rules;\n        });\n    }\n    /**\n     * A key of component context value containing default form preset combined from all provided {@link FormPreset.Spec\n     * specifiers}.\n     *\n     * As a bare minimum it attaches the following aspects to controls:\n     *\n     * - `InRenderScheduler` set to `ElementRenderScheduler`,\n     * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n     */\n    static get [ContextKey__symbol]() {\n        return FormPreset__key;\n    }\n    /**\n     * Combines form preset specifiers.\n     *\n     * @param specs - Form preset specifiers to combine.\n     *\n     * @returns Form preset rules instance combining the given specifiers.\n     */\n    static combine(...specs) {\n        return {\n            setupField: FormPreset$setupField(specs),\n            setupForm: FormPreset$setupForm(specs),\n        };\n    }\n    /**\n     * Builds an `AfterEvent` keeper of this form preset {@link FormPreset.Rules rules}.\n     */\n    [AfterEvent__symbol]() {\n        return this.rules;\n    }\n    /**\n     * Sets up form field controls.\n     *\n     * @param builder - Target field builder.\n     */\n    setupField(builder) {\n        this[FormPreset$rules__symbol].setupField(builder);\n    }\n    /**\n     * Sets up form controls.\n     *\n     * @param builder - Target form builder.\n     */\n    setupForm(builder) {\n        this[FormPreset$rules__symbol].setupForm(builder);\n    }\n}\nfunction FormPreset$setupField(specs) {\n    return specs.reduce((prev, spec) => spec.setupField\n        ? (builder) => {\n            prev(builder);\n            spec.setupField(builder);\n        }\n        : prev, FormPreset$noFieldSetup);\n}\nfunction FormPreset$noFieldSetup(_builder) {\n    // No field setup\n}\nfunction FormPreset$setupForm(specs) {\n    return specs.reduce((prev, spec) => spec.setupForm\n        ? (builder) => {\n            prev(builder);\n            spec.setupForm(builder);\n        }\n        : prev, FormPreset$noFormSetup);\n}\nfunction FormPreset$noFormSetup(_builder) {\n    // No form setup\n}\n\n/**\n * Abstract unit of input {@link Form form}.\n *\n * Represents a form or its field control and contains its value.\n *\n * @typeParam TValue - Input value type.\n * @typeParam TControls - A type of input controls this unit represents.\n * @typeParam TSharer - Unit sharer component type.\n */\nclass FormUnit extends Shareable {\n    /**\n     * Constructs form unit.\n     *\n     * @param controls - Either input controls, or their provider.\n     */\n    constructor(// eslint-disable-line @typescript-eslint/no-useless-constructor\n    controls) {\n        super(controls);\n    }\n    /**\n     * Input control of the field, if present.\n     */\n    get control() {\n        var _a;\n        return (_a = this.body) === null || _a === void 0 ? void 0 : _a.control;\n    }\n    [Contextual__symbol](sharer) {\n        super[Contextual__symbol](sharer);\n        this.read(noop).needs(sharer); // Create controls eagerly.\n        return this;\n    }\n}\n\n/**\n * A field of the user input {@link Form form}.\n *\n * A component {@link FieldShare shares} field (e.g. using {@link SharedField @SharedField} decorator) to make it\n * accessible by component itself and nested ones. E.g. to add it to {@link Form form} or to manipulate its value.\n *\n * The field instance is not usable until it is bound to its sharer component. The latter is done automatically when\n * the field is shared by {@link FieldShare}.\n *\n * @typeParam TValue - Field value type.\n * @typeParam TSharer - Field sharer component type.\n */\nclass Field extends FormUnit {\n    /**\n     * Creates a form field by the given field control factory.\n     *\n     * @param factory - Field control factory.\n     *\n     * @returns New field instance.\n     */\n    static by(factory) {\n        return new this(this.providerBy(factory));\n    }\n    /**\n     * Creates a form field controls provider by the given control factory.\n     *\n     * @param factory - Field control factory.\n     *\n     * @returns New form field controls provider.\n     */\n    static providerBy(factory) {\n        return builder => ({\n            control: builder.control.build(factory),\n        });\n    }\n    /**\n     * Constructs form field.\n     *\n     * @param controls - Either a field controls instance, or its provider.\n     */\n    constructor(controls) {\n        super(Field$provider(() => this, valueRecipe(controls)));\n    }\n    toString() {\n        return 'Field';\n    }\n}\nfunction Field$provider(field, provider) {\n    return sharer => sharer.get(FormPreset).rules.do(digAfter_(preset => {\n        const builder = {\n            sharer,\n            field: field(),\n            control: new InBuilder(),\n        };\n        preset.setupField(builder);\n        return afterValue(provider(builder));\n    }), deduplicateAfter_(Field$isDuplicateControls, ([controls]) => controls), mapAfter(controls => controls && { field: field(), control: controls.control }));\n}\nfunction Field$isDuplicateControls(prior, next) {\n    if ((prior === null || prior === void 0 ? void 0 : prior.control) !== (next === null || next === void 0 ? void 0 : next.control)) {\n        prior === null || prior === void 0 ? void 0 : prior.control.supply.off();\n        return false;\n    }\n    return true;\n}\n\nconst FieldShare$map = ( /*#__PURE__*/new WeakMap());\n/**\n * A kind of component share containing a {@link Field form field}.\n *\n * This class may be inherited to represent a specific type of forms. E.g. to distinguish multiple fields defined\n * within the same component.\n *\n * @typeParam TValue - Field value type.\n */\nclass FieldShare extends Share {\n    /**\n     * Default field share instance.\n     */\n    static get [Share__symbol]() {\n        let instance = FieldShare$map.get(this);\n        if (!instance) {\n            instance = new this('field');\n            FieldShare$map.set(this, instance);\n        }\n        return instance;\n    }\n    /**\n     * A key of component context value containing default field instance.\n     */\n    static get [ContextKey__symbol]() {\n        return this[Share__symbol][ContextKey__symbol];\n    }\n}\n\nconst FormShare$map = ( /*#__PURE__*/new WeakMap());\n/**\n * A kind of component share containing a user input form.\n *\n * This class may be inherited to represent a specific type of forms. E.g. to support multiple forms within the same\n * component tree.\n *\n * @typeParam TModel - A model type of the form.\n * @typeParam TElt - A type of HTML form element.\n */\nclass FormShare extends Share {\n    /**\n     * Default form share instance.\n     */\n    static get [Share__symbol]() {\n        let instance = FormShare$map.get(this);\n        if (!instance) {\n            instance = new this('form');\n            FormShare$map.set(this, instance);\n        }\n        return instance;\n    }\n    /**\n     * A key of component context value containing default form instance.\n     */\n    static get [ContextKey__symbol]() {\n        return this[Share__symbol][ContextKey__symbol];\n    }\n}\n\n/**\n * Creates a field adjacent to some form unit.\n *\n * Suitable e.g. for buttons or error indicators.\n *\n * The controls of adjacent field are based on the ones of the unit it is adjacent to.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TAdjacentTo - A type of form unit the field is adjacent to.\n * @typeParam TAdjusted - A type of controls to adjust. I.e. the ones of the form unit the field is adjacent to.\n * @typeParam TSharer - Adjacent field sharer component type.\n */\nfunction adjacentField(controls, adjacentTo) {\n    return new Field(AdjacentField$provider(valueRecipe(controls), shareLocator(adjacentTo, { local: 'too' })));\n}\n/**\n * Creates a field adjacent to another one.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TSharer - Adjacent field sharer component type.\n * @param controls - Either a field controls instance, or its provider.\n * @param adjacentTo - A locator of the field share the created field is adjacent to. Includes local shares by\n * default. Defaults to {@link FieldShare}.\n */\nfunction adjacentToField(controls, adjacentTo = FieldShare) {\n    return adjacentField(controls, adjacentTo);\n}\n/**\n * Creates a field adjacent to form.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TSharer - Adjacent field sharer component type.\n * @param controls - Either a field controls instance, or its provider.\n * @param adjacentTo - A locator of the form share the created field is adjacent to. Includes local shares by default.\n * Defaults to {@link FormShare}.\n */\nfunction adjacentToForm(controls, adjacentTo = FormShare) {\n    return adjacentField(controls, adjacentTo);\n}\nfunction AdjacentField$provider(provider, adjacentLocator) {\n    return builder => adjacentLocator(builder.sharer).do(digAfter((adjacentTo, _sharer) => adjacentTo\n        ? adjacentTo.read.do(digAfter((adjusted) => adjusted\n            ? afterValue(provider({\n                ...builder,\n                adjacentTo,\n                adjusted,\n            }))\n            : afterThe()))\n        : afterThe()));\n}\n\n/**\n * @internal\n */\nfunction Field$name(key, name) {\n    if (name === '') {\n        return null;\n    }\n    if (name) {\n        return name;\n    }\n    return Field$nameByKey(key);\n}\n/**\n * @internal\n */\nfunction Field$nameByKey(key) {\n    return typeof key === 'string' ? key : null;\n}\n\n/**\n * Creates a {@link SharedForm shared form} member amendment that adds nested form to enclosing one.\n *\n * @typeParam TForm - Nested form type.\n * @typeParam TModel - Nested form model type.\n * @typeParam TElt - A type of nested HTML form element.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Nested form naming definition.\n *\n * @returns Shared form definition builder.\n */\nfunction FormName(def) {\n    return FormUnitName(def);\n}\n/**\n * Creates a {@link SharedField shared field} member amendment that adds the field to enclosing form.\n *\n * @typeParam TField - Field type.\n * @typeParam TValue - Field value type.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Field naming definition.\n *\n * @returns Shared field definition builder.\n */\nfunction FieldName(def = {}) {\n    return FormUnitName(def);\n}\nfunction FormUnitName(def = {}) {\n    return ({ key, share, locateForm: defaultForm, name: defaultName, amend, }) => {\n        const { name = defaultName } = def;\n        let fieldName;\n        if (name) {\n            fieldName = name;\n        }\n        else if (name != null) {\n            return; // Empty field name. Do not ad it to form.\n        }\n        else {\n            const autoName = Field$nameByKey(key);\n            if (!autoName) {\n                return;\n            }\n            fieldName = autoName;\n        }\n        const locateForm = shareLocator(def.form || defaultForm, { share: FormShare });\n        amend({\n            componentDef: {\n                setup(setup) {\n                    setup.whenComponent(context => {\n                        afterAll({\n                            unit: context.get(share).do(digAfter_(asis, valuesProvider())),\n                            form: locateForm(context).do(digAfter_((form, _sharer) => form, valuesProvider())),\n                        }).do(consumeEvents(({ unit: [field], form: [form] }) => {\n                            if (!form || !field) {\n                                return;\n                            }\n                            const group = form.control.aspect(InGroup);\n                            if (!group) {\n                                return;\n                            }\n                            return group.controls.set(fieldName, field.control);\n                        }));\n                    });\n                },\n            },\n        });\n    };\n}\n\nconst Form__aspect = {\n    applyTo(_control) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return nullInAspect();\n    },\n};\n/**\n * User input form.\n *\n * A component {@link FormShare shares} form (e.g. using {@link SharedForm @SharedForm} decorator) to make its\n * accessible by component itself and nested ones. E.g. to add {@link Field fields} to it or submit it.\n *\n * A form may be nested within another one, as it implements a {@link Field} interface.\n *\n * The form instance is not usable until it is bound to its sharer component. The latter is done automatically when the\n * form is shared by {@link FormShare}.\n *\n * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n * @typeParam TElt - A type of HTML form element.\n * @typeParam TSharer - Form sharer component type.\n */\nclass Form extends FormUnit {\n    /**\n     * Builds a user input form for the given form control and HTML element.\n     *\n     * @param control - Submitted control. Typically a container one.\n     * @param element - HTML element to create control for.\n     * @param options - Form element control options.\n     *\n     * @returns New form instance.\n     */\n    static forElement(control, element, options) {\n        return {\n            control,\n            element: inFormElement(element, { ...options, form: control }),\n        };\n    }\n    /**\n     * Creates a form instance by the given control factories.\n     *\n     * @param factory - Submittable form control factory.\n     * @param elementFactory - Form element control factory or options.\n     *\n     * @returns New form instance.\n     */\n    static by(factory, elementFactory) {\n        return new this(this.providerBy(factory, elementFactory));\n    }\n    /**\n     * Creates a form controls provider by the given control factories.\n     *\n     * @param factory - Submittable form control factory.\n     * @param elementFactory - Form element control factory or options.\n     *\n     * @returns New form controls provider.\n     */\n    static providerBy(factory, elementFactory) {\n        return builder => {\n            let control = () => builder.control.build(\n            // Allow recurrent access to `Form` aspect during control setup.\n            opts => (control = lazyValue(() => factory(opts)))());\n            let element = () => builder.element.build(\n            // Allow recurrent access to `Form` aspect during control setup.\n            opts => (element = lazyValue(() => elementFactory({\n                form: control(),\n                ...opts,\n            })))());\n            return {\n                get control() {\n                    return control();\n                },\n                get element() {\n                    return element();\n                },\n            };\n        };\n    }\n    /**\n     * An input control aspect representing a form this control belongs to.\n     *\n     * This aspect is available in {@link Form.Body.control submittable form control} and {@link Form.Body.element form\n     * element control}.\n     */\n    static get [InAspect__symbol]() {\n        return Form__aspect;\n    }\n    /**\n     * Constructs form.\n     *\n     * @param controls - Either form controls instance, or its provider.\n     */\n    constructor(controls) {\n        super(Form$provider(() => this, valueRecipe(controls)));\n    }\n    /**\n     * Form element control, if present.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    get element() {\n        var _a;\n        return (_a = this.body) === null || _a === void 0 ? void 0 : _a.element;\n    }\n    toString() {\n        return 'Form';\n    }\n}\nfunction Form$provider(form, provider) {\n    const formAspect = control => ({\n        applyAspect(_aspect) {\n            return inconvertibleInAspect(control, Form, form());\n        },\n    });\n    return sharer => sharer.get(FormPreset).rules.do(digAfter_(preset => {\n        const builder = {\n            sharer,\n            form: form(),\n            control: new InBuilder().addAspect(Form, formAspect),\n            element: new InBuilder().addAspect(Form, formAspect),\n        };\n        preset.setupForm(builder);\n        return afterValue(provider(builder));\n    }), deduplicateAfter_(Form$isDuplicateControls, ([controls]) => controls), mapAfter(controls => controls && {\n        get form() {\n            return form();\n        },\n        get control() {\n            return controls.control;\n        },\n        get element() {\n            return controls.element;\n        },\n    }));\n}\nfunction Form$isDuplicateControls(prior, next) {\n    let duplicate = true;\n    if ((prior === null || prior === void 0 ? void 0 : prior.control) !== (next === null || next === void 0 ? void 0 : next.control)) {\n        prior === null || prior === void 0 ? void 0 : prior.control.supply.off();\n        duplicate = false;\n    }\n    if ((prior === null || prior === void 0 ? void 0 : prior.element) !== (next === null || next === void 0 ? void 0 : next.element)) {\n        prior === null || prior === void 0 ? void 0 : prior.element.supply.off();\n        duplicate = false;\n    }\n    return duplicate;\n}\n\nconst FormScope = {\n    /**\n     * Creates an input control setup procedure applied to the given scope.\n     *\n     * @typeParam TControl - Input control type.\n     * @typeParam TValue - Input value type.\n     * @param scope - Setup applicability scope.\n     * @param setup - A setup procedure to apply. Accepts target control instance as parameter and returns a setup supply\n     * peer. The setup should be reverted once this peer's supply cut off.\n     * @param defaultRole - A role name to apply by default. `'default'` when omitted.\n     *\n     * @returns A setup procedure accepting target control as parameter and returning a setup supply. The setup is\n     * reverted once this supply cut off.\n     */\n    createSetup(scope, setup, defaultRole = 'default') {\n        if (scope === false) {\n            return _control => neverSupply();\n        }\n        if (scope === true) {\n            return control => setup(control).supply;\n        }\n        let roles = arrayOfElements(scope);\n        if (!roles.length) {\n            roles = [defaultRole];\n        }\n        if (roles.length === 1) {\n            return control => control.aspect(InRole).when(roles[0], () => setup(control));\n        }\n        return control => roles.reduce((supply, role) => control.aspect(InRole).when(role, () => setup(control)).as(supply), new Supply());\n    },\n};\n\nconst AbstractFormPreset$map = ( /*#__PURE__*/new WeakMap());\n/**\n * Abstract form preset implementation.\n *\n * A class extending it may be used as a feature. E.g. passed to `bootstrapComponents()` function or used as a\n * dependency of another feature.\n *\n * An instance of implementation class may be created to customize its behavior. Such instance implements a\n * `ContextBuilder` interface. Thus is can be passed to context value registration method.\n */\nclass AbstractFormPreset {\n    /**\n     * Feature definition of the preset.\n     */\n    static get [FeatureDef__symbol]() {\n        const found = AbstractFormPreset$map.get(this);\n        if (found) {\n            return found;\n        }\n        const preset = new this();\n        const featureDef = {\n            setup: setup => {\n                setup.provide(preset);\n            },\n        };\n        AbstractFormPreset$map.set(this, featureDef);\n        return featureDef;\n    }\n    /**\n     * Provides this form preset to the given context.\n     *\n     * @param registry - A context registry to provide a value to.\n     *\n     * @returns A supply instance that removes the added preset once cut off.\n     */\n    [ContextBuilder__symbol](registry) {\n        return registry.provide({ a: FormPreset, is: this });\n    }\n    /**\n     * Sets up form field controls.\n     *\n     * Does nothing by default.\n     *\n     * @param _builder - Target field builder.\n     */\n    setupField(_builder) {\n        // No field setup\n    }\n    /**\n     * Sets up form controls.\n     *\n     * Does nothing by default.\n     *\n     * @param _builder - Target form builder.\n     */\n    setupForm(_builder) {\n        // No form setup\n    }\n}\n\nconst ScopedFormConfig = {\n    /**\n     * Creates an input control setup procedure that applies the given configuration to appropriate scope.\n     *\n     * @typeParam TOptions - A type of setup options.\n     * @typeParam TControl - Input control type.\n     * @typeParam TValue - Input value type.\n     * @param config - Scoped form setup configuration.\n     * @param createSetup - A function accepting setup options and returning a procedure that sets up the given control\n     * with these options. The setup procedure returns a setup supply peer. The setup should be reverted once this peer's\n     * supply cut off.\n     * @param defaultRole - A role name to apply by default. `'default'` when omitted.\n     *\n     * @returns A setup procedure accepting target control as parameter and returning a setup supply. The setup is\n     * reverted once this supply cut off.\n     */\n    createSetup(config, createSetup, defaultRole) {\n        let scope;\n        let options;\n        if (Array.isArray(config)) {\n            const [first, ...rest] = config;\n            if (ScopedFormConfig$isOptions(first)) {\n                scope = rest.length > 1 ? rest : rest[0];\n                options = first;\n            }\n            else {\n                scope = config;\n            }\n        }\n        else if (ScopedFormConfig$isOptions(config)) {\n            options = config;\n        }\n        else {\n            scope = config;\n        }\n        return FormScope.createSetup(scope, createSetup(options), defaultRole);\n    },\n};\nfunction ScopedFormConfig$isOptions(config) {\n    return config != null && typeof config !== 'string' && typeof config !== 'boolean';\n}\n\n/**\n * Form preset that enables CSS class indication of form and field states.\n *\n * - Enables CSS info classes (`inCssInfo()`) for forms and fields.\n * - Enables error indication (`inCssError()`) for fields.\n */\nclass FormCssPreset extends AbstractFormPreset {\n    /**\n     * Constructs customized form CSS preset.\n     *\n     * @param options - Custom form CSS preset options.\n     */\n    constructor(options = {}) {\n        super();\n        this._info = ScopedFormConfig.createSetup(options.info, opts => {\n            const src = inCssInfo(opts);\n            return control => control.aspect(InCssClasses).add(src);\n        });\n        this._error = ScopedFormConfig.createSetup(options.error, opts => {\n            const src = inCssError(opts);\n            return control => control.aspect(InCssClasses).add(src);\n        });\n    }\n    setupField(builder) {\n        builder.control.setup(this._info).setup(this._error);\n    }\n    setupForm(builder) {\n        builder.control.setup(this._info);\n        builder.element.setup(InCssClasses, (css, element) => css.add(element.aspect(Form).control.aspect(InCssClasses)));\n    }\n}\n\n/**\n * Form preset that enables default form and field mode management.\n *\n * - Makes form mode depend on its validity (`inModeByValidity()`).\n * - Derives form field's mode from form element's one.\n */\nclass FormModePreset extends AbstractFormPreset {\n    /**\n     * Constructs customized form mode preset.\n     *\n     * @param options - Custom form mode preset options.\n     */\n    constructor(options = {}) {\n        super();\n        this._byValidity = ScopedFormConfig.createSetup(options.byValidity, opts => {\n            const src = inModeByValidity(opts);\n            return control => control.aspect(InMode).derive(src);\n        });\n        this._byForm = FormScope.createSetup(options.byForm, control => control.aspect(InParents).read.do(consumeEvents(parents => {\n            const supply = new Supply();\n            itsEach(parents, ({ parent }) => {\n                const form = parent.aspect(Form);\n                if (form) {\n                    control.aspect(InMode).derive(form.element.aspect(InMode)).as(supply);\n                }\n            });\n            return supply;\n        })));\n    }\n    setupField(builder) {\n        builder.control.setup(this._byForm);\n    }\n    setupForm(builder) {\n        builder.control.setup(this._byValidity);\n    }\n}\n\n/**\n * Creates an amendment (and decorator) of component method to call on input form submit.\n *\n * @typeParam TModel - Submitted model type.\n * @typeParam TElt - A type of HTML form element.\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Submit handler definition.\n *\n * @returns New component property decorator.\n */\nfunction OnSubmit(def = {}) {\n    const { form: formRef = FormShare, cancel = true } = def;\n    const locateForm = shareLocator(formRef, { share: FormShare, local: 'too' });\n    return ComponentMember(({ get, amend }) => amend({\n        componentDef: {\n            define(defContext) {\n                defContext.whenComponent(context => {\n                    context.whenConnected(() => {\n                        const { component } = context;\n                        locateForm(context).do(consumeEvents((form, _sharer) => {\n                            const controls = form === null || form === void 0 ? void 0 : form.body;\n                            if (!controls) {\n                                return;\n                            }\n                            let onSubmit = controls.element.events.on('submit');\n                            if (cancel) {\n                                onSubmit = onSubmit.do(handleDomEvents(false));\n                            }\n                            return onSubmit(event => get(component).call(component, controls, event));\n                        })).needs(context);\n                    });\n                });\n            },\n        },\n    }));\n}\n\nfunction SharedField(defOrAmendment = {}, ...amendments) {\n    let def;\n    let fieldName;\n    let amender;\n    if (typeof defOrAmendment === 'function' || isAmendatory(defOrAmendment)) {\n        def = {};\n        amender = allAmender([defOrAmendment, ...amendments, FieldName()]);\n    }\n    else {\n        def = defOrAmendment;\n        fieldName = defOrAmendment.name;\n        amender = allAmender([...amendments, FieldName({ name: fieldName })]);\n    }\n    const { share = FieldShare, form, } = def;\n    const locateForm$default = shareLocator(form, { share: FormShare });\n    return Shared(share, baseTarget => {\n        amender(newAmendTarget({\n            base: {\n                ...baseTarget,\n                locateForm: locateForm$default,\n                name: Field$name(baseTarget.key, fieldName),\n            },\n            amend(base, request = {}) {\n                const { locateForm = base.locateForm, name = base.name, ...baseRequest } = request;\n                const createBaseTarget = baseTarget.amend(baseRequest);\n                return () => ({\n                    ...createBaseTarget(),\n                    locateForm,\n                    name,\n                });\n            },\n        }));\n    });\n}\n\nfunction SharedForm(defOrAmendment = {}, ...amendments) {\n    if (typeof defOrAmendment === 'function' || isAmendatory(defOrAmendment)) {\n        return Shared(FormShare, defOrAmendment, ...amendments);\n    }\n    const { share = FormShare } = defOrAmendment;\n    return Shared(share, ...amendments);\n}\n\nexport { AbstractFormPreset, Field, FieldName, FieldShare, Form, FormCssPreset, FormModePreset, FormName, FormPreset, FormScope, FormShare, FormUnit, OnSubmit, ScopedFormConfig, SharedField, SharedForm, adjacentField, adjacentToField, adjacentToForm };\n//# sourceMappingURL=wesib.forms.js.map\n","import { newRenderSchedule, immediateRenderScheduler } from '@frontmeans/render-scheduler';\nimport { isEventKeeper, afterSupplied, mapAfter_, deduplicateAfter, isEventSender, afterThe, afterAll, mapAfter, EventEmitter, onSupplied, AfterEvent__symbol, OnEvent__symbol, onEventBy, shareOn, trackValue, digAfter, afterEventBy, consumeEvents, shareAfter, EventNotifier, onNever } from '@proc7ts/fun-events';\nimport { itsEach, overKeys, itsIterator, filterIt, overEntries, itsReduction, flatMapIt, mapIt, overElementsOf, overOne, PushIterator__symbol, itsElements } from '@proc7ts/push-iterator';\nimport { valuesProvider, isPresent, noop, valueProvider, asis, lazyValue } from '@proc7ts/primitives';\nimport { escapeCSSVal, escapeCSS, hyphenateCSSName } from '@frontmeans/httongue';\nimport { isQualifiedName, compareNames, namesEqual, newNamespaceAliaser, id__naming, css__naming, html__naming } from '@frontmeans/namespace-aliaser';\nimport { Supply, neverSupply } from '@proc7ts/supply';\n\n/**\n * @internal\n */\nconst IMPORTANT_CSS_SUFFIX = '!important';\n\n/**\n * @internal\n */\nfunction isReadonlyArray(value) {\n    return Array.isArray(value);\n}\n/**\n * @internal\n */\nfunction isNotEmptyArray(array) {\n    return !!array.length;\n}\n\n/**\n * Structured property CSS value. E.g. [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length),\n * [percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/percentage),\n * [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value), etc.\n *\n * @category CSS Value\n * @typeParam TSelf - A type of itself.\n */\nclass StypValueStruct {\n    /**\n     * Constructs structured CSS property value.\n     *\n     * @param opts - Construction options.\n     */\n    constructor(opts) {\n        this.priority = opts && opts.priority || 0 /* Default */;\n    }\n    /**\n     * Creates `!important` variant of this value.\n     *\n     * @returns Either a new value equal to this one but having `priority` equal to {@link StypPriority.Important},\n     * or this one if already the case.\n     */\n    important() {\n        return this.prioritize(1 /* Important */);\n    }\n    /**\n     * Creates usual (not `!important`) variant of this value.\n     *\n     * @returns Either a new value equal to this one but having `priority` equal to {@link StypPriority.Usual},\n     * or this one if already the case.\n     */\n    usual() {\n        return this.prioritize(0 /* Usual */);\n    }\n}\n/**\n * Checks whether two CSS property values are equal.\n *\n * Compares scalar values verbatim. Compares structured values using their {@link StypValueStruct.is} method. The latter\n * method is applied when at least one of the values is structured.\n *\n * @category CSS Value\n * @param first - The first CSS property value to compare.\n * @param second - The second CSS property value to compare.\n *\n * @returns `true` if `first` equals to `second`, or `false otherwise.\n */\nfunction stypValuesEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (typeof first === 'object') {\n        return first.is(second);\n    }\n    if (typeof second === 'object') {\n        return second.is(first);\n    }\n    return false;\n}\n\n/**\n * Structured color CSS property value base.\n *\n * @category CSS Value\n */\nclass StypColorStruct extends StypValueStruct {\n}\n/**\n * CSS property value representing [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors)\n * in `rgb()` or `rgba()` functional notation.\n *\n * @category CSS Value\n */\nclass StypRGB extends StypColorStruct {\n    /**\n     * Constructs RGB color value.\n     *\n     * @param coords - Color coordinates.\n     * @param opts - Construction options.\n     */\n    constructor(coords, opts) {\n        super(opts);\n        this.r = intCoord(coords.r, 255);\n        this.g = intCoord(coords.g, 255);\n        this.b = intCoord(coords.b, 255);\n        this.a = coords.a != null ? coord(coords.a, 1) : 1;\n    }\n    // noinspection JSMethodCanBeStatic\n    /**\n     * `rgb` value type.\n     */\n    get type() {\n        return 'rgb';\n    }\n    /**\n     * This color in RGB coordinates.\n     *\n     * Always the same as `this`.\n     */\n    get rgb() {\n        return this;\n    }\n    /**\n     * This color in HSL coordinates.\n     */\n    get hsl() {\n        const { a } = this;\n        const r = this.r * 100 / 255;\n        const g = this.g * 100 / 255;\n        const b = this.b * 100 / 255;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        const l = Math.round((max + min) / 2);\n        if (max === min) {\n            return new StypHSL({ h: 0, s: 0, l, a }, this);\n        }\n        const d = max - min;\n        const s = Math.round(l > 50 ? d * 100 / (200 - max - min) : d * 100 / (max + min));\n        let h;\n        switch (max) {\n            case r:\n                h = ((g - b) / d) + (g < b ? 6 : 0);\n                break;\n            case g:\n                h = ((b - r) / d) + 2;\n                break;\n            default:\n                h = ((r - g) / d) + 4;\n                break;\n        }\n        h *= 60;\n        h = Math.round(h);\n        return new StypHSL({ h, s, l, a }, this);\n    }\n    by(source) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return StypColor.by(source) || this;\n    }\n    is(other) {\n        return typeof other === 'object'\n            && other.type === this.type\n            && other.r === this.r\n            && other.g === this.g\n            && other.b === this.b\n            && other.a === this.a\n            && other.priority === this.priority;\n    }\n    prioritize(priority) {\n        return this.priority === priority ? this : new StypRGB(this, { priority });\n    }\n    set(coords) {\n        if (typeof coords === 'function') {\n            coords = coords(this);\n        }\n        const { r = this.r, g = this.g, b = this.b, a = this.a } = coords;\n        return new StypRGB({ r, g, b, a }, this);\n    }\n    toString() {\n        const rgb = `${this.r}, ${this.g}, ${this.b}`;\n        return this.a === 1 ? `rgb(${rgb})` : `rgba(${rgb}, ${this.a})`;\n    }\n}\n/**\n * CSS property value representing [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors)\n * in `hsl()` or `hsla()` functional notation.\n *\n * @category CSS Value\n */\nclass StypHSL extends StypColorStruct {\n    /**\n     * Constructs HSL color value.\n     *\n     * @param coords - Color coordinates.\n     * @param opts - Construction options.\n     */\n    constructor(coords, opts) {\n        super(opts);\n        this.h = angleCoord(coords.h);\n        this.s = coord(coords.s, 100);\n        this.l = coord(coords.l, 100);\n        this.a = coords.a != null ? coord(coords.a, 1) : 1;\n    }\n    // noinspection JSMethodCanBeStatic\n    get type() {\n        return 'hsl';\n    }\n    /**\n     * This color in RGB coordinates.\n     */\n    get rgb() {\n        const { a } = this;\n        const s = this.s / 100;\n        const l = this.l / 100;\n        if (!s) {\n            const c = l * 255;\n            return new StypRGB({ r: c, g: c, b: c, a }, this);\n        }\n        const q = l < 0.5 ? l * (1 + s) : (l + s) - (l * s);\n        const p = (2 * l) - q;\n        const hueAsFraction = this.h / 360;\n        return new StypRGB({\n            r: hueToRgb(p, q, hueAsFraction + (1.0 / 3.0)),\n            g: hueToRgb(p, q, hueAsFraction),\n            b: hueToRgb(p, q, hueAsFraction - (1.0 / 3.0)),\n            a,\n        }, this);\n    }\n    /**\n     * This color in HSL coordinates.\n     *\n     * Always the same as `this`.\n     */\n    get hsl() {\n        return this;\n    }\n    by(source) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return StypColor.by(source) || this;\n    }\n    is(other) {\n        return typeof other === 'object'\n            && other.type === this.type\n            && other.h === this.h\n            && other.s === this.s\n            && other.l === this.l\n            && other.a === this.a\n            && other.priority === this.priority;\n    }\n    prioritize(priority) {\n        return this.priority === priority ? this : new StypHSL(this, { priority });\n    }\n    set(coords) {\n        if (typeof coords === 'function') {\n            coords = coords(this);\n        }\n        const { h = this.h, s = this.s, l = this.l, a = this.a } = coords;\n        return new StypHSL({ h, s, l, a }, this);\n    }\n    toString() {\n        const hsl = `${this.h}, ${this.s}%, ${this.l}%`;\n        return this.a === 1 ? `hsl(${hsl})` : `hsla(${hsl}, ${this.a})`;\n    }\n}\n/**\n * @category CSS Value\n */\nconst StypColor = {\n    /**\n     * Maps the given CSS property value to color. Defaults to `undefined` if mapping is not possible.\n     *\n     * This method allows to use a {@link StypColor} object as {@link StypMapper.Mapping CSS property mapping}.\n     *\n     * @param source - A raw property value that should be converted.\n     *\n     * @returns Mapped property value or `undefined`.\n     */\n    by(source) {\n        if (typeof source === 'object' && (source.type === 'rgb' || source.type === 'hsl')) {\n            return source;\n        }\n        return;\n    },\n};\n/**\n * @internal\n */\nfunction angleCoord(value) {\n    value = value % 360;\n    return value < 0 ? 360 + value : value;\n}\n/**\n * @internal\n */\nfunction intCoord(value, max) {\n    return coord(Math.round(value), max);\n}\n/**\n * @internal\n */\nfunction coord(value, max) {\n    return Math.max(Math.min(value, max), 0);\n}\n/**\n * @internal\n */\nfunction hueToRgb(p, q, t) {\n    let newT = t;\n    if (newT < 0) {\n        newT += 1;\n    }\n    else if (newT > 1) {\n        newT -= 1;\n    }\n    let result;\n    if (newT < 1.0 / 6.0) {\n        result = p + ((q - p) * (6 * newT));\n    }\n    else if (newT < 1.0 / 2.0) {\n        result = q;\n    }\n    else if (newT < 2.0 / 3.0) {\n        result = p + (((q - p) * ((2.0 / 3.0) - newT)) * 6);\n    }\n    else {\n        result = p;\n    }\n    return result * 255;\n}\n\n/**\n * Mixes two colors.\n *\n * Both the `weight` and the relative opacity of each color determines how much of each color is in the result.\n *\n * @category CSS Value\n * @param color1 - First color to mix\n * @param color2 - Second color to mix.\n * @param weight - A number between `0` and `1`. A larger weight indicates that more of `color1` should be used, and a\n * smaller weight indicates that more of `color2` should be used.\n *\n * @returns Mixed color.\n */\nfunction mixStypColors(color1, color2, weight) {\n    const w = weight * 2 - 1;\n    const rgba1 = color1.rgb;\n    const rgba2 = color2.rgb;\n    const aDiff = rgba1.a - rgba2.a;\n    const w1 = (((w * aDiff === -1) ? w : (w + aDiff) / (1 + w * aDiff)) + 1) / 2.0;\n    const w2 = 1 - w1;\n    return new StypRGB({\n        r: rgba1.r * w1 + rgba2.r * w2,\n        g: rgba1.g * w1 + rgba2.g * w2,\n        b: rgba1.b * w1 + rgba2.b * w2,\n        a: rgba1.a * weight + rgba2.a * (1 - weight),\n    }, color1);\n}\n\n/**\n * Base implementation of structured numeric CSS property value.\n *\n * @category CSS Value\n * @typeParam TSelf - A type of itself.\n * @typeParam TUnit - Allowed unit type.\n */\nclass StypNumericStruct extends StypValueStruct {\n    constructor(opts) {\n        super(opts);\n        this.dim = opts.dim;\n    }\n    by(source) {\n        return this.dim.by(source) || this;\n    }\n    toString() {\n        return this.toFormula();\n    }\n}\n\n/**\n * @category CSS Value\n */\nconst StypMapper = {\n    /**\n     * Maps CSS properties accordingly to the given `mappings`.\n     *\n     * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n     * @param mappings - Mappings of CSS properties.\n     * @param from - Raw CSS properties to map.\n     *\n     * @returns Mapped properties.\n     */\n    map(mappings, from) {\n        const result = {};\n        const mapped = {\n            from,\n            get(key) {\n                if (key in result) {\n                    return result[key];\n                }\n                const mapper = mappingBy(mappings[key]);\n                const mappedValue = mapper(from[key], this, key);\n                result[key] = mappedValue;\n                return mappedValue;\n            },\n        };\n        itsEach(overKeys(mappings), key => mapped.get(key));\n        return result;\n    },\n    /**\n     * Creates CSS properties mapper function.\n     *\n     * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n     * @param mappings - Mappings of CSS properties.\n     *\n     * @returns A function that maps CSS properties accordingly to the given `mappings`.\n     */\n    by(mappings) {\n        return StypMapper.map.bind(undefined, mappings);\n    },\n};\n/**\n * @internal\n */\nfunction mappingBy(mapping) {\n    switch (typeof mapping) {\n        case 'function':\n            return mapping;\n        case 'object':\n            return mapping.by.bind(mapping);\n    }\n    const type = typeof mapping;\n    return (from) => typeof from === type\n        ? from\n        : mapping;\n}\n\nfunction stypSplitPriority(value) {\n    if (value == null) {\n        return [undefined, 0 /* Default */];\n    }\n    switch (typeof value) {\n        case 'object':\n            return [value, value.priority];\n        case 'string':\n            if (value.endsWith(IMPORTANT_CSS_SUFFIX)) {\n                return [\n                    value.substring(0, value.length - IMPORTANT_CSS_SUFFIX.length).trim(),\n                    1 /* Important */,\n                ];\n            }\n            break;\n    }\n    return [value, 0 /* Default */];\n}\n\n/**\n * @internal\n */\nclass StypDimension extends StypNumericStruct {\n    /**\n     * Constructs new structured dimension value.\n     *\n     * @param val - The numeric value.\n     * @param unit - The unit.\n     * @param opts - CSS value options.\n     */\n    constructor(val, unit, opts) {\n        super(opts);\n        this.val = val;\n        this.unit = unit;\n    }\n    get type() {\n        return 'dimension';\n    }\n    toDim(dim) {\n        const thisDim = this.dim;\n        if (dim === thisDim /* same dimension */\n            || dim === thisDim.pt /* !% to compatible +% */\n            || dim === (this.unit === '%' ? dim.pt /* % to any +% */ : thisDim.noPt /* !% to compatible -% */)) {\n            return this;\n        }\n        return;\n    }\n    is(other) {\n        if (other === this) {\n            return true;\n        }\n        return typeof other === 'object'\n            && other.type === this.type\n            && this.unit === other.unit\n            && this.val === other.val\n            && this.priority === other.priority;\n    }\n    prioritize(priority) {\n        return this.priority === priority\n            ? this\n            : new StypDimension(this.val, this.unit, { dim: this.dim, priority });\n    }\n    add(addendum, unit) {\n        if (typeof addendum === 'number') {\n            addendum = stypDimension(addendum, unit || this.unit, this);\n        }\n        if (addendum.type === 'dimension' && this.unit === addendum.unit) {\n            return stypDimension(this.val + addendum.val, this.unit, this);\n        }\n        return stypAddSub(this, '+', addendum);\n    }\n    sub(subtrahend, unit) {\n        if (typeof subtrahend === 'number') {\n            subtrahend = stypDimension(subtrahend, unit || this.unit, this);\n        }\n        if (subtrahend.type === 'dimension' && this.unit === subtrahend.unit) {\n            return stypDimension(this.val - subtrahend.val, this.unit, this);\n        }\n        return stypAddSub(this, '-', subtrahend);\n    }\n    mul(multiplier) {\n        return multiplier === 1 ? this : stypDimension(this.val * multiplier, this.unit, this);\n    }\n    div(divisor) {\n        return divisor === 1 ? this : stypDimension(this.val / divisor, this.unit, this);\n    }\n    negate() {\n        return stypDimension(-this.val, this.unit, this);\n    }\n    /**\n     * Returns a textual representation of this value to be used within CSS `calc()` function.\n     *\n     * @returns `<value><unit>` or just `0`.\n     */\n    toFormula() {\n        return `${this.val}${this.unit}`;\n    }\n}\n/**\n * Constructs structured [dimension] CSS property value.\n *\n * @param val - Numeric value.\n * @param unit - Value unit.\n * @param opts - Construction options.\n *\n * @returns Either {@link StypDimension}, or {@link StypZero} if `val === 0`.\n *\n * [dimension]: https://developer.mozilla.org/en-US/docs/Web/CSS/dimension\n *\n * @internal\n */\nfunction stypDimension(val, unit, opts) {\n    return val\n        ? new StypDimension(val, unit, opts)\n        : opts.dim.zero.prioritize(opts.priority || 0 /* Default */);\n}\n/**\n * @internal\n */\nclass StypCalcBase extends StypNumericStruct {\n    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n    constructor(left, op, right, opts) {\n        super(opts);\n        this.left = left.usual();\n        this.op = op;\n        this.right = right;\n    }\n    // noinspection JSMethodCanBeStatic\n    get type() {\n        return 'calc';\n    }\n    is(other) {\n        if (this === other) {\n            return true;\n        }\n        if (typeof other === 'object' && other.type === this.type) {\n            return this.op === other.op\n                && this.left.is(other.left)\n                && stypValuesEqual(this.right, other.right)\n                && this.priority === other.priority;\n        }\n        return false;\n    }\n    add(addendum, unit) {\n        if (typeof addendum === 'number') {\n            addendum = stypDimension(addendum, unit, this);\n        }\n        return stypAddSub(this, '+', addendum);\n    }\n    sub(subtrahend, unit) {\n        if (typeof subtrahend === 'number') {\n            subtrahend = stypDimension(subtrahend, unit, this);\n        }\n        return stypAddSub(this, '-', subtrahend);\n    }\n    mul(multiplier) {\n        return stypMul(this, multiplier);\n    }\n    div(divisor) {\n        return stypDiv(this, divisor);\n    }\n    toString() {\n        return 'calc' + super.toString();\n    }\n}\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @typeParam TUnit - Allowed unit type.\n *\n * @internal\n */\nclass StypAddSub extends StypCalcBase {\n    constructor(left, op, right, opts) {\n        super(left, op, right.usual(), opts);\n    }\n    prioritize(priority) {\n        return this.priority === priority\n            ? this\n            : new StypAddSub(this.left, this.op, this.right, { dim: this.dim, priority });\n    }\n    toDim(dim) {\n        const left = this.left.toDim(dim);\n        if (!left) {\n            return;\n        }\n        const right = this.right.toDim(dim);\n        if (!right) {\n            return;\n        }\n        if (left === this.left && right === this.right) {\n            return this;\n        }\n        return new StypAddSub(left, this.op, right, { dim, priority: this.priority });\n    }\n    negate() {\n        return this.op === '-'\n            ? new StypAddSub(this.right, this.op, this.left, this)\n            : new StypAddSub(this.left.negate(), '-', this.right, this);\n    }\n    /**\n     * Returns a textual representation of this value to be used within CSS `calc()` function.\n     *\n     * @returns `(<left> <op> <right>)`.\n     */\n    toFormula() {\n        return `(${this.left.toFormula()} ${this.op} ${this.right.toFormula()})`;\n    }\n}\nfunction stypAddSub(left, op, right) {\n    return !right.type ? left : new StypAddSub(left, op, right, left);\n}\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @typeParam TUnit - Allowed unit type.\n *\n * @internal\n */\nclass StypMulDiv extends StypCalcBase {\n    prioritize(priority) {\n        return this.priority === priority\n            ? this\n            : new StypMulDiv(this.left, this.op, this.right, { dim: this.dim, priority });\n    }\n    toDim(dim) {\n        const left = this.left.toDim(dim);\n        if (!left) {\n            return;\n        }\n        if (left === this.left) {\n            return this;\n        }\n        return new StypMulDiv(left, this.op, this.right, { dim, priority: this.priority });\n    }\n    mul(multiplier) {\n        return (this.op === '*'\n            ? stypMul(this.left, this.right * multiplier)\n            : stypDiv(this.left, this.right / multiplier))\n            .prioritize(this.priority);\n    }\n    div(divisor) {\n        return (this.op === '/'\n            ? stypDiv(this.left, this.right * divisor)\n            : stypMul(this.left, this.right / divisor))\n            .prioritize(this.priority);\n    }\n    negate() {\n        return new StypMulDiv(this.left, this.op, -this.right, this);\n    }\n    /**\n     * Returns a textual representation of this value to be used within CSS `calc()` function.\n     *\n     * @returns `(<left> <op> <right>)`.\n     */\n    toFormula() {\n        return `(${this.left.toFormula()} ${this.op} ${this.right})`;\n    }\n}\nfunction stypMul(left, right) {\n    return !right\n        ? left.dim.zero.prioritize(left.priority)\n        : right === 1\n            ? left.prioritize(left.priority)\n            : new StypMulDiv(left, '*', right, left);\n}\nfunction stypDiv(left, right) {\n    return right === 1\n        ? left.prioritize(left.priority)\n        : new StypMulDiv(left, '/', right, left);\n}\n/**\n * @internal\n */\nfunction isStypNumeric(source) {\n    return typeof source === 'object' && (source.type === 'dimension' || source.type === 'calc' || source.type === 0);\n}\n\nclass Zero extends StypNumericStruct {\n    constructor(_byPriority, opts) {\n        super(opts);\n        this._byPriority = _byPriority;\n    }\n    get type() {\n        return 0;\n    }\n    toDim(dim) {\n        return dim.zero.prioritize(this.priority);\n    }\n    is(other) {\n        if (this === other) {\n            return true;\n        }\n        if (typeof other === 'object') {\n            return other.type === this.type && other.priority === this.priority;\n        }\n        if (other === 0 || other === '0') {\n            return this.priority === 0 /* Usual */;\n        }\n        if (other === '0 !important') {\n            return this.priority === 1 /* Important */;\n        }\n        return false;\n    }\n    add(addendum, unit) {\n        if (typeof addendum === 'number') {\n            addendum = stypDimension(addendum, unit, this);\n        }\n        return addendum.prioritize(this.priority);\n    }\n    sub(subtrahend, unit) {\n        if (typeof subtrahend === 'number') {\n            subtrahend = stypDimension(subtrahend, unit, this);\n        }\n        return subtrahend.negate().prioritize(this.priority);\n    }\n    mul() {\n        return this;\n    }\n    div() {\n        return this;\n    }\n    negate() {\n        return this;\n    }\n    prioritize(priority) {\n        return this._byPriority.get(priority);\n    }\n    important() {\n        return this._byPriority.important;\n    }\n    usual() {\n        return this._byPriority.usual;\n    }\n    toFormula() {\n        return '0';\n    }\n}\nclass ZeroByPriority {\n    constructor(dim) {\n        this.dim = dim;\n        this.usual = new Zero(this, { dim });\n        this.important = new Zero(this, { dim, priority: 1 /* Important */ });\n    }\n    get(priority) {\n        switch (priority) {\n            case 0 /* Usual */: return this.usual;\n            case 1 /* Important */: return this.important;\n        }\n        return new Zero(this, { dim: this.dim, priority });\n    }\n}\n/**\n * @internal\n */\nfunction newStypZero(dim) {\n    return new ZeroByPriority(dim).usual;\n}\n\n/**\n * @internal\n */\nfunction unitlessZeroDimensionKind({ pt, noPt, }) {\n    const dimension = {\n        get zero() {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return zero;\n        },\n        get pt() {\n            return pt();\n        },\n        get noPt() {\n            return noPt();\n        },\n        of(val, unit) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return val ? new StypDimension(val, unit, { dim: this }) : zero;\n        },\n        by(source) {\n            if (!isStypNumeric(source)) {\n                return;\n            }\n            return source.toDim(this);\n        },\n    };\n    const zero = newStypZero(dimension);\n    return dimension;\n}\n/**\n * @internal\n */\nfunction unitZeroDimensionKind({ zeroUnit, withPercent, noPercent, }) {\n    const dim = {\n        get pt() {\n            return withPercent && withPercent();\n        },\n        get noPt() {\n            return noPercent ? noPercent() : this;\n        },\n        get zero() {\n            return zero; // eslint-disable-line @typescript-eslint/no-use-before-define\n        },\n        of(val, unit) {\n            return new StypDimension(val, unit, { dim: this });\n        },\n        by(source) {\n            if (!isStypNumeric(source)) {\n                return;\n            }\n            return source.toDim(this);\n        },\n    };\n    const zero = new StypDimension(0, zeroUnit, { dim });\n    return dim;\n}\n\n/**\n * @category CSS Value\n */\nconst StypAngle = ( /*#__PURE__*/unitlessZeroDimensionKind({\n    pt() {\n        return StypAnglePt; // eslint-disable-line @typescript-eslint/no-use-before-define\n    },\n    noPt() {\n        return StypAngle;\n    },\n}));\n/**\n * @category CSS Value\n */\nconst StypAnglePt = (\n/*#__PURE__*/ unitlessZeroDimensionKind({\n    pt() {\n        return StypAnglePt;\n    },\n    noPt() {\n        return StypAngle;\n    },\n}));\n\n/**\n * @category CSS Value\n */\nconst StypFrequency = ( /*#__PURE__*/unitZeroDimensionKind({\n    zeroUnit: 'kHz',\n    withPercent() {\n        return StypFrequencyPt; // eslint-disable-line @typescript-eslint/no-use-before-define\n    },\n    noPercent() {\n        return StypFrequency;\n    },\n}));\n/**\n * @category CSS Value\n */\nconst StypFrequencyPt = ( /*#__PURE__*/unitZeroDimensionKind({\n    zeroUnit: 'kHz',\n    withPercent() {\n        return StypFrequencyPt;\n    },\n    noPercent() {\n        return StypFrequency;\n    },\n}));\n\n/**\n * @category CSS Value\n */\nconst StypLength = ( /*#__PURE__*/unitlessZeroDimensionKind({\n    pt() {\n        return StypLengthPt; // eslint-disable-line @typescript-eslint/no-use-before-define\n    },\n    noPt() {\n        return StypLength;\n    },\n}));\n/**\n * @category CSS Value\n */\nconst StypLengthPt = (\n/*#__PURE__*/ unitlessZeroDimensionKind({\n    pt() {\n        return StypLengthPt;\n    },\n    noPt() {\n        return StypLength;\n    },\n}));\n\n/**\n * @category CSS Value\n */\nconst StypResolution = (\n/*#__PURE__*/ unitZeroDimensionKind({ zeroUnit: 'dpi' }));\n\n/**\n * @category CSS Value\n */\nconst StypTime = ( /*#__PURE__*/unitlessZeroDimensionKind({\n    pt() {\n        return StypTimePt; // eslint-disable-line @typescript-eslint/no-use-before-define\n    },\n    noPt() {\n        return StypTime;\n    },\n}));\n/**\n * @category CSS Value\n */\nconst StypTimePt = ( /*#__PURE__*/unitlessZeroDimensionKind({\n    pt() {\n        return StypTimePt;\n    },\n    noPt() {\n        return StypTime;\n    },\n}));\n\n/**\n * Structured [URL](https://developer.mozilla.org/en-US/docs/Web/CSS/url) CSS property value.\n *\n * @category CSS Value\n */\nclass StypURL extends StypValueStruct {\n    /**\n     * Constructs URL value.\n     *\n     * @param url - Target URL.\n     * @param opts - Construction options.\n     */\n    constructor(url, opts) {\n        super(opts);\n        this.url = url;\n    }\n    /**\n     * `url` value type.\n     */\n    get type() {\n        return 'url';\n    }\n    /**\n     * Maps the given CSS property value to URL. Defaults to `undefined` if mapping is not possible.\n     *\n     * This method allows to use a {@link StypURL} class as [CSS property mapping]{@link StypMapper.Mapping}.\n     *\n     * Strings are treated as URLs (without `url()` functional syntax). `!important` suffix is respected.\n     *\n     * @param source - A raw property value that should be converted.\n     *\n     * @returns Mapped property value or `undefined`.\n     */\n    static by(source) {\n        switch (typeof source) {\n            case 'string': {\n                const [url, priority] = stypSplitPriority(source);\n                return new StypURL(url, { priority });\n            }\n            case 'object':\n                if (source.type === 'url') {\n                    return source;\n                }\n                break;\n        }\n        return;\n    }\n    by(source) {\n        return StypURL.by(source) || this;\n    }\n    prioritize(priority) {\n        return priority === this.priority ? this : new StypURL(this.url, { priority });\n    }\n    is(other) {\n        return typeof other === 'object'\n            && other.type === 'url'\n            && other.url === this.url\n            && other.priority === this.priority;\n    }\n    toString() {\n        return `url(\"${escapeCSSVal(this.url)}\")`;\n    }\n}\n\n/**\n * @internal\n */\nconst noStypProperties = ( /*#__PURE__*/afterThe({}));\n/**\n * @internal\n */\nfunction noStypPropertiesSpec() {\n    return noStypProperties;\n}\n/**\n * @internal\n */\nfunction stypPropertiesBySpec(rule, spec) {\n    if (!spec) {\n        return noStypProperties;\n    }\n    if (typeof spec !== 'string') {\n        if (isEventKeeper(spec)) {\n            return preventDuplicates(spec);\n        }\n        if (isEventSender(spec)) {\n            return preventDuplicates(propertiesKeeper(spec));\n        }\n        if (typeof spec === 'function') {\n            const senderOrProperties = spec(rule);\n            if (typeof senderOrProperties !== 'string') {\n                if (isEventKeeper(senderOrProperties)) {\n                    return preventDuplicates(senderOrProperties);\n                }\n                if (isEventSender(senderOrProperties)) {\n                    return preventDuplicates(propertiesKeeper(senderOrProperties));\n                }\n            }\n            return afterThe(propertiesMap(senderOrProperties));\n        }\n    }\n    return afterThe(propertiesMap(spec));\n}\nfunction propertiesKeeper(sender) {\n    return afterSupplied(sender, valuesProvider({}));\n}\nfunction preventDuplicates(properties) {\n    return afterSupplied(properties).do(mapAfter_(propertiesMap), deduplicateAfter(isDuplicateProperties, cloneProperties));\n}\nfunction propertiesMap(properties) {\n    return typeof properties === 'string' ? { $$css: properties } : properties;\n}\nfunction isDuplicateProperties(first, second) {\n    const s = itsIterator(propertyEntries(second));\n    for (const [key, value] of propertyEntries(first)) {\n        const { value: sentry } = s.next();\n        if (!sentry || key !== sentry[0] || !stypValuesEqual(value, sentry[1])) {\n            return false;\n        }\n    }\n    return !s.next().value;\n}\nfunction cloneProperties([properties]) {\n    return { ...properties };\n}\nfunction propertyEntries(properties) {\n    return filterIt(overEntries(properties), ([, value]) => isPresent(value));\n}\n/**\n * @internal\n */\nfunction mergeStypProperties(base, addendum) {\n    return preventDuplicates(afterAll({ base, addendum }).do(mapAfter(({ base: [baseProperties], addendum: [addendumProperties], }) => addValues(baseProperties, addendumProperties))));\n}\nfunction addValues(base, addendum) {\n    return itsReduction(overEntries(addendum), (result, [k, v]) => addValue(result, k, v), { ...base });\n}\nfunction addValue(properties, key, value) {\n    if (priorityOf(properties[key]) <= priorityOf(value)) {\n        delete properties[key];\n        properties[key] = value;\n    }\n    return properties;\n}\nfunction priorityOf(value) {\n    switch (typeof value) {\n        case 'string':\n            return value.endsWith(IMPORTANT_CSS_SUFFIX) ? 1 : 0;\n        case 'object':\n            return value.priority;\n        default:\n            return 0;\n    }\n}\n\n/**\n * @internal\n */\nfunction isCombinator(item) {\n    return item === '>' || item === '+' || item === '~';\n}\nfunction normalizeStypSelector(selector) {\n    if (!isReadonlyArray(selector)) {\n        return [normalizeKey(selector)];\n    }\n    const normalized = [];\n    let combinator;\n    for (const item of selector) {\n        const prevCombinator = combinator;\n        if (combinator) {\n            normalized.push(combinator);\n            combinator = undefined;\n        }\n        let part;\n        if (isCombinator(item)) {\n            combinator = item;\n            if (!prevCombinator) {\n                continue;\n            }\n            part = {};\n        }\n        else {\n            part = normalizeKey(item);\n        }\n        normalized.push(part);\n    }\n    if (combinator) {\n        normalized.push(combinator, {});\n    }\n    return normalized;\n}\nfunction normalizeKey(key) {\n    if (typeof key === 'string') {\n        if (!key) {\n            return {};\n        }\n        return { s: key };\n    }\n    return normalizeStypSelectorPart(key);\n}\n/**\n * @internal\n */\nfunction normalizeStypSelectorPart(part) {\n    const ns = part.ns || undefined;\n    const i = part.i || undefined;\n    const c = normalizeClasses(part.c);\n    const u = normalizeSubSelectors(part.u);\n    return {\n        ns,\n        e: (part.e !== '*' || !ns && !i && !c && u && isPseudoSubSelector(u[0])) && part.e || undefined,\n        i,\n        c,\n        u,\n        s: part.s || undefined,\n        $: normalizeQualifiers(part.$),\n    };\n}\nfunction normalizeClasses(classes) {\n    if (!classes) {\n        return;\n    }\n    if (isQualifiedName(classes)) {\n        return [classes];\n    }\n    const result = classes.filter(c => !!c);\n    return isNotEmptyArray(result) ? result.sort(compareNames) : undefined;\n}\nfunction normalizeSubSelectors(subs) {\n    if (!subs) {\n        return;\n    }\n    if ( /*#__INLINE__*/isSubSelectorsArray(subs)) {\n        const result = subs.map(normalizeSubSelector);\n        return isNotEmptyArray(result) ? result : undefined;\n    }\n    return [normalizeSubSelector(subs)];\n}\nfunction isSubSelectorsArray(subs) {\n    return typeof subs[0] !== 'string';\n}\nfunction normalizeSubSelector(sub) {\n    if (!isPseudoSubSelector(sub)) {\n        return sub;\n    }\n    if (sub.length < 3) {\n        return sub;\n    }\n    const [prefix, name, ...params] = sub;\n    if ( /*#__INLINE__*/isSubSelectorParametersArray(params)) {\n        return [prefix, name, ...params.map(normalizeStypSelector)];\n    }\n    return [prefix, name, normalizeStypSelector(params)];\n}\nfunction isPseudoSubSelector(sub) {\n    return sub.length > 1 && (sub[0] === ':' || sub[0] === '::');\n}\nfunction isSubSelectorParametersArray(param) {\n    return isReadonlyArray(param[0]);\n}\nfunction normalizeQualifiers(qualifiers) {\n    if (!qualifiers) {\n        return;\n    }\n    if (!isReadonlyArray(qualifiers)) {\n        qualifiers = [...exposeQualifier(qualifiers)];\n    }\n    else {\n        qualifiers = [...new Set(flatMapIt(qualifiers, exposeQualifier))].sort();\n    }\n    return isNotEmptyArray(qualifiers) ? qualifiers : undefined;\n}\nconst noQualifiers = new Set();\nfunction exposeQualifier(qualifier) {\n    if (!qualifier) {\n        return noQualifiers;\n    }\n    const eqIdx = qualifier.indexOf('=');\n    const name = eqIdx < 0 ? qualifier : qualifier.substring(0, eqIdx);\n    const exposed = new Set();\n    let lastExposed;\n    for (const part of name.split(':')) {\n        if (lastExposed) {\n            lastExposed += ':' + part;\n        }\n        else {\n            lastExposed = part;\n        }\n        exposed.add(lastExposed);\n    }\n    if (eqIdx >= 0) {\n        exposed.add(qualifier);\n    }\n    return exposed;\n}\nconst noKeyAndTail = [[]];\n/**\n * @internal\n */\nfunction stypRuleKeyAndTail(selector) {\n    if (!selector.length) {\n        return noKeyAndTail;\n    }\n    let i = 0;\n    let combinator;\n    for (;;) {\n        const part = selector[i++];\n        if (isCombinator(part)) {\n            combinator = part;\n            continue;\n        }\n        const key = combinator ? [combinator, part] : [part];\n        return [key, selector.slice(i)];\n    }\n}\nconst rootSelector$1 = [];\n/**\n * @internal\n */\nfunction stypOuterSelector(selector) {\n    let i = selector.length - 1;\n    if (i <= 0) {\n        return i ? undefined : rootSelector$1;\n    }\n    do {\n        --i;\n        switch (selector[i]) {\n            case '>':\n                return selector.slice(0, i);\n            case '+':\n            case '~':\n                --i;\n                continue;\n            default:\n                return selector.slice(0, i + 1);\n        }\n    } while (i > 0);\n    return;\n}\n\n/**\n * Normalizes arbitrary CSS rule query.\n *\n * @category CSS Rule\n * @param query - CSS rule query to normalize.\n *\n * @returns Normalized CSS rule query.\n */\nfunction stypQuery(query) {\n    return normalizeStypSelectorPart(query);\n}\n/**\n * Checks whether the given structured CSS `selector` matches target `query`.\n *\n * @category CSS Rule\n * @param selector - Normalized structured CSS selector.\n * @param query - Normalized CSS rule query.\n *\n * @returns `true` if `selector` matches the `query`, or `false` otherwise.\n */\nfunction stypSelectorMatches(selector, query) {\n    if (!selector.length) {\n        return false;\n    }\n    const part = selector[selector.length - 1];\n    if (query.ns && part.ns !== query.ns) {\n        return false;\n    }\n    if (query.e && part.e !== query.e) {\n        return false;\n    }\n    if (query.i && part.i !== query.i) {\n        return false;\n    }\n    if (query.c && !classesMatch(part.c, query.c)) {\n        return false;\n    }\n    // noinspection RedundantIfStatementJS\n    if (query.$ && !classesMatch(part.$, query.$)) {\n        return false;\n    }\n    return true;\n}\n/**\n * @internal\n */\nfunction classesMatch(classes, query) {\n    return classes && query.every(qClass => classes.find(mClass => namesEqual(qClass, mClass)));\n}\n\nfunction stypSelector(selector) {\n    return normalizeStypSelector(selector);\n}\n\nconst ruleKeyTextOpts = {\n    qualify(qualifier) {\n        return `@${escapeCSS(qualifier)}`;\n    },\n};\n/**\n * @internal\n */\nfunction stypRuleKeyText(key) {\n    return formatStypSelector(key, ruleKeyTextOpts);\n}\nconst defaultFormat = {};\n/**\n * @internal\n */\nfunction formatStypSelector(selector, { qualify, nsAlias = newNamespaceAliaser(), } = defaultFormat) {\n    const format = { qualify, nsAlias };\n    return selector.reduce((result, item) => {\n        if (isCombinator(item)) {\n            return result + item;\n        }\n        if (result && !isCombinator(result[result.length - 1])) {\n            result += ' ';\n        }\n        return result + formatItem(item, format);\n    }, '');\n}\nfunction formatItem(item, { qualify, nsAlias, }) {\n    const { ns, e, i, c, s, u, $ } = item;\n    let hasProperties = false;\n    let out = '';\n    if (i) {\n        hasProperties = true;\n        out += `#${escapeCSS(id__naming.name(i, nsAlias))}`;\n    }\n    if (c) {\n        hasProperties = true;\n        out = c.reduce((result, className) => `${result}.${escapeCSS(css__naming.name(className, nsAlias))}`, out);\n    }\n    if (u) {\n        hasProperties = true;\n        const subFormat = { nsAlias };\n        out = u.reduce((result, sub) => formatSubSelector(result, sub, subFormat), out);\n    }\n    if (s) {\n        hasProperties = true;\n        out += s;\n    }\n    if (qualify && $) {\n        out = $.reduce((result, qualifier) => result + qualify(qualifier), out);\n    }\n    if (ns) {\n        const alias = xmlNs(ns, nsAlias);\n        if (alias) {\n            out = `${alias}|${e || '*'}${out}`;\n        }\n        else {\n            out = qualifyElement();\n        }\n    }\n    else {\n        out = qualifyElement();\n    }\n    return out;\n    function qualifyElement() {\n        if (hasProperties) {\n            return `${e ? html__naming.name(e, nsAlias) : ''}${out}`;\n        }\n        return `${e ? html__naming.name(e, nsAlias) : '*'}${out}`;\n    }\n}\nfunction formatSubSelector(out, sub, format) {\n    if (isPseudoSubSelector(sub)) {\n        out += sub[0] + sub[1];\n        const len = sub.length;\n        if (len > 2) {\n            out += '(' + formatStypSelector(sub[2], format);\n            for (let i = 3; i < sub.length; ++i) {\n                out += ',' + formatStypSelector(sub[i], format);\n            }\n            out += ')';\n        }\n        return out;\n    }\n    const [attrName, attrOp, attrVal, attrFlag] = sub;\n    out += '[' + escapeCSS(attrName);\n    if (attrOp) {\n        out += `${attrOp}\"${escapeCSSVal(attrVal)}\"`;\n    }\n    if (attrFlag) {\n        out += ' ' + attrFlag;\n    }\n    return out + ']';\n}\nfunction xmlNs(ns, nsAlias) {\n    return typeof ns === 'string' ? ns : ns.url ? nsAlias(ns) : undefined;\n}\n\n/**\n * Converts structured CSS selector to its textual representation.\n *\n * @category CSS Rule\n * @param selector - Target CSS selector.\n * @param format - CSS selector format.\n *\n * @returns CSS selector string.\n */\nfunction stypSelectorText(selector, format) {\n    return formatStypSelector(stypSelector(selector), format);\n}\n\n/**\n * Tests whether two normalized structured CSS selectors equal.\n *\n * @category CSS Rule\n * @param first - First selector.\n * @param second - Second selector.\n *\n * @returns `true` if selectors are equal, `false` otherwise.\n */\nfunction stypSelectorsEqual(first, second) {\n    if (first.length !== second.length) {\n        return false;\n    }\n    return first.every((part, i) => stypSelectorPartsEqual(part, second[i]));\n}\n/**\n * @internal\n */\nfunction stypSelectorPartsEqual(first, second) {\n    if (typeof first === 'string') {\n        return first === second;\n    }\n    if (typeof second === 'string') {\n        return false;\n    }\n    return namespacesEqual(first.ns, second.ns)\n        && namesEqualOrAbsent(first.e, second.e)\n        && namesEqualOrAbsent(first.i, second.i)\n        && classesEqual(first.c, second.c)\n        && subSelectorListEqual(first.u, second.u)\n        && qualifiersEqual(first.$, second.$);\n}\n/**\n * @internal\n */\nfunction namespacesEqual(first, second) {\n    if (!first || typeof first === 'string') {\n        return first === second;\n    }\n    if (!second || typeof second === 'string') {\n        return false;\n    }\n    return first.url === second.url;\n}\n/**\n * @internal\n */\nfunction namesEqualOrAbsent(first, second) {\n    return first == null ? second == null : second != null && namesEqual(first, second);\n}\n/**\n * @internal\n */\nfunction classesEqual(first, second) {\n    if (!first) {\n        return !second;\n    }\n    if (!second) {\n        return false;\n    }\n    return first.length === second.length && first.every((name, i) => namesEqual(name, second[i]));\n}\n/**\n * @internal\n */\nfunction subSelectorListEqual(first, second) {\n    if (!first) {\n        return !second;\n    }\n    if (!second) {\n        return false;\n    }\n    return first.length === second.length && first.every((sub, i) => subSelectorsEqual(sub, second[i]));\n}\n/**\n * @internal\n */\nfunction subSelectorsEqual(first, second) {\n    if (first.length !== second.length) {\n        return false;\n    }\n    if (isPseudoSubSelector(first)) {\n        return first.every((p, i) => i < 2\n            ? p === second[i]\n            : stypSelectorsEqual(p, second[i]));\n    }\n    return first.every((str, i) => str === second[i]);\n}\n/**\n * @internal\n */\nfunction qualifiersEqual(first, second) {\n    if (!first) {\n        return !second;\n    }\n    if (!second) {\n        return false;\n    }\n    return first.length === second.length && first.every((qualifier, i) => qualifier === second[i]);\n}\n\n/**\n * @internal\n */\nconst FIRST_RENDER_ORDER = -0xffff;\n\n/**\n * @internal\n */\nclass AtRulesRenderer {\n    constructor(_rule) {\n        this._rule = _rule;\n    }\n    read(properties) {\n        let outer = this._rule.outer;\n        while (outer) {\n            properties = mergeStypProperties(outer.read.do(mapAfter(onlyAtProperties)), properties);\n            outer = outer.outer;\n        }\n        return properties;\n    }\n    render(producer, properties) {\n        const { selector } = producer;\n        let { writer } = producer;\n        if (!writer.isGroup) {\n            producer.render(properties);\n            return;\n        }\n        let sheet = writer;\n        const extracted = extractAtSelectors(selector);\n        if (!extracted) {\n            producer.render(properties);\n            return;\n        }\n        const [atSelectors, restSelector] = extracted;\n        for (const atSelector of atSelectors) {\n            const [name, params] = buildAtSelector(properties, atSelector);\n            if (params) {\n                writer = sheet = sheet.addGroup(name, params);\n            }\n            else {\n                writer = sheet.addStyle(name);\n                break;\n            }\n        }\n        producer.render(properties, { writer, selector: restSelector });\n    }\n}\n/**\n * @internal\n */\nfunction buildAtSelector(properties, [key, [names, customQuery]]) {\n    let query = '';\n    const addQuery = (q) => {\n        if (q) {\n            if (query) {\n                query += ' and ';\n            }\n            query += q;\n        }\n    };\n    for (const name of names) {\n        const [namedQuery] = stypSplitPriority(properties[name]);\n        addQuery(namedQuery);\n    }\n    addQuery(customQuery);\n    return query ? [key, query] : [key];\n}\n/**\n * CSS stylesheet renderer of at-rules like `@media` queries.\n *\n * At-rules are represented by qualifiers which names start with `@` symbol. Qualifier names are used as at-rules keys,\n * and their values - as queries. If the rest of the selector is not empty, then properties are rendered in CSS\n * rule nested inside at-rule. Otherwise the properties are rendered in at-rule.\n *\n * So, for example CSS rule with `{ c: 'screen-only', $: '@media=screen' }` selector would be rendered as\n * ```css\n * @media screen {\n *   .screen-only {\n *      \\/* CSS properties *\\/\n *   }\n * }\n * ```\n *\n * Another option is to use named at-rules qualifiers. When named qualifier is used, the corresponding property is\n * searched in CSS rule and all of its outer rules. The values of all matching properties are used as queries.\n *\n * So the above example could be written as: `{ c: 'screen-only', $: '@media:screen' }` if CSS rule (or its outer\n * one) contains property `@media:screen` with value `screen`.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nconst stypRenderAtRules = {\n    order: FIRST_RENDER_ORDER,\n    create(rule) {\n        return new AtRulesRenderer(rule);\n    },\n};\n/**\n * @internal\n */\nfunction onlyAtProperties(properties) {\n    return itsReduction(filterIt(overEntries(properties), isAtEntry), (result, [key, value]) => {\n        result[key] = value;\n        return result;\n    }, {});\n}\n/**\n * @internal\n */\nfunction isAtEntry(entry) {\n    return String(entry[0])[0] === '@';\n}\n/**\n * @internal\n */\nfunction extractAtSelectors(selector) {\n    const atSelectors = new Map();\n    const rest = [];\n    for (const part of selector) {\n        if (isCombinator(part)) {\n            rest.push(part);\n        }\n        else {\n            rest.push(extractPartAtSelectors(part, atSelectors));\n        }\n    }\n    if (!atSelectors.size) {\n        return; // No at-rule qualifiers found.\n    }\n    return [atSelectors, stypSelector(rest)];\n}\n/**\n * @internal\n */\nfunction extractPartAtSelectors(part, atSelectors) {\n    const qualifiers = part.$;\n    if (!qualifiers) {\n        return part;\n    }\n    const restQualifies = [];\n    for (const qualifier of qualifiers) {\n        if (qualifier[0] === '@') {\n            addAtSelector(atSelectors, qualifier);\n        }\n        else {\n            restQualifies.push(qualifier);\n        }\n    }\n    if (restQualifies.length === qualifiers.length) {\n        return part; // No at-rule qualifiers found\n    }\n    if (isNotEmptyArray(restQualifies)) {\n        return { ...part, $: restQualifies };\n    }\n    return { ...part, $: undefined };\n}\n/**\n * @internal\n */\nfunction addAtSelector(atSelectors, qualifier) {\n    const eqIdx = qualifier.indexOf('=');\n    let name;\n    let query;\n    if (eqIdx < 0) {\n        name = qualifier;\n    }\n    else {\n        name = qualifier.substring(0, eqIdx);\n        query = qualifier.substring(eqIdx + 1);\n    }\n    const colonIdx = name.indexOf(':');\n    const key = colonIdx < 0 ? name : name.substring(0, colonIdx);\n    const atSelector = atSelectors.get(key);\n    if (!atSelector) {\n        atSelectors.set(key, [new Set().add(name), query]);\n    }\n    else {\n        const [names, prevQuery] = atSelector;\n        names.add(name);\n        if (query) {\n            atSelector[1] = prevQuery ? `${prevQuery} and ${query}` : query;\n        }\n    }\n}\n\n/**\n * CSS stylesheet renderer of global at-rules.\n *\n * It renders at-rules that should stay at the top level:\n * - `@namespace`\n * - `@import`\n *\n * At-rule parameters are taken from root CSS rule properties and treated as following.\n *\n * **`@import:url`** property value is treated as media query and appended after stylesheet URL. I.e.\n * ```json\n * {\n *     \"@import:path/to/included.css\": \"screen\"\n * }\n * ```\n * becomes\n * ```css\n * @import url(path/to/included.css) screen;\n * ```\n *\n * **`@namespace`** property value is treated as default namespace URL. I.e.\n * ```json\n * {\n *     \"@namespace\": \"http://www.w3.org/1999/xhtml\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace url(http://www.w3.org/1999/xhtml);\n * ```\n *\n * **`@namespace:prefix`** property value is treated as namespace URL with the given prefix. I.e\n * ```json\n * {\n *     \"@namespace:svg\": \"http://www.w3.org/2000/svg\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace svg url(http://www.w3.org/2000/svg);\n * ```\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nconst stypRenderGlobals = {\n    order: FIRST_RENDER_ORDER + 1,\n    needs: stypRenderAtRules,\n    render(producer, properties) {\n        const rootRule = !producer.rule.selector.length;\n        const { sheet } = producer;\n        let importIndex = 0;\n        let nsIndex = 0;\n        for (const [k, v] of overEntries(properties)) {\n            const key = String(k);\n            if (key[0] === '@') {\n                const [value] = stypSplitPriority(v);\n                const importDelta = rootRule ? renderImport(sheet, importIndex, key, value) : 0;\n                importIndex += importDelta;\n                nsIndex += importDelta;\n                const url = StypURL.by(value);\n                if (url) {\n                    nsIndex += renderDefaultNamespace(sheet, nsIndex, key, url);\n                    nsIndex += renderNamespacePrefix(sheet, nsIndex, key, url);\n                }\n            }\n        }\n        producer.render(properties);\n    },\n};\n/**\n * @internal\n */\nconst IMPORT_PREFIX = '@import:';\n/**\n * @internal\n */\nfunction renderImport(sheet, index, key, value) {\n    if (!key.startsWith(IMPORT_PREFIX)) {\n        return 0;\n    }\n    const url = new StypURL(key.substring(IMPORT_PREFIX.length));\n    let css = String(url);\n    if (value) {\n        css += ` ${value}`;\n    }\n    sheet.addGlobal('@import', css, index);\n    return 1;\n}\n/**\n * @internal\n */\nfunction renderDefaultNamespace(sheet, index, key, url) {\n    if (key !== '@namespace') {\n        return 0;\n    }\n    sheet.addGlobal('@namespace', String(url), index);\n    return 1;\n}\n/**\n * @internal\n */\nconst NS_PREFIX = '@namespace:';\n/**\n * @internal\n */\nfunction renderNamespacePrefix(sheet, index, key, url) {\n    if (!key.startsWith(NS_PREFIX)) {\n        return 0;\n    }\n    const prefix = key.substring(NS_PREFIX.length);\n    sheet.addGlobal('@namespace', `${prefix} ${url}`, index);\n    return 1;\n}\n\n/**\n * Renders CSS properties.\n *\n * This renderer is always present, so there is typically no need to use it explicitly.\n *\n * @category Rendering\n */\nfunction stypRenderProperties(producer, properties) {\n    const style = producer.addStyle();\n    itsEach(filterIt(overEntries(properties), notCustomProperty), ([k, v]) => {\n        const [value, priority] = stypSplitPriority(v);\n        style.set(hyphenateCSSName(k), `${value}`, priority);\n    });\n    producer.render(properties, { writer: style });\n}\n/**\n * @internal\n */\nfunction notCustomProperty(entry) {\n    const [key, value] = entry;\n    if (value == null) {\n        return false;\n    }\n    const first = String(key)[0];\n    return first >= 'a' && first <= 'z' || first >= 'A' && first <= 'Z';\n}\n\n/**\n * Renders raw CSS text. I.e. the contents of {@link StypProperties.Generic.$$css} property.\n *\n * It should be rendered before CSS properties normally to add the rendered rule as a first one.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nfunction stypRenderText(producer, properties) {\n    const css = properties.$$css;\n    if (!css) {\n        producer.render(properties);\n    }\n    else {\n        const style = producer.addStyle();\n        style.replace(css);\n        producer.render(properties, { writer: style });\n    }\n}\n\n/**\n * CSS stylesheet renderer of global XML namespace definitions.\n *\n * Renders `@namespace` declarations for CSS selectors containing namespace definitions.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nconst stypRenderXmlNs = {\n    order: FIRST_RENDER_ORDER,\n    needs: stypRenderGlobals,\n    render(producer, properties) {\n        const xmlNsDefs = extractXmlNsDefs(producer.selector);\n        if (xmlNsDefs.length) {\n            const declareNs = (result, ns) => {\n                const alias = producer.nsAlias(ns);\n                result[`@namespace:${alias}`] = new StypURL(ns.url);\n                return result;\n            };\n            producer.render(xmlNsDefs.reduce(declareNs, { ...properties }));\n        }\n        else {\n            producer.render(properties);\n        }\n    },\n};\n/**\n * @internal\n */\nfunction extractXmlNsDefs(selector) {\n    return selector\n        .map(part => !isCombinator(part) && part.ns && typeof part.ns !== 'string' ? part.ns : null)\n        .filter(isPresent);\n}\n\n/**\n * @internal\n */\nfunction stypRenderFactories(format) {\n    const factories = new Map();\n    addRenderers(format.renderer);\n    factories.delete(stypRenderProperties);\n    return [...factories.values(), rendererFactory(stypRenderProperties)].sort(compareRenderers);\n    function addRenderers(renderers) {\n        if (renderers) {\n            if (isReadonlyArray(renderers)) {\n                renderers.forEach(addRenderer);\n            }\n            else {\n                addRenderer(renderers);\n            }\n        }\n    }\n    function addRenderer(renderer) {\n        if (factories.has(renderer)) {\n            return;\n        }\n        const factory = rendererFactory(renderer);\n        factories.set(renderer, factory);\n        addRenderers(factory.needs);\n    }\n}\nfunction rendererFactory(renderer) {\n    if (typeof renderer === 'function') {\n        return {\n            create() {\n                return { render: renderer };\n            },\n        };\n    }\n    if (isRendererFactory(renderer)) {\n        return {\n            order: renderer.order,\n            needs: renderer.needs,\n            create(rule) {\n                return rendererSpec(renderer.create(rule));\n            },\n        };\n    }\n    const render = renderer.render.bind(renderer);\n    return {\n        order: renderer.order,\n        needs: renderer.needs,\n        create() {\n            return { render };\n        },\n    };\n}\nfunction isRendererFactory(renderer) {\n    return 'create' in renderer;\n}\nfunction compareRenderers(first, second) {\n    const firstOrder = first.order || 0;\n    const secondOrder = second.order || 0;\n    return firstOrder > secondOrder ? 1 : firstOrder < secondOrder ? -1 : 0;\n}\nfunction rendererSpec(renderer) {\n    return typeof renderer === 'function' ? { render: renderer } : renderer;\n}\n/**\n * @internal\n */\nfunction stypRenderScheduler(parent, scheduler = newRenderSchedule) {\n    return (options = {}) => {\n        const { node = parent, error } = options;\n        return scheduler({\n            ...options,\n            node,\n            error: error && error.bind(options),\n        });\n    };\n}\n/**\n * @internal\n */\nfunction removeStyleElement(element) {\n    var _a;\n    (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n}\n\n/**\n * @internal\n */\nconst defaultPrettyPrint = {\n    indent: '  ',\n};\n/**\n * @internal\n */\nconst compactStypTextFormatter = {\n    nv: '',\n    eol: '',\n    pre: '',\n    indent() {\n        return this;\n    },\n};\n/**\n * @internal\n */\nclass StypTextFormatter$ {\n    constructor(_config, pre = '') {\n        this._config = _config;\n        this.pre = pre;\n    }\n    get nv() {\n        return ' ';\n    }\n    get eol() {\n        return '\\n';\n    }\n    indent() {\n        return new StypTextFormatter$(this._config, this.pre + this._config.indent);\n    }\n}\n/**\n * @internal\n */\nclass StypStyleTextWriter {\n    constructor(f, selector) {\n        this.f = f;\n        this.selector = selector;\n        this.body = '';\n        this.nf = f.indent();\n    }\n    get isGroup() {\n        return false;\n    }\n    set(name, value, priority) {\n        const p = priority >= 1 /* Important */ ? ' !important' : '';\n        const { pre, nv, eol } = this.nf;\n        if (this.body) {\n            this.body += `;${eol}`;\n        }\n        this.body += `${pre}${name}:${nv}${value}${p}`;\n    }\n    replace(css) {\n        this.body = css.trim();\n        if (this.body.endsWith(';')) {\n            this.body = this.body.substr(0, this.body.length - 1);\n        }\n    }\n    toString() {\n        const { pre, nv, eol } = this.f;\n        if (this.body) {\n            const afterBody = eol ? `;${eol}` : '';\n            return `${pre}${this.selector}${nv}{${eol}${this.body}${afterBody}${pre}}`;\n        }\n        return '';\n    }\n}\n/**\n * @internal\n */\nclass AbstractStypGroupTextWriter {\n    constructor(nf) {\n        this.nf = nf;\n        this._nested = [];\n    }\n    get isGroup() {\n        return true;\n    }\n    addGroup(name, params, index) {\n        return this._add(new StypGroupTextWriter(this.nf, name, params), index);\n    }\n    addStyle(selector, index) {\n        return this._add(new StypStyleTextWriter(this.nf, selector), index);\n    }\n    toString() {\n        let out = '';\n        for (const nested of this._nested) {\n            const text = String(nested);\n            if (text) {\n                if (out) {\n                    out += this.nf.eol;\n                }\n                out += text;\n            }\n        }\n        return out;\n    }\n    _add(nested, index = this._nested.length) {\n        this._nested.splice(index, 0, nested);\n        return nested;\n    }\n}\n/**\n * @internal\n */\nclass StypGroupTextWriter extends AbstractStypGroupTextWriter {\n    constructor(f, name, params) {\n        super(f.indent());\n        this.f = f;\n        this.name = name;\n        this.params = params;\n    }\n    toString() {\n        const body = super.toString();\n        if (!body) {\n            return '';\n        }\n        const { pre, nv, eol } = this.f;\n        return `${pre}${this.name} ${this.params}${nv}{${eol}${body}${eol}${pre}}`;\n    }\n}\n/**\n * @internal\n */\nclass StypSheetTextWriter extends AbstractStypGroupTextWriter {\n    constructor(id, f, sender) {\n        super(f);\n        this.id = id;\n        this.f = f;\n        this.sender = sender;\n    }\n    addGlobal(name, value, index) {\n        this._add(`${this.f.pre}${name} ${value};`, index);\n    }\n    clear() {\n        this._nested.length = 0;\n    }\n    remove() {\n        this.clear();\n        this.sender.send({ id: this.id });\n    }\n    done() {\n        this.sender.send({\n            id: this.id,\n            css: this.toString(),\n        });\n    }\n}\n/**\n * Builds textual CSS production format.\n *\n * It is necessary to register {@link StypTextFormat.onSheet CSS text receiver(s)} prior to start {@link produceStyle\n * style production} in order to receive CSS text for style sheets.\n *\n * @category Rendering\n * @param config - Textual format config.\n *\n * @returns Textual CSS production format.\n */\nfunction stypTextFormat(config = {}) {\n    const pretty = config.pretty === true || config.pretty == null\n        ? defaultPrettyPrint\n        : (config.pretty || false);\n    const { scheduler = immediateRenderScheduler } = config;\n    const sender = new EventEmitter();\n    const formatter = pretty ? new StypTextFormatter$(pretty) : compactStypTextFormatter;\n    let idSeq = 0;\n    return {\n        ...config,\n        pretty,\n        scheduler,\n        onSheet: sender.on,\n        addSheet() {\n            return new StypSheetTextWriter(String(++idSeq), formatter, sender);\n        },\n    };\n}\n\n/**\n * Builds DOM style production format.\n *\n * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and fills it with CSS text\n * generated by {@link stypTextFormat textual CSS production format}.\n *\n * This format is generally slower than {@link stypObjectFormat CSS object model production format}, but allows to add\n * `<style>` elements to DOM node outside document. E.g. to `DocumentFragment`.\n *\n * @category Rendering\n * @param config - DOM style format configuration.\n *\n * @returns CSS production format.\n */\nfunction stypDomFormat(config = {}) {\n    var _a;\n    const { document = ((_a = config.parent) === null || _a === void 0 ? void 0 : _a.ownerDocument) || window.document, parent = document.head, } = config;\n    const textFormat = stypTextFormat(config);\n    const scheduler = stypRenderScheduler(parent, config.scheduler);\n    const schedule = scheduler();\n    const elements = new Map();\n    const supply = textFormat.onSheet(({ id, css }) => {\n        // CSS text is reported within schedule. No need to re-schedule DOM manipulations here.\n        let element = elements.get(id);\n        if (css == null) { // element exists here\n            elements.delete(id);\n            removeStyleElement(element);\n        }\n        else if (element) {\n            element.textContent = css;\n        }\n        else {\n            element = document.createElement('style');\n            element.setAttribute('type', 'text/css');\n            element.textContent = css;\n            parent.appendChild(element);\n            elements.set(id, element);\n            supply.whenOff(\n            // Schedule element removal on style sheet removal instead of removing it right away.\n            () => schedule(() => removeStyleElement(element)));\n        }\n    });\n    return {\n        ...config,\n        scheduler,\n        addSheet(producer) {\n            supply.needs(producer);\n            this.addSheet = textFormat.addSheet.bind(textFormat);\n            return this.addSheet(producer);\n        },\n    };\n}\n\n/**\n * @internal\n */\nclass StypStyleObjectWriter {\n    constructor(_target) {\n        this._target = _target;\n    }\n    get isGroup() {\n        return false;\n    }\n    set(name, value, priority) {\n        this._target.style.setProperty(name, value, priority >= 1 /* Important */ ? 'important' : undefined);\n    }\n    replace(css) {\n        this._target.style.cssText = css;\n    }\n}\n/**\n * @internal\n */\nclass StypGroupObjectWriter {\n    constructor(_target) {\n        this._target = _target;\n    }\n    get isGroup() {\n        return true;\n    }\n    addGroup(name, params, index) {\n        return new StypGroupObjectWriter(this._add(`${name} ${params}{}`, index));\n    }\n    addStyle(selector, index) {\n        return new StypStyleObjectWriter(this._add(`${selector}{}`, index));\n    }\n    _add(ruleText, index = this._target.cssRules.length) {\n        const idx = this._target.insertRule(ruleText, index);\n        return this._target.cssRules[idx];\n    }\n}\n/**\n * @internal\n */\nclass StypSheetObjectWriter extends StypGroupObjectWriter {\n    constructor(_element) {\n        super(_element.sheet);\n        this._element = _element;\n    }\n    addGlobal(name, value, index) {\n        this._add(`${name} ${value};`, index);\n    }\n    clear() {\n        const { cssRules } = this._target;\n        while (cssRules.length) {\n            this._target.deleteRule(cssRules.length - 1);\n        }\n    }\n    remove() {\n        removeStyleElement(this._element);\n    }\n    done() {\n        /* do nothing */\n    }\n}\n/**\n * Builds CSS object model production format.\n *\n * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and builds its style sheet\n * with CSS object model methods.\n *\n * @category Rendering\n * @param config - Object format configuration.\n *\n * @returns CSS production format.\n */\nfunction stypObjectFormat(config = {}) {\n    const { parent = document.head } = config;\n    return {\n        ...config,\n        scheduler: stypRenderScheduler(parent, config.scheduler),\n        addSheet() {\n            const element = document.createElement('style');\n            element.setAttribute('type', 'text/css');\n            element.append(document.createTextNode(''));\n            parent.appendChild(element);\n            return new StypSheetObjectWriter(element);\n        },\n    };\n}\n\n/**\n * Produces and dynamically updates basic CSS stylesheets based on the given CSS rules.\n *\n * Unlike {@link produceStyle}, this function does not enable renderers but the basic one which just renders CSS\n * properties. This can be used to save the bundle size by enabling only select renderers.\n *\n * @category Rendering\n * @param rules - CSS rules to produce stylesheets for. This can be e.g. a {@link StypRule.rules} to render all rules,\n * or a result of {@link StypRuleList.grab} method call to render only matching ones.\n * @param format - Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nfunction produceBasicStyle(rules, format) {\n    const { rootSelector = { e: 'body' }, scheduler = newRenderSchedule, nsAlias = newNamespaceAliaser(), } = format;\n    const supply = new Supply();\n    const selectorFormat = { nsAlias };\n    const factories = stypRenderFactories(format);\n    const renderSupply = renderRules(rules);\n    const trackSupply = trackRules();\n    return supply.as(renderSupply).as(trackSupply);\n    function styleProducer(rule, renderer, production) {\n        class StyleProducer$ {\n            get supply() {\n                return supply;\n            }\n            get rule() {\n                return rule;\n            }\n            get sheet() {\n                return production.sheet;\n            }\n            get writer() {\n                return production.writer;\n            }\n            get selector() {\n                return production.selector;\n            }\n            nsAlias(ns) {\n                return nsAlias(ns);\n            }\n            render(properties, options) {\n                if (!options) {\n                    renderer(this, properties);\n                }\n                else {\n                    renderer(styleProducer(rule, renderer, {\n                        sheet: production.sheet,\n                        writer: options.writer || production.writer,\n                        selector: options.selector || production.selector,\n                    }), properties);\n                }\n            }\n            addStyle(_selector = production.selector) {\n                const { writer } = production;\n                if (!writer.isGroup) {\n                    return writer;\n                }\n                return writer.addStyle(selectorText(_selector));\n            }\n        }\n        return new StyleProducer$();\n    }\n    function selectorText(selector) {\n        return stypSelectorText(selector, selectorFormat);\n    }\n    function renderRules(rulesToRender) {\n        return itsReduction(mapIt(rulesToRender, renderRule), (prev, supply) => new Supply().cuts(supply).cuts(prev), new Supply());\n    }\n    function trackRules() {\n        const supply = new Supply();\n        return onSupplied(rules)({\n            supply,\n            receive: (_ctx, added) => {\n                added.forEach(r => renderRule(r).needs(supply));\n            },\n        });\n    }\n    function renderRule(rule) {\n        const [reader, renderer] = rendererForRule(rule);\n        let sheet;\n        const selector = ruleSelector(rule);\n        const schedule = scheduler();\n        return reader(renderProperties).whenOff(removeStyle);\n        function renderProperties(properties) {\n            schedule(() => {\n                sheet === null || sheet === void 0 ? void 0 : sheet.clear();\n                const producer = styleProducer(rule, renderer, {\n                    get sheet() {\n                        if (!sheet) {\n                            sheet = format.addSheet(producer);\n                        }\n                        return sheet;\n                    },\n                    get writer() {\n                        return this.sheet;\n                    },\n                    selector,\n                });\n                producer.render(properties);\n                sheet === null || sheet === void 0 ? void 0 : sheet.done();\n            });\n        }\n        function removeStyle() {\n            schedule(() => {\n                const lastSheet = sheet;\n                if (lastSheet) {\n                    sheet = undefined;\n                    return lastSheet.remove();\n                }\n                // Otherwise element is removed before anything rendered.\n                // Should never happen for properly constructed rule.\n            });\n        }\n    }\n    function ruleSelector(rule) {\n        const selector = rule.selector;\n        if (!selector.length) {\n            // Use configured root selector\n            return stypSelector(rootSelector);\n        }\n        if (isCombinator(selector[0])) {\n            // First combinator is relative to root selector\n            return [...stypSelector(rootSelector), ...selector];\n        }\n        return selector;\n    }\n    function rendererForRule(rule) {\n        const specs = factories.map(factory => factory.create(rule));\n        const reader = specs.reduce((read, spec) => spec.read ? afterSupplied(spec.read(read)) : read, rule.read);\n        return [reader, renderAt(0)];\n        function renderAt(index) {\n            return (producer, properties) => {\n                const nextIndex = index + 1;\n                let nextRenderer;\n                if (nextIndex === factories.length) {\n                    nextRenderer = noop;\n                }\n                else {\n                    nextRenderer = renderAt(nextIndex);\n                }\n                const nextProducer = styleProducer(producer.rule, nextRenderer, producer);\n                specs[index].render(nextProducer, properties);\n            };\n        }\n    }\n}\n\n/**\n * @internal\n */\nfunction defaultStypRenderers(renderer) {\n    const result = [\n        stypRenderAtRules,\n        stypRenderXmlNs,\n        stypRenderGlobals,\n        stypRenderText,\n    ];\n    if (renderer) {\n        if (isReadonlyArray(renderer)) {\n            result.push(...renderer);\n        }\n        else {\n            result.push(renderer);\n        }\n    }\n    return result;\n}\n\n/**\n * Produces and dynamically updates CSS stylesheets based on the given CSS rules.\n *\n * Appends `<style>` element(s) to the given parent DOM node (`document.head` by default) and updates them when CSS\n * rules change.\n *\n * This function enables all default renderers. E.g. the one supporting raw CSS text rules. If some of them are not\n * needed a {@link produceBasicStyle} variant of this function may be used instead.\n *\n * @category Rendering\n * @param rules - CSS rules to produce stylesheets for. This can be e.g. a {@link StypRule.rules} to render all rules,\n * or a result of {@link StypRuleList.grab} method call to render only matching ones.\n * @param format - Production format.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nfunction produceStyle(rules, format) {\n    return produceBasicStyle(rules, { ...format, renderer: defaultStypRenderers(format.renderer) });\n}\n\n/**\n * CSS rule.\n *\n * Represents CSS selector and corresponding CSS properties.\n *\n * @category CSS Rule\n */\nclass StypRule {\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n    /**\n     * Appends CSS properties to this rule.\n     *\n     * @param properties - CSS properties specifier.\n     *\n     * @returns `this` rule instance.\n     */\n    add(properties) {\n        return this.rules.add([], properties);\n    }\n    /**\n     * Clears CSS properties of this rule.\n     *\n     * Calling this method is the same as calling `set()` without properties.\n     *\n     * @returns `this` rule instance.\n     */\n    clear() {\n        return this.set();\n    }\n}\n/**\n * Dynamically updated list of CSS rules.\n *\n * This is an iterable of rules, an EventSender` of their updates, and an `EventKeeper` of itself.\n *\n * @category CSS Rule\n */\nclass StypRuleList {\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n    [OnEvent__symbol]() {\n        return this.onUpdate;\n    }\n}\n/**\n * Dynamic list of all CSS rules in hierarchy starting from its root.\n *\n * @category CSS Rule\n */\nclass StypRuleHierarchy extends StypRuleList {\n}\n\n/**\n * @internal\n */\nclass Rules extends StypRuleList {\n    constructor(_list, ruleMatches) {\n        super();\n        this._list = _list;\n        let filterArray;\n        if (ruleMatches) {\n            this._buildList = () => filterIt(_list, ruleMatches);\n            filterArray = rules => rules.filter(ruleMatches);\n        }\n        else {\n            this._buildList = valueProvider(_list);\n            filterArray = asis;\n        }\n        this.onUpdate = onEventBy(receiver => {\n            const rules = this._ruleSet || (this._ruleSet = new Set(this._buildList()));\n            onSupplied(this._list)({\n                supply: receiver.supply.whenOff(() => this._ruleSet = undefined),\n                receive: (context, added, removed) => {\n                    added = filterArray(added);\n                    removed = filterArray(removed);\n                    if (removed.length || added.length) {\n                        removed.forEach(rule => rules.delete(rule));\n                        added.forEach(rule => rules.add(rule));\n                        receiver.receive(context, added, removed);\n                    }\n                },\n            });\n        }).do(shareOn);\n        const returnSelf = valueProvider(this);\n        this.read = this.onUpdate.do(mapAfter(returnSelf, returnSelf));\n    }\n    [Symbol.iterator]() {\n        if (this._ruleSet) {\n            // List changes are tracked.\n            return this._ruleSet.values();\n        }\n        // List changes are not currently tracked.\n        // Request the rules explicitly.\n        return itsIterator(this._buildList());\n    }\n    grab(query) {\n        return grabRules(this, query);\n    }\n}\n/**\n * @internal\n */\nfunction grabRules(list, query) {\n    const q = stypQuery(query);\n    return new Rules(list, rule => stypSelectorMatches(rule.selector, q));\n}\n\nclass AllRules extends StypRuleHierarchy {\n    constructor(_root, nested) {\n        super();\n        this._root = _root;\n        this.nested = nested;\n        this._updates = new EventEmitter();\n        this.self = selfRuleList(_root, this);\n        this._it = lazyValue(() => iterateAllRules(_root));\n        const returnSelf = valueProvider(this);\n        this.read = this._updates.on.do(mapAfter(returnSelf, returnSelf));\n    }\n    get onUpdate() {\n        return this._updates.on;\n    }\n    [Symbol.iterator]() {\n        return this[PushIterator__symbol]();\n    }\n    [PushIterator__symbol](accept) {\n        return this._it()[PushIterator__symbol](accept);\n    }\n    grab(query) {\n        return grabRules(this, query);\n    }\n    add(selector, properties) {\n        return extendRule(this._root, stypSelector(selector), properties, true);\n    }\n    get(selector) {\n        return this._get(stypSelector(selector));\n    }\n    _get(selector) {\n        const [key, tail] = stypRuleKeyAndTail(selector);\n        if (!tail) {\n            return this._root;\n        }\n        const found = this.nested._rule(stypRuleKeyText(key));\n        if (!found) {\n            return;\n        }\n        return found.rules.get(tail);\n    }\n    watch(selector) {\n        const request = stypSelector(selector);\n        return afterEventBy(receiver => {\n            const tracker = trackValue({});\n            const propertiesSupply = this.read.do(consumeEvents(() => {\n                const found = this._get(request);\n                return found && found\n                    .read(properties => tracker.it = properties)\n                    .whenOff(() => tracker.it = {});\n            }));\n            return tracker.read(receiver).cuts(propertiesSupply);\n        }).do(shareAfter);\n    }\n    _add(rule, sendUpdate) {\n        rule.rules.onUpdate((added, removed) => this._updates.send(added, removed));\n        if (sendUpdate) {\n            this._updates.send(itsElements(rule.rules), []);\n        }\n    }\n    _remove(reason) {\n        const removed = itsElements(this);\n        this._updates.send([], removed);\n        removed.forEach(rule => {\n            rule.rules._updates.supply.off(reason);\n            rule._spec.supply.off(reason);\n        });\n    }\n}\nfunction selfRuleList(rule, all) {\n    const onUpdate = new EventEmitter();\n    const rules = [rule];\n    all.onUpdate((_added, removed) => {\n        if (removed[0] === rule) {\n            rules.length = 0;\n            onUpdate.send([], [rule]);\n        }\n    }).cuts(onUpdate);\n    class Self {\n        [OnEvent__symbol]() {\n            return onUpdate.on;\n        }\n        [Symbol.iterator]() {\n            return itsIterator(rules);\n        }\n    }\n    return new Rules(new Self());\n}\nfunction iterateAllRules(rule) {\n    return overElementsOf(overOne(rule), flatMapIt(rule.rules.nested, nested => iterateAllRules(nested)));\n}\nclass NestedRules extends StypRuleList {\n    constructor(root) {\n        super();\n        this._updates = new EventEmitter();\n        this._byKey = new Map();\n        this._all = new AllRules(root, this);\n        const returnSelf = valueProvider(this);\n        this.read = this._updates.on.do(mapAfter(returnSelf, returnSelf));\n    }\n    get onUpdate() {\n        return this._updates.on;\n    }\n    [Symbol.iterator]() {\n        return this._byKey.values();\n    }\n    grab(query) {\n        return grabRules(this, query);\n    }\n    _rule(key) {\n        return this._byKey.get(key);\n    }\n    _add(key, rule, sendUpdate) {\n        this._byKey.set(key, rule);\n        rule.rules.onUpdate((_added, removed) => {\n            if (removed[0] === rule) {\n                this._byKey.delete(key);\n                this._updates.send([], [rule]);\n            }\n        });\n        if (sendUpdate) {\n            this._updates.send([rule], []);\n        }\n        this._all._add(rule, sendUpdate);\n    }\n}\n/**\n * @internal\n */\nclass StypRule$ extends StypRule {\n    constructor(root, selector, key, spec = noStypPropertiesSpec) {\n        super();\n        this._root = root || this;\n        this._selector = selector;\n        this._key = key;\n        this._spec = trackValue(spec);\n        this.read = this._spec.read.do(digAfter(builder => builder(this)));\n        this._nested = new NestedRules(this);\n    }\n    get root() {\n        return this._root;\n    }\n    get outer() {\n        if (this._outer !== undefined) {\n            return this._outer;\n        }\n        const outerSelector = stypOuterSelector(this.selector);\n        return this._outer = outerSelector && this.root.rules.get(outerSelector) || null;\n    }\n    get selector() {\n        return this._selector;\n    }\n    get key() {\n        return this._key;\n    }\n    get empty() {\n        return this._spec.it === noStypPropertiesSpec;\n    }\n    get rules() {\n        return this._nested._all;\n    }\n    set(properties) {\n        this._spec.it = properties ? r => stypPropertiesBySpec(r, properties) : noStypPropertiesSpec;\n        return this;\n    }\n    remove(reason) {\n        this.rules._remove(reason);\n        return this;\n    }\n}\nfunction extendRule(rule, targetSelector, properties, sendUpdate) {\n    const [key, tail] = stypRuleKeyAndTail(targetSelector);\n    if (!tail) {\n        // Target rule\n        rule._spec.it = extendSpec(rule, properties);\n        return rule;\n    }\n    const keyText = stypRuleKeyText(key);\n    const found = rule.rules.nested._rule(keyText);\n    if (found) {\n        return extendRule(found, tail, properties, sendUpdate);\n    }\n    const newNested = new StypRule$(rule.root, [...rule.selector, ...key], key);\n    const result = extendRule(newNested, tail, properties, false); // Send only a top-level update\n    rule.rules.nested._add(keyText, newNested, sendUpdate);\n    return result;\n}\nfunction extendSpec(rule, properties) {\n    const oldSpec = rule._spec.it;\n    if (!properties) {\n        return oldSpec;\n    }\n    if (rule.empty) {\n        return r => stypPropertiesBySpec(r, properties);\n    }\n    return r => mergeStypProperties(oldSpec(r), stypPropertiesBySpec(r, properties));\n}\n\n/**\n * @internal\n */\nconst rootSelector = [];\n/**\n * Constructs root CSS rule representing global CSS declarations.\n *\n * All other rules are nested within single root.\n *\n * The root CSS rule selector is empty.\n *\n * @category CSS Rule\n * @param properties - Initial CSS rule properties specifier.\n *\n * @returns New root CSS rule.\n */\nfunction stypRoot(properties) {\n    return new StypRule$(undefined, rootSelector, [], properties ? r => stypPropertiesBySpec(r, properties) : undefined);\n}\n\n/**\n * A type safe reference to CSS rule.\n *\n * Allows to access an modify CSS properties of the rule in a type safe manner.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties structure of referenced rule.\n */\nclass StypRuleRef {\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n    /**\n     * Clears CSS properties of the referenced rule.\n     *\n     * Calling this method is the same as calling `set()` without properties.\n     *\n     * @returns `this` rule instance.\n     */\n    clear() {\n        return this.set();\n    }\n}\n/**\n * @internal\n */\nclass StypRuleRef$ extends StypRuleRef {\n    constructor(_root, _selector, _map) {\n        super();\n        this._root = _root;\n        this._selector = _selector;\n        this._map = _map;\n        this.read = afterAll({\n            ms: this._map(this._root),\n            ps: this._root.rules.watch(this._selector),\n        }).do(mapAfter(({ ms: [_mappings], ps: [_properties], }) => StypMapper.map(_mappings, _properties)));\n    }\n    add(properties) {\n        this._root.rules.add(this._selector, properties);\n        return this;\n    }\n    set(properties) {\n        this._root.rules.add(this._selector).set(properties);\n        return this;\n    }\n}\n/**\n * @category CSS Rule\n */\nconst RefStypRule = {\n    /**\n     * Constructs a CSS rule referrer that maps original CSS properties accordingly to the given `mappings`.\n     *\n     * @typeparam T  CSS properties structure of referenced rule.\n     * @param selector - CSS selector of target rule.\n     * @param mappings - Either a mappings of CSS properties, an event keeper sending such mappings, or a function\n     * returning one of them and accepting a root CSS rule as its only argument.\n     * The constructed reference will be relative to as its only parameter.\n     *\n     * @returns New CSS rule key instance.\n     */\n    by(selector, mappings) {\n        let map;\n        if (typeof mappings === 'function') {\n            map = root => mappingsKeeper(mappings(root));\n        }\n        else {\n            map = valueProvider(mappingsKeeper(mappings));\n        }\n        return root => new StypRuleRef$(root, selector, map);\n    },\n};\n/**\n * @internal\n */\nfunction mappingsKeeper(mappings) {\n    return isEventKeeper(mappings) ? mappings : afterThe(mappings);\n}\n\n/**\n * Named CSS rule references complying to the CSS properties structure.\n *\n * Implements an event keeper interface by sending named CSS properties structures for each CSS rule reference.\n *\n * @category CSS Rule\n * @typeParam TRefMap - A type of target map of named CSS properties structures.\n */\nclass StypRuleRefs {\n    /**\n     * Constructs named CSS rules.\n     *\n     * @param refs - A map of named CSS rule references.\n     */\n    constructor(refs) {\n        this.refs = refs;\n        const fromAll = afterAll(this.refs);\n        this.read = fromAll.do(mapAfter(flattenProperties));\n    }\n    static by(referrers, root) {\n        const refs = {};\n        for (const key of Object.keys(referrers)) {\n            refs[key] = referrers[key](root);\n        }\n        return new StypRuleRefs(refs);\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n}\n/**\n * @internal\n */\nfunction flattenProperties(propertiesMap) {\n    const result = {};\n    for (const name of Object.keys(propertiesMap)) {\n        result[name] = propertiesMap[name][0];\n    }\n    return result;\n}\n\n/**\n * @internal\n */\nconst noStypRules = ( /*#__PURE__*/new Rules({\n    [OnEvent__symbol]() {\n        return onNever;\n    },\n    [Symbol.iterator]() {\n        return [][Symbol.iterator]();\n    },\n}));\n/**\n * Constructs dynamically updated CSS rule list out of rule sources.\n *\n * @category CSS Rule\n * @param sources - CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nfunction stypRules(...sources) {\n    return sources.length ? rulesByList(sources.map(rulesFromSource)) : noStypRules;\n}\n/**\n * @internal\n */\nfunction rulesFromSource(source) {\n    return typeof source === 'function' ? evalRules(source) : rulesByValue(source);\n}\n/**\n * Constructs lazily updated CSS rule list out of rule sources.\n *\n * In contrast to {@link stypRules} this one does not evaluate sources (e.g. does not call source functions) until there\n * is an updates receiver registered.\n *\n * This means that the constructed rule set won't necessary contain the rules from all sources originally. It will\n * report them as updates instead.\n *\n * @category CSS Rule\n * @param sources - CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nfunction lazyStypRules(...sources) {\n    return sources.length ? rulesByList(sources.map(lazyRulesFromSource)) : noStypRules;\n}\n/**\n * @internal\n */\nfunction lazyRulesFromSource(source) {\n    return typeof source === 'function' ? lazyRules(source) : rulesByValue(source);\n}\n/**\n * @internal\n */\nfunction rulesByList(sources) {\n    if (sources.length === 1) {\n        const source = sources[0];\n        return source instanceof StypRuleList ? source : new Rules(source);\n    }\n    return new Rules({\n        *[Symbol.iterator]() {\n            for (const rules of sources) {\n                yield* rules;\n            }\n        },\n        [OnEvent__symbol]() {\n            return onEventBy(receiver => {\n                sources.forEach(source => onSupplied(source)({\n                    supply: new Supply().needs(receiver.supply),\n                    receive(context, added, removed) {\n                        receiver.receive(context, added, removed);\n                    },\n                }));\n            }).do(shareOn);\n        },\n    });\n}\n/**\n * @internal\n */\nfunction evalRules(source) {\n    let rules;\n    const getRules = () => rules || (rules = rulesByValue(source()));\n    return {\n        [Symbol.iterator]() {\n            return getRules()[Symbol.iterator]();\n        },\n        [OnEvent__symbol]() {\n            return getRules()[OnEvent__symbol]();\n        },\n    };\n}\n/**\n * @internal\n */\nfunction lazyRules(source) {\n    const ruleSet = new Set();\n    const onEvent = onEventBy(receiver => {\n        const rules = rulesByValue(source());\n        reportExistingRules(rules, ruleSet, receiver);\n        rules[OnEvent__symbol]()({\n            supply: receiver.supply.whenOff(() => ruleSet.clear()),\n            receive(context, added, removed) {\n                removed.forEach(rule => ruleSet.delete(rule));\n                added.forEach(rule => ruleSet.add(rule));\n                receiver.receive(context, added, removed);\n            },\n        });\n    }).do(shareOn);\n    return {\n        [OnEvent__symbol]() {\n            return onEvent;\n        },\n        [Symbol.iterator]() {\n            return ruleSet.values();\n        },\n    };\n}\n/**\n * @internal\n */\nfunction rulesByValue(source) {\n    return source instanceof StypRule ? source.rules.self : isEventSender(source) ? source : asyncRules(source);\n}\n/**\n * @internal\n */\nfunction asyncRules(source) {\n    const ruleSet = new Set();\n    const onEvent = onEventBy(receiver => {\n        let sourceSupply = neverSupply();\n        const { supply } = receiver;\n        supply.cuts(sourceSupply)\n            .whenOff(() => ruleSet.clear());\n        source.then(resolution => {\n            if (!supply.isOff) {\n                const rules = resolution instanceof StypRule ? resolution.rules : resolution;\n                reportExistingRules(rules, ruleSet, receiver);\n                sourceSupply = onSupplied(rules)({\n                    receive(context, added, removed) {\n                        removed.forEach(rule => ruleSet.delete(rule));\n                        added.forEach(rule => ruleSet.add(rule));\n                        receiver.receive(context, added, removed);\n                    },\n                }).needs(supply);\n            }\n        }).catch(error => supply.off(error));\n    }).do(shareOn);\n    return {\n        [OnEvent__symbol]() {\n            return onEvent;\n        },\n        [Symbol.iterator]() {\n            return ruleSet.values();\n        },\n    };\n}\n/**\n * @internal\n */\nfunction reportExistingRules(rules, ruleSet, receiver) {\n    const existing = [];\n    itsEach(rules, rule => {\n        existing.push(rule);\n        ruleSet.add(rule);\n    });\n    if (existing.length) {\n        const dispatcher = new EventNotifier();\n        dispatcher.on(receiver);\n        dispatcher.send(existing, []); // Report existing rules as just added\n    }\n}\n\nexport { RefStypRule, StypAngle, StypAnglePt, StypColor, StypColorStruct, StypFrequency, StypFrequencyPt, StypHSL, StypLength, StypLengthPt, StypMapper, StypNumericStruct, StypRGB, StypResolution, StypRule, StypRuleHierarchy, StypRuleList, StypRuleRef, StypRuleRefs, StypTime, StypTimePt, StypURL, StypValueStruct, lazyStypRules, mixStypColors, produceBasicStyle, produceStyle, stypDomFormat, stypObjectFormat, stypQuery, stypRenderAtRules, stypRenderGlobals, stypRenderProperties, stypRenderText, stypRenderXmlNs, stypRoot, stypRules, stypSelector, stypSelectorMatches, stypSelectorText, stypSelectorsEqual, stypSplitPriority, stypTextFormat, stypValuesEqual };\n//# sourceMappingURL=style-producer.js.map\n","import { produceBasicStyle, lazyStypRules, stypSelector, stypObjectFormat, stypDomFormat, produceStyle, stypRules, stypRoot } from '@frontmeans/style-producer';\nimport { SingleContextKey, MultiContextKey, ContextKey__symbol, IterativeContextKey } from '@proc7ts/context-values';\nimport { bootstrapDefault, DefaultNamespaceAliaser, ComponentRenderScheduler, ComponentContext, DefinitionContext, ShadowContentRoot, ComponentMember, FeatureDef__symbol } from '@wesib/wesib';\nimport { nodeDocument } from '@frontmeans/dom-primitives';\nimport { valueProvider, extendSetOfElements, setOfElements, elementOrArray } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { css__naming, NamespaceDef } from '@frontmeans/namespace-aliaser';\nimport { itsEach } from '@proc7ts/push-iterator';\n\n/**\n * A key of bootstrap, definition, or component context value containing a component style producer.\n *\n * Utilizes `produceBasicStyle()` by default. I.e. it does not enable default renderers. To enable them all a\n * {@link StyleProducerSupport} can be used.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n */\nconst ComponentStyleProducer = (\n/*#__PURE__*/ new SingleContextKey('component-style-producer', {\n    byDefault: bootstrapDefault(() => produceBasicStyle),\n}));\n\n/**\n * Builds configuration of DOM style production format.\n *\n * Schedules style rendering in `ComponentRenderScheduler` by default.\n *\n * Utilizes `DefaultNamespaceAliaser` by default.\n *\n * @param format - Target component style production format.\n * @param config - Original component style production format configuration.\n * @param render - Element render definition to apply to style render schedule, unless render scheduler specified\n * explicitly in `config`.\n *\n * @returns Configuration of DOM style production format.\n */\nfunction componentStypDomFormatConfig(format, config = {}, render) {\n    const { context } = format;\n    return {\n        ...config,\n        document: config.document || nodeDocument(context.element),\n        parent: config.parent || context.contentRoot,\n        rootSelector: [],\n        scheduler: config.scheduler || defaultStypRenderScheduler(context, render),\n        nsAlias: config.nsAlias || context.get(DefaultNamespaceAliaser),\n        renderer: format.renderer(config),\n    };\n}\n/**\n * @internal\n */\nfunction defaultStypRenderScheduler(context, render = {}) {\n    const scheduler = context.get(ComponentRenderScheduler);\n    return (opts = {}) => scheduler({ ...opts, ...render });\n}\n\n/**\n * A key of component context value containing component CSS renderers.\n */\nconst ComponentStypRenderer = (\n/*#__PURE__*/ new MultiContextKey('component-styp-renderer'));\n\n/**\n * @internal\n */\nconst ElementIdClass__NS = ( /*#__PURE__*/new NamespaceDef('https://wesib.github.io/ns/element-id-class', 'elic', 'element-id-class'));\n/**\n * @internal\n */\nconst ElementIdClass = ( /*#__PURE__*/new SingleContextKey('unique-element-class', { byDefault: assignElementId }));\n/**\n * @internal\n */\nlet uniqueClassSeq = 0;\n/**\n * @internal\n */\nfunction assignElementId(contextValues) {\n    const aliaser = contextValues.get(DefaultNamespaceAliaser);\n    const context = contextValues.get(ComponentContext);\n    const { tagName = 'component' } = context.get(DefinitionContext).elementDef;\n    const local = `${tagName}#${++uniqueClassSeq}`;\n    const qualified = ElementIdClass__NS.name(aliaser(ElementIdClass__NS), local, css__naming);\n    const element = context.element;\n    element.classList.add(qualified);\n    return qualified;\n}\n\nconst ComponentStypFormat__symbol = ( /*#__PURE__*/new SingleContextKey('component-styp-format', {\n    byDefault(context) {\n        return new ComponentStypObjectFormat(context.get(ComponentContext));\n    },\n}));\n/**\n * Component style production format.\n *\n * This format can be obtained from component context.\n *\n * The formats implemented:\n * - {@link ComponentStypObjectFormat} (the default) renders CSS using CSS object model.\n * - {@link ComponentStypDomFormat} renders CSS as text. May render CSS of disconnected element.\n */\nclass ComponentStypFormat {\n    /**\n     * A key of component context value containing its style production format.\n     */\n    static get [ContextKey__symbol]() {\n        return ComponentStypFormat__symbol;\n    }\n    /**\n     * Produces and dynamically updates component's CSS stylesheets based on the given CSS rules.\n     *\n     * Utilizes {@link newProducer component's producer function}.\n     *\n     * @param rules - A source of CSS rules to produce stylesheets for.\n     * @param config - Style production format configuration.\n     *\n     * @returns CSS rules supply. Once cut off the produced stylesheets are removed.\n     */\n    produce(rules, config) {\n        const producer = this.newProducer(rules, config);\n        const supply = new Supply();\n        this.context.whenSettled(() => producer().as(supply));\n        return supply;\n    }\n    /**\n     * Creates component's CSS stylesheets producer based on the given CSS rules.\n     *\n     * Utilizes {@link ComponentStyleProducer}.\n     *\n     * @param rules - A source of CSS rules to produce stylesheets for.\n     * @param config - Style production format configuration.\n     *\n     * @returns CSS rules producer function returning CSS rules supply. Once cut off the produced stylesheets are removed.\n     */\n    newProducer(rules, config) {\n        const css = lazyStypRules(rules);\n        let producer;\n        const componentSupply = this.context.supply;\n        producer = () => {\n            const produceStyle = this.context.get(ComponentStyleProducer);\n            return produceStyle(css, this.format(config)).needs(componentSupply);\n        };\n        // In case the component destroyed already, the producer will be reassigned here _before_ return.\n        componentSupply.whenOff(() => {\n            // Prevent style production once component destroyed.\n            producer = valueProvider(componentSupply);\n        });\n        return () => producer();\n    }\n    /**\n     * Builds component-specific style renderer.\n     *\n     * This renderer applies {@link ComponentStypFormatConfig.hostSelector host selector} to generated CSS rules.\n     *\n     * This method is called by {@link format} one.\n     *\n     * @param config - Component style production format configuration.\n     *\n     * @returns Component style renderer(s).\n     */\n    renderer(config) {\n        const shadowRoot = this.context.get(ShadowContentRoot, { or: null });\n        const { renderer } = config;\n        const renderers = extendSetOfElements(setOfElements(renderer), this.context.get(ComponentStypRenderer));\n        const hostSelector = config.hostSelector\n            ? stypSelector(config.hostSelector)[0]\n            : undefined;\n        renderers.add(shadowRoot\n            ? shadowRenderer(hostSelector)\n            : noShadowRenderer(hostSelector || { c: [this.context.get(ElementIdClass)] }));\n        return elementOrArray(renderers);\n    }\n}\n/**\n * @internal\n */\nfunction shadowRenderer(hostSelector) {\n    return {\n        order: -100,\n        render(producer, properties) {\n            let { selector } = producer;\n            if (!selector.length) {\n                selector = [hostSelector || { u: [[':', 'host']] }];\n            }\n            else if (hostSelector) {\n                const [rest, host] = extractHostSelector(selector);\n                if (host) {\n                    if (host.length) {\n                        selector = [{ u: [[':', 'host', extendHostSelector(host, hostSelector)]] }, ...rest];\n                    }\n                    else {\n                        selector = [{ u: [[':', 'host', [hostSelector]]] }, ...rest];\n                    }\n                }\n            }\n            producer.render(properties, { selector });\n        },\n    };\n}\n/**\n * @internal\n */\nfunction noShadowRenderer(hostSelector) {\n    return {\n        order: -100,\n        render(producer, properties) {\n            let { selector } = producer;\n            if (!selector.length) {\n                selector = [hostSelector];\n            }\n            else {\n                const [rest, host] = extractHostSelector(selector);\n                if (host && host.length) {\n                    selector = [...extendHostSelector(host, hostSelector), ...rest];\n                }\n                else {\n                    selector = [hostSelector, ...rest];\n                }\n            }\n            producer.render(properties, { selector });\n        },\n    };\n}\n/**\n * @internal\n */\nfunction extractHostSelector(selector) {\n    if (typeof selector[0] !== 'string') {\n        const [{ ns, e, i, c, u, s, $ }, ...restParts] = selector;\n        if (!ns && !e && !i && !c && !s && u) {\n            const [[prefix, name, ...params]] = u;\n            if (prefix === ':' && name === 'host') {\n                let host;\n                if (params.length) {\n                    host = params[0].slice();\n                    host[0].$ = $;\n                }\n                else {\n                    host = $ ? [{ $ }] : [];\n                }\n                return [restParts, host];\n            }\n        }\n    }\n    return [selector];\n}\n/**\n * @internal\n */\nfunction extendHostSelector(selector, { ns, e, i, c, u, s, }) {\n    const [first, ...rest] = selector;\n    return [\n        {\n            ns: first.e || first.ns ? first.ns : ns,\n            e: first.e || first.ns ? first.e : e,\n            i: first.i || i,\n            c: first.c ? (c ? [...first.c, ...c] : first.c) : c,\n            u: first.u ? (u ? [...first.u, ...u] : first.u) : u,\n            s: ((first.s || '') + (s || '')) || undefined,\n            $: first.$,\n        },\n        ...rest,\n    ];\n}\n/**\n * Component's CSS object model production format.\n *\n * Renders CSS when component's element connected to document.\n *\n * This format is used by default.\n */\nclass ComponentStypObjectFormat extends ComponentStypFormat {\n    /**\n     * Constructs CSS object model production format.\n     *\n     * @param context - Target component context.\n     */\n    constructor(context) {\n        super();\n        this.context = context;\n    }\n    format(config) {\n        return stypObjectFormat(this.config(config));\n    }\n    /**\n     * Builds configuration of CSS object model production format.\n     *\n     * This method is called by {@link format} one.\n     *\n     * @param config - Original component style production format configuration.\n     *\n     * @returns Configuration of CSS object model production format.\n     */\n    config(config) {\n        return componentStypDomFormatConfig(this, config, { when: 'connected' });\n    }\n}\n\n/**\n * Component's DOM style production format.\n *\n * Renders CSS styles as text.\n *\n * This format is generally slower than {@link ComponentStypObjectFormat}, but allows to render styles before element\n * is connected to document.\n */\nclass ComponentStypDomFormat extends ComponentStypFormat {\n    /**\n     * Constructs DOM style production format.\n     *\n     * @param context - Target component context.\n     * @param when - When to start style rendering. `settled` by default.\n     */\n    constructor(context, { when = 'settled', } = {}) {\n        super();\n        this.context = context;\n        this.when = when;\n    }\n    format(config) {\n        return stypDomFormat(this.config(config));\n    }\n    /**\n     * Builds configuration of DOM style production format.\n     *\n     * This method is called by {@link format} one.\n     *\n     * @param config - Original component style production format configuration.\n     *\n     * @returns Configuration of DOM style production format.\n     */\n    config(config) {\n        return componentStypDomFormatConfig(this, config, { when: this.when });\n    }\n}\n\n/**\n * Creates an amendment (and decorator) of component member producing CSS rules to apply to component.\n *\n * An amended member should either contain a CSS rules source of type `StypRules.Source` or be a method returning it.\n *\n * Produces CSS using {@link ComponentStypFormat component style production format}.\n *\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param config - Non-mandatory component style production format config.\n *\n * @returns Component property decorator.\n */\nfunction ProduceStyle(config) {\n    return ComponentMember(({ get, amend }) => amend({\n        componentDef: {\n            define(defContext) {\n                defContext.whenComponent(context => {\n                    context.whenReady(({ component }) => {\n                        const value = get(component);\n                        const source = typeof value === 'function' ? value.bind(component) : value;\n                        const format = context.get(ComponentStypFormat);\n                        format.produce(source, config);\n                    });\n                });\n            },\n        },\n    }));\n}\n\n/**\n * @internal\n */\nconst StyleProducerSupport__feature = {\n    setup(setup) {\n        setup.provide({ a: ComponentStyleProducer, is: produceStyle });\n    },\n};\n/**\n * Style producer support feature.\n *\n * This feature enables default CSS renderers.\n *\n * It is _not_ enabled automatically by {@link ProduceStyle @ProduceStyle} decorator.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n */\nclass StyleProducerSupport {\n    static get [FeatureDef__symbol]() {\n        return StyleProducerSupport__feature;\n    }\n}\n\n/**\n * @internal\n */\nclass ThemeStyleKey extends IterativeContextKey {\n    constructor() {\n        super('theme-style');\n    }\n    grow(slot) {\n        const providers = new Map();\n        itsEach(slot.seed, style => {\n            let key;\n            let provider;\n            let isId;\n            if (typeof style === 'function') {\n                key = provider = style;\n                isId = true;\n            }\n            else {\n                key = style.style;\n                provider = style.provide.bind(style);\n                isId = false;\n            }\n            const prev = providers.get(key);\n            if (!prev) {\n                providers.set(key, [provider, isId]);\n            }\n            else {\n                const [prevProvider, hasId] = prev;\n                providers.set(key, [\n                    isId ? combineStyles(provider, prevProvider) : combineStyles(prevProvider, provider),\n                    isId || hasId,\n                ]);\n            }\n        });\n        if (providers.size || !slot.hasFallback) {\n            slot.insert(byId);\n        }\n        function byId(id) {\n            const existing = providers.get(id);\n            if (!existing) {\n                return id;\n            }\n            const [provider, hasId] = existing;\n            return hasId ? provider : combineStyles(id, provider);\n        }\n    }\n}\n/**\n * A key of bootstrap context value containing theme styles.\n */\nconst ThemeStyle = ( /*#__PURE__*/new ThemeStyleKey());\n/**\n * @internal\n */\nfunction combineStyles(first, second) {\n    return theme => stypRules(first(theme), second(theme));\n}\n\n/**\n * @internal\n */\nconst Theme__key = ( /*#__PURE__*/new SingleContextKey('theme', {\n    byDefault: bootstrapDefault(context => new Theme$(context.get(ThemeStyle))),\n}));\n/**\n * A hierarchy of CSS rules within single root.\n *\n * A component may use it to extract styling information.\n *\n * Current theme is available in bootstrap, definition, or component context. By default, only one theme is declared\n * per bootstrap. But this can be overridden.\n */\nclass Theme {\n    /**\n     * A key of bootstrap, definition, or component context value containing current theme instance.\n     */\n    static get [ContextKey__symbol]() {\n        return Theme__key;\n    }\n    /**\n     * Obtains CSS rule reference by its `referrer`.\n     *\n     * This is a helper method that resolves the given `referrer` against the `root` CSS rule of this theme.\n     *\n     * @param referrer - Target CSS rule referrer.\n     *\n     * @returns CSS rule reference.\n     */\n    ref(referrer) {\n        return referrer(this.root);\n    }\n}\n/**\n * @internal\n */\nclass Theme$ extends Theme {\n    constructor(_styles) {\n        super();\n        this._styles = _styles;\n        this.root = stypRoot();\n        this._rules = new Map();\n    }\n    style(...styles) {\n        const theme = this;\n        return lazyStypRules(...styles.reduce(addStyleRules, []));\n        function addStyleRules(target, style) {\n            const existing = theme._rules.get(style);\n            if (existing) {\n                target.push(existing);\n            }\n            else {\n                const constructed = theme._styles(style)(theme);\n                theme._rules.set(style, constructed);\n                target.push(constructed);\n            }\n            return target;\n        }\n    }\n}\n\nexport { ComponentStyleProducer, ComponentStypDomFormat, ComponentStypFormat, ComponentStypObjectFormat, ComponentStypRenderer, ProduceStyle, StyleProducerSupport, Theme, ThemeStyle, componentStypDomFormatConfig };\n//# sourceMappingURL=wesib.css.js.map\n","/**\n * @internal\n */\nfunction hthvItem({ $ = 'raw', n, t, v, x = [], p = {}, pl = [], }) {\n    if (n) {\n        p[n] = { $, n, v, x: [], p: {}, pl: [] };\n    }\n    return {\n        $,\n        n,\n        t,\n        v,\n        x,\n        p,\n        pl,\n    };\n}\n\n/**\n * @internal\n */\nfunction hthvParseTrivial(value) {\n    if (typeof value === 'string') {\n        return value.split(',').map(item => item.trim());\n    }\n    const result = [];\n    for (const val of value) {\n        result.push(...hthvParseTrivial(val));\n    }\n    return result;\n}\n/**\n * @internal\n */\nfunction hthvParseFirstTrivial(value) {\n    if (!value) {\n        return value;\n    }\n    if (typeof value === 'string') {\n        const commaIdx = value.indexOf(',');\n        return (commaIdx >= 0 ? value.substr(0, commaIdx) : value).trim();\n    }\n    return hthvParseFirstTrivial(value[Symbol.iterator]().next().value);\n}\n\nexport { hthvParseTrivial as a, hthvParseFirstTrivial as b, hthvItem as h };\n//# sourceMappingURL=_http-header-value.base.js.map\n","import { h as hthvItem } from './_http-header-value.base.js';\n\n/**\n * @internal\n */\nfunction addParam({ p, pl, }, param) {\n    const key = param.n || param.v;\n    const prev = p[key];\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!prev || !prev.n && param.n) {\n        p[key] = param;\n    }\n    pl.push(param);\n}\n\n/**\n * @internal\n */\nfunction angleBracketsParser({ delimiterOf }) {\n    return (input, out) => {\n        if (!(delimiterOf(input.s[input.i]) & 262144 /* AngleBracketStart */)) {\n            return false;\n        }\n        let result = '';\n        ++input.i;\n        while (input.i < input.s.length) {\n            const c = input.s[input.i++];\n            if (delimiterOf(c) & 524288 /* AngleBracketEnd */) {\n                break;\n            }\n            result += c;\n        }\n        out(result);\n        return true;\n    };\n}\n\n/**\n * @internal\n */\nconst parseNone = () => false;\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n/**\n * @internal\n */\nfunction dateTimeParser({ dateTime }) {\n    return dateTime ? parseDateTime : parseNone;\n}\nfunction parseDateTime(input, out) {\n    input.s = input.s.substring(input.i);\n    input.i = 0;\n    if (datePattern.test(input.s)) {\n        out(input.s.substring(input.i, input.i += 29));\n        return true;\n    }\n    return false;\n}\n\n/**\n * @internal\n */\nfunction nextInItem({ delimiterOf }) {\n    return input => {\n        const c = input.s[input.i];\n        input.d = delimiterOf(c);\n        return c;\n    };\n}\n\n/**\n * @internal\n */\nfunction quotedStringParser({ delimiterOf }) {\n    return (input, out) => {\n        let unquoted = '';\n        ++input.i;\n        for (; input.i < input.s.length; ++input.i) {\n            const c = input.s[input.i];\n            if (c === '\\\\') {\n                const next = input.s[++input.i];\n                if (next) {\n                    unquoted += next;\n                }\n                else {\n                    unquoted += c;\n                }\n            }\n            else if (delimiterOf(c) & 65536 /* Quote */) {\n                ++input.i;\n                out(unquoted);\n                return;\n            }\n            else {\n                unquoted += c;\n            }\n        }\n        out(unquoted);\n    };\n}\n\n/**\n * @internal\n */\nfunction itemParser(config, { named = true, tagged = true, extra = true, next = nextInItem(config), } = {}) {\n    const parseAngleBrackets = angleBracketsParser(config);\n    const parseDateTime = dateTimeParser(config);\n    const parseQuotedString = quotedStringParser(config);\n    const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n    return (input, out) => {\n        let name = '';\n        let type = 'raw';\n        let tag;\n        let value;\n        while (input.i < input.s.length) {\n            const c = next(input);\n            if (input.d) {\n                if (input.d & (4 /* Item */ | 8 /* Parameter */)) {\n                    break;\n                }\n                if (value == null) {\n                    if (input.d & 16 /* Assignment */) {\n                        value = name ? '' : c;\n                        ++input.i;\n                        continue;\n                    }\n                    if (input.d & 65536 /* Quote */) {\n                        if (tagged || !name) {\n                            parseQuotedString(input, v => {\n                                if (name) {\n                                    type = 'tagged-string';\n                                    tag = name;\n                                }\n                                else {\n                                    type = 'quoted-string';\n                                }\n                                name = '';\n                                value = v;\n                            });\n                        }\n                        break;\n                    }\n                    if (!name && parseAngleBrackets(input, v => {\n                        type = 'angle-bracketed-string';\n                        value = v;\n                    })) {\n                        break;\n                    }\n                    value = name;\n                    name = '';\n                }\n                else if (input.d & 65536 /* Quote */) {\n                    if (tagged || !value) {\n                        parseQuotedString(input, v => {\n                            if (value) {\n                                type = 'tagged-string';\n                                tag = value;\n                            }\n                            else {\n                                type = 'quoted-string';\n                            }\n                            value = v;\n                        });\n                    }\n                    break;\n                }\n                else if (!value && parseAngleBrackets(input, v => {\n                    type = 'angle-bracketed-string';\n                    value = v;\n                })) {\n                    break;\n                }\n            }\n            if (value == null) {\n                if (!name && parseDateTime(input, v => value = v)) {\n                    type = 'date-time';\n                    break;\n                }\n                if (named) {\n                    name += c;\n                }\n                else {\n                    value = c;\n                }\n            }\n            else if (!value && parseDateTime(input, v => value = v)) {\n                type = 'date-time';\n                break;\n            }\n            else {\n                value += c;\n            }\n            ++input.i;\n        }\n        let item;\n        if (value == null) {\n            if (!name) {\n                return false;\n            }\n            item = hthvItem({ $: type, v: name });\n        }\n        else {\n            item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n        }\n        // noinspection StatementWithEmptyBodyJS\n        while (parseExtra(input, extraItem => item.x.push(extraItem)))\n            ; // eslint-disable-line curly\n        out(item);\n        return true;\n    };\n}\n\n/**\n * @internal\n */\nfunction nextInComment({ delimiterOf }) {\n    return input => {\n        let c = input.s[input.i];\n        if (c !== '\\\\') {\n            input.d = delimiterOf(c);\n            return c;\n        }\n        ++input.i;\n        if (input.i < input.s.length) {\n            c = input.s[input.i];\n            input.d = delimiterOf(c) ? 1 /* NonToken */ : 0 /* None */;\n        }\n        else {\n            input.d = 1 /* NonToken */;\n        }\n        return c;\n    };\n}\n\n/**\n * @internal\n */\nfunction spacesParser({ delimiterOf }) {\n    return input => {\n        const start = input.i;\n        do {\n            const c = input.s[input.i];\n            if (!(delimiterOf(c) & 2 /* Space */)) {\n                break;\n            }\n            input.i++;\n        } while (input.i < input.s.length);\n        return input.i !== start;\n    };\n}\n\n/**\n * @internal\n */\nfunction paramParser(config, opts = {}) {\n    const { delimiterOf } = config;\n    const skipSpaces = spacesParser(config);\n    const parseItem = itemParser(config, { ...opts, tagged: false });\n    return (input, out) => {\n        if (!(delimiterOf(input.s[input.i]) & 8 /* Parameter */)) {\n            return false;\n        }\n        ++input.i;\n        skipSpaces(input);\n        return parseItem(input, out);\n    };\n}\n\n/**\n * @internal\n */\nfunction commentParser(config) {\n    const { delimiterOf } = config;\n    const skipSpaces = spacesParser(config);\n    const commentParserConfig = {\n        next: nextInComment(config),\n    };\n    const parseItem = itemParser(config, commentParserConfig);\n    const parseParam = paramParser(config, commentParserConfig);\n    return (input, out) => {\n        if (!(delimiterOf(input.s[input.i]) & 131072 /* Comment */)) {\n            return false;\n        }\n        ++input.i;\n        let result;\n        // noinspection StatementWithEmptyBodyJS\n        while ( // eslint-disable-line curly\n        skipSpaces(input)\n            || parseParam(input, param => {\n                if (!result) {\n                    result = hthvItem({ $: 'raw', v: '' });\n                }\n                addParam(result, param);\n            })\n            || parseItem(input, item => result = item))\n            ;\n        ++input.i; // closing parent\n        out(result || hthvItem({ $: 'raw', v: '' }));\n        return true;\n    };\n}\n\n/**\n * @internal\n */\nfunction itemDelimitParser(config) {\n    const { delimiterOf } = config;\n    const skipSpaces = spacesParser(config);\n    return input => {\n        if (delimiterOf(input.s[input.i]) & 4 /* Item */) {\n            input.i++;\n            skipSpaces(input);\n            return true;\n        }\n        return false;\n    };\n}\n\n/**\n * @internal\n */\nconst defaultDelimit = {\n    ' ': 1 /* NonToken */ | 2 /* Space */ | 4 /* Item */,\n    '\\t': 1 /* NonToken */ | 2 /* Space */ | 4 /* Item */,\n    ',': 1 /* NonToken */ | 4 /* Item */,\n    ';': 1 /* NonToken */ | 8 /* Parameter */,\n    '\"': 1 /* NonToken */ | 32 /* Escaped */ | 65536 /* Quote */,\n    '\\\\': 1 /* NonToken */ | 32 /* Escaped */,\n    '<': 1 /* NonToken */ | 262144 /* AngleBracketStart */,\n    '>': 1 /* NonToken */ | 524288 /* AngleBracketEnd */,\n    '=': 1 /* NonToken */ | 16 /* Assignment */,\n    '(': 1 /* NonToken */,\n    ')': 1 /* NonToken */,\n    '/': 1 /* NonToken */,\n    ':': 1 /* NonToken */,\n    '?': 1 /* NonToken */,\n    '@': 1 /* NonToken */,\n    '[': 1 /* NonToken */,\n    ']': 1 /* NonToken */,\n    '{': 1 /* NonToken */,\n    '}': 1 /* NonToken */,\n};\n/**\n * @internal\n */\nfunction buildParserConfig({ delimit, dateTime, } = {}) {\n    const delimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n    return {\n        dateTime,\n        delimiterOf(c) {\n            return delimitConfig[c]\n                || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? 1 /* NonToken */ : 0 /* None */);\n        },\n    };\n}\n/**\n * @internal\n */\nconst defaultParserConfig = ( /*#__PURE__*/buildParserConfig());\n/**\n * @internal\n */\nconst commentParserConfig = ( /*#__PURE__*/buildParserConfig({\n    delimit: {\n        ':': 1 /* NonToken */ | 16 /* Assignment */,\n        '(': 1 /* NonToken */ | 32 /* Escaped */ | 131072 /* Comment */,\n        ')': 1 /* NonToken */ | 32 /* Escaped */ | 4 /* Item */,\n        ' ': 1 /* NonToken */ | 2 /* Space */,\n        '\\t': 1 /* NonToken */ | 2 /* Space */,\n        '=': 1 /* NonToken */,\n        ',': 1 /* NonToken */,\n    },\n}));\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config  New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nfunction newHthvParser(config) {\n    const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n    const parseItemDelimit = itemDelimitParser(parserConfig);\n    const parseParam = paramParser(parserConfig);\n    const parseItem = itemParser(parserConfig);\n    const parseComment = (config === null || config === void 0 ? void 0 : config.comments) ? commentParser(commentParserConfig) : parseNone;\n    return headerValue => {\n        const result = [];\n        const input = { i: 0, s: headerValue };\n        // noinspection StatementWithEmptyBodyJS\n        while (parseTopLevelItem())\n            ; // eslint-disable-line curly\n        return result;\n        function parseTopLevelItem() {\n            return input.i < input.s.length && (parseItemDelimit(input)\n                || parseParam(input, param => {\n                    if (!result.length) {\n                        result.push(hthvItem({ $: 'raw', v: '' }));\n                    }\n                    addParam(result[result.length - 1], param);\n                })\n                || parseComment(input, item => result.push(item))\n                || parseItem(input, item => result.push(item)));\n        }\n    };\n}\n\n/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\n/**\n * Parses HTTP header value that may contain comments.\n *\n * This is particularly useful when parsing headers such as:\n * - `User-Agent`\n * - `Server`\n */\nconst hthvParseCommented = ( /*#__PURE__*/newHthvParser({ comments: true }));\n\n/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\n/**\n * Parses HTTP header values containing directives.\n *\n * Directives are parameterized items using spaces instead of semicolons to delimit parameters. While semicolons and\n * colons are used to delimit items.\n *\n * Date/time values within directives are usually enclosed into quotes. So, no need to parse them in a special way.\n *\n * This is particularly useful when parsing headers such as:\n * - `Content-Security-Policy`\n * - `Content-Security-Policy-Report-Only`\n * - `Feature-Policy`\n * - `Via`\n * - `Warning`\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma-separated value items with space-separated parameters.\n */\nconst hthvParseDirectives = ( /*#__PURE__*/newHthvParser({\n    delimit: {\n        ' ': 1 /* NonToken */ | 2 /* Space */ | 8 /* Parameter */,\n        '\\t': 1 /* NonToken */ | 2 /* Space */ | 8 /* Parameter */,\n        ';': 1 /* NonToken */ | 4 /* Item */,\n    },\n}));\n\n/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\n/**\n * Parses semicolon-separated HTTP header value items.\n *\n * Treats ';' just like ','.\n *\n * This is particularly useful when parsing a `Cookies` header.\n *\n * The parsed items won't have any parameters.\n */\nconst hthvParseSemiSep = (\n/*#__PURE__*/ newHthvParser({\n    delimit: {\n        ';': 1 /* NonToken */ | 4 /* Item */,\n    },\n}));\n\n/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\n/**\n * Parses HTTP header value containing URI(s) without parameters.\n *\n * `,`, `;`, '(', ')', and `=` symbols can be part of URI. This function returns multiple items only if URIs are\n * space-separated.\n *\n * This is particularly useful when parsing headers such as:\n * - `Content-Location`\n * - `Location`\n * - `Referef`\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of space-separated value items without parameters.\n */\nconst hthvParseURIs = (\n/*#__PURE__*/ newHthvParser({\n    delimit: {\n        ',': 1 /* NonToken */,\n        ';': 1 /* NonToken */,\n        '=': 1 /* NonToken */,\n    },\n}));\n\n/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\n/**\n * Escapes a `string` to be included into [quoted-string](https://tools.ietf.org/html/rfc7230#section-3.2.6) within HTTP\n * header value.\n *\n * Replaces `\\` with `\\\\`, and `\"` with `\\\"`.\n *\n * @param string  A string to escape.\n *\n * @returns Escaped `string`.\n */\nfunction hthvEscapeQ(string) {\n    return hthvEscape(string, defaultParserConfig);\n}\n/**\n * Escapes a `string` to be included into [comment](https://tools.ietf.org/html/rfc7230#section-3.2.6) withing HTTP\n * header value.\n *\n * Replaces `\\` with `\\\\`, `\"` with `\\\"`, `(` with `\\(`, and `)` with `\\)`.\n *\n * According to [RFC7230] the sender should not escape a double quote in this case. However, it may be necessary\n * to distinguish between raw double quote and nested [quoted-string].\n *\n * [RFC7230]: https://tools.ietf.org/html/rfc7230\n * [quoted-string]: https://tools.ietf.org/html/rfc7230#section-3.2.6\n *\n * @param string  A string to escape.\n *\n * @returns Escaped `string`.\n */\nfunction hthvEscapeC(string) {\n    return hthvEscape(string, commentParserConfig);\n}\n/**\n * @internal\n */\nfunction hthvEscape(string, { delimiterOf }) {\n    let escaped;\n    for (let i = 0; i < string.length; ++i) {\n        const c = string[i];\n        if (delimiterOf(c) & 32 /* Escaped */) {\n            if (!escaped) {\n                escaped = string.substring(0, i);\n            }\n            escaped += '\\\\' + c;\n        }\n        else if (escaped) {\n            escaped += c;\n        }\n    }\n    return escaped || string;\n}\n\n/**\n * Flattens HTTP header value items by extracting their parameters.\n *\n * The result is an items collection containing original `items`, as well as their parameters.\n *\n * Recursively places `items` and their parameters to result map in their original order, and:\n * - prefers named items over unnamed ones,\n * - prefers original items over their parameters,\n * - prefers items added first.\n *\n * @param items Items collection.\n */\nfunction hthvFlatten(items) {\n    const map = {};\n    const list = [];\n    const depths = {};\n    const put = (item, depth) => {\n        list.push(item);\n        const key = item.n || item.v;\n        const prev = map[key];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (prev) {\n            if (item.n) {\n                if (prev.n && depths[key] <= depth) {\n                    return;\n                }\n            }\n            else if (prev.n || depths[key] <= depth) {\n                return;\n            }\n        }\n        map[key] = item;\n        depths[key] = depth;\n    };\n    const add = (item, depth) => {\n        put(item, depth);\n        ++depth;\n        item.pl.forEach(p => add(p, depth));\n    };\n    items.forEach(item => add(item, 0));\n    return { map, list };\n}\n\n/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments or date/time values.\n *\n * Treats illegal characters as ASCII letters.\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nconst hthvParse = ( /*#__PURE__*/newHthvParser());\n/**\n * Parses HTTP header value that may contain date/time.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default config except {@link HthvParserConfig.dateTime date/time parsing enabled}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nconst hthvParseDT = ( /*#__PURE__*/newHthvParser({ dateTime: true }));\n\n/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string  A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nfunction hthvQuote(string) {\n    if (!string) {\n        return '\"\"';\n    }\n    const { delimiterOf } = defaultParserConfig;\n    let escaped;\n    let quote = false;\n    for (let i = 0; i < string.length; ++i) {\n        const c = string[i];\n        const delimiter = delimiterOf(c);\n        if (delimiter) {\n            if (delimiter & 32 /* Escaped */) {\n                if (!escaped) {\n                    escaped = string.substring(0, i);\n                }\n                escaped += '\\\\' + c;\n            }\n            quote = true;\n        }\n        else if (escaped) {\n            escaped += c;\n        }\n    }\n    return quote ? `\"${escaped || string}\"` : string;\n}\n\nexport { hthvEscapeC, hthvEscapeQ, hthvFlatten, hthvParse, hthvParseCommented, hthvParseDT, hthvParseDirectives, hthvParseSemiSep, hthvParseURIs, hthvQuote, newHthvParser };\n//# sourceMappingURL=http-header-value.js.map\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { ContextValues, SingleContextKey, ContextKey__symbol, ContextRegistry, Contextual__symbol } from '@proc7ts/context-values';\nimport { digAfter, afterThe, OnEvent__symbol, AfterEvent__symbol, trackValue, onAny, onSupplied, mapAfter, isAfterEvent, translateAfter_, afterAll, onEventBy, valueOn_, supplyOn, EventEmitter, shareOn, mapOn_, eventReceiver, EventNotifier, resolveOnOrdered, digOn_, onceAfter } from '@proc7ts/fun-events';\nimport { noop, mergeFunctions, setOfElements, valueByRecipe, asis, valueProvider } from '@proc7ts/primitives';\nimport { BootstrapWindow, FeatureDef__symbol, bootstrapDefault, DefaultNamespaceAliaser, ComponentRenderScheduler, Wesib__NS, ComponentContext, ComponentMember } from '@wesib/wesib';\nimport { itsEach, flatMapIt, overIterator, itsEvery, mapIt, filterArray, filterIt, overArray, itsFirst } from '@proc7ts/push-iterator';\nimport { ContextUpKey, contextDestroyed, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { drekCssClassesOf, deriveDrekContext, drekContextOf } from '@frontmeans/drek';\nimport { css__naming } from '@frontmeans/namespace-aliaser';\nimport { Supply, neverSupply } from '@proc7ts/supply';\nimport { FetchAgentKey, HttpFetch, FragmentRenderCtl } from '@wesib/generic';\nimport { hthvQuote, hthvParse } from '@hatsy/http-header-value';\nimport { importNode, importNodeContent } from '@frontmeans/dom-primitives';\n\n/**\n * Extracts URL contained in the hash of another URL.\n *\n * Extracted hash URL is based on origin of the original URL. Still, it may be absolute one.\n *\n * Input URL is never altered.\n *\n * @param url - An URL to extract hash from.\n *\n * @returns URL extracted from hash.\n */\nfunction getHashURL(url) {\n    return new URL(url.hash.substring(1), url.origin);\n}\n/**\n * Creates an URL based on original one, but with hash substituted by the given hash URL.\n *\n * The hash URL is substituted as following:\n *\n * 1. If the hash URL's origin is not the same as the one of the base one, or if it contains a username,\n *    then absolute hash URL is substituted:\n * 2. Otherwise:\n *    - pathname is substituted, unless it is equal to `/` and no hash and search parameters present,\n *    - search parameters are substituted when at least one present,\n *    - hash is substituted only when present.\n *\n * Input URLs are never altered.\n *\n * @param url - Base URL.\n * @param hashURL - Hash URL to substitute.\n *\n * @returns URL with updated hash.\n */\nfunction setHashURL(url, hashURL) {\n    if (hashURL.origin !== url.origin || hashURL.username) {\n        return new URL(`#${hashURL}`, url);\n    }\n    const { pathname, search, hash } = hashURL;\n    const result = new URL('', url);\n    result.hash = (search || hash || pathname.length > 1) ? (pathname + search + hash) : (search + hash);\n    return result;\n}\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nconst PageParam__symbol = ( /*#__PURE__*/Symbol('PageParam'));\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to {@link LeavePageEvent}). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeParam T - Parameter value type.\n * @typeParam TInput - Parameter input type.\n */\nclass PageParam {\n    get [PageParam__symbol]() {\n        return this;\n    }\n    /**\n     * Creates default page parameter handle.\n     *\n     * This method is called when {@link Page.get requesting page parameter} which value is not present in the page.\n     * The value handle returned is assigned to the page.\n     *\n     * Returns nothing by default.\n     *\n     * @param _page - A page to assign navigation parameter to.\n     * @param _context - Page parameter context.\n     *\n     * @returns New page parameter value handle or nothing if there is no default value.\n     */\n    byDefault(_page, _context) {\n        return;\n    }\n}\n\nclass PageHashURLValueParam$ extends PageParam {\n    create(page, input) {\n        let hashURL;\n        const handle = {\n            get() {\n                return hashURL;\n            },\n            put(value) {\n                hashURL = typeof value === 'string' ? new URL(value, page.url.origin) : value;\n            },\n        };\n        handle.put(input);\n        return handle;\n    }\n}\n/**\n * @internal\n */\nconst PageHashURLValueParam = (\n/*#__PURE__*/ new PageHashURLValueParam$());\n\n/**\n * @internal\n */\nclass PageHashURLParam$ extends PageParam {\n    create(page, input) {\n        const handle = {\n            get() {\n                return page.get(PageHashURLValueParam) || getHashURL(page.url);\n            },\n            put(value) {\n                page.put(PageHashURLValueParam, value);\n            },\n        };\n        handle.put(input);\n        return handle;\n    }\n    byDefault(page) {\n        return this.create(page, null);\n    }\n}\n/**\n * Page parameter representing its {@link getHashURL hash URL}.\n *\n * When {@link Navigation.with set} to another value while navigating, the hash of target URL is updated, unless set to\n * `null` or `undefined`.\n *\n * Requires {@link PageHashURLSupport} for above to function properly.\n */\nconst PageHashURLParam = (\n/*#__PURE__*/ new PageHashURLParam$());\n\n/**\n * @internal\n */\nclass NavigationAgentKey extends ContextUpKey {\n    constructor(name) {\n        super(name);\n        this.upKey = this.createUpKey(slot => {\n            const { document } = slot.context.get(BootstrapWindow);\n            slot.insert(slot.seed.do(digAfter((...agents) => {\n                if (agents.length) {\n                    return afterThe(combinedAgent);\n                }\n                if (slot.hasFallback && slot.or) {\n                    return slot.or;\n                }\n                return afterThe(defaultNavigationAgent);\n                function combinedAgent(next, when, from, to) {\n                    return navigate(0, to);\n                    function navigate(agentIdx, agentTo) {\n                        const agent = agents[agentIdx];\n                        if (!agent) {\n                            return next(agentTo);\n                        }\n                        agent(({ url: nextURL = agentTo.url, title: nextTitle = agentTo.title, \n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        data: nextData = agentTo.data, } = agentTo) => navigate(agentIdx + 1, {\n                            url: new URL(String(nextURL), document.baseURI),\n                            title: nextTitle,\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            data: nextData,\n                            get visited() {\n                                return agentTo.visited;\n                            },\n                            get current() {\n                                return agentTo.current;\n                            },\n                            get(ref) {\n                                return agentTo.get(ref);\n                            },\n                            put(ref, input) {\n                                agentTo.put(ref, input);\n                            },\n                        }), when, from, agentTo);\n                    }\n                }\n            })));\n        });\n    }\n    grow(slot) {\n        let delegated;\n        slot.context.get(this.upKey, slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined)(agent => delegated = agent).whenOff(reason => delegated = contextDestroyed(reason));\n        slot.insert((next, when, from, to) => delegated(next, when, from, to));\n    }\n}\n/**\n * @internal\n */\nfunction defaultNavigationAgent(next, _when, _from, to) {\n    next(to);\n}\n/**\n * A key of context value containing an {@link NavigationAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nconst NavigationAgent = (\n/*#__PURE__*/ new NavigationAgentKey('navigation-agent'));\n\nconst PageHashURLSupport__feature = {\n    setup(setup) {\n        setup.provide({ a: NavigationAgent, is: pageHashURLAgent });\n    },\n};\n/**\n * {@link PageHashURLParam Page hash URL parameter} support feature.\n */\nclass PageHashURLSupport {\n    static get [FeatureDef__symbol]() {\n        return PageHashURLSupport__feature;\n    }\n}\nfunction pageHashURLAgent(next, _when, _from, to) {\n    const hashURL = to.get(PageHashURLValueParam);\n    if (hashURL) {\n        next({ url: setHashURL(to.url, hashURL) });\n    }\n    else {\n        next();\n    }\n}\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nclass PageParamContext extends ContextValues {\n}\n\n/**\n * @internal\n */\nconst NavHistory__key = ( /*#__PURE__*/new SingleContextKey('nav-history', {\n    byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n}));\n/**\n * @internal\n */\nconst NAV_DATA_KEY = 'wesib:navigation:data';\n/**\n * @internal\n */\nfunction extractNavData(state) {\n    return state == null || typeof state !== 'object'\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        ? { data: state }\n        : state[NAV_DATA_KEY];\n}\n/**\n * @internal\n */\nclass NavHistory {\n    constructor(_context) {\n        this._context = _context;\n        this._entries = new Map();\n        this._lastId = 0;\n        const window = _context.get(BootstrapWindow);\n        this._document = window.document;\n        this._location = window.location;\n        this._history = window.history;\n        this._uid = btoa(String(Math.random()));\n    }\n    static get [ContextKey__symbol]() {\n        return NavHistory__key;\n    }\n    init() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const { data } = extractNavData(this._history.state);\n        const entry = this.newEntry({\n            url: new URL(this._location.href),\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            data,\n            title: this._document.title,\n        });\n        this._entries.set(entry.id, entry);\n        entry.schedule(() => {\n            entry.enter('init');\n            this._history.replaceState(this._historyState(entry), '');\n        });\n        return entry;\n    }\n    newEntry(target) {\n        return new PageEntry(this._context, ++this._lastId, target);\n    }\n    open(toEntry, tracker) {\n        const { page: { title = '', url } } = toEntry;\n        this._history.pushState(this._historyState(toEntry), title, url.href);\n        this._enter('open', toEntry, tracker);\n    }\n    _enter(when, toEntry, tracker) {\n        const fromEntry = tracker.it;\n        this._entries.set(toEntry.id, toEntry);\n        try {\n            // Forget all entries starting from next one\n            for (let e = fromEntry.next; e; e = e.next) {\n                this._forget(e);\n            }\n        }\n        finally {\n            toEntry.prev = fromEntry;\n            fromEntry.next = toEntry;\n            toEntry.schedule(() => {\n                try {\n                    fromEntry.leave();\n                }\n                finally {\n                    toEntry.enter(when);\n                }\n            });\n            tracker.it = toEntry;\n        }\n    }\n    replace(toEntry, tracker) {\n        const fromEntry = tracker.it;\n        const { page: { title = '', url } } = toEntry;\n        this._history.replaceState(this._historyState(toEntry), title, url.href);\n        this._entries.set(toEntry.id, toEntry);\n        const prev = fromEntry.prev;\n        if (prev) {\n            toEntry.prev = prev;\n            prev.next = toEntry;\n        }\n        toEntry.schedule(() => {\n            try {\n                fromEntry.leave();\n            }\n            finally {\n                try {\n                    this._forget(fromEntry);\n                }\n                finally {\n                    toEntry.enter('replace');\n                }\n            }\n        });\n        tracker.it = toEntry;\n    }\n    popState(popState, tracker) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const { state } = popState;\n        if (state == null) {\n            // Hash change\n            if (this._history.state == null) {\n                // Not a return\n                return this._changeHash(tracker);\n            }\n            return; // Already handled by `hashchange` handler\n        }\n        const fromEntry = tracker.it;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const { uid, data, id: pageId } = extractNavData(state);\n        let toEntry;\n        const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n        if (existingEntry) {\n            toEntry = existingEntry;\n        }\n        else {\n            // Returning to page existed in previous app version\n            toEntry = this.newEntry({\n                url: new URL(this._location.href),\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                data,\n                title: this._document.title,\n            });\n            fromEntry.transfer(toEntry, 'return');\n            this._entries.set(toEntry.id, toEntry);\n            this._history.replaceState(this._historyState(toEntry), '');\n        }\n        toEntry.schedule(() => {\n            try {\n                fromEntry.leave();\n            }\n            finally {\n                toEntry.enter('return');\n            }\n        });\n        tracker.it = toEntry;\n        return toEntry;\n    }\n    hashChange(tracker) {\n        if (this._history.state == null) {\n            // Not a return\n            return this._changeHash(tracker);\n        }\n        // Otherwise, a `popstate` event is also triggered,\n        // and its handler would do the job (or already did).\n    }\n    update(tracker, url) {\n        const oldEntry = tracker.it;\n        const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n        this._entries.set(newEntry.id, newEntry);\n        this._history.replaceState(this._historyState(newEntry), '', url.href);\n        this._entries.delete(oldEntry.id);\n        return tracker.it = newEntry;\n    }\n    _changeHash(tracker) {\n        const fromEntry = tracker.it;\n        const toEntry = this.newEntry({\n            url: new URL(this._location.href),\n            data: null,\n            title: this._document.title,\n        });\n        try {\n            fromEntry.transfer(toEntry, 'enter');\n        }\n        finally {\n            this._history.replaceState(this._historyState(toEntry), '');\n            this._enter('enter', toEntry, tracker);\n        }\n        return toEntry;\n    }\n    _forget(entry) {\n        this._entries.delete(entry.id);\n        entry.forget();\n    }\n    _historyState({ id, page: { data } }) {\n        return {\n            [NAV_DATA_KEY]: {\n                uid: this._uid,\n                id,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                data,\n            },\n        };\n    }\n}\n/**\n * @internal\n */\nclass PageEntry {\n    constructor(_bsContext, id, target, proto) {\n        this._bsContext = _bsContext;\n        this.id = id;\n        this._status = 0 /* New */;\n        this._update = noop;\n        this._params = proto ? proto._params : new Map();\n        const entry = this;\n        this.page = {\n            get url() {\n                return target.url;\n            },\n            get title() {\n                return target.title;\n            },\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            get data() {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return target.data;\n            },\n            get visited() {\n                return !!entry._status;\n            },\n            get current() {\n                return entry._status === 2 /* Current */;\n            },\n            get(ref) {\n                return entry.get(ref);\n            },\n            put(ref, input) {\n                entry.put(ref, input);\n            },\n        };\n    }\n    get(ref) {\n        const param = ref[PageParam__symbol];\n        const handle = this._params.get(param);\n        if (handle) {\n            return handle.get();\n        }\n        const newHandle = param.byDefault(this.page, this._newContext());\n        return newHandle && this._init(param, newHandle);\n    }\n    put(ref, input) {\n        const param = ref[PageParam__symbol];\n        const handle = this._params.get(param);\n        if (handle) {\n            handle.put(input);\n            return handle.get();\n        }\n        return this._init(param, param.create(this.page, input, this._newContext()));\n    }\n    _newContext() {\n        const registry = new ContextRegistry(this._bsContext);\n        class ParamContext extends PageParamContext {\n            constructor() {\n                super(...arguments);\n                this.get = registry.newValues().get;\n            }\n        }\n        return new ParamContext();\n    }\n    _init(param, handle) {\n        this._params.set(param, handle);\n        if (this.page.current && handle.enter) {\n            handle.enter(this.page, 'init');\n        }\n        return handle.get();\n    }\n    transfer(to, when) {\n        itsEach(this._params.entries(), ([param, handle]) => {\n            if (handle.transfer) {\n                const transferred = handle.transfer(to.page, when);\n                if (transferred) {\n                    to._params.set(param, transferred);\n                }\n            }\n        });\n    }\n    stay(at) {\n        itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n    }\n    enter(when) {\n        this._status = 2 /* Current */;\n        itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n    }\n    leave() {\n        this._status = 1 /* Visited */;\n        itsEach(this._params.values(), handle => handle.leave && handle.leave());\n    }\n    forget() {\n        itsEach(this._params.values(), handle => handle.forget && handle.forget());\n        this._params.clear();\n    }\n    schedule(update) {\n        this._update = update;\n    }\n    apply() {\n        const update = this._update;\n        this._update = noop;\n        update();\n    }\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nclass EnterPageEvent extends Event {\n    /**\n     * Constructs enter page event.\n     *\n     * @param type - Event type.\n     * @param init - Initialization options.\n     */\n    constructor(type, init) {\n        super(type, { ...init, cancelable: false });\n        this.when = init.when;\n        this.to = init.to;\n    }\n}\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nclass LeavePageEvent extends Event {\n    /**\n     * Constructs leave page event.\n     *\n     * @param type - Event type.\n     * @param init - Initialization options.\n     */\n    constructor(type, init) {\n        super(type, { ...init, cancelable: true });\n        this.when = init.when;\n        this.from = init.from;\n        this.to = init.to;\n    }\n}\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nclass StayOnPageEvent extends Event {\n    /**\n     * Constructs stay on page event.\n     *\n     * @param type - Event type.\n     * @param init - Initialization options.\n     */\n    constructor(type, init) {\n        super(type, { ...init, cancelable: true });\n        this.from = init.from;\n        this.to = init.to;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.reason = init.reason;\n    }\n    /**\n     * When navigation event occurred. Always `stay`.\n     */\n    get when() {\n        return 'stay';\n    }\n}\n\n/**\n * @internal\n */\nconst Navigation__key = ( /*#__PURE__*/new SingleContextKey('navigation', {\n    byDefault: bootstrapDefault(createNavigation),\n}));\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nclass Navigation {\n    static get [ContextKey__symbol]() {\n        return Navigation__key;\n    }\n    [OnEvent__symbol]() {\n        return this.on;\n    }\n    [AfterEvent__symbol]() {\n        return this.read;\n    }\n    /**\n     * Goes to the previous page in navigation history.\n     *\n     * Calling this method is the same as calling `go(-1)`.\n     */\n    back() {\n        this.go(-1);\n    }\n    /**\n     * Goes to the next page in navigation history.\n     *\n     * Calling this method is the same as calling `go(1)`.\n     */\n    forward() {\n        this.go(1);\n    }\n    /**\n     * Reloads current page.\n     *\n     * Calling this method is the same as calling `go()`.\n     */\n    reload() {\n        this.go();\n    }\n}\nfunction createNavigation(context) {\n    const window = context.get(BootstrapWindow);\n    const { document, history } = window;\n    const dispatcher = new DomEventDispatcher(window);\n    const navHistory = context.get(NavHistory);\n    const agent = context.get(NavigationAgent);\n    const nav = trackValue(navHistory.init());\n    nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n    let next = Promise.resolve();\n    dispatcher.on('popstate')(popState => {\n        const entry = navHistory.popState(popState, nav);\n        if (entry) {\n            dispatcher.dispatch(new EnterPageEvent(\"wesib:enterPage\" /* EnterPage */, {\n                when: popState.state != null ? 'return' : 'enter',\n                to: entry.page,\n            }));\n        }\n    });\n    dispatcher.on('hashchange')(() => {\n        const entry = navHistory.hashChange(nav);\n        if (entry) {\n            dispatcher.dispatch(new EnterPageEvent(\"wesib:enterPage\" /* EnterPage */, {\n                when: 'enter',\n                to: entry.page,\n            }));\n        }\n    });\n    class Navigation$ extends Navigation {\n        constructor() {\n            super();\n            this.onEnter = dispatcher.on(\"wesib:enterPage\" /* EnterPage */);\n            this.onLeave = dispatcher.on(\"wesib:leavePage\" /* LeavePage */);\n            this.onStay = dispatcher.on(\"wesib:stayOnPage\" /* StayOnPage */);\n            this.on = onAny(onSupplied(this.onEnter), onSupplied(this.onLeave), onSupplied(this.onStay));\n            this.read = nav.read.do(mapAfter(({ page }) => page));\n        }\n        get page() {\n            return nav.it.page;\n        }\n        get length() {\n            return history.length;\n        }\n        go(delta) {\n            history.go(delta);\n        }\n        open(target) {\n            return navigate('pre-open', 'open', target);\n        }\n        replace(target) {\n            return navigate('pre-replace', 'replace', target);\n        }\n        update(url) {\n            return navHistory.update(nav, toURL(url)).page;\n        }\n        with(ref, input) {\n            return withParam(page => page.put(ref, input));\n        }\n    }\n    return new Navigation$();\n    function withParam(applyParams) {\n        return {\n            with(ref, input) {\n                return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n            },\n            open(target) {\n                return navigate('pre-open', 'open', target, applyParams);\n            },\n            replace(target) {\n                return navigate('pre-replace', 'replace', target, applyParams);\n            },\n            pretend(targetOrCallback, callback = (_from, to) => to) {\n                let target;\n                if (typeof targetOrCallback === 'function') {\n                    callback = targetOrCallback;\n                    target = undefined;\n                }\n                else {\n                    target = targetOrCallback;\n                }\n                const navTarget = navTargetOf(target);\n                const fromEntry = nav.it;\n                const toEntry = newEntry('pretend', fromEntry, navTarget, applyParams);\n                try {\n                    return applyAgent('pretend', fromEntry, navTarget, toEntry)\n                        ? callback(fromEntry.page, toEntry.page)\n                        : undefined;\n                }\n                finally {\n                    toEntry.stay(nav.it.page);\n                }\n            },\n        };\n    }\n    function toURL(url) {\n        if (typeof url === 'string') {\n            return new URL(url, document.baseURI);\n        }\n        return url || nav.it.page.url;\n    }\n    function navTargetOf(target) {\n        if (target == null || typeof target === 'string' || target instanceof URL) {\n            return { url: toURL(target) };\n        }\n        if (target.url instanceof URL) {\n            return target;\n        }\n        return { ...target, url: toURL(target.url) };\n    }\n    function navigate(whenLeave, when, target, applyParams = noop) {\n        const navTarget = navTargetOf(target);\n        const promise = next = next.then(doNavigate, doNavigate);\n        return promise;\n        function doNavigate() {\n            let toEntry = undefined;\n            try {\n                const prepared = prepare();\n                if (!prepared) {\n                    return prepared; // Navigation cancelled\n                }\n                toEntry = prepared;\n                navHistory[when](toEntry, nav);\n                dispatcher.dispatch(new EnterPageEvent(\"wesib:enterPage\" /* EnterPage */, {\n                    when,\n                    to: toEntry.page,\n                }));\n                return toEntry.page;\n            }\n            catch (e) {\n                stay(toEntry, e);\n                throw e;\n            }\n        }\n        function prepare() {\n            if (next !== promise) {\n                return stay();\n            }\n            const fromEntry = nav.it;\n            const toEntry = newEntry(whenLeave, fromEntry, navTarget, applyParams);\n            const leavePage = new LeavePageEvent(\"wesib:leavePage\" /* LeavePage */, {\n                when: whenLeave,\n                from: fromEntry.page,\n                to: toEntry.page,\n            });\n            if (!dispatcher.dispatch(leavePage)\n                || next !== promise\n                || !applyAgent(whenLeave, fromEntry, navTarget, toEntry)) {\n                return stay(toEntry);\n            }\n            return toEntry;\n        }\n        function stay(toEntry, reason) {\n            if (toEntry) {\n                toEntry.stay(nav.it.page);\n            }\n            dispatcher.dispatch(new StayOnPageEvent(\"wesib:stayOnPage\" /* StayOnPage */, {\n                from: nav.it.page,\n                to: navTarget,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                reason,\n            }));\n            return null;\n        }\n    }\n    function newEntry(whenLeave, fromEntry, navTarget, applyParams) {\n        const toEntry = navHistory.newEntry(navTarget);\n        try {\n            fromEntry.transfer(toEntry, whenLeave);\n            applyParams(toEntry.page);\n        }\n        catch (e) {\n            toEntry.stay(nav.it.page);\n            throw e;\n        }\n        return toEntry;\n    }\n    function applyAgent(whenLeave, fromEntry, navTarget, toEntry) {\n        let navigated = false;\n        agent(({ url, data, title }) => {\n            navigated = true;\n            navTarget.url = url;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            navTarget.data = data;\n            navTarget.title = title;\n        }, whenLeave, fromEntry.page, toEntry.page);\n        return navigated;\n    }\n}\n\nconst NavElement$activeClass = ['active', Wesib__NS];\nfunction navElement(element, options) {\n    const getHref = options.href.bind(options);\n    const events = setOfElements(options.event || 'click');\n    const { active = NavElement$activeClass } = options;\n    let activeClass;\n    return owner => {\n        const anchor = valueByRecipe(element, owner);\n        if (!anchor) {\n            return;\n        }\n        const { context, supply: ownerSupply = context.supply } = owner;\n        activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n        const navigation = context.get(Navigation);\n        const scheduler = context.get(ComponentRenderScheduler);\n        const schedule = scheduler({ node: anchor });\n        const supply = new Supply().needs(ownerSupply);\n        const handleClick = {\n            supply,\n            receive(_ctx, event) {\n                const href = getHref(anchor);\n                const pageURL = navigation.page.url;\n                const url = new URL(href, anchor.ownerDocument.baseURI);\n                if (url.origin !== pageURL.origin) {\n                    return; // External link\n                }\n                event.preventDefault();\n                if (pageURL.href !== url.href) {\n                    navigation.open(href).catch(console.error);\n                }\n            },\n        };\n        const eventDispatcher = new DomEventDispatcher(anchor);\n        supply.cuts(eventDispatcher);\n        for (const event of events) {\n            eventDispatcher.on(event)(handleClick);\n        }\n        const css = drekCssClassesOf(anchor)\n            .renderIn(deriveDrekContext(drekContextOf(anchor), {\n            scheduler: _opts => schedule,\n        }));\n        return ({\n            get href() {\n                return getHref(anchor);\n            },\n            supply,\n            activate() {\n                return css.add(activeClass);\n            },\n        });\n    };\n}\n\nfunction navAnchor(element, options = {}) {\n    return navElement(element, {\n        ...options,\n        href(element) {\n            return element.href;\n        },\n    });\n}\n\nconst NavMenu$Links__symbol = ( /*#__PURE__*/Symbol('NavMenu.links'));\n/**\n * Navigation menu.\n *\n * Serves as an {@link NavLink.Owner owner} of navigation links. Activates the links matching {@link Navigation.page\n * current page}.\n */\nclass NavMenu {\n    /**\n     * Constructs navigation menu.\n     *\n     * @param links - Navigation links of this menu. Either an iterable of navigation links or their providers,\n     * an `AfterEvent` keeper of the same, or a function accepting component context and this menu as parameters,\n     * and returning one of the above.\n     * @param options - Additional options.\n     */\n    constructor(links, options) {\n        this[NavMenu$Links__symbol] = new NavMenu$Links(this, links, options);\n    }\n    /**\n     * Navigation menu supply.\n     */\n    get supply() {\n        return this[NavMenu$Links__symbol].supply;\n    }\n    /**\n     * Binds this menu to the given context.\n     *\n     * Subsequent calls have no effect.\n     *\n     * @param context - Owning component context.\n     *\n     * @returns `this` instance.\n     */\n    bindTo(context) {\n        this[NavMenu$Links__symbol].bindTo(context);\n        return this;\n    }\n    /**\n     * Binds this menu to the given context.\n     *\n     * Calls {@link bindTo} method.\n     *\n     * @param context - Owning component context.\n     *\n     * @returns `this` instance.\n     */\n    [Contextual__symbol](context) {\n        return this.bindTo(context);\n    }\n}\nclass NavMenu$Links {\n    constructor(_menu, _navLinks, options = {}) {\n        this._menu = _menu;\n        this._navLinks = _navLinks;\n        this._links = trackValue([new Set()]);\n        this._active = new Map();\n        this.supply = new Supply().cuts(this._links);\n        const { activate = true, weigh } = options;\n        this._activate = activate;\n        this._weigh = weigh ? weigh.bind(options) : defaultNavLinkWeight;\n    }\n    bindTo(context) {\n        this.bindTo = noop;\n        context.whenConnected(context => {\n            let afterLinks;\n            if (isAfterEvent(this._navLinks)) {\n                afterLinks = this._navLinks;\n            }\n            else {\n                const linkValues = valueByRecipe(this._navLinks, context, this._menu);\n                afterLinks = isAfterEvent(linkValues)\n                    ? linkValues\n                    : afterThe(linkValues).do(translateAfter_((send, links) => send(...links)));\n            }\n            const owner = {\n                context,\n                supply: this.supply,\n            };\n            afterLinks((...links) => {\n                this._replace(owner, links);\n            });\n            if (this._activate) {\n                const navigation = context.get(Navigation);\n                afterAll({\n                    page: navigation,\n                    links: this._links,\n                })(({ page: [page], links: [[links]], }) => {\n                    this._updateActive(context, page, links);\n                });\n            }\n        });\n    }\n    _replace(owner, replacement) {\n        var _a;\n        const toAdd = new Set();\n        for (const linkOrProvider of replacement) {\n            const link = valueByRecipe(linkOrProvider, owner);\n            if (link) {\n                toAdd.add(link);\n            }\n        }\n        const [links] = this._links.it;\n        const toRemove = [];\n        for (const link of links.keys()) {\n            if (!toAdd.delete(link)) {\n                toRemove.push(link);\n            }\n        }\n        if (toAdd.size || toRemove.length) {\n            for (const removed of toRemove) {\n                links.delete(removed);\n                this._deactivate(removed);\n                (_a = removed.supply) === null || _a === void 0 ? void 0 : _a.off();\n            }\n            for (const added of toAdd) {\n                const { supply } = added;\n                if (supply) {\n                    if (supply.isOff) {\n                        continue; // Exclude disabled nav link.\n                    }\n                    supply.needs(this).whenOff(() => {\n                        // Handle nav link removal\n                        const [links] = this._links.it;\n                        if (links.delete(added)) {\n                            this._links.it = [links];\n                        }\n                    });\n                }\n                links.add(added);\n            }\n            this._links.it = [links];\n        }\n    }\n    _updateActive(context, page, links) {\n        const toDeactivate = [];\n        const toActivate = this._selectActive(context, page, links);\n        for (const link of this._active.keys()) {\n            if (!toActivate.delete(link)) {\n                toDeactivate.push(link);\n            }\n        }\n        for (const deactivated of toDeactivate) {\n            this._deactivate(deactivated);\n        }\n        for (const activated of toActivate) {\n            if (activated.activate) {\n                this._active.set(activated, activated.activate());\n            }\n        }\n    }\n    _selectActive(context, page, links) {\n        let maxWeight = 0;\n        let active = new Set();\n        for (const link of links) {\n            const weight = this._weigh({ link, menu: this._menu, context, page });\n            if (weight > maxWeight) {\n                maxWeight = weight;\n                active = new Set().add(link);\n            }\n            else if (weight === maxWeight) {\n                active.add(link);\n            }\n        }\n        return active;\n    }\n    _deactivate(link) {\n        const supply = this._active.get(link);\n        if (supply) {\n            this._active.delete(link);\n            supply.off();\n        }\n    }\n}\nfunction defaultNavLinkWeight({ link, context, page, }) {\n    const href = link.href;\n    const linkURL = new URL(href, context.get(BootstrapWindow).document.baseURI);\n    return calcNavLinkWeight(linkURL, page.url);\n}\nfunction calcNavLinkWeight(linkURL, pageURL) {\n    if (linkURL.origin !== pageURL.origin) {\n        return -1;\n    }\n    const linkDir = navLinkPath2dir(linkURL);\n    const pageDir = navLinkPath2dir(pageURL);\n    if (linkURL.hash) {\n        if (linkDir !== pageDir) {\n            return -1;\n        }\n        // Require search parameters to be equal\n        const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n        if (searchParamWeight < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n            return -1;\n        }\n        return linkURL.pathname.length\n            + searchParamWeight\n            + calcNavLinkWeight(getHashURL(linkURL), getHashURL(pageURL));\n    }\n    const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n    if (searchParamWeight) {\n        if (searchParamWeight < 0) {\n            return -1;\n        }\n        if (linkDir !== pageDir) {\n            return -1;\n        }\n        return linkURL.pathname.length + searchParamWeight;\n    }\n    if (!pageDir.startsWith(linkDir)) {\n        return -1;\n    }\n    return linkURL.pathname.length;\n}\nfunction navLinkPath2dir(url) {\n    const path = url.pathname;\n    return path.endsWith('/') ? path : path + '/';\n}\nfunction navLinkSearchParamsWeight({ searchParams: linkParams }, { searchParams: pageParams }) {\n    let weight = 0;\n    linkParams.forEach((value, key) => {\n        if (!isIgnoredSearchParam(key)) {\n            if (weight >= 0) {\n                if (pageParams.getAll(key).includes(value)) {\n                    weight += 1;\n                }\n                else {\n                    weight = -1;\n                }\n            }\n        }\n    });\n    return weight;\n}\nfunction isIgnoredSearchParam(key) {\n    return key.startsWith('__') && key.endsWith('__');\n}\n\n/**\n * A key of context value containing an {@link PageLoadAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nconst PageLoadAgent = (\n/*#__PURE__*/ new FetchAgentKey('page-load-agent'));\n\n/**\n * @internal\n */\nfunction cachingPageLoader(loader) {\n    let state;\n    return page => {\n        const url = pageUrl(page);\n        if (state) {\n            if (state.url === url) {\n                return state.on;\n            }\n            state.sup.off();\n        }\n        let tracked;\n        const supply = new Supply(() => {\n            state = undefined;\n            tracked = undefined;\n        });\n        const on = onEventBy(receiver => {\n            if (!tracked) {\n                const onLoad = loader(page);\n                const tracker = trackValue();\n                const trackSupply = onLoad(resp => {\n                    tracker.it = resp;\n                }).whenOff(reason => {\n                    // Error drops page cache, unlike successful page load.\n                    if (reason != null) {\n                        supply.off(reason);\n                    }\n                });\n                supply.cuts(trackSupply).cuts(tracker);\n                tracked = {\n                    on: tracker.read.do(valueOn_(asis)),\n                    num: 0,\n                };\n            }\n            const requested = tracked;\n            ++requested.num;\n            return requested.on.do(supplyOn(supply))(receiver).whenOff(reason => {\n                if (!--requested.num) {\n                    // Allow to request the same page again\n                    Promise.resolve().then(() => {\n                        if (!requested.num && requested === tracked) {\n                            supply.off(reason);\n                        }\n                    }).catch(console.error);\n                }\n            });\n        });\n        state = { url, on, sup: supply };\n        return on;\n    };\n}\nfunction pageUrl(page) {\n    return new URL('', page.url).href;\n}\n\nclass PageLoadAbortError extends Error {\n}\nclass PageLoadRequestsParam$ extends PageParam {\n    create(_page, requests) {\n        return {\n            get() {\n                return requests;\n            },\n            put: noop,\n        };\n    }\n}\n/**\n * @internal\n */\nconst PageLoadRequestsParam = new PageLoadRequestsParam$();\n/**\n * @internal\n */\nclass PageLoadRequests {\n    constructor(_navigation, _loader) {\n        this._navigation = _navigation;\n        this._loader = _loader;\n        this._map = new Map();\n        this._requests = flatMapIt(overIterator(() => this._map.values()));\n    }\n    get fragments() {\n        const result = [];\n        if (!itsEvery(this._requests, request => {\n            if (!request.fragment) {\n                return false;\n            }\n            result.push(request.fragment);\n            return true;\n        })) {\n            return [];\n        }\n        return result;\n    }\n    handle() {\n        const self = this;\n        const pageSupply = new Supply(noop);\n        let loadSupply = neverSupply();\n        return {\n            get() { },\n            put(request) {\n                self._add(request);\n            },\n            transfer(to, when) {\n                if (when === 'pretend') {\n                    return;\n                }\n                const transferred = self._transfer();\n                to.put(PageLoadRequestsParam, transferred);\n                return transferred.handle();\n            },\n            enter(page, when) {\n                if (when === 'init') {\n                    // The page is loaded already. No need to fetch it.\n                    return;\n                }\n                loadSupply = new Supply(noop).needs(pageSupply);\n                const onLoad = onEventBy(responseReceiver => {\n                    const emitter = new EventEmitter();\n                    const supply = emitter.on(responseReceiver);\n                    self._loader(page).do(supplyOn(loadSupply))(response => emitter.send(response)).whenOff(error => {\n                        if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n                            // Report current page load error as failed load response\n                            emitter.send({\n                                ok: false,\n                                page,\n                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                error,\n                            });\n                        }\n                    });\n                    return supply;\n                }).do(shareOn);\n                itsEach(self._requests, ({ fragment, receiver }) => onFragment(onLoad, fragment)({\n                    supply: new Supply().needs(receiver.supply),\n                    receive(context, response) {\n                        receiver.receive(context, response);\n                    },\n                }));\n            },\n            leave() {\n                loadSupply.off(new PageLoadAbortError('page left'));\n            },\n            stay() {\n                pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n            },\n            forget() {\n                pageSupply.off(new PageLoadAbortError('page forgotten'));\n            },\n        };\n    }\n    _add(request) {\n        const req = { ...request, receiver: eventReceiver(request.receiver) };\n        const { supply } = req.receiver;\n        const list = this._map.get(supply);\n        if (list) {\n            list.push(req);\n        }\n        else {\n            this._map.set(supply, [req]);\n            supply.whenOff(() => this._map.delete(supply));\n        }\n    }\n    _transfer() {\n        const transferred = new PageLoadRequests(this._navigation, this._loader);\n        for (const [supply, list] of this._map.entries()) {\n            transferred._map.set(supply, list.slice());\n        }\n        return transferred;\n    }\n}\nfunction onFragment(onLoad, fragment) {\n    return fragment\n        ? onLoad.do(mapOn_(response => response.ok\n            ? {\n                ...response,\n                fragment: (fragment.tag != null\n                    ? response.document.getElementsByTagName(fragment.tag)[0]\n                    : response.document.getElementById(fragment.id)) || undefined,\n            }\n            : response))\n        : onLoad;\n}\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nconst PageLoadURLModifier = (\n/*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) }));\n\n/**\n * @internal\n */\nconst PageLoader = ( /*#__PURE__*/new SingleContextKey('page-loader', {\n    byDefault: bootstrapDefault(newPageLoader),\n}));\nfunction newPageLoader(context) {\n    const window = context.get(BootstrapWindow);\n    const httpFetch = context.get(HttpFetch);\n    const modifyURL = context.get(PageLoadURLModifier);\n    const agent = context.get(PageLoadAgent);\n    const parser = new window.DOMParser();\n    return page => {\n        const url = new URL(page.url.href);\n        modifyURL(url);\n        const request = new Request(url.href, {\n            mode: 'same-origin',\n            credentials: 'same-origin',\n            headers: new Headers({ Accept: 'text/html' }),\n        });\n        return onEventBy(receiver => agent(fetch, request)(receiver));\n        function fetch(fetchRequest) {\n            requestPageFragments(page, fetchRequest);\n            return onEventBy(receiver => {\n                const dispatcher = new EventNotifier();\n                dispatcher.on(receiver);\n                dispatcher.send({ page });\n                httpFetch(fetchRequest).do(mapOn_(response => Promise.all([response, response.text()])), resolveOnOrdered, digOn_((...batch) => afterThe(...batch)), mapOn_(([response, text]) => {\n                    if (!response.ok) {\n                        return {\n                            ok: false,\n                            page,\n                            response,\n                            error: response.status,\n                        };\n                    }\n                    try {\n                        return {\n                            ok: true,\n                            page,\n                            response,\n                            document: parsePageDocument(parser, url, response, text),\n                        };\n                    }\n                    catch (error) {\n                        return {\n                            ok: false,\n                            page,\n                            response,\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            error,\n                        };\n                    }\n                }))(receiver);\n            });\n        }\n    };\n}\nfunction requestPageFragments(page, request) {\n    var _a;\n    const fragments = (_a = page.get(PageLoadRequestsParam)) === null || _a === void 0 ? void 0 : _a.fragments;\n    if (fragments && fragments.length) {\n        request.headers.set('Accept-Fragment', fragments.reduce((header, fragment) => (header ? header + ', ' : '') + (fragment.tag != null\n            ? 'tag=' + hthvQuote(fragment.tag)\n            : 'id=' + hthvQuote(fragment.id)), ''));\n    }\n}\nfunction parsePageDocument(parser, url, response, text) {\n    const doc = parser.parseFromString(text, hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v);\n    if (doc.head) {\n        const base = doc.head.querySelector('base');\n        if (base) {\n            base.href = new URL(base.getAttribute('href'), url).href;\n        }\n        else {\n            const newBase = doc.createElement('base');\n            newBase.href = url.href;\n            doc.head.appendChild(newBase);\n        }\n    }\n    return doc;\n}\n\n/**\n * @internal\n */\nclass PageLoadParam$ extends PageParam {\n    create(page, request, context) {\n        const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n        const handle = requests.handle();\n        page.put(PageLoadRequestsParam, requests);\n        handle.put(request);\n        return handle;\n    }\n}\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nconst PageLoadParam = ( /*#__PURE__*/new PageLoadParam$());\n\nconst PageCacheBuster__key = ( /*#__PURE__*/new SingleContextKey('page-cache-buster', {\n    byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n}));\n/**\n * @internal\n */\nconst appRevSearchParam = '__wesib_app_rev__';\n/**\n * @internal\n */\nclass PageCacheBuster {\n    constructor(context) {\n        const rev = appRev(context.get(BootstrapWindow).document);\n        if (!rev) {\n            this.urlModifier = afterThe();\n            this.agent = afterThe();\n        }\n        else {\n            const navigation = context.get(Navigation);\n            this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n            this.agent = afterThe((next, request) => next(new Request(request.url, request)).do(mapOn_(response => {\n                if (response.ok) {\n                    const newRev = appRev(response.document);\n                    if (newRev && newRev !== rev) {\n                        const url = new URL(response.page.url.href);\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                    }\n                }\n                return response;\n            })));\n        }\n    }\n    static get [ContextKey__symbol]() {\n        return PageCacheBuster__key;\n    }\n}\nfunction appRev(doc) {\n    var _a;\n    return (_a = doc.querySelector('meta[name=wesib-app-rev]')) === null || _a === void 0 ? void 0 : _a.getAttribute('content');\n}\n\n/**\n * @internal\n */\nfunction pageScriptsAgent(context) {\n    const doc = context.get(BootstrapWindow).document;\n    return next => next().do(mapOn_(response => {\n        if (response.ok) {\n            const allScripts = new Set(mapIt(externalScripts(doc, doc.scripts), ([src]) => src));\n            itsEach(filterIt(externalScripts(response.document, response.document.querySelectorAll('script')), ([src]) => !allScripts.has(src)), ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n            });\n        }\n        return response;\n    }));\n}\nfunction externalScripts(doc, scripts) {\n    return mapIt(filterArray(scripts, ({ src }) => !!src), script => [new URL(script.src, doc.baseURI).href, script]);\n}\n\n/**\n * @internal\n */\nfunction pageStyleAgent(context) {\n    const doc = context.get(BootstrapWindow).document;\n    return next => next().do(mapOn_(response => {\n        if (!response.ok) {\n            return response;\n        }\n        const newStyles = response.document.querySelectorAll('link[rel=stylesheet]');\n        if (!newStyles.length) {\n            return response;\n        }\n        let target = doc.head;\n        let before = null;\n        const oldStyles = doc.querySelectorAll('link[rel=stylesheet]');\n        const oldStylesByHref = new Map();\n        const firstOldStyle = oldStyles.item(0);\n        if (firstOldStyle) {\n            target = firstOldStyle.parentNode;\n            before = firstOldStyle;\n            itsEach(overArray(oldStyles), link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link));\n        }\n        itsEach(overArray(newStyles), newStyle => {\n            const href = new URL(newStyle.href, doc.baseURI).href;\n            const oldStyle = oldStylesByHref.get(href);\n            if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                    // In proper position already.\n                    // Insert the remaining styles after it.\n                    target = oldStyle.parentNode;\n                    before = oldStyle.nextSibling;\n                }\n                else {\n                    // Move to proper position.\n                    target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n            }\n            else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n            }\n        });\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode.removeChild(style));\n        return response;\n    }));\n}\n\n/**\n * @internal\n */\nfunction pageTitleAgent(context) {\n    const doc = context.get(BootstrapWindow).document;\n    return next => next().do(mapOn_(response => {\n        if (response.ok) {\n            const title = response.document.getElementsByTagName('title').item(0);\n            if (title && title.textContent) {\n                doc.title = title.textContent;\n            }\n        }\n        return response;\n    }));\n}\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature = {\n    setup(setup) {\n        setup.provide({\n            a: PageLoadURLModifier,\n            by: (buster) => buster.urlModifier,\n            with: [PageCacheBuster],\n        });\n        setup.provide({\n            a: PageLoadAgent,\n            by: (buster) => buster.agent,\n            with: [PageCacheBuster],\n        });\n        setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n        setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n        setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n    },\n};\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nclass PageLoadSupport {\n    static get [FeatureDef__symbol]() {\n        return PageLoadSupport__feature;\n    }\n}\n\n/**\n * A key of component context value containing {@link PageRenderCtl page render control}.\n */\nconst PageRenderCtl = ( /*#__PURE__*/new SingleContextKey('page-render-ctl', {\n    byDefault(context) {\n        return new PageRenderCtl$(context.get(ComponentContext));\n    },\n}));\nclass PageRenderCtl$ {\n    constructor(_context) {\n        this._context = _context;\n    }\n    renderPageBy(renderer, def = {}) {\n        const spec = valueByRecipe(def, this._context);\n        const { contentKey = RenderPage$contentKey$default } = spec;\n        const detectFragment = RenderPage$fragmentDetector(spec);\n        const navigation = this._context.get(Navigation);\n        const renderCtl = this._context.get(FragmentRenderCtl);\n        let lastPageKey;\n        const responseTracker = trackValue();\n        const handleResponse = (response) => {\n            const pageKey = contentKey(response.page);\n            if (pageKey === lastPageKey) {\n                return; // Only hash changed? Do not refresh the page.\n            }\n            responseTracker.it = [response, pageKey];\n        };\n        const supply = renderCtl.renderFragmentBy(fragExec => {\n            const responseAndKey = responseTracker.it;\n            if (!responseAndKey) {\n                fragExec.retainContent();\n                return;\n            }\n            const [response, pageKey] = responseAndKey;\n            const exec = {\n                ...fragExec,\n                postpone(postponed) {\n                    fragExec.postpone(() => postponed(exec));\n                },\n                response,\n            };\n            if (response.ok) {\n                lastPageKey = pageKey;\n                const { fragment } = response;\n                if (fragment) {\n                    importNodeContent(fragment, fragExec.content);\n                }\n            }\n            renderer(exec);\n        }, {\n            ...spec,\n            when: 'connected',\n            on: responseTracker.on,\n        });\n        this._context.whenConnected(context => {\n            lastPageKey = contentKey(navigation.page);\n            navigation.read.do(onceAfter)(page => {\n                page.put(PageLoadParam, {\n                    fragment: detectFragment(context),\n                    receiver: {\n                        supply: new Supply().needs(supply),\n                        receive: (_ctx, response) => handleResponse(response),\n                    },\n                });\n            });\n        });\n        return supply;\n    }\n}\nfunction RenderPage$fragmentDetector({ fragment }) {\n    if (fragment) {\n        return _context => fragment;\n    }\n    return ({ element: { id, tagName }, }) => id\n        ? { id }\n        : { tag: tagName.toLowerCase() };\n}\nfunction RenderPage$contentKey$default({ url }) {\n    return new URL('', url).href;\n}\n\n/**\n * Creates a {@link RenderPageDef.Method page renderer} method amendment (and decorator).\n *\n * Renders pages using {@link PageRenderCtl page render control}.\n *\n * Utilizes {@link PageLoadParam} navigation parameter.\n *\n * Enables {@link PageLoadSupport} feature.\n *\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Page inclusion definition.\n *\n * @returns New component method amendment.\n */\nfunction RenderPage(def) {\n    return ComponentMember(({ get, amend }) => amend({\n        componentDef: {\n            feature: {\n                needs: [PageLoadSupport],\n            },\n            define(defContext) {\n                defContext.whenComponent(context => {\n                    context.whenReady(context => {\n                        const { component } = context;\n                        const renderer = get(component).bind(component);\n                        context.get(PageRenderCtl).renderPageBy(renderer, def);\n                    });\n                });\n            },\n        },\n    }));\n}\n\nexport { EnterPageEvent, LeavePageEvent, NavMenu, Navigation, NavigationAgent, PageHashURLParam, PageHashURLSupport, PageLoadAgent, PageLoadParam, PageLoadSupport, PageLoadURLModifier, PageParam, PageParamContext, PageParam__symbol, PageRenderCtl, RenderPage, StayOnPageEvent, getHashURL, navAnchor, navElement, setHashURL };\n//# sourceMappingURL=wesib.navigation.js.map\n"],"names":["decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","value","Array","isArray","isArrayOfElements","first","second","values","provider","get","lazyValue$recurrent","valueProvider","TypeError","recipe","args","isValueEvaluator","elementsAreEqual","fromOrLength","to","start","end","Math","max","source","array","from","elements","Set","set","forEach","add","element","type","satisfying","prototype","getPrototypeOf","superType","constructor","superClassOf","len","idx","merge","_f","s","apply","this","hasOwnProperty$","hasOwnProperty","call","PushIterator__symbol","iterable","Symbol","iterator","iterate","PushIterable$iterator","accept","isOver","forNext","over","PushIterator$dontIterate","PushIterator$iterator","next","PushIterator$next","result","pushIterated","done","_accept","emptyPushIterator","indexed","elementOf","accept2","goOn","PushIterator$noNext","index","iterateOverIndexed","arrayElementOf","makePushIterable","iterateOverArray","isPushIterable","it","iteratorOf","status","action","itsElements$defaultConverter","convert","pushedElements","push","isEmpty","test","allMatch","res","pushHead","arrayHead","rawIteratorPusher","toPushIterator","rawIterableHead","reducer","initialValue","reduced","overNone","iterateOverRawIterator","sources","src","srcTail","itsHead","makePushIterator","iterateOverSubElements","overArray","overIterator","iterateOverOneValue","ownKeys","iterateOverFilteredIndexed","filterPusher","filterRawPusher","tail","elementsOf","array2","flatMapArray$defaultElementOf","subs","subsTail","flatMapIt$defaultConverter","flatMapPusher","flatMapRawPusher","lastSrc","sourceTail","list","item","mapPusher","mapRawPusher","valueOf","valuePusher","valueRawPusher","mapIt","overKeys","Supply$unexpectedAbort","Supply$unexpectedAbort$byDefault","reason","error","Supply$off$unexpected$reasons","Supply$off","prevOff","reasons","SupplyState__symbol","SupplyState$done","isOff","off","SupplyState$done$off","[object Object]","_supply","callback","_reason","SupplyState$noCallback","supply","Supply$off$start","SupplyState$off","SupplyState$withCallback","prev","handler","whenOff","Promise","resolve","reject","another","needs","cuts","Supply","_callback","_another","alwaysSupply$","AlwaysSupply","neverSupply$","NeverSupply","Error","message","ContextKey__symbol","name","ContextKey","opts","seeder","seed","hasFallback","insert","Contextual__symbol","_providers","Map","delete","context","initial","overElementsOf","providers","valueIt","itsElements","lazyValue","bind","iterativeSeed","pushedEmpty","itsEmpty","ContextSeedKey","IterativeContextSeeder","seedKey","IterativeSeedKey","IterativeContextKey","byDefault","valuesProvider","slot","defaultSources","entry","unshift","splice","lastIndexOf","noop","makeSeed","seeds","map","combineSimpleSeeds","SimpleContextSeeder","SimpleSeedKey","SimpleContextKey","or","alwaysSupply","ContextSupply","ContextSupplyKey","ContextBuilder__symbol","_initial","_issuers","found","issuer","factory","spec","isValueSpecByProvider","isValueSpecWithDeps","a","by","with","deps","dep","isConstantValueSpec","is","isValueSpecViaAlias","via","ctx","isValueSpecAsInstance","isSelfInstanceValueSpec","__spreadProps","as","toAsInstance","Type","DepType","JSON","stringify","seeders","_opts","_constructed","_setup","newSeed","grow","setup","prevSetup","ContextKeyError","_seeders","ContextSeeders","isContextBuilder","contextValueSpec","provide","newValues","registry","ContextValues","cached","constructed","ContextValueSlot$","_grow","newContextValues","other","otherSeeds","ContextRegistry","combine","amendment","isAmendatoryAmendment","applyAmendment","_target","noopAmender","amendments","amender","amenderOf","amendBy","amend2","request","amend","nextTarget","options","base","baseAmend","createBase","nextBase","nextRequest","modify","__spreadValues","AmendTarget$default$modify","newAmendTarget","AeClass$target$amend","_base","allAmender","decorateAmended","AeClass$target","decorator","amendedClass","autoAmended","WeakSet","has","superClass","autoAmend","host","kind","pName","cls","AmendProp$accessString","_instance","_update","AeProp$idPattern","String","createHost","hostClass","decorated","descriptor","getValue","setValue","toAccessor","instance","AeProp$notReadable","update","AeProp$notWritable","valueKey","vDesc","host2","writeValue","writable","superProto","hostInstance","createAePropAccessor","init","enumerable","configurable","readable","baseTarget","_a2","$key","$readable","$writable","$get","$set","baseRequest","createBaseTarget","createAePropApplicator","classTarget","newDescriptor","targetHost","aeClass","AeMember$HostKind","proto","nsAlias","local","ns","Naming","alias","default__naming","DefaultNaming","html__naming","id__naming","XmlNaming","css__naming","CssNaming","url","aliases","naming","applyAlias","NamespaceDef","isNameAndNamespace","compareStrings","firstName","firstUrl","aliasesByNs","nsNumPerAlias","mostPreferred","nsNumRegistered","preferred","ids","generated","AfterEvent__symbol","receiver","receive","_context","event","EventReceiver$doDonReceive","_event","receivers","send","actualReceivers","received","recurrent","processEvent","shift","sendNonRecurrent","recurrentReceivers","recurrentReceiver","eventReceiver","recurrentEvent","rcs","_rcs","receiveByEach","clear","size","generic","OnEvent__symbol","NoEventsError","input","extract","nestedSupply","neverSupply","prevSupply","extracted","digEvents","processors","reduce","arg","supplier","onEvent","onCutOff","e","_ctx","sharer","EventSharer","on","EventNotifier","_on","_onInit","initialEvents","sharedSupply","onFirst","_onFirst","dispatch","_onNext","_addReceiver","sendEventsTo","required","dependentSupply","translate","register","OnEvent$supplier","do","OnEvent$do","then","OnEvent$then","fallback","AfterEvent$noFallback","cleanup","AfterEvent$noCleanup","lastEvent","numReceivers","afterEvent","dest","reported","isOnEvent","keys","afterEventBy","shareEvents","onceEvent","sender","isEventKeeper","afterSent","isAfterEvent","afterThe","consume","consumerSupply","deduplicateAfter$default","deduplicateAfter_$default","isSimilar","getCue","deduplicateAfter$create","processor","deduplicateAfter_","shareAfter","deduplicateAfter_$create","deduplicateAfter$noPrior","deduplicateAfter$isDuplicate","asis","prior","nextEvent","compareOrFromOrLength","countArgs","arrayElementsAreEqual","areTheSame","digAfter_","extractKeeper","events","afterSupplied","onEventBy","super","onNever","neverReceive","isEventSender","suppliers","remained","removeSupplier","onSupplied","promise","alwaysReceiveValue","catch","extractSender","mapper","translateOn_","shareOn","translateEvents","mapAfter_","mapOn_","isAlwaysSupply","supplyEvents","sourceSupply","numInProcess","supplyOn","mapOn","numSent","numReceived","lastIndex","toSend","translateAfter_","valueOn_","path","_drop","emitter","EventEmitter","_nested","newValue","oldValue","nested","slice","_dropIfEmpty","dontCreateMissing","created","PathEntry","_remove","_root","_entry","nest","_trackers","_path","onUpdate","statePath","SubStateTracker","_tracker","Trackers","subTracker","track","_by","read","valueReceiver","onRecurrent","recurrentValue","acceptValuesFrom","byNone","container","consumeEvents","ValueTracker","_it","TrackedValue","trackValue","old","third","syncWithTracker","tracker","syncTrackers","extractTracker","tracker1","tracker2","supply1","supply2","OnDomEvent$sample","OnDomEvent$context","onDomEvent","listener","onDomEventBy","domListener","addEventListener","removeEventListener","dispatchEvent","flatUpSources","providers2","providersTracker","afterEach","prov","toUpSrcKeeper","upSrcKeepers","ContextUpSeeder","_key","fillBy","supplyAfter","ContextSeed$UpKey","ContextUpKey$UpKey","filterIt","isContextual","isPresent","applyContextAfter_","ContextUpKey","upKey","createUpKey","digAfter","fns","delegated","fn","contextDestroyed","module","dependencies","out","contextModuleDependencyErrorMessage","_useCounter","_impl","_rev","provided","used","settled","ready","contextSupply","module2","_load","handle","use","user","_use","rev","_updateStatus","async","moduleInit","ContextModuleInit","initBy","whenReady","impl","whenSettled","ContextModule$Use$when","isContextModuleSettled","isContextModuleReady","_module","_whenDone","_ready","finally","_done","status2","usage","ContextModuleUsage","createHandle","implementBy","candidates","ContextModule$impl__symbol","ContextModuleKey","setOfElements","replaced","contextModuleDeps","loadContextModuleDeps","whenContextModuleSettled","whenContextModuleReady","whenLoaded","notLoaded","whenDone","race","all","results","failures","filter","isDefined","ContextModuleDependencyError","ContextModule$","replace","node","ownerDocument","nodeType","beforeOrImport","importContent","importNodeContent","before","doc","nodeDocument","isElementNode","elementClone","createElement","tagName","toLowerCase","getAttributeNames","setAttribute","attr","getAttribute","insertBefore","nodeClone","importNode","childNodes","parentNode","getRootNode","RenderScheduleConfig","win","console","window","defaultView","RenderQ__symbol","q","ref","schedule","doSchedule","execute","recur","execRecurring","execNonRecurring","queue","RenderQ","shot","config","RenderQ$doNotSchedule","postponed","execution","reset","suspend","postpone","post","exec","resume","pull","scheduled","_config","scheduleOptions","queueRef","newQueue","enqueued","lastQueue","executed","nextQueue","activeQueue","nextEnqueued","RenderQueue","scheduleRecurrent","RenderQueue$doNotReplace","task","replaceQueue","_replacement","animationRenderQueues","WeakMap","animationRenderScheduler","existing","window2","requestAnimationFrame","replacement","asyncRenderQueue","asyncRenderQueue$schedule","asyncRenderScheduler","immediateRenderScheduler","shot2","last","pop","immediateRenderQueue","queuedRenderScheduler","defaultRenderScheduler","DrekContext$registrar","DrekContext$autoRegister","DrekContext$autoRegistrar","registered","DrekContext$createAutoRegistrar","DrekContext$autoRegisterFirst","context2","lift","builder","resetRegistrar","registrar","priorRegistrar","DrekContext$dontRegister","DrekContext$setRegistrar","DrekPlacement$Status__symbol","placement","onceConnected","readStatus","connected","eventCtx","whenConnected","onceOn","DrekPlacement$Status","DrekPlacement","DrekContext__symbol","scheduler","_nsAlias","_scheduler","scheduler2","document2","state","DrekContext$State","newNamespaceAliaser","newRenderSchedule","view","DrekContext","root","DrekContext$ofDocument","derivedCtx","getFragment","fragment","newRoot","composed","lifted","DrekContext$ofRootNode","document","DrekContext$Unrooted","DrekContext$unrooted","DrekCssClasses__symbol","_element","_uses","drekContextOf","className","_add","render","n","classList","remove","contains","_has","renderIn","newContext","DrekFragment$Context__symbol","_fragment","_content","_status","withinFragment","_settled","_rendered","_getFragment","_lift","_state","_createSchedule","_whenSettled","content","createDocumentFragment","DrekFragment$Context","placeContent","_whenRendered","_createExecution","fragmentExecution","attach","_settle","_render","appendChild","charger","DrekCharger$custom","charge","DrekCharger$commentWrapper","random","toString","substr","rem","wrapContent","createComment","content2","range","createRange","setStartAfter","setEndBefore","deleteContents","insertNode","append","textContent","workload","work","workName","allocator","_work","_allotment","_queues","TaskQueue","enqueue","_tasks","run","_runNext","Workload","allotment","OrderedTasks","WorkOrdering","$","workbench","runner","WorkStageRunner","stage","_whenTaskDone","_whenAllDone","_end","_task","WorkDoneError","_start","_addTask","taskPromise","taskDone","whenStarted","_awaitDeps","addDep","runAfter","after","Workbench$impl__symbol","_works","_run","Workbench$run","ensureWorking","runWorkTask","work2","setWork","runTask","whenWork","newWork","_workload","Workbench$","text","charCodeAt","uppercasePattern","letters","offset","str","lowerCase","hyphenateCSSName$cache","toHyphenLower","hyphenated","hyphenateName","startsWith","BootstrapContext__key","SingleContextKey","bootstrapContext","BootstrapContext","symbol","ownDef","own","superDef","of","metas","prevMeta","newMeta","target1","method1","target2","method2","m1","m2","FeatureDef__symbol","MetaAccessor","defs","def","elementOrArray","extendSetOfElements","mergeInitMethods","featureMeta","FeatureMeta","FeatureDef","featureType","define","featureDefs","featureAmendments","isFeatureAmendment","featureDef","Feature$toAmender","AeClass","defRequest","featureDef2","isAmendatory","FeatureContext__key","componentType","whenDefined","feature","load","BootstrapWorkbench","bootstrapDefault","Workbench","featureSetupStage","WorkStage","featureInitStage","componentDefStage","ComponentDef__symbol","meta","mergeFunctions","isQualifiedName","componentMeta","ComponentMeta","ComponentDef","componentDefs","componentAmendments","isComponentAmendment","componentDef","Component$toAmender","Feature","ComponentContext__key","ComponentEventDispatcher__key","dispatcher","DomEventDispatcher","ContentRoot","combined","StateUpdater","StateUpdaterKey","ComponentContext__symbol","updateState","component","AeProp","AeMember$createHost","AeMember$hostClass","AeMember","Component","ComponentSlot$empty","unbind","rebind","drop","_provider","mapAfter","digOn_","ComponentSlot$known","binder","getContext","newSupply","bindContext","ComponentSlot$bound","ComponentSlot__symbol","ComponentSlot","ComponentSlot$","BootstrapContextRegistry__key","BootstrapContextRegistry","PerComponentRegistry","ComponentContextRegistry","PerDefinitionRegistry","DefinitionContextRegistry","bsContext","PostDefSetup__symbol","onAny","valueOn","superPostDefSetup","postDefSetup","BootstrapWindow","DefaultNamespaceAliaser","RenderScheduler$adopt","DefaultPreRenderScheduler","RenderScheduler$Key","DefaultRenderScheduler","DocumentRenderKit","docs","DefinitionContext__symbol","CustomElements__key","customElements","CustomElements","componentTypeOrName","elementType","defContext","definitionContextOf","extend","elementDef","extends","componentResolver","ComponentResolver__symbol","resolvePromise","rejectPromise","buildPromise","settle","resolution","newPromiseResolver","DefinitionContext__key","ElementNaming","bsWindow","elementExtend","HTMLElement","ComponentConstructor__symbol","context__symbol","defaultContext","prevContext","newComponentConstructor","_val","_canSettle","onceReady","ComponentStatus$once","onceSettled","componentCtx","ComponentContext","_definitionContext","_newComponentRegistry","ComponentStatus","_component","componentDestroyed","isReady","isSettled","isConnected","whenComponent","_whenComponent","lastRev","readNotifier","notifier","_","_elementBuilder","components","newComponent","connect","create","ComponentContext$","currentRev","onCreated","receiverRev","eventContext","componentContext","notifiedRev","recurrentContext","DefinitionContext","_bsContext","_b","WhenComponent","_whenReady","translateOn","_def","definitionContextRegistry","parentPerComponentRegistry","_perComponentRegistry","definitionSetup","perDefinition","perComponent","_elementType","ComponentContext$Mounted","_createComponent","drekContext","contextOf","_connect","_created","definitions","renderKit","bindBy","ComponentContext$Custom","connectedCallback","disconnectedCallback","CustomElement$","customElementType","ElementBuilder","definitionContext","DefinitionContext$","_define","_components","_defineAll","whenDefined2","elementBuilder","buildElement","FeatureContext","_componentRegistry","ComponentRegistry","_onDefinition","_onComponent","onPostDefSetup","FeatureModule__symbol","ContextModule","FeatureModule","featureContext","FeatureContext$","whenInit","FeatureModule$options","WhenDefined__symbol","features","bootstrapContextRegistry","complete","bsStage","onPromise","feature2","lastStatus","FeatureRef$read","BootstrapContext$","initBootstrap","AttributePath__root","attributePathTo","updateAttributeState","AttributeRegistry","AttributeRegistry$","attrs","mounted","mount","change","observedAttributes","attributeChangedCallback","attributeFilter","MutationObserver","records","attributeName","record","observe","attributes","attributeOldValue","alreadyObserved","newAttrs","prevCallback","attrChanged","ComponentMember","propertyKey","hyphenateDecapName","attributeStateUpdate","parseAttributeDescriptor","declareAttribute","removeAttribute","ComponentState","ComponentState__key","ComponentStateKey","StateTracker","_name","AttributeTracker","RenderPath__root","RenderDef","trigger","renderer","ComponentRenderer$State","preRenderer","ComponentPreRenderer$State","_ctl","_renderer","_spec","valueByRecipe","when","_scheduleRenderer","_cancel","_scheduleBy","drekBuild","rendererExecution","currentRenderer","_over","ComponentRenderer$BaseState","renderBy","ComponentPreRenderer$done","_nextRenderer","_preSupply","preScheduler","preRendererExecution","preRenderBy","ComponentRenderCtl","ComponentRenderCtl$","ComponentRenderScheduler","renderCtl","recentShot","ShadowContentRoot","ShadowRootBuilder","FnContextKey","attachShadow","shadowRoot","shadowRootOf","defaultShadowContentDef","mode","Wesib__NS","agents","fetch","agentIdx","agentRequest","agent","combineFetchAgents","defaultFetchAgent","HttpFetchAgent","FetchAgentKey","HttpFetchAborted","HttpFetch","Request","responseEmitter","abortController","AbortController","signal","abort","response","customSignal","aborted","FragmentRenderCtl","FragmentRenderCtl$","RenderFragment$done","doRenderFragment","RenderFragment$justRender","RenderFragment$settleThenRender","RenderFragment$defaultTarget","getTarget","renderSupply","DrekFragment","retainContent","preExec","renderer2","retain","contentRoot","drekCharger","drekAppender","innerContext","upgrade","renderFragmentBy","RenderFragment$defaultRem","RenderFragment$def","Share__symbol","ShareRegistry__key","ShareRegistry","_sharers","share","elementName","sharers","Sharers$new","names","counter","counter2","_share","selectValue","Share$impl__symbol","ShareKey","_aliases","arrayOfElements","addSharer","shareAs","priorityOffset","priority","shareValue","withPriority","SharedValue__symbol","SharedValue","hasDetails","SharedValue$BoundRegistrar","applyContextAfter","applyContextTo","SharedValue$bindProvider","newPriority","SharedValue$detailedProvider","SharedValue$bareProvider","translateAfter","value2","Share$","SharedValue$Registrar","consumer","nodeHost","afterAll","b","Share$consumerStatus","sharers2","Share$sharedValue","deduplicateAfter","selected","details","locator","defaultSpec","isShareRef","share2","valueFor","hostByDefault2","localByDefault2","shareByDefault","shareRef","hostByDefault","localByDefault","Shareable$Internals__symbol","body","Shareable$Internals","valueRecipe","afterValue","_source","_get","Shareable","_notBound","trackValueBy","_set","dynSync","val","_syncDyn","_syncVal","_valSupply","share$default","localShare$default","accessorKey","lastTarget","accessorOf","ShareAccessor","getShared","createRegistrar","SharedValue$ContextBuilder","localShare","$getShared","_added","_removed","deltaSetDeltaReceiver","removed","added","nullInAspect$","convertTo","control","aspectKey","builtInAspect$","build","origin","attachTo","aspect","InAspect__symbol","InputAspects__NS","InNamespaceAliaser__aspect","applyTo","knownInAspect","InNamespaceAliaser","applyAspect","InRenderScheduler__aspect","InRenderScheduler","InRole__aspect","InControlRole","roles","_activate","active","role","InRole$Active","_defaultSupply","isDefault","named","defaultSupply","activateBy","activator","prevActivator","InRole","_control","_active","_activators","activate","active2","activators","role2","activatedSupply","noopInConversion","_aspect","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","aspectConverters","conversion","itsReduction","filterArray","acf","cv","isInAspectConversion","aspects","intoConvertedBy","InBuilder$Impl__symbol","_aspectsByKey","_commonAspects","_aspects","byKey","intoConvertedByKey","_a","InBuilder$Impl","addAspect","addAspects","aspectKeyOrSetup","aspectSetup","isAspectKey","InControl$Aspects__symbol","_byKey","applied","application","_applyAspect","aspectList","InControl$Aspects","intoConvertedAspects","InControl$SameValued","and","InControl$Converted","InControl","backward","convertAspect","prevValue","prevRev","InContainer__aspect","inconvertibleInAspect","InContainer","InParents__aspect","InControlParents","InParents","_map","allParents","existingSupply","parent","InElement__aspect","InElement","InMode__aspect","builtInAspect","InMode","InControlMode","ctrl","initialInMode","_all","mergeInModes","_derived","DerivedInModes","OwnModeTracker","derive","parentsInMode","derived","substring","lastUpdate","applyInMode","parents","parentList","modes","inModeValue","ro","InData__aspect","InData","hasData","InGroup__aspect","InGroup","RequireNothing$","dontRemove","validators","validatorMessages","validate","_messages","resultSupply","validator","validatorSupply","messages","entries","flatMapIt","inValidator","InValidation__aspect","InValidation","validation","InControlValidation","noInValidationErrors","hasBut","_byCode","nonEmpty","overEntries","code","codePresent","codes","some","every","InValidationErrors","InValidationMessages","inValidationResult","controls","flatMapArray","nestedInValidationMessages","numValidators","requireNothing","requireAll","missing","requirePresent","InSubmit__aspect","InSubmit","InControlSubmit","errors","submit","InSubmitError","rejected","_flags","submitted","busy","_errors","flags","data","ok","itsEvery","submitter","InSubmitRejectedError","submitData","toInSubmitMessages","_input","self","_value","doUpdate","correction","listenForInput","onInput","AbstractInElement","InFocus__aspect","InFocus","InControlFocus","inElement","owner","activeElement","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","updateInStatusFlags","elementInStatusFlags","_container","snapshot","inControlStatuses","combineInStatusFlags","onceAfter","itsEach","markEdited","markTouched","form","notReady","invalid","inModeByForm","InStyledElement__aspect","nullInAspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","UnsubscribeReason__symbol","InCssClasses","_sources","classes","mergeInCssClassesMap","DeltaSet","classesSent","flag","delta","redelta","undelta","_schedule","controlSchedule","specs","inSupply","classesSupply","isUnsubscribeReason","updateClasses","mark","hasError","defaultInCssHasError","defaultInCssErrorMarks","marks","inCssErrorMarks","md","vl","st","valid","DefaultFormPreset","nsAliaser","renderScheduler","FormPreset","FormPreset__key","FormPresetKey","FormPreset$rules__symbol","rules","rules2","setupField","FormPreset$setupField","setupForm","FormPreset$setupForm","FormPreset$noFieldSetup","_builder","FormPreset$noFormSetup","FormUnit","providerBy","field","InBuilder","Field$isDuplicateControls","FieldShare$map","Share","FormShare$map","adjacentTo","Field","adjacentLocator","shareLocator","_sharer","adjusted","FieldShare","adjacentField","locateForm","defaultForm","defaultName","fieldName","autoName","Field$nameByKey","FormShare","unit","group","FormUnitName","Form__aspect","inFormElement","elementFactory","formAspect","Form","Form$isDuplicateControls","Form$provider","duplicate","FormScope","scope","defaultRole","AbstractFormPreset$map","preset","ScopedFormConfig","createSetup","rest","ScopedFormConfig$isOptions","AbstractFormPreset","_info","info","inCssInfo","_error","inCssError","css","_byValidity","byValidity","ignore","validity","inModeByValidity","_byForm","byForm","defOrAmendment","FieldName","locateForm$default","Shared","prioritize","StypValueStruct","StypColorStruct","coords","intCoord","g","coord","min","l","round","StypHSL","h","StypColor","StypRGB","rgb","p","hueAsFraction","hueToRgb","hsl","t","newT","color1","color2","weight","w","rgba1","rgba2","aDiff","w1","w2","dim","toFormula","StypMapper","mappings","mapped","mappedValue","mapping","mappingBy","endsWith","trim","StypNumericStruct","thisDim","pt","noPt","StypDimension","addendum","stypDimension","stypAddSub","subtrahend","multiplier","divisor","zero","left","op","right","usual","stypValuesEqual","stypMul","stypDiv","StypCalcBase","StypAddSub","toDim","negate","StypMulDiv","_byPriority","important","Zero","dimension","isStypNumeric","ZeroByPriority","StypLength","StypLengthPt","stypSplitPriority","StypURL","escapeCSSVal","noStypProperties","rule","preventDuplicates","propertiesKeeper","senderOrProperties","propertiesMap","properties","isDuplicateProperties","cloneProperties","$$css","itsIterator","propertyEntries","sentry","baseProperties","addendumProperties","k","v","priorityOf","addValue","addValues","selector","isReadonlyArray","normalizeKey","normalized","combinator","prevCombinator","part","isCombinator","normalizeStypSelectorPart","isNotEmptyArray","sort","compareNames","normalizeClasses","u","isSubSelectorsArray","normalizeSubSelector","normalizeSubSelectors","isPseudoSubSelector","normalizeQualifiers","sub","prefix","params","normalizeStypSelector","qualifiers","exposeQualifier","noQualifiers","qualifier","eqIdx","indexOf","exposed","lastExposed","split","noKeyAndTail","rootSelector$1","query","find","namesEqual","qClass","mClass","ruleKeyTextOpts","qualify","escapeCSS","formatStypSelector","defaultFormat","format","hasProperties","subFormat","attrName","attrOp","attrVal","attrFlag","formatSubSelector","xmlNs","qualifyElement","formatItem","_rule","outer","mergeStypProperties","onlyAtProperties","producer","writer","isGroup","sheet","atSelectors","extractPartAtSelectors","stypSelector","extractAtSelectors","restSelector","atSelector","buildAtSelector","addStyle","addGroup","customQuery","addQuery","namedQuery","stypRenderAtRules","order","AtRulesRenderer","isAtEntry","restQualifies","colonIdx","prevQuery","stypRenderGlobals","FIRST_RENDER_ORDER","rootRule","importIndex","nsIndex","importDelta","renderImport","renderDefaultNamespace","renderNamespacePrefix","addGlobal","style","notCustomProperty","hyphenateCSSName","stypRenderXmlNs","xmlNsDefs","declareNs","isRendererFactory","rendererSpec","firstOrder","secondOrder","removeChild","defaultPrettyPrint","indent","compactStypTextFormatter","nv","eol","pre","StypTextFormatter$","f","nf","afterBody","StypGroupTextWriter","StypStyleTextWriter","AbstractStypGroupTextWriter","id","head","textFormat","pretty","formatter","idSeq","onSheet","addSheet","StypSheetTextWriter","stypTextFormat","stypRenderScheduler","removeStyleElement","setProperty","cssText","StypGroupObjectWriter","StypStyleObjectWriter","ruleText","cssRules","insertRule","deleteRule","rootSelector","selectorFormat","factories","stypRenderProperties","rendererFactory","compareRenderers","renderers","addRenderer","stypRenderFactories","renderRule","trackSupply","trackRules","production","styleProducer","_selector","stypSelectorText","reader","renderAt","nextIndex","nextRenderer","nextProducer","rendererForRule","rootSelector2","ruleSelector","lastSheet","stypRenderText","produceBasicStyle","defaultStypRenderers","StypRuleList","_list","ruleMatches","filterArray2","_buildList","_ruleSet","returnSelf","grabRules","stypQuery","Rules","classesMatch","stypSelectorMatches","StypRuleHierarchy","_updates","Self","selfRuleList","iterateAllRules","extendRule","stypRuleKeyAndTail","stypRuleKeyText","propertiesSupply","sendUpdate","overOne","AllRules","StypRule","noStypPropertiesSpec","NestedRules","_outer","outerSelector","stypOuterSelector","stypPropertiesBySpec","targetSelector","oldSpec","empty","extendSpec","keyText","newNested","StypRule$","StypRuleRef","ms","ps","watch","_mappings","_properties","RefStypRule","mappingsKeeper","StypRuleRef$","refs","fromAll","flattenProperties","referrers","StypRuleRefs","propertiesMap2","noStypRules","rulesByList","rulesFromSource","getRules","rulesByValue","evalRules","lazyRulesFromSource","ruleSet","lazyRules","asyncRules","ComponentStyleProducer","defaultStypRenderScheduler","ComponentStypRenderer","MultiContextKey","ElementIdClass__NS","ElementIdClass","contextValues","aliaser","uniqueClassSeq","qualified","ComponentStypFormat__symbol","ComponentStypObjectFormat","newProducer","lazyStypRules","componentSupply","produceStyle2","hostSelector","extractHostSelector","extendHostSelector","shadowRenderer","noShadowRenderer","restParts","ComponentStypFormat","createTextNode","StypSheetObjectWriter","stypObjectFormat","componentStypDomFormatConfig","stypDomFormat","produce","StyleProducerSupport__feature","produceStyle","isId","prevProvider","hasId","combineStyles","ThemeStyle","ThemeStyleKey","stypRules","theme","Theme__key","Theme$","referrer","Theme","_styles","_rules","styles","x","pl","param","parseNone","datePattern","delimiterOf","tagged","extra","nextInItem","parseAngleBrackets","angleBracketsParser","parseDateTime2","dateTime","parseDateTime","dateTimeParser","parseQuotedString","unquoted","quotedStringParser","parseExtra","itemParser","tag","hthvItem","extraItem","skipSpaces","spacesParser","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","delimit","delimitConfig","defaultParserConfig","commentParserConfig","parserConfig","buildParserConfig","parseItemDelimit","itemDelimitParser","parseParam","paramParser","parseComment","comments","commentParserConfig2","nextInComment","commentParser","headerValue","hthvParse","string","escaped","quote","delimiter","URL","hash","PageParam__symbol","_page","navigate","agentTo","nextURL","title","nextTitle","nextData","baseURI","visited","current","put","defaultNavigationAgent","_when","_from","NavigationAgent","NavigationAgentKey","NavHistory__key","NavHistory","_entries","_lastId","_document","_location","location","_history","history","_uid","btoa","extractNavData","newEntry","href","enter","replaceState","_historyState","PageEntry","toEntry","page","pushState","_enter","fromEntry","_forget","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","_params","newHandle","_newContext","_init","PageParamContext","transferred","at","stay","Event","cancelable","Navigation__key","navHistory","nav","nextEntry","EnterPageEvent","hashChange","Navigation","onEnter","onLeave","onStay","go","toURL","withParam","applyParams","open","targetOrCallback","navTarget","navTargetOf","applyAgent","whenLeave","doNavigate","prepared","leavePage","LeavePageEvent","prepare","StayOnPageEvent","navigated","NavElement$activeClass","getHref","activeClass","anchor","ownerSupply","navigation","handleClick","pageURL","preventDefault","eventDispatcher","DrekCssClasses$","drekCssClassesOf","initialNsAlias","initialScheduler","deriveDrekContext","navElement","element2","NavMenu$Links__symbol","links","NavMenu$Links","bindTo","_menu","_navLinks","_links","weigh","_weigh","defaultNavLinkWeight","afterLinks","linkValues","_replace","_updateActive","toAdd","linkOrProvider","link","toRemove","_deactivate","links2","toDeactivate","toActivate","_selectActive","deactivated","activated","maxWeight","menu","calcNavLinkWeight","linkURL","linkDir","navLinkPath2dir","pageDir","searchParamWeight2","navLinkSearchParamsWeight","pathname","getHashURL","searchParamWeight","searchParams","linkParams","pageParams","isIgnoredSearchParam","getAll","includes","PageLoadAgent","loader","pageUrl","sup","tracked","onLoad","resp","num","requested","PageLoadRequestsParam","PageParam","requests","_navigation","_loader","_requests","pageSupply","loadSupply","_transfer","responseReceiver","PageLoadAbortError","getElementsByTagName","getElementById","onFragment","req","PageLoadRequests","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","fragments","header","hthvQuote","resolveOnOrdered","batch","parsePageDocument","parseFromString","querySelector","newBase","cachingPageLoader","PageLoadParam","PageLoadParam$","PageCacheBuster__key","PageCacheBuster","appRev","urlModifier","newRev","reload","allScripts","externalScripts","scripts","querySelectorAll","script","newStyles","oldStyles","oldStylesByHref","firstOldStyle","newStyle","oldStyle","pushedFirst","rawFirst","itsFirst","nextSibling","PageLoadSupport__feature","buster","pageScriptsAgent","pageStyleAgent","pageTitleAgent","PageRenderCtl","PageRenderCtl$","contentKey","RenderPage$contentKey$default","detectFragment","RenderPage$fragmentDetector","lastPageKey","responseTracker","responseAndKey","pageKey","fragExec","handleResponse","PageLoadSupport","renderPageBy"],"mappings":"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"}