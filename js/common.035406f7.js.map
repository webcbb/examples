{"version":3,"file":"common.035406f7.js","sources":["../../../../proc7ts/primitives/src/array/array-of-elements.ts","../../../../proc7ts/primitives/src/array/element-or-array.ts","../../../../proc7ts/primitives/src/array/set-of-elements.ts","../../../../proc7ts/primitives/src/class/super-class-of.ts","../../../../proc7ts/primitives/src/fn/asis.ts","../../../../proc7ts/primitives/src/fn/merge-functions.ts","../../../../proc7ts/primitives/src/fn/noop.ts","../../../../proc7ts/primitives/src/value/value-providers.ts","../../../../proc7ts/primitives/src/value/lazy-value.ts","../../../../proc7ts/primitives/src/supply/supply.ts","../../../../proc7ts/primitives/src/supply/never-supply.ts","../../../../proc7ts/primitives/src/type/presence.ts","../../../../proc7ts/push-iterator/src/push-iterable.ts","../../../../proc7ts/push-iterator/src/base/is-push-iterable.ts","../../../../proc7ts/push-iterator/src/base/iterator-of.ts","../../../../proc7ts/push-iterator/src/base/make-push-iterable.ts","../../../../proc7ts/push-iterator/src/base/push-iterated.ts","../../../../proc7ts/push-iterator/src/base/make-push-iterator.ts","../../../../proc7ts/push-iterator/src/base/push-head.ts","../../../../proc7ts/push-iterator/src/base/iterate-over-array.impl.ts","../../../../proc7ts/push-iterator/src/base/iterate-over-indexed.impl.ts","../../../../proc7ts/push-iterator/src/construction/over-array.ts","../../../../proc7ts/push-iterator/src/consumption/its-iterated.ts","../../../../proc7ts/push-iterator/src/consumption/its-each.ts","../../../../proc7ts/push-iterator/src/consumption/its-elements.ts","../../../../proc7ts/push-iterator/src/consumption/its-empty.ts","../../../../proc7ts/push-iterator/src/consumption/its-first.ts","../../../../proc7ts/push-iterator/src/base/raw-iterator.impl.ts","../../../../proc7ts/push-iterator/src/consumption/its-head.ts","../../../../proc7ts/push-iterator/src/consumption/its-iterator.ts","../../../../proc7ts/push-iterator/src/consumption/its-reduction.ts","../../../../proc7ts/push-iterator/src/construction/over-none.ts","../../../../proc7ts/push-iterator/src/construction/over-iterator.ts","../../../../proc7ts/push-iterator/src/construction/over-elements-of.ts","../../../../proc7ts/push-iterator/src/construction/over-iterable.ts","../../../../proc7ts/push-iterator/src/construction/over-one.ts","../../../../proc7ts/push-iterator/src/objects/over-keys.ts","../../../../proc7ts/push-iterator/src/transformation/filter-array.ts","../../../../proc7ts/push-iterator/src/transformation/iterate-over-filtered-indexed.impl.ts","../../../../proc7ts/push-iterator/src/transformation/filter-it.ts","../../../../proc7ts/push-iterator/src/transformation/flat-map-array.ts","../../../../proc7ts/push-iterator/src/transformation/iterate-over-flattened-indexed.impl.ts","../../../../proc7ts/push-iterator/src/transformation/flat-map-it.ts","../../../../proc7ts/push-iterator/src/transformation/map-it.ts","../../../../proc7ts/push-iterator/src/transformation/value-it.ts","../../../../proc7ts/push-iterator/src/objects/over-entries.ts","../../../../proc7ts/context-values/src/context-key.ts","../../../../proc7ts/context-values/src/context-key-error.ts","../../../../proc7ts/context-values/src/context-seeders.impl.ts","../../../../proc7ts/context-values/src/context-value-spec.ts","../../../../proc7ts/context-values/src/context-values.ts","../../../../proc7ts/context-values/src/context-values.impl.ts","../../../../proc7ts/context-values/src/context-registry.ts","../../../../proc7ts/context-values/src/simple-context-key.ts","../../../../proc7ts/context-values/src/context-supply.ts","../../../../proc7ts/context-values/src/iterative-context-key.ts","../../../../proc7ts/context-values/src/multi-context-key.ts","../../../../proc7ts/context-values/src/single-context-key.ts","../../../../frontmeans/namespace-aliaser/src/naming.ts","../../../../frontmeans/namespace-aliaser/src/namings.ts","../../../../frontmeans/namespace-aliaser/src/namespace.ts","../../../../frontmeans/namespace-aliaser/src/name.ts","../../../../frontmeans/namespace-aliaser/src/namespace-aliaser.ts","../../../../proc7ts/fun-events/src/base/event-keeper.ts","../../../../proc7ts/fun-events/src/base/event-receiver.ts","../../../../proc7ts/fun-events/src/base/event-notifier.impl.ts","../../../../proc7ts/fun-events/src/base/event-notifier.ts","../../../../proc7ts/fun-events/src/base/event-sender.ts","../../../../proc7ts/fun-events/src/base/send-events-to.ts","../../../../proc7ts/fun-events/src/impl/after-event.no-fallback.ts","../../../../proc7ts/fun-events/src/impl/event-dig.ts","../../../../proc7ts/fun-events/src/impl/on-event.do.ts","../../../../proc7ts/fun-events/src/impl/on-event.supplier.ts","../../../../proc7ts/fun-events/src/impl/once-event.ts","../../../../proc7ts/fun-events/src/impl/on-event.then.ts","../../../../proc7ts/fun-events/src/impl/share-events.ts","../../../../proc7ts/fun-events/src/impl/supply-events.ts","../../../../proc7ts/fun-events/src/impl/translate-events.ts","../../../../proc7ts/fun-events/src/base/impl/never-receive.ts","../../../../proc7ts/fun-events/src/after-event.ts","../../../../proc7ts/fun-events/src/keepers/after-all.ts","../../../../proc7ts/fun-events/src/keepers/after-each.ts","../../../../proc7ts/fun-events/src/keepers/after-sent.ts","../../../../proc7ts/fun-events/src/keepers/after-supplied.ts","../../../../proc7ts/fun-events/src/keepers/after-the.ts","../../../../proc7ts/fun-events/src/on-event.ts","../../../../proc7ts/fun-events/src/processors/consume-events.ts","../../../../proc7ts/fun-events/src/processors/share-after.ts","../../../../proc7ts/fun-events/src/processors/dig-after.ts","../../../../proc7ts/fun-events/src/senders/event-emitter.ts","../../../../proc7ts/fun-events/src/senders/on-never.ts","../../../../proc7ts/fun-events/src/senders/on-supplied.ts","../../../../proc7ts/fun-events/src/senders/on-any.ts","../../../../proc7ts/fun-events/src/senders/on-promise.ts","../../../../proc7ts/fun-events/src/base/impl/always-receive-value.ts","../../../../proc7ts/fun-events/src/processors/share-on.ts","../../../../proc7ts/fun-events/src/processors/translate-on.ts","../../../../proc7ts/fun-events/src/processors/map-after.ts","../../../../proc7ts/fun-events/src/processors/map-on.ts","../../../../proc7ts/fun-events/src/processors/once-after.ts","../../../../proc7ts/fun-events/src/processors/once-on.ts","../../../../proc7ts/fun-events/src/processors/supply-on.ts","../../../../proc7ts/fun-events/src/processors/resolve-on-ordered.ts","../../../../proc7ts/fun-events/src/processors/resolve-on.ts","../../../../proc7ts/fun-events/src/processors/supply-after.ts","../../../../proc7ts/fun-events/src/processors/translate-after.ts","../../../../proc7ts/fun-events/src/processors/value-on.ts","../../../../proc7ts/fun-events/src/state/state-path.ts","../../../../proc7ts/fun-events/src/state/state-tracker.ts","../../../../proc7ts/fun-events/src/value/value-tracker.ts","../../../../proc7ts/fun-events/src/value/track-value.ts","../../../../proc7ts/fun-events/src/value/value-sync.ts","../../../../frontmeans/dom-events/src/on-dom-event.ts","../../../../frontmeans/dom-events/src/dom-event-dispatcher.ts","../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts","../../../../frontmeans/render-scheduler/src/render-schedule.ts","../../../../frontmeans/render-scheduler/src/custom-render-scheduler.ts","../../../../frontmeans/render-scheduler/src/render-queue.ts","../../../../frontmeans/render-scheduler/src/animation-render-scheduler.ts","../../../../frontmeans/render-scheduler/src/immediate-render-scheduler.ts","../../../../frontmeans/render-scheduler/src/render-scheduler.ts","../../../wesib/src/boot/bootstrap-context.key.impl.ts","../../../wesib/src/boot/bootstrap-context.ts","../../../wesib/src/boot/bootstrap-default.ts","../../../wesib/src/common/decorators.ts","../../../../proc7ts/primitives/src/reflection/property-accessor.ts","../../../wesib/src/common/is-element.ts","../../../wesib/src/common/meta-accessor.ts","../../../wesib/src/feature/feature-def.ts","../../../wesib/src/feature/feature.decorator.ts","../../../wesib/src/feature/feature-context.ts","../../../wesib/src/feature/feature-needs-error.ts","../../../wesib/src/feature/feature-ref.ts","../../../wesib/src/component/component-def.ts","../../../wesib/src/component/component.decorator.ts","../../../wesib/src/component/component-context.key.impl.ts","../../../wesib/src/component/component-event.key.impl.ts","../../../wesib/src/component/content-root.ts","../../../wesib/src/component/state-updater.ts","../../../wesib/src/component/component-context.ts","../../../wesib/src/component/component-event.ts","../../../wesib/src/component/component-property.decorator.ts","../../../wesib/src/boot/impl/bootstrap-context-registry.impl.ts","../../../wesib/src/boot/impl/component-context-registry.impl.ts","../../../wesib/src/boot/impl/definition-context-registry.impl.ts","../../../wesib/src/boot/impl/post-def-setup.impl.ts","../../../wesib/src/boot/globals/bootstrap-window.ts","../../../wesib/src/boot/globals/bootstrap-root.ts","../../../wesib/src/boot/globals/default-namespace-aliaser.ts","../../../wesib/src/boot/globals/default-render-scheduler.ts","../../../wesib/src/boot/globals/element-adapter.ts","../../../wesib/src/boot/globals/element-observer.ts","../../../wesib/src/boot/impl/definition-context.symbol.impl.ts","../../../wesib/src/component/definition/custom-elements.ts","../../../../proc7ts/primitives/src/promises/promise-resolver.ts","../../../wesib/src/component/definition/definition.context.key.impl.ts","../../../wesib/src/component/definition/element-def.ts","../../../wesib/src/component/definition/definition-context.ts","../../../wesib/src/boot/impl/component-context.impl.ts","../../../wesib/src/boot/impl/component-mount.impl.ts","../../../wesib/src/component/component-mount.ts","../../../wesib/src/boot/impl/custom-element.impl.ts","../../../wesib/src/boot/impl/when-component.impl.ts","../../../wesib/src/boot/impl/definition-context.impl.ts","../../../wesib/src/boot/impl/element-builder.impl.ts","../../../wesib/src/feature/loader/component-registry.impl.ts","../../../wesib/src/feature/loader/feature-context.impl.ts","../../../wesib/src/feature/loader/feature-loader.impl.ts","../../../wesib/src/feature/loader/feature-request.impl.ts","../../../wesib/src/feature/loader/feature-requester.impl.ts","../../../wesib/src/boot/impl/when-defined.impl.ts","../../../wesib/src/feature/attributes/attribute-path.ts","../../../wesib/src/feature/attributes/attribute-state-update.impl.ts","../../../wesib/src/feature/attributes/property2attribute-name.ts","../../../wesib/src/feature/attributes/attribute-registry.ts","../../../wesib/src/feature/attributes/attribute.decorator.ts","../../../wesib/src/feature/attributes/attribute-descriptor.impl.ts","../../../wesib/src/feature/state/component-state.ts","../../../wesib/src/feature/attributes/track-attribute.ts","../../../wesib/src/feature/dom-properties/dom-property-path.ts","../../../wesib/src/feature/render/render-def.ts","../../../../proc7ts/primitives/src/value/value-recipe.ts","../../../wesib/src/feature/render/element-render-ctl.impl.ts","../../../wesib/src/feature/render/element-render-ctl.ts","../../../wesib/src/feature/render/element-render-scheduler.ts","../../../wesib/src/feature/render/render.decorator.ts","../../../wesib/src/feature/shadow-dom/shadow-content-root.ts","../../../wesib/src/feature/shadow-dom/shadow-dom-event.ts","../../../wesib/src/feature/shadow-dom/shadow-root-builder.ts","../../../wesib/src/feature/shadow-dom/attach-shadow.decorator.ts","../../../wesib/src/wesib.ns.ts","../../../../proc7ts/delta-set/src/delta-set.ts","../../../../frontmeans/input-aspects/src/aspect.ts","../../../../frontmeans/input-aspects/src/aspect.impl.ts","../../../../frontmeans/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../../../frontmeans/input-aspects/src/aspects/render-scheduler.aspect.ts","../../../../frontmeans/input-aspects/src/converter.ts","../../../../frontmeans/input-aspects/src/control.ts","../../../../frontmeans/input-aspects/src/controls/value-of.control.ts","../../../../frontmeans/input-aspects/src/controls/abstract.control.ts","../../../../frontmeans/input-aspects/src/containers/container.control.ts","../../../../frontmeans/input-aspects/src/containers/parents.aspect.ts","../../../../frontmeans/input-aspects/src/element.control.ts","../../../../frontmeans/input-aspects/src/data/mode.aspect.ts","../../../../frontmeans/input-aspects/src/data/data.aspect.ts","../../../../frontmeans/input-aspects/src/containers/group.control.ts","../../../../frontmeans/input-aspects/src/validation/require-nothing.validator.ts","../../../../frontmeans/input-aspects/src/validation/validator.impl.ts","../../../../frontmeans/input-aspects/src/validation/validator.ts","../../../../frontmeans/input-aspects/src/validation/validation.aspect.ts","../../../../frontmeans/input-aspects/src/validation/require-all.validator.ts","../../../../frontmeans/input-aspects/src/validation/require-present.validator.ts","../../../../frontmeans/input-aspects/src/elements/abstract-element.control.ts","../../../../frontmeans/input-aspects/src/elements/text.control.ts","../../../../frontmeans/input-aspects/src/elements/focus/focus.aspect.ts","../../../../frontmeans/input-aspects/src/elements/focus/status.aspect.ts","../../../../frontmeans/input-aspects/src/elements/style/styled-element.aspect.ts","../../../../frontmeans/input-aspects/src/elements/style/css-classes.aspect.ts","../../../../frontmeans/input-aspects/src/elements/style/css-error.ts","../../../../frontmeans/input-aspects/src/elements/style/css-info.ts","../../../../frontmeans/httongue/src/escape-css.ts","../../../../frontmeans/httongue/src/escape-css-val.ts","../../../../frontmeans/httongue/src/hyphenate.impl.ts","../../../../frontmeans/httongue/src/hyphenate.ts","../../../../frontmeans/style-producer/src/internal/types.ts","../../../../frontmeans/style-producer/src/value/value.ts","../../../../frontmeans/style-producer/src/value/color/color.ts","../../../../frontmeans/style-producer/src/value/color/mix.ts","../../../../frontmeans/style-producer/src/value/numeric/numeric.ts","../../../../frontmeans/style-producer/src/value/mapper.ts","../../../../frontmeans/style-producer/src/value/priority.ts","../../../../frontmeans/style-producer/src/internal/css.ts","../../../../frontmeans/style-producer/src/value/numeric/numeric.impl.ts","../../../../frontmeans/style-producer/src/value/numeric/zero.impl.ts","../../../../frontmeans/style-producer/src/value/numeric/dimension-kind.impl.ts","../../../../frontmeans/style-producer/src/value/unit/length.ts","../../../../frontmeans/style-producer/src/value/url.ts","../../../../frontmeans/style-producer/src/rule/properties.impl.ts","../../../../frontmeans/style-producer/src/selector/selector.impl.ts","../../../../frontmeans/style-producer/src/selector/query.ts","../../../../frontmeans/style-producer/src/selector/selector-constructor.ts","../../../../frontmeans/style-producer/src/selector/selector-text.impl.ts","../../../../frontmeans/style-producer/src/producer/renderers/at-rules.renderer.ts","../../../../frontmeans/style-producer/src/producer/renderers/renderer.impl.ts","../../../../frontmeans/style-producer/src/producer/renderers/globals.renderer.ts","../../../../frontmeans/style-producer/src/producer/renderers/properties.renderer.ts","../../../../frontmeans/style-producer/src/producer/renderers/text.renderer.ts","../../../../frontmeans/style-producer/src/producer/renderers/xml-ns.renderer.ts","../../../../frontmeans/style-producer/src/producer/formats/format.impl.ts","../../../../frontmeans/style-producer/src/producer/formats/text.format.ts","../../../../frontmeans/style-producer/src/producer/formats/dom.format.ts","../../../../frontmeans/style-producer/src/producer/formats/object.format.ts","../../../../frontmeans/style-producer/src/producer/produce-basic-style.ts","../../../../frontmeans/style-producer/src/selector/selector-text.ts","../../../../frontmeans/style-producer/src/producer/renderers/default-renderers.impl.ts","../../../../frontmeans/style-producer/src/producer/produce-style.ts","../../../../frontmeans/style-producer/src/rule/rule.ts","../../../../frontmeans/style-producer/src/rule/rules.impl.ts","../../../../frontmeans/style-producer/src/rule/rule.impl.ts","../../../../frontmeans/style-producer/src/rule/root.ts","../../../../frontmeans/style-producer/src/rule/rule-ref.ts","../../../../frontmeans/style-producer/src/rule/rule-refs.ts","../../../../frontmeans/style-producer/src/rule/rules.ts","../../../../hatsy/http-header-value/src/impl/hthv-item.ts","../../../../hatsy/http-header-value/src/parser/add-param.ts","../../../../hatsy/http-header-value/src/parser/parse-none.ts","../../../../hatsy/http-header-value/src/parser/date-time-parser.ts","../../../../hatsy/http-header-value/src/parser/next-in-item.ts","../../../../hatsy/http-header-value/src/parser/item-parser.ts","../../../../hatsy/http-header-value/src/parser/angle-brackets-parser.ts","../../../../hatsy/http-header-value/src/parser/quoted-string-parser.ts","../../../../hatsy/http-header-value/src/parser/next-in-comment.ts","../../../../hatsy/http-header-value/src/parser/spaces-parser.ts","../../../../hatsy/http-header-value/src/parser/param-parser.ts","../../../../hatsy/http-header-value/src/parser/parser-config.ts","../../../../hatsy/http-header-value/src/hthv-parser.ts","../../../../hatsy/http-header-value/src/parser/item-delimit-parser.ts","../../../../hatsy/http-header-value/src/parser/comment-parser.ts","../../../../hatsy/http-header-value/src/hthv-parse.ts","../../../../hatsy/http-header-value/src/hthv-quote.ts","../../../generic/src/fetch/fetch-agent-key.impl.ts","../../../generic/src/fetch/http-fetch-agent.ts","../../../generic/src/fetch/http-fetch.impl.ts","../../../generic/src/fetch/http-fetch.ts","../../../generic/src/hierarchy/hierarchy-updates.impl.ts","../../../generic/src/hierarchy/hierarchy-context.ts","../../../generic/src/hierarchy/hierarchy-registry.impl.ts","../../../generic/src/tree/element-node-list.ts","../../../generic/src/tree/element-node-list.impl.ts","../../../generic/src/tree/node-attributes.impl.ts","../../../generic/src/tree/node-properties.impl.ts","../../../generic/src/tree/element-node.impl.ts","../../../generic/src/tree/element-node.ts","../../../generic/src/navigation/hash-url/hash-url.ts","../../../generic/src/navigation/page-param.ts","../../../generic/src/navigation/navigation-agent.ts","../../../generic/src/navigation/page-param-context.ts","../../../generic/src/navigation/nav-history.impl.ts","../../../generic/src/navigation/navigation.event.ts","../../../generic/src/navigation/navigation.ts","../../../generic/src/navigation/activate-nav-link.decorator.ts","../../../generic/src/navigation/handle-nav-links.decorator.ts","../../../generic/src/util/import-node.ts","../../../generic/src/navigation/page-load/caching-page-loader.impl.ts","../../../generic/src/navigation/page-load/page-load-requests.impl.ts","../../../../proc7ts/push-iterator/src/consumption/its-every.ts","../../../generic/src/navigation/page-load/page-load-agent.ts","../../../generic/src/navigation/page-load/page-load-url-modifier.ts","../../../generic/src/navigation/page-load/page-loader.impl.ts","../../../../proc7ts/fun-events/src/processors/dig-on.ts","../../../generic/src/navigation/page-load/page-load-param.ts","../../../generic/src/navigation/page-load/page-cache-buster.impl.ts","../../../generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../../generic/src/navigation/page-load/page-style-agent.impl.ts","../../../generic/src/navigation/page-load/page-title-agent.impl.ts","../../../generic/src/navigation/page-load/page-load-support.feature.ts","../../../generic/src/navigation/page-load/include-page.decorator.ts","../../../generic/src/input/default-in-aspects.ts","../../../generic/src/input/input-from-control.ts","../../../generic/src/styp/component-style-producer.ts","../../../generic/src/styp/component-styp-dom.format-config.ts","../../../generic/src/styp/component-styp-renderer.ts","../../../generic/src/styp/element-id-class.impl.ts","../../../generic/src/styp/component-styp-format.ts","../../../generic/src/styp/component-styp-dom.format.ts","../../../generic/src/styp/produce-style.decorator.ts","../../../generic/src/styp/style-producer-support.feature.ts","../../../generic/src/styp/theme/theme-style.ts","../../../generic/src/styp/theme/theme.ts","../../src/common/examples.ns.ts","../../src/common/theme/theme-settings.ts","../../src/common/theme/link.style.ts","../../src/common/theme/default.style.ts","../../src/common/theme/body.style.ts","../../src/common/input/form.theme-settings.ts","../../src/common/input/in-error.component.ts","../../../generic/src/input/convert-input.decorator.ts","../../../wesib/src/feature/attributes/attributes.decorator.ts","../../src/common/input/input-support.feature.ts","../../src/common/layout/main.component.ts","../../src/common/layout/nav.component.ts","../../src/common/layout/container.component.ts","../../src/common/layout/layout-support.feature.ts","../../src/common/theme/body-style-support.feature.ts","../../src/common/app.feature.ts","../../src/common/input/input.style.ts","../../src/common/index.ts","../../../wesib/src/boot/bootstrap/bootstrap-components.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\n\n/**\n * Checks whether the given value is an array.\n *\n * @param value - Either element, array of elements, `null`, or `undefined`.\n *\n * @returns `true` if the given `value` is an array, or `false` otherwise.\n */\nexport function isArrayOfElements<T>(value: T | T[] | null | undefined): value is T[];\n\n/**\n * Checks whether the given value is a readonly array.\n *\n * @param value - Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns `true` if the given `value` is an array, or `false` otherwise.\n */\nexport function isArrayOfElements<T>(value: T | readonly T[] | null | undefined): value is readonly T[];\n\nexport function isArrayOfElements<T>(value: T | readonly T[] | null | undefined): value is T[] {\n  return Array.isArray(value);\n}\n\n/**\n * Converts element or array of elements to array of elements.\n *\n * @param value - Either element, array of elements, `null`, or `undefined`.\n *\n * @returns The `value` itself if it is an array, empty array if `value` is `null` or `undefined`, or an array\n * containing only `value` otherwise.\n */\nexport function arrayOfElements<T>(value: T | T[] | null | undefined): T[];\n\n/**\n * Converts element or readonly array of elements to readonly array of elements.\n *\n * @param value - Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns The `value` itself if it is an array, empty array if the `value` is `null` or `undefined`, or an array\n * containing only `value` otherwise.\n */\nexport function arrayOfElements<T>(value: T | readonly T[] | null | undefined): readonly T[];\n\nexport function arrayOfElements<T>(value: T | T[] | null | undefined): T[] {\n  return (/*#__INLINE__*/ isArrayOfElements(value)) ? value : value != null ? [value] : [];\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\n\n/**\n * Builds element or array of the given elements.\n *\n * @param source - A source of elements as their iterable or array-like container.\n *\n * @returns The only element of the `source`, an array of all elements of non-empty source, or `undefined` if the\n * `source` is empty.\n */\nexport function elementOrArray<T>(source: Iterable<T> | ArrayLike<T>): T | T[] | undefined {\n\n  const array = Array.from(source);\n  const { length } = array;\n\n  if (length) {\n    return length === 1 ? array[0] : array;\n  }\n\n  return;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\nimport { isArrayOfElements } from './array-of-elements';\n\n/**\n * Builds a set of the given element or array of elements.\n *\n * @param elements Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns A new set containing all of the given elements, or empty set if `elements` is `null` or `undefined`.\n */\nexport function setOfElements<T>(elements: T | readonly T[] | null | undefined): Set<T> {\n  return (/*#__INLINE__*/ isArrayOfElements(elements))\n      ? new Set(elements)\n      : (elements != null ? new Set([elements]) : new Set());\n}\n\n/**\n * Adds element of array of elements to the given set.\n *\n * Adds to the set a single element, all `elements` of the given array, or nothing when `elements` is `null`\n * or `undefined`.\n *\n * @param set - Target set to add elements to.\n * @param elements - Element(s) to add to the `set`. Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns The target `set`.\n */\nexport function extendSetOfElements<T>(set: Set<T>, elements: T | readonly T[] | null | undefined): Set<T> {\n  if (/*#__INLINE__*/ isArrayOfElements(elements)) {\n    elements.forEach(element => set.add(element));\n  } else if (elements != null) {\n    set.add(elements);\n  }\n  return set;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\nimport type { Class } from './class';\n\n/**\n * Detects a super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @param type - The class constructor to find super class of.\n * @param satisfying - The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(type: Class, satisfying: (type: Class) => boolean = () => true): Class | undefined {\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const prototype: object = Object.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as Class;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\n/**\n * A function that returns its argument as is.\n *\n * @param value - A value to return.\n *\n * @returns `value`.\n */\nexport function asis<T>(value: T): T {\n  return value;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\n/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @typeParam TArgs - Function parameter types as tuple.\n * @typeParam TReturn - A type of function result.\n * @typeParam TThis - A type if `this` object expected by function.\n * @param first - The first function to call.\n * @param second - The second function to call.\n * @param merge - Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: (this: TThis, ...args: TArgs) => TReturn,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge: (first: TReturn, second: TReturn) => TReturn,\n): (this: TThis, ...args: TArgs) => TReturn;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: (this: TThis, ...args: TArgs) => TReturn,\n    merge?: (first: TReturn, second: TReturn) => TReturn,\n): (this: TThis, ...args: TArgs) => TReturn;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge?: (first: TReturn, second: TReturn) => TReturn,\n): ((this: TThis, ...args: TArgs) => TReturn) | undefined;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge: (first: TReturn, second: TReturn) => TReturn = (_f, s) => s,\n): ((this: TThis, ...args: TArgs) => TReturn) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function (this: TThis, ...args: TArgs): TReturn {\n    return merge(\n        first.apply(this, args),\n        second.apply(this, args),\n    );\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\n/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nexport function noop(): undefined {\n  return;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\n/**\n * Creates a provider of the only argument.\n *\n * @param value - A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return (): T => value;\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values - Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return (): T => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values - Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return (): T => Array.from(values) as T;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\nimport { valueProvider } from './value-providers';\n\n/**\n * Creates a provider of lazily evaluated value.\n *\n * The returned function evaluates the value first time it is called. Then it just returns previously evaluated value.\n *\n * @param provider - A no-arg function evaluating the value.\n *\n * @returns A function that returns the value evaluated by `provider`.\n */\nexport function lazyValue<T>(provider: (this: void) => T): (this: void) => T {\n\n  let get = (): T => (get = valueProvider(provider()))();\n\n  return (): T => get();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\nimport { noop } from '../fn';\nimport type { SupplyPeer } from './supply-peer';\n\n/**\n * Supply handle.\n *\n * Represents a supply of something.\n *\n * The supply can be {@link off cut off}, and can {@link whenOff inform} on cutting off.\n */\nexport class Supply implements SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _off: (reason?: unknown) => void;\n\n  /**\n   * @internal\n   */\n  private _whenOff: (callback: (reason?: unknown) => void) => void;\n\n  /**\n   * Constructs new supply instance.\n   *\n   * @param off - A function to call when the supply is {@link Supply.off cut off}. Accepts optional cut off reason\n   * as its only parameter. No-op by default.\n   */\n  constructor(off: (this: void, reason?: unknown) => void = noop) {\n    this._off = reason => {\n      this._whenOff = callback => callback(reason);\n      this._off = noop;\n      off(reason);\n    };\n    this._whenOff = callback => {\n\n      const prev = this._off;\n\n      this._off = reason => {\n        prev(reason);\n        callback(reason);\n      };\n    };\n  }\n\n  /**\n   * `this` supply instance.\n   */\n  get supply(): this {\n    return this;\n  }\n\n  /**\n   * Whether this supply is {@link off cut off} already.\n   *\n   * `true` means nothing would be supplied any more.\n   */\n  get isOff(): boolean {\n    return this._off === noop;\n  }\n\n  /**\n   * Cuts off this supply.\n   *\n   * After this method call nothing would be supplied any more.\n   *\n   * Calling this method for the second time has no effect.\n   *\n   * @param reason - An optional reason why the supply is cut off. It will be reported to {@link whenOff} callbacks.\n   * By convenience, an absent reason means the supply is done successfully.\n   *\n   * @returns The cut off supply instance.\n   */\n  off(reason?: unknown): Supply {\n    this._off(reason);\n    return this;\n  }\n\n  /**\n   * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n   * will be called immediately if {@link isOff} is `true`.\n   *\n   * @param callback - A callback function accepting optional cut off reason as its only parameter.\n   * By convenience an `undefined` reason means the supply is done successfully.\n   *\n   * @returns `this` instance.\n   */\n  whenOff(callback: (this: void, reason?: unknown) => void): this {\n    this._whenOff(callback);\n    return this;\n  }\n\n  /**\n   * Builds a promise that will be resolved once this supply is {@link off done}.\n   *\n   * @returns A promise that will be successfully resolved once this supply is cut off without a reason, or rejected\n   * once this supply is cut off with any reason except `undefined`.\n   */\n  whenDone(): Promise<void> {\n    return new Promise(\n        (resolve, reject) => this.whenOff(\n            reason => reason === undefined ? resolve() : reject(reason),\n        ),\n    );\n  }\n\n  /**\n   * Makes another supply depend on this one.\n   *\n   * Once this supply is {@link off cut off}, `another` one will be cut off with the same reason.\n   *\n   * Calling this method has the same effect as calling {@link needs another.supply.need(this)}.\n   *\n   * @param another - A supply peer to make dependent on this one.\n   *\n   * @returns `this` instance.\n   */\n  cuts(another: SupplyPeer): this {\n    another.supply.needs(this);\n    return this;\n  }\n\n  /**\n   * Makes this supply depend on another one.\n   *\n   * Once `another` supply is {@link off cut off}, this one will be cut off with the same reason.\n   *\n   * @param another - A supply peer to make this one depend on.\n   *\n   * @returns `this` instance.\n   */\n  needs(another: SupplyPeer): this {\n    another.supply.whenOff(reason => this.off(reason));\n    return this;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\nimport { Supply } from './supply';\nimport type { SupplyPeer } from './supply-peer';\n\n/**\n * @internal\n */\nclass NeverSupply extends Supply {\n\n  get isOff(): true {\n    return true;\n  }\n\n  off(): this {\n    return this;\n  }\n\n  whenOff(callback: (reason?: any) => void): this {\n    callback();\n    return this;\n  }\n\n  cuts(another: SupplyPeer): this {\n    another.supply.off();\n    return this;\n  }\n\n  needs(_another: SupplyPeer): this {\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst neverSupply$ = (/*#__PURE__*/ new NeverSupply());\n\n/**\n * Builds a never-supply instance.\n *\n * @returns A supply instance that is already cut off without any particular reason.\n */\nexport function neverSupply(): Supply {\n  return neverSupply$;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\n/**\n * A function that checks whether the given value is present.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nexport function isPresent<T>(value: T | undefined | null): value is T {\n  return value != null;\n}\n\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nexport function isNotPresent<T>(value: T | undefined | null): value is T {\n  return value == null;\n}\n\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nexport function isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nexport function isUndefined<T>(value: T | undefined): value is T {\n  return value === undefined;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterator } from './push-iterator';\n\n/**\n * A key of {@link PushIterable} iteration method.\n */\nexport const PushIterator__symbol = (/*#__PURE__*/ Symbol('push-iterator'));\n\n/**\n * An iterable implementing push iteration protocol.\n *\n * @typeParam T - Iterated elements type.\n */\nexport interface PushIterable<T> extends Iterable<T> {\n\n  /**\n   * Creates a {@link PushIterator | push iterator} over elements of this iterable.\n   *\n   * @returns New push iterator instance.\n   */\n  [Symbol.iterator](): PushIterator<T>;\n\n  /**\n   * Iterates over elements of this push iterable.\n   *\n   * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n   * `true` or `false`.\n   *\n   * Calling this method with `accept` parameter is a faster alternative to creating a push iterator and iterating with\n   * it.\n   *\n   * Calling this method without arguments is the same as calling `[Symbol.iterator]()` one.\n   *\n   * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n   * `true` to suspend iteration, or `false` to stop it.\n   *\n   * @returns A push iterator instance to continue iteration with. If `accept` returned `false` then further iteration\n   * won't be possible with returned iterator.\n   */\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<T>): PushIterator<T>;\n\n}\n\nexport namespace PushIterable {\n\n  /**\n   * A signature of function conforming to push iteration protocol.\n   *\n   * Used as `PushIterable[PushIterator__symbol]` method implementation when passed to {@link makePushIterable}\n   * function.\n   *\n   * @typeParam T - Iterated elements type.\n   */\n  export type Iterate<T> =\n  /**\n   * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n   * `true` to suspend iteration, or `false` to stop it.\n   *\n   * @returns A push iterator instance to continue iteration with. If `accept` returned `false` then further iteration\n   * won't be possible with returned iterator.\n   */\n      (this: void, accept?: PushIterator.Acceptor<T>) => PushIterator<T>;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Checks whether the given iterable conforms to {@link PushIterable | push iteration protocol}.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to check.\n *\n * @returns `true` if the given `iterable` has a {@link PushIterator__symbol [PushIterator__symbol]} property,\n * or `false` otherwise.\n */\nexport function isPushIterable<T>(iterable: Iterable<T>): iterable is PushIterable<T>;\n\n/**\n * Checks whether the given iterator conforms to {@link PushIterable | push iteration protocol}.\n *\n * @typeParam T - Iterated elements type.\n * @param iterator - An iterator to check.\n *\n * @returns `true` if the given `iterator` has a {@link PushIterator__symbol | [PushIterator__symbol]} property,\n * or `false` otherwise.\n */\nexport function isPushIterable<T>(iterator: Iterator<T>): iterator is PushIterator<T>;\n\nexport function isPushIterable<T>(iterable: Iterable<T> | Iterator<T>): iterable is PushIterator<T> {\n  return !!(iterable as Partial<PushIterable<T>>)[PushIterator__symbol];\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a push iterator over elements of the given push `iterable`.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to construct iterator of.\n *\n * @returns Push iterator.\n */\nexport function iteratorOf<T>(iterable: PushIterable<T>): PushIterator<T>;\n\n/**\n * Creates an iterable iterator over elements of the given `iterable` supporting iterable iteration.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to construct iterator of.\n *\n * @returns Iterable iterator.\n */\nexport function iteratorOf<T>(iterable: { [Symbol.iterator](): IterableIterator<T> }): IterableIterator<T>;\n\n/**\n * Creates iterator over elements of the given `iterable`.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to construct iterator of.\n *\n * @returns Either push or raw iterator.\n */\nexport function iteratorOf<T>(iterable: Iterable<T>): Iterator<T>;\n\nexport function iteratorOf<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a push iterable implementation.\n *\n * @typeParam T - Iterated elements type.\n * @param iterate - A function iterating over iterable elements conforming to {@link PushIterable.Iterate} requirements.\n *\n * @returns New push iterable instance performing iteration by `forNext` function.\n */\nexport function makePushIterable<T>(iterate: PushIterable.Iterate<T>): PushIterable<T> {\n  return {\n    [Symbol.iterator]: PushIterable$iterator,\n    [PushIterator__symbol]: iterate,\n  };\n}\n\n/**\n * @internal\n */\nfunction PushIterable$iterator<T>(this: PushIterable<T>): PushIterator<T> {\n  return this[PushIterator__symbol]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `!iterable[PushIterator__symbol](accept).isOver()`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nexport function pushIterated<T>(iterable: PushIterable<T>, accept: PushIterator.Acceptor<T>): boolean {\n  return !iterable[PushIterator__symbol](accept).isOver();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { pushIterated } from './push-iterated';\n\n/**\n * Creates a push iterator implementation.\n *\n * @typeParam T - Iterated elements type.\n * @param forNext - A function iterating over elements conforming to push iteration protocol.\n *\n * @returns New push iterator instance performing iteration by `forNext` function.\n */\nexport function makePushIterator<T>(forNext: PushIterator.Pusher<T>): PushIterator<T> {\n\n  let over = false;\n  let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n    if (accept && !forNext(accept)) {\n      over = true;\n      iterate = PushIterator$dontIterate;\n    }\n  };\n\n  return {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](accept) {\n      iterate(accept);\n      return this;\n    },\n    next: PushIterator$next,\n    isOver: () => over,\n  };\n}\n\n/**\n * @internal\n */\nexport function PushIterator$iterator<T>(this: T): T {\n  return this;\n}\n\n/**\n * @internal\n */\nexport function PushIterator$next<T>(this: PushIterator<T>): IteratorResult<T> {\n  for (; ;) {\n\n    let result: IteratorYieldResult<T> | undefined;\n    const over = !pushIterated(\n        this,\n        value => {\n          result = { value };\n          return true;\n        },\n    );\n\n    if (result) {\n      return result;\n    }\n    if (over) {\n      return { done: true } as IteratorReturnResult<T>;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function PushIterator$noNext<T>(): IteratorReturnResult<T> {\n  return { done: true } as IteratorReturnResult<T>;\n}\n\n/**\n * @internal\n */\nexport function PushIterator$dontIterate<T>(\n    _accept?: PushIterator.Acceptor<T>, // unused parameter to prevent deoptimization\n): void {\n  /* do not iterate */\n}\n\n/**\n * @internal\n */\nexport const emptyPushIterator: PushIterator<any> & PushIterable<any> = {\n  [Symbol.iterator]: PushIterator$iterator,\n  [PushIterator__symbol](\n      _accept, // unused parameter to prevent deoptimization\n  ) {\n    return this;\n  },\n  next: () => ({ done: true } as IteratorReturnResult<unknown>),\n  isOver: () => true,\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over the head elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `iterable[PushIterator__symbol](accept)`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nexport function pushHead<T>(iterable: PushIterable<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  return iterable[PushIterator__symbol](accept);\n}\n","import type { PushIterable } from '../push-iterable';\nimport { iterateOverIndexed } from './iterate-over-indexed.impl';\n\n/**\n * @internal\n */\nexport function arrayElementOf<T>(array: ArrayLike<T>, index: number): T {\n  return array[index];\n}\n\n/**\n * @internal\n */\nexport function iterateOverArray<T>(array: ArrayLike<T>): PushIterable.Iterate<T> {\n  return iterateOverIndexed<ArrayLike<T>, T>(array, arrayElementOf);\n}\n","import type { IndexedItemList } from '../construction';\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport {\n  emptyPushIterator,\n  PushIterator$dontIterate,\n  PushIterator$iterator,\n  PushIterator$noNext,\n} from './make-push-iterator';\n\n/**\n * @internal\n */\nexport interface IndexedElements {\n\n  readonly length: number;\n\n}\n\n/**\n * @internal\n */\nexport function indexedItemOf<T>(indexed: IndexedItemList<T>, index: number): T {\n  return indexed.item(index) as T; // The index is always valid.\n}\n\n/**\n * @internal\n */\nexport function iterateOverIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementOf: (indexed: TIndexed, index: number) => T,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      if (i >= indexed.length) {\n        return false;\n      }\n      for (; ;) {\n\n        const goOn = accept(elementOf(indexed, i++));\n\n        if (i >= indexed.length || goOn === false) {\n          return false;\n        }\n        if (goOn === true) {\n          return true;\n        }\n      }\n    };\n\n    if (accept && !forNext(accept)) {\n      return emptyPushIterator;\n    }\n\n    let over = false;\n    let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n      if (accept && !forNext(accept)) {\n        over = true;\n        iterate = PushIterator$dontIterate;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        next = PushIterator$noNext;\n      }\n    };\n    let next = (): IteratorResult<T> => {\n      if (i < indexed.length) {\n        return { value: elementOf(indexed, i++) };\n      }\n\n      over = true;\n      iterate = PushIterator$dontIterate;\n      next = PushIterator$noNext;\n\n      return { done: true } as IteratorReturnResult<T>;\n    };\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        iterate(accept);\n        return this;\n      },\n      next: () => next(),\n      isOver: () => over,\n    };\n\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { iterateOverArray } from '../base/iterate-over-array.impl';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of array-like structure.\n *\n * @typeParam T - Array elements type.\n * @param array - An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns New push iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): PushIterable<T> {\n  return makePushIterable<T>(iterateOverArray(array));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushIterated} function, this one accepts any iterable instance.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nexport function itsIterated<T>(iterable: Iterable<T>, accept: PushIterator.Acceptor<T>): boolean {\n  if (isPushIterable(iterable)) {\n    return pushIterated(iterable, accept);\n  }\n\n  const it = iteratorOf(iterable);\n\n  if (isPushIterable(it)) {\n    return pushIterated(it, accept);\n  }\n\n  for (; ;) {\n\n    const next = it.next();\n\n    if (next.done) {\n      return false;\n    }\n\n    const status = accept(next.value);\n\n    if (typeof status === 'boolean') {\n      return status;\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable of elements to perform actions on.\n * @param action - An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  itsIterated(iterable, element => { action(element); });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * @internal\n */\nconst itsElements$defaultConverter = <T, TConv>(element: T): TConv => element as unknown as TConv;\n\n/**\n * Creates a new, shallow-copied array instance containing elements of the `source` iterable.\n *\n * Calling this function result to the same result as calling `Array.from(source)`, except it is optimized for\n * {@link PushIterable push iterables}.\n *\n * @typeParam T - Iterated elements type.\n * @param source - A source iterable to copy elements from.\n *\n * @returns New array of `source` elements.\n */\nexport function itsElements<T>(source: Iterable<T>): T[];\n\n/**\n * Creates a new, shallow-copied array instance containing elements of the `source` iterable converted by the given\n * converter function.\n *\n * Calling this function result to the same result as calling `Array.from(source, convert)`, except it is optimized for\n * {@link PushIterable push iterables}.\n *\n * @typeParam T - Iterated elements type.\n * @typeParam TConv - Resulting array elements type.\n * @param source - A source iterable to convert elements from.\n * @param convert - A function that produces an element of result array, taking element of `source` iterable as the only\n * parameter.\n *\n * @returns New array of elements converted from `source` ones.\n */\nexport function itsElements<T, TConv>(source: Iterable<T>, convert: (this: void, element: T) => TConv): TConv[];\n\nexport function itsElements<T, TConv>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => TConv = itsElements$defaultConverter,\n): TConv[] {\n  if (isPushIterable(source)) {\n    return pushedElements(source, convert);\n  }\n\n  const it = iteratorOf(source);\n\n  return isPushIterable(it) ? pushedElements(it, convert) : Array.from(source, convert);\n}\n\n/**\n * @internal\n */\nfunction pushedElements<T, TConv>(\n    it: PushIterable<T>,\n    convert: (this: void, element: T) => TConv,\n): TConv[] {\n\n  const result: TConv[] = [];\n\n  pushIterated(it, element => { result.push(convert(element)); });\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable - An iterable or push iterable to check for elements.\n *\n * @returns `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<unknown>): boolean {\n  if (isPushIterable(iterable)) {\n    return pushedEmpty(iterable);\n  }\n\n  const it = iteratorOf(iterable);\n\n  return isPushIterable(it) ? pushedEmpty(it) : !!it.next().done;\n}\n\n/**\n * @internal\n */\nfunction pushedEmpty(it: PushIterable<unknown>): boolean {\n\n  let isEmpty = true;\n\n  pushIterated(it, _element /* Unused parameter to prevent deoptimization */ => isEmpty = false);\n\n  return isEmpty;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Extracts the first element of the given `iterable`, if any.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to extract element from.\n *\n * @returns Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  if (isPushIterable(iterable)) {\n    return pushedFirst(iterable);\n  }\n\n  const it = iteratorOf(iterable);\n\n  return isPushIterable(it) ? pushedFirst(it) : rawFirst(it);\n}\n\n/**\n * @internal\n */\nfunction pushedFirst<T>(it: PushIterable<T>): T | undefined {\n\n  let first: T | undefined;\n\n  pushIterated(\n      it,\n      element => {\n        first = element;\n        return false;\n      },\n  );\n\n  return first;\n}\n\n/**\n * @internal\n */\nfunction rawFirst<T>(it: Iterator<T>): T | undefined {\n\n  const result = it.next();\n\n  return result.done ? undefined : result.value;\n}\n","import { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { PushIterator$dontIterate, PushIterator$iterator, PushIterator$noNext } from './make-push-iterator';\n\n/**\n * @internal\n */\nexport function toPushIterator<T>(it: Iterator<T>, forNext: PushIterator.Pusher<T>): PushIterator<T> {\n\n  let over = false;\n  let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n    if ((over = !!accept && !forNext(accept))) {\n      iterate = PushIterator$dontIterate;\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      next = PushIterator$noNext;\n    }\n  };\n  let next = (): IteratorResult<T> => {\n\n    const res = it.next();\n\n    if (res.done) {\n      over = true;\n      iterate = PushIterator$dontIterate;\n      next = PushIterator$noNext;\n    }\n\n    return res;\n  };\n\n  return {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](accept) {\n      iterate(accept);\n      return this;\n    },\n    next() {\n      return next();\n    },\n    isOver: () => over,\n  };\n}\n\n/**\n * @internal\n */\nexport function rawIteratorPusher<T>(it: Iterator<T>): PushIterator.Pusher<T> {\n  return accept => {\n    for (; ;) {\n\n      const res = it.next();\n\n      if (res.done) {\n        return false;\n      }\n\n      const status = accept(res.value);\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, pushHead } from '../base';\nimport { iterateOverArray } from '../base/iterate-over-array.impl';\nimport { emptyPushIterator } from '../base/make-push-iterator';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushHead} function, this one accepts any iterable instance.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nexport function itsHead<T>(iterable: Iterable<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  if (isPushIterable(iterable)) {\n    return pushHead(iterable, accept);\n  }\n  if (Array.isArray(iterable)) {\n    return arrayHead(iterable, accept);\n  }\n  return rawIterableHead(iterable, accept);\n}\n\n/**\n * @internal\n */\nfunction arrayHead<T>(array: ArrayLike<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  return array.length ? iterateOverArray(array)(accept) : emptyPushIterator;\n}\n\n/**\n * @internal\n */\nfunction rawIterableHead<T>(\n    iterable: Iterable<T>,\n    accept: PushIterator.Acceptor<T>,\n): PushIterator<T> {\n\n  const it = iteratorOf(iterable);\n\n  if (isPushIterable(it)) {\n    return pushHead(it, accept);\n  }\n\n  const forEach = rawIteratorPusher(it);\n\n  return forEach(accept) ? toPushIterator(it, forEach) : emptyPushIterator;\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf } from '../base';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable or push iterable to iterate over.\n *\n * @returns A push iterator iterating over the given iterable.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): PushIterator<T> {\n\n  const it = iteratorOf(iterable);\n\n  return isPushIterable(it) ? it : toPushIterator(it, rawIteratorPusher(it));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeParam T - Iterated elements type.\n * @typeParam TResult - A type of reduced value.\n * @param iterable - An iterable to reduce values of.\n * @param reducer - A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue - Initial value passed to the first `reducer` call.\n *\n * @returns Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, TResult>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: TResult, element: T) => TResult,\n    initialValue: TResult,\n): TResult {\n\n  let reduced = initialValue;\n\n  itsIterated(iterable, element => { reduced = reducer(reduced, element); });\n\n  return reduced;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { emptyPushIterator } from '../base/make-push-iterator';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Returns a {@link PushIterator | push iterable iterator} without elements.\n *\n * @typeParam T - Iterated elements type.\n *\n * @returns Empty push iterable and push iterator instance.\n */\nexport function overNone<T>(): PushIterable<T> & PushIterator<T> {\n  return emptyPushIterator;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, makePushIterable } from '../base';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of iterator created by the given function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterate - A function creating new iterator.\n *\n * @returns New push iterable over elements of created iterator.\n */\nexport function overIterator<T>(iterate: (this: void) => Iterator<T>): PushIterable<T> {\n  return makePushIterable(iterateOverRawIterator(iterate));\n}\n\n/**\n * @internal\n */\nfunction iterateOverRawIterator<T>(iterate: (this: void) => Iterator<T>): PushIterable.Iterate<T> {\n  return accept => {\n\n    const it = iterate();\n\n    if (isPushIterable(it)) {\n      return it[PushIterator__symbol](accept);\n    }\n\n    const forNext = rawIteratorPusher(it);\n\n    return accept && !forNext(accept) ? overNone() : toPushIterator(it, forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable, makePushIterator } from '../base';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { overIterable } from './over-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of other iterables.\n *\n * @typeParam T - Iterated elements type.\n * @param sources - Source iterables to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `sources`.\n */\nexport function overElementsOf<T>(...sources: readonly Iterable<T>[]): PushIterable<T> {\n  return sources.length > 1\n      ? makePushIterable(iterateOverSubElements(sources))\n      : (sources.length\n          ? overIterable(sources[0])\n          : overNone());\n}\n\n/**\n * @internal\n */\nfunction iterateOverSubElements<T>(sources: readonly Iterable<T>[]): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    let src: Iterable<T> = sources[0];\n\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      for (; ;) {\n\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        let status: boolean | void;\n        const srcTail = itsHead(src, element => status = accept(element));\n\n        if (srcTail.isOver()) {\n          if (++i >= sources.length) {\n            return false;\n          }\n\n          src = sources[i];\n        } else {\n          src = srcTail;\n        }\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    };\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { iteratorOf } from '../base';\nimport type { PushIterable } from '../push-iterable';\nimport { overArray } from './over-array';\nimport { overIterator } from './over-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of the given raw iterable.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `iterable`.\n */\nexport function overIterable<T>(iterable: Iterable<T>): PushIterable<T> {\n  return Array.isArray(iterable)\n      ? overArray<T>(iterable)\n      : overIterator(() => iteratorOf(iterable));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { PushIterator$iterator } from '../base/make-push-iterator';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over one value.\n *\n * @typeParam T - Iterated element value type.\n * @param value - A value to iterate over.\n *\n * @returns New push iterable over the given value.\n */\nexport function overOne<T>(value: T): PushIterable<T> {\n  return makePushIterable(iterateOverOneValue(value));\n}\n\n/**\n * @internal\n */\nfunction iterateOverOneValue<T>(value: T): PushIterable.Iterate<T> {\n  return accept => {\n    if (accept) {\n      accept(value);\n      return overNone();\n    }\n\n    let over = false;\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        if (over) {\n          return overNone();\n        }\n        if (accept) {\n          over = true;\n          accept(value);\n          return overNone();\n        }\n        return this;\n      },\n      next() {\n        if (over) {\n          return { done: over } as IteratorReturnResult<undefined>;\n        }\n\n        over = true;\n\n        return { value };\n      },\n      isOver: () => over,\n    };\n\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { overArray } from '../construction';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable | push iterable} over keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam TObj - Source object type.\n * @param source - An object to select keys from.\n *\n * @returns New push iterable over own object keys retrieved by `Reflect.ownKeys()`.\n */\nexport function overKeys<TObj extends object>(source: TObj): PushIterable<keyof TObj> {\n  return overArray(Reflect.ownKeys(source) as (keyof TObj)[]);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport { arrayElementOf } from '../base/iterate-over-array.impl';\nimport type { PushIterable } from '../push-iterable';\nimport { iterateOverFilteredIndexed } from './iterate-over-filtered-indexed.impl';\n\n/**\n * Creates a {@link PushIterable push iterable} with all `array` elements extending the given type.\n *\n * @typeParam T - A type of array elements.\n * @typeParam TTarget - Target type.\n * @param array - A source array.\n * @param test - A predicate function to test that element extends the type `TTarget`. Returns `true` to keep the\n * element, or `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterArray<T, TTarget extends T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => element is TTarget,\n): PushIterable<TTarget>;\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `array` elements that pass the test implemented by\n * the provided function.\n *\n * @typeParam T - A type of array elements.\n * @param array - A source array.\n * @param test - A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T>;\n\nexport function filterArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T> {\n  return makePushIterable(iterateOverFilteredIndexed(array, arrayElementOf, test));\n}\n","import type { IndexedElements } from '../base/iterate-over-indexed.impl';\nimport { PushIterator$dontIterate, PushIterator$iterator, PushIterator$noNext } from '../base/make-push-iterator';\nimport { overNone } from '../construction';\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * @internal\n */\nexport function iterateOverFilteredIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementOf: (indexed: TIndexed, index: number) => T,\n    test: (this: void, element: T) => boolean,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      for (; ;) {\n        if (i >= indexed.length) {\n          return false;\n        }\n\n        const value = elementOf(indexed, i++);\n\n        if (test(value)) {\n\n          const status = accept(value);\n\n          if (typeof status === 'boolean') {\n            return status;\n          }\n        }\n      }\n    };\n\n    if (accept && !forNext(accept)) {\n      return overNone();\n    }\n\n    let over = false;\n    let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n      if (accept && !forNext(accept)) {\n        over = true;\n        iterate = PushIterator$dontIterate;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        next = PushIterator$noNext;\n      }\n    };\n    let next = (): IteratorResult<T> => {\n      for (; ;) {\n        if (i >= indexed.length) {\n          over = true;\n          iterate = PushIterator$dontIterate;\n          next = PushIterator$noNext;\n          return { done: true } as IteratorReturnResult<T>;\n        }\n\n        const value = elementOf(indexed, i++);\n\n        if (test(value)) {\n          return { value };\n        }\n      }\n    };\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        iterate(accept);\n        return this;\n      },\n      next: () => next(),\n      isOver: () => over,\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `source` iterable elements extending the given type.\n *\n * @typeParam T - A type of source elements.\n * @typeParam TTarget - Target type.\n * @param source - A source iterable.\n * @param test - A predicate function to test that element extends the type `TTarget`. Returns `true` to keep the\n * element, or`false` otherwise. It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterIt<T, TTarget extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is TTarget,\n): PushIterable<TTarget>;\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `source` iterable elements that pass the test implemented by\n * the provided function.\n *\n * @typeParam T - A type of source elements.\n * @param source - A source iterable.\n * @param test - A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T>;\n\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? filterPusher(source, test) : filterRawPusher(source, test);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction filterPusher<T>(\n    source: PushIterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterator.Pusher<T> {\n  return accept => {\n\n    const tail = pushHead(\n        source,\n        element => {\n          if (test(element)) {\n            return accept(element);\n          }\n          return;\n        },\n    );\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction filterRawPusher<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterator.Pusher<T> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return filterPusher(it, test);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const value = next.value;\n\n      if (test(value)) {\n\n        const status = accept(value);\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { makePushIterable } from '../base';\nimport type { PushIterable } from '../push-iterable';\nimport { iterateOverFlattenedIndexed } from './iterate-over-flattened-indexed.impl';\n\n/**\n * Flattens the source `array` of iterables into new {@link PushIterable | push iterable}.\n *\n * Calling this function is the same as calling `flatMapArray(source, element => element)`.\n *\n * @typeParam T - A type of converted elements.\n * @param array - A source array-like instance of iterables.\n *\n * @returns New push iterable with each element of `array` being flattened.\n */\nexport function flatMapArray<T>(array: ArrayLike<Iterable<T>>): PushIterable<T>;\n\n/**\n * First maps each element of the source `array` using a mapping function, then flattens the result into new\n * {@link PushIterable | push iterable}.\n *\n * @typeParam TSrc - A type of array elements.\n * @typeParam TConv - A type of converted elements.\n * @param array - A source array-like instance of elements to convert.\n * @param convert - A function that produces new iterable, taking array element as the only parameter.\n *\n * @returns New push iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapArray<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv>;\n\nexport function flatMapArray<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    convert?: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv> {\n  return makePushIterable(iterateOverFlattenedIndexed<ArrayLike<TSrc>, TConv>(\n      array,\n      convert\n          ? (array, index) => convert(array[index])\n          : flatMapArray$defaultElementOf,\n  ));\n}\n\n/**\n * @internal\n */\nfunction flatMapArray$defaultElementOf<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    index: number,\n): Iterable<TConv> {\n  return array[index] as unknown as Iterable<TConv>;\n}\n\n","import { makePushIterator } from '../base';\nimport type { IndexedElements } from '../base/iterate-over-indexed.impl';\nimport { overNone } from '../construction';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * @internal\n */\nexport function iterateOverFlattenedIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementsOf: (indexed: TIndexed, index: number) => Iterable<T>,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    let subs: Iterable<T> | undefined;\n\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      if (i >= indexed.length) {\n        return false;\n      }\n      if (!subs) {\n        subs = elementsOf(indexed, i);\n      }\n\n      for (; ;) {\n\n        let status: boolean | void;\n        const subsTail: PushIterator<T> = itsHead<T>(subs, element => status = accept(element));\n\n        if (subsTail.isOver()) {\n          if (++i >= indexed.length) {\n            return false;\n          }\n          subs = elementsOf(indexed, i);\n        } else {\n          subs = subsTail;\n        }\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    };\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Flattens the source iterable of iterables into new {@link PushIterable | push iterable}.\n *\n * Calling this function is the same as calling `flatMapIt(source, element => element)`.\n *\n * @typeParam T - A type of converted elements.\n * @param source - A source iterable of iterables.\n *\n * @returns New push iterable with each element of `source` being flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): PushIterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into new\n * {@link PushIterable | push iterable}.\n *\n * @typeParam TSrc - A type of source elements.\n * @typeParam TConv - A type of converted elements.\n * @param source - A source iterable of elements to convert.\n * @param convert - A function that produces new iterable, taking the source element as the only parameter.\n *\n * @returns New push iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv>;\n\nexport function flatMapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv> = flatMapIt$defaultConverter,\n): PushIterable<TConv> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? flatMapPusher(source, convert) : flatMapRawPusher(source, convert);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction flatMapPusher<TSrc, TConv>(\n    source: PushIterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterator.Pusher<TConv> {\n\n  let subs: Iterable<TConv> | undefined;\n  let lastSrc = false;\n\n  return accept => {\n    for (; ;) {\n      while (!subs) {\n\n        const sourceTail = pushHead(source, src => {\n          subs = convert(src);\n          return true;\n        });\n\n        source = sourceTail;\n\n        if (sourceTail.isOver()) {\n          if (!subs) {\n            return false;\n          }\n          lastSrc = true;\n        }\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n      let status: boolean | void;\n      const subsTail: PushIterator<TConv> = itsHead(subs, element => status = accept(element));\n\n      if (subsTail.isOver()) {\n        subs = undefined;\n        if (lastSrc) {\n          return false;\n        }\n      } else {\n        subs = subsTail;\n      }\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n\n/**\n * @internal\n */\nfunction flatMapRawPusher<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterator.Pusher<TConv> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return flatMapPusher(it, convert);\n  }\n\n  let subs: Iterable<TConv> | undefined;\n\n  return accept => {\n    for (; ;) {\n      if (!subs) {\n\n        const next = it.next();\n\n        if (next.done) {\n          return false;\n        }\n\n        subs = convert(next.value);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n      let status: boolean | void;\n      const subsTail: PushIterator<TConv> = itsHead(subs, element => status = accept(element));\n\n      subs = subsTail.isOver() ? undefined : subsTail;\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n\n/**\n * @internal\n */\nfunction flatMapIt$defaultConverter<T, TConv>(\n    element: T,\n): Iterable<TConv> {\n  return element as unknown as Iterable<TConv>;\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} with the results of calling a provided function on every element\n * of the `source` iterable.\n *\n * @typeParam TSrc - A type of source elements.\n * @typeParam TConv - A type of converted elements.\n * @param source - A source iterable.\n * @param convert - A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n *\n * @returns New push iterable of transformed elements.\n */\nexport function mapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterable<TConv> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? mapPusher(source, convert) : mapRawPusher(source, convert);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction mapPusher<TSrc, TConv>(\n    source: PushIterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterator.Pusher<TConv> {\n  return accept => {\n\n    const tail = pushHead(source, element => accept(convert(element)));\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction mapRawPusher<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterator.Pusher<TConv> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return mapPusher(it, convert);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const status = accept(convert(next.value));\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} with the values of elements of the `source` iterable.\n *\n * Element value is the result of provided function call, except `false`, `null`, and `undefined` which are filtered\n * out.\n *\n * This can be used as a more effective {@link mapIt} / {@link filterIt} combination.\n *\n * @typeParam T - A type of source elements.\n * @typeParam TValue - A type of source element values.\n * @param source - A source iterable.\n * @param valueOf - A function that values elements, taking the source element as the only parameter, and returning\n * either its value, or `false`/`null`/`undefined` to filter it out.\n *\n * @returns New push iterable with the element values.\n */\nexport function valueIt<T, TValue>(\n    source: Iterable<T>,\n    valueOf: (this: void, element: T) => TValue | false | null | undefined,\n): PushIterable<TValue> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? valuePusher(source, valueOf) : valueRawPusher(source, valueOf);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction valuePusher<T, TValue>(\n    source: PushIterable<T>,\n    valueOf: (this: void, element: T) => TValue | false | null | undefined,\n): PushIterator.Pusher<TValue> {\n  return accept => {\n\n    const tail = pushHead(\n        source,\n        element => {\n\n          const value = valueOf(element);\n\n          if (value != null && value !== false) {\n            return accept(value);\n          }\n          return;\n        },\n    );\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction valueRawPusher<T, TValue>(\n    source: Iterable<T>,\n    valueOf: (this: void, element: T) => TValue | false | null | undefined,\n): PushIterator.Pusher<TValue> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return valuePusher(it, valueOf);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const value = valueOf(next.value);\n\n      if (value != null && value !== false) {\n\n        const status = accept(value);\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport type { PushIterable } from '../push-iterable';\nimport { mapIt } from '../transformation';\nimport type { ObjectEntry } from './object-entry';\nimport { overKeys } from './over-keys';\n\n/**\n * Creates a {@link PushIterable | push iterable} over the property key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam TObj - Object type.\n *\n * @param source - An object to select keys and values from.\n *\n * @returns New push iterable of object property entries.\n */\nexport function overEntries<TObj extends object>(source: TObj): PushIterable<ObjectEntry<TObj>> {\n  return mapIt(\n      overKeys(source),\n      key => [key, source[key]],\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { ContextRef } from './context-ref';\nimport type { ContextRegistry } from './context-registry';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [ContextKey] instance.\n */\nexport const ContextKey__symbol = (/*#__PURE__*/ Symbol('context-key'));\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by {@link ContextKey.grow} method.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextKey<TValue, TSrc = TValue, TSeed = unknown> implements ContextRef<TValue, TSrc> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same {@link seedKey} to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<TSrc, TSeed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name - Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @param slot - Context value slot to insert the value to.\n   */\n  abstract grow(slot: ContextValueSlot<TValue, TSrc, TSeed>): void;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value slot to put the grown value into.\n *\n * An instance of the value slot is passed to {@link ContextKey.grow} method to provide the necessary context\n * and optionally accept a new value.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport type ContextValueSlot<TValue, TSrc, TSeed> =\n    | ContextValueSlot.WithFallback<TValue, TSrc, TSeed>\n    | ContextValueSlot.WithoutFallback<TValue, TSrc, TSeed>;\n\nexport namespace ContextValueSlot {\n\n  /**\n   * Base context value slot interface.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Target context.\n     */\n    readonly context: ContextValues;\n\n    /**\n     * A key to associated value with.\n     */\n    readonly key: ContextKey<TValue, TSrc, TSeed>;\n\n    /**\n     * Context value seeder.\n     */\n    readonly seeder: ContextSeeder<ContextValues, TSrc, TSeed>;\n\n    /**\n     * Context value seed.\n     */\n    readonly seed: TSeed;\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     */\n    readonly hasFallback: boolean;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     *\n     * Always `undefined` when {@link hasFallback there is no fallback}.\n     */\n    readonly or: TValue | null | undefined;\n\n    /**\n     * Insert the value into the slot.\n     *\n     * The value will be associated with key after {@link ContextKey.grow} method exit.\n     *\n     * Supersedes a previously inserted value.\n     *\n     * @param value - A value to associate with the key, or `null`/`undefined` to not associate any value.\n     */\n    insert(value: TValue | null | undefined): void;\n\n    /**\n     * Fills this slot by the given function.\n     *\n     * @param grow - A function accepting a value slot as its only parameter.\n     *\n     * @returns A value associated with target key by the given function, or `null`/`undefined` when no value\n     * associated.\n     */\n    fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined;\n\n    /**\n     * Registers a setup procedure issued when context value associated with target key.\n     *\n     * Setup will be issued at most once per context. Setup won't be issued if no value {@link insert inserted}.\n     *\n     * @param setup - Context value setup procedure.\n     */\n    setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void;\n\n  }\n\n  /**\n   * Base context value slot with fallback value.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface WithFallback<TValue, TSrc, TSeed> extends Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `true`\n     */\n    readonly hasFallback: true;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Can be `null` or `undefined`.\n     */\n    readonly or: TValue | null | undefined;\n\n  }\n\n  export interface WithoutFallback<TValue, TSrc, TSeed> extends Base<TValue, TSrc, TSeed> {\n\n    /**\n     * Whether a {@link ContextRequest.Opts.or fallback} value has been specified.\n     *\n     * Always `false`\n     */\n    readonly hasFallback: false;\n\n    /**\n     * A {@link ContextRequest.Opts.or fallback} value that will be used unless another one {@link insert inserted} into\n     * this slot.\n     *\n     * Always `undefined`.\n     */\n    readonly or: undefined;\n\n  }\n\n}\n\n/**\n * Context value setup procedure signature.\n *\n * A function with this signature can be passed to {@link ContextValueSlot.Base.setup} method to be issued when\n * the value associated with target key.\n */\nexport type ContextValueSetup<TValue, TSrc, TSeed> =\n/**\n * @param key - A key the value associated with.\n * @param context - Target context the value associated with.\n * @param registry - A registry of context value providers. This context is shared among all contexts\n * {@link ContextRegistry.newValues created} by it.\n */\n    (\n        this: void,\n        {\n          key,\n          context,\n          registry,\n        }: {\n          key: ContextKey<TValue, TSrc, TSeed>;\n          context: ContextValues;\n          registry: ContextRegistry;\n        }\n    ) => void;\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TKey - Context key type.\n */\nexport type ContextKeyDefault<TValue, TKey extends ContextKey<unknown, unknown>> =\n/**\n * @param context - Target context.\n * @param key - Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: TKey) => TValue | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextSeedKey<TSrc, TSeed> extends ContextKey<TSeed, TSrc, TSeed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key - A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<unknown, TSrc>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeParam TCtx - Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc, TSeed>;\n\n  grow(opts: ContextValueSlot<TSeed, TSrc, TSeed>): void {\n\n    const { seeder, seed } = opts;\n\n    if (!seeder.isEmpty(seed)) {\n      opts.insert(seed);\n    } else if (!opts.hasFallback) {\n      opts.insert(seed);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key - Missing value key.\n   * @param message - Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","import type { ContextKey, ContextSeedKey } from './context-key';\nimport type { ContextSeeder, ContextSeeds } from './context-seeder';\nimport type { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nexport type SeedIssuer<TCtx extends ContextValues, TSrc, TSeed> = readonly [\n  seeder: ContextSeeder<TCtx, TSrc, TSeed>,\n  factory: (this: void, context: TCtx) => TSeed,\n];\n\n/**\n * @internal\n */\nexport class ContextSeeders<TCtx extends ContextValues> {\n\n  private readonly _issuers = new Map<ContextSeedKey<any, any>, SeedIssuer<TCtx, any, any>>();\n\n  constructor(private readonly _initial: ContextSeeds<TCtx>) {\n  }\n\n  issuer<TSrc, TSeed>(seedKey: ContextSeedKey<TSrc, TSeed>): SeedIssuer<TCtx, TSrc, TSeed> {\n\n    const found: SeedIssuer<TCtx, TSrc, TSeed> | undefined = this._issuers.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<TCtx, TSrc, TSeed> = seedKey.seeder();\n    const issuer: SeedIssuer<TCtx, TSrc, TSeed> = [\n      seeder,\n      context => seeder.seed(context, this._initial(seedKey, context)),\n    ];\n\n    this._issuers.set(seedKey, issuer);\n\n    return issuer;\n  }\n\n  newSeed<TSrc, TSeed>(\n      context: TCtx,\n      key: ContextKey<any, TSrc, TSeed>,\n  ): readonly [seeder: ContextSeeder<TCtx, TSrc, TSeed>, seed: TSeed] {\n\n    const { seedKey } = key;\n    const [seeder, factory] = this.issuer(seedKey);\n\n    if (seedKey !== key as any) {\n      // This is not a seed key\n      // Retrieve the seed by seed key\n      return [seeder, context.get(seedKey)];\n    }\n\n    return [seeder, factory(context)];\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valueProvider } from '@proc7ts/primitives';\nimport type { ContextRequest, ContextTarget } from './context-ref';\nimport type { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TSrc - Source value type.\n */\nexport type ContextValueProvider<TCtx extends ContextValues, TSrc> =\n/**\n * @param context - Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: TCtx) => TSrc | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TDeps - Dependencies tuple type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport type ContextValueSpec<\n    TCtx extends ContextValues,\n    TValue,\n    TDeps extends any[] = unknown[],\n    TSrc = TValue,\n    TSeed = unknown> =\n    | ContextValueSpec.IsConstant<TSrc, TSeed>\n    | ContextValueSpec.ViaAlias<TSrc, TSeed>\n    | ContextValueSpec.ByProvider<TCtx, TSrc, TSeed>\n    | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>\n    | ContextValueSpec.AsInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>\n    | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface IsConstant<TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Constant context value.\n     */\n    is: TSrc;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface ViaAlias<TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<TSrc, TSeed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface ByProvider<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<TCtx, TSrc>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface ByProviderWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: TDeps) => TSrc | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface AsInstance<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: TCtx) => TSrc;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface SelfInstance<TCtx extends ContextValues, TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc, TSeed> & (new (context: TCtx) => TSrc);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface AsInstanceWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc, TSeed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: TDeps) => TSrc;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   */\n  export interface SelfInstanceWithDeps<TDeps extends any[], TSrc, TSeed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc, TSeed> & (new (...args: TDeps) => TSrc);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export type DepsRequests<TDeps extends any[]> = {\n    [K in keyof TDeps]: ContextRequest<TDeps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TDeps - Dependencies tuple type.\n * @typeParam TSrc - Source value type.\n * @param spec - Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<TCtx extends ContextValues, TValue, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, TValue, TDeps, TSrc, TSeed>,\n): ContextValueSpec.ByProvider<TCtx, TSrc, TSeed> {\n  if (byProvider(spec)) {\n    if (!withDeps<TCtx, TDeps, TSrc, TSeed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: TCtx) {\n        return by(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n  if (isConstant<TSrc, TSeed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: TCtx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<TCtx, TDeps, TSrc, TSeed>(spec)) {\n    if (selfInstance<TCtx, TDeps, TSrc, TSeed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<TCtx, TDeps, TSrc, TSeed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: TCtx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: TCtx) {\n        return new DepType(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.ByProvider<TCtx, TSrc, TSeed>\n    | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.AsInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): spec is\n    | ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed>\n    | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.SelfInstance<TCtx, TSrc, TSeed> | ContextValueSpec.SelfInstanceWithDeps<TDeps, TSrc, TSeed>,\n): ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<TSrc, TSeed>(\n    spec: ContextValueSpec<any, unknown, any, TSrc, TSeed>,\n): spec is ContextValueSpec.IsConstant<TSrc, TSeed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<TSrc, TSeed>(\n    spec: ContextValueSpec<any, unknown, any, TSrc, TSeed>,\n): spec is ContextValueSpec.ViaAlias<TSrc, TSeed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.ByProvider<TCtx, TSrc, TSeed> | ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>,\n): spec is ContextValueSpec.ByProviderWithDeps<TDeps, TSrc, TSeed>;\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec.AsInstance<TCtx, TSrc, TSeed> | ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<TDeps, TSrc, TSeed>;\n\n/**\n * @internal\n */\nfunction withDeps<TCtx extends ContextValues, TDeps extends any[], TSrc, TSeed>(\n    spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrNull<TValue>): TValue | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrUndefined<TValue>): TValue | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts?: ContextRequest.OrFallback<TValue>): TValue;\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport { ContextKey, ContextKey__symbol, ContextValueSetup, ContextValueSlot } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport type { ContextRef, ContextRequest } from './context-ref';\nimport type { ContextRegistry } from './context-registry';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextSeeders } from './context-seeders.impl';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nexport function newContextValues<TCtx extends ContextValues>(\n    registry: ContextRegistry<TCtx>,\n    seedRegistry: ContextSeeders<TCtx>,\n): ContextValues {\n\n  const values = new Map<ContextKey<any>, any>();\n\n  class ContextValues$ extends ContextValues {\n\n    get<TValue, TSrc>(\n        this: TCtx,\n        { [ContextKey__symbol]: key }: ContextRef<TValue, TSrc>,\n        opts?: ContextRequest.Opts<TValue>,\n    ): TValue | null | undefined {\n\n      const cached = values.get(key);\n\n      if (cached != null) {\n        return cached;\n      }\n\n      const [constructed, setup] = new ContextValueSlot$(seedRegistry, this, key, opts)._grow();\n\n      if (setup) {\n        values.set(key, constructed);\n        setup({\n          key,\n          context: this,\n          registry: registry as ContextRegistry<any>,\n        });\n      }\n\n      return constructed;\n    }\n\n  }\n\n  return new ContextValues$();\n}\n\n/**\n * @internal\n */\nclass ContextValueSlot$<TCtx extends ContextValues, TValue, TSrc, TSeed>\n    implements ContextValueSlot.Base<TValue, TSrc, TSeed> {\n\n  readonly hasFallback: boolean;\n  readonly seeder: ContextSeeder<TCtx, TSrc, TSeed>;\n  readonly seed: TSeed;\n  private _constructed: TValue | null | undefined = null;\n  private _setup: ContextValueSetup<TValue, TSrc, TSeed> = noop;\n\n  constructor(\n      registry: ContextSeeders<TCtx>,\n      readonly context: TCtx,\n      readonly key: ContextKey<TValue, TSrc, TSeed>,\n      private readonly _opts: ContextRequest.Opts<TValue> = {},\n  ) {\n\n    const [seeder, seed] = registry.newSeed<TSrc, TSeed>(context, key);\n\n    this.seeder = seeder;\n    this.seed = seed;\n    this.hasFallback = 'or' in _opts;\n  }\n\n  get or(): TValue | null | undefined {\n    return this._opts.or;\n  }\n\n  insert(value: TValue | null | undefined): void {\n    this._constructed = value;\n  }\n\n  fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined {\n    grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n    return this._constructed;\n  }\n\n  setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void {\n\n    const prevSetup = this._setup;\n\n    this._setup = opts => {\n      prevSetup(opts);\n      setup(opts);\n    };\n  }\n\n  _grow(): readonly [value: TValue | null | undefined, setup?: ContextValueSetup<TValue, TSrc, TSeed>] {\n    this.key.grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n\n    if (this._constructed != null) {\n      return [this._constructed, this._setup];\n    }\n    if (!this.hasFallback) {\n      throw new ContextKeyError(this.key);\n    }\n\n    return [this.or];\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { ContextKey__symbol, ContextSeedKey } from './context-key';\nimport type { ContextSeeds } from './context-seeder';\nimport { ContextSeeders } from './context-seeders.impl';\nimport { ContextValueSpec, contextValueSpec } from './context-value-spec';\nimport type { ContextValues } from './context-values';\nimport { newContextValues } from './context-values.impl';\n\n/**\n * A registry of context value providers.\n *\n * @typeParam TCtx - Context type.\n */\nexport class ContextRegistry<TCtx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _seeders: ContextSeeders<TCtx>;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial - An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<TCtx> | ContextValues) {\n    this._seeders = new ContextSeeders<TCtx>(\n        initial\n            ? (typeof initial === 'function' ? initial : (seedKey => initial.get(seedKey)))\n            : noop,\n    );\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   * @param spec - Context value specifier.\n   *\n   * @returns Provider supply instance that removes just added context value provider once cut off.\n   */\n  provide<TDeps extends any[], TSrc, TSeed>(spec: ContextValueSpec<TCtx, unknown, TDeps, TSrc, TSeed>): Supply {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeders.issuer<TSrc, TSeed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context - Target context.\n   * @param key - Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<TSrc, TSeed>(context: TCtx, key: ContextSeedKey<TSrc, TSeed>): TSeed {\n\n    const [, factory] = this._seeders.issuer(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider originated from this registry.\n   *\n   * @returns Mandatory context seeds provider.\n   */\n  seeds(): ContextSeeds.Mandatory<TCtx> {\n    return (seedKey, context) => this.seed(context, seedKey);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context - Target value context.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: TCtx): ContextSeeds.Headless {\n    return this.newValues().get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(): ContextValues {\n    return newContextValues(this, this._seeders);\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other - Another context value registry or context seeds provider.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<TCtx> | ContextSeeds<TCtx>): ContextRegistry<TCtx> {\n\n    const otherSeeds: ContextSeeds<TCtx> = typeof other === 'function' ? other : other.seeds();\n\n    return new ContextRegistry(<TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>, context: TCtx) => {\n\n      const second = otherSeeds(key, context);\n      const [seeder, factory] = this._seeders.issuer(key);\n      const first = factory(context);\n\n      return second ? seeder.combine(first, second, context) : first;\n    });\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { lazyValue, noop, Supply } from '@proc7ts/primitives';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextValueProvider } from './context-value-spec';\nimport type { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  private readonly _providers: (readonly [ContextValueProvider<TCtx, TSrc>])[] = [];\n\n  provide(provider: ContextValueProvider<TCtx, TSrc>): Supply {\n\n    // Ensure the same provider may be registered multiple times\n    const entry: readonly [ContextValueProvider<TCtx, TSrc>] = [provider];\n\n    this._providers.unshift(entry);\n\n    return new Supply(() => this._providers.splice(this._providers.lastIndexOf(entry), 1));\n  }\n\n  seed(context: TCtx, initial?: SimpleContextKey.Seed<TSrc>): SimpleContextKey.Seed<TSrc> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (\n        [provider]: readonly [ContextValueProvider<TCtx, TSrc>],\n    ): SimpleContextKey.Seed<TSrc> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<TSrc>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<TSrc>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<TSrc>,\n      second: SimpleContextKey.Seed<TSrc>,\n  ): SimpleContextKey.Seed<TSrc> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<TSrc>(\n    seeds: readonly SimpleContextKey.Seed<TSrc>[],\n): SimpleContextKey.Seed<TSrc> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<TSrc> extends ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): SimpleContextSeeder<TCtx, TSrc> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class SimpleContextKey<TValue, TSrc = TValue>\n    extends ContextKey<TValue, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeParam TSrc - Source vale type.\n   */\n  export type Seed<TSrc> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when when absent.\n   */\n      (this: void) => TSrc | null | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport type { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport type { ContextValueSlot } from './context-key';\nimport type { ContextRef } from './context-ref';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Context values supply.\n *\n * When available as context value, it is used to indicate the context is no longer used (e.g. destroyed).\n *\n * A context value provider can destroy the value it provides when this supply is cut off.\n */\nexport type ContextSupply = Supply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow(\n      slot: ContextValueSlot<ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): void {\n    slot.insert(\n        slot.seed()\n        || (slot.hasFallback ? slot.or : null)\n        || (slot.context as Partial<SupplyPeer>).supply,\n    );\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is not guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `SupplyPeer` interface.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { lazyValue, Supply } from '@proc7ts/primitives';\nimport {\n  itsElements,\n  itsEmpty,\n  overElementsOf,\n  overIterator,\n  overNone,\n  PushIterable,\n  valueIt,\n} from '@proc7ts/push-iterator';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextValueProvider } from './context-value-spec';\nimport type { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass IterativeContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, PushIterable<TSrc>> {\n\n  private readonly _providers = new Map<Supply, ContextValueProvider<TCtx, TSrc>>();\n\n  provide(provider: ContextValueProvider<TCtx, TSrc>): Supply {\n\n    const supply = new Supply();\n\n    this._providers.set(supply, provider);\n\n    return supply.whenOff(() => this._providers.delete(supply));\n  }\n\n  seed(context: TCtx, initial: Iterable<TSrc> = overNone()): PushIterable<TSrc> {\n    return overElementsOf(\n        initial,\n        iterativeSeed(context, this._providers),\n    );\n  }\n\n  isEmpty(seed: Iterable<TSrc>): boolean {\n    return itsEmpty(seed);\n  }\n\n  combine(first: Iterable<TSrc>, second: Iterable<TSrc>): PushIterable<TSrc> {\n    return overElementsOf(first, second);\n  }\n\n}\n\n/**\n * @internal\n */\nclass IterativeSeedKey<TSrc> extends ContextSeedKey<TSrc, PushIterable<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): IterativeContextSeeder<TCtx, TSrc> {\n    return new IterativeContextSeeder();\n  }\n\n}\n\n/**\n * Iterative context value key implementation.\n *\n * Collects value sources as iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class IterativeContextKey<TValue, TSrc = TValue> extends ContextKey<TValue, TSrc, Iterable<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, Iterable<TSrc>>;\n\n  /**\n   * Constructs iterative context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, Iterable<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new IterativeSeedKey(this);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction iterativeSeed<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providers: Map<Supply, ContextValueProvider<TCtx, TSrc>>,\n): PushIterable<TSrc> {\n\n  // Lazily evaluated providers\n  const lazyProviders = itsElements(\n      overIterator(() => providers.values()),\n      provider => lazyValue(provider.bind(undefined, context)),\n  );\n\n  return valueIt(lazyProviders, provider => provider());\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valuesProvider } from '@proc7ts/primitives';\nimport { itsElements } from '@proc7ts/push-iterator';\nimport type { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from './context-key';\nimport type { ContextRef } from './context-ref';\nimport { IterativeContextKey } from './iterative-context-key';\n\n/**\n * Multiple context value reference.\n *\n * Represents context value as read-only array of source values.\n *\n * @typeParam TSrc - TValue source type and context value item type.\n */\nexport type MultiContextRef<TSrc> = ContextRef<readonly TSrc[], TSrc>;\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeParam TSrc - TValue source type and context value item type.\n */\nexport class MultiContextKey<TSrc>\n    extends IterativeContextKey<readonly TSrc[], TSrc>\n    implements MultiContextRef<TSrc> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly TSrc[], ContextKey<readonly TSrc[], TSrc>>;\n\n  /**\n   * Constructs multiple context values key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified then the default value is empty array.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = valuesProvider(),\n      }: {\n        seedKey?: ContextSeedKey<TSrc, Iterable<TSrc>>;\n        byDefault?: ContextKeyDefault<readonly TSrc[], ContextKey<readonly TSrc[], TSrc>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<readonly TSrc[], TSrc, Iterable<TSrc>>,\n  ): void {\n\n    const result = itsElements(slot.seed);\n\n    if (result.length) {\n      slot.insert(result);\n    } else if (!slot.hasFallback) {\n\n      const defaultSources = this.byDefault(slot.context, this);\n\n      if (defaultSources) {\n        slot.insert(Array.from(defaultSources));\n      }\n    }\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/primitives';\nimport type { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from './context-key';\nimport type { ContextRef } from './context-ref';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextRef<TValue> = ContextRef<TValue, TValue>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextKey<TValue>\n    extends SimpleContextKey<TValue>\n    implements SingleContextRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextKey<TValue>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<TValue, SimpleContextKey.Seed<TValue>>;\n        byDefault?: ContextKeyDefault<TValue, ContextKey<TValue>>;\n      } = {},\n  ) {\n    super(name, { seedKey });\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<TValue, TValue, SimpleContextKey.Seed<TValue>>,\n  ): void {\n\n    const value = slot.seed();\n\n    if (value != null) {\n      slot.insert(value);\n    } else if (!slot.hasFallback) {\n      slot.insert(this.byDefault(slot.context, this));\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\nimport type { QualifiedName } from './name';\nimport type { NamespaceDef } from './namespace';\nimport type { NamespaceAliaser } from './namespace-aliaser';\n\n/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nexport abstract class Naming {\n\n  /**\n   * Applies the given namespace `alias` to the given local `name`.\n   *\n   * @param name Local name to apply namespace alias to.\n   * @param alias Namespace alias to apply.\n   * @param namespace Aliased namespace definition.\n   *\n   * @returns A string containing the `name` with `alias` applied to it.\n   */\n  abstract applyAlias(name: string, alias: string, namespace: NamespaceDef): string;\n\n  /**\n   * Converts the given qualified `name` into simple one accordingly to this naming schema.\n   *\n   * @param name Qualified name to convert.\n   * @param nsAlias Namespace aliaser to use.\n   */\n  name(name: QualifiedName, nsAlias: NamespaceAliaser): string {\n    if (typeof name === 'string') {\n      return name;\n    }\n\n    const [local, ns] = name;\n\n    return ns.name(nsAlias(ns), local, this);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\nimport { Naming } from './naming';\n\n/**\n * @internal\n */\nclass DefaultNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}-${name}`;\n  }\n\n}\n\n/**\n * Default naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const default__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * HTML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const html__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * @internal\n */\nclass XmlNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}:${name}`;\n  }\n\n}\n\n/**\n * XML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const xml__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * Element identifiers naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const id__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * @internal\n */\nclass CssNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${name}@${alias}`;\n  }\n\n}\n\n/**\n * CSS classes naming scheme.\n *\n * Appends namespace alias as a name suffix separated by `@` sign.\n *\n * The result looks like `<name>@<alias>`.\n */\nexport const css__naming: Naming = (/*#__PURE__*/ new CssNaming());\n","/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\nimport type { Naming } from './naming';\nimport { default__naming } from './namings';\n\n/**\n * Namespace definition.\n *\n * Namespaces are identified by their URLs.\n */\nexport class NamespaceDef {\n\n  /**\n   * Unique namespace URL.\n   */\n  readonly url: string;\n\n  /**\n   * Preferred namespace aliases.\n   */\n  readonly aliases: readonly string[];\n\n  /**\n   * The most preferred namespace alias.\n   *\n   * By default this is the first preferred alias, or `ns` if there is no preferred aliases.\n   */\n  get alias(): string {\n    return this.aliases[0] || 'ns';\n  }\n\n  /**\n   * Constructs new namespace definition.\n   *\n   * @param url - Unique namespace URL.\n   * @param aliases - Preferred namespace aliases. It is expected that each alias is an ASCII letter followed by\n   * any number of ASCII letters, digits, `-`, or `_` signs. Aliases starting with `xml` are reserved. Empty alias\n   * is reserved for {@link DEFAULT__NS default namespace}.\n   */\n  constructor(url: string, ...aliases: string[]) {\n    this.url = url;\n    this.aliases = aliases;\n  }\n\n  /**\n   * Converts a local `name` belonging to this namespace to simple one according to the given `naming` schema.\n   *\n   * Calls {@link Naming.applyAlias} by default.\n   *\n   * @param alias - Namespace alias to apply to the name.\n   * @param name - A name to convert.\n   * @param naming - Naming schema to use. {@link default__naming default naming schema} is used when omitted.\n   *\n   * @returns A simple name with this namespace alias applied.\n   */\n  name(alias: string, name: string, naming: Naming = default__naming): string {\n    return naming.applyAlias(name, alias, this);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\nimport { DEFAULT__NS } from './default.ns';\nimport { NamespaceDef } from './namespace';\n\n/**\n * A name qualified with namespace.\n *\n * This can be either:\n * - a simple name string, which means a name in default namespace, or\n * - a name+namespace tuple.\n */\nexport type QualifiedName = string | NameAndNamespace;\n\n/**\n * A local name and namespace tuple.\n *\n * Consists of a local name string and namespace definition this name belongs to.\n */\nexport type NameAndNamespace = readonly [string, NamespaceDef];\n\n/**\n * Checks whether the given `value` is a name+namespace tuple.\n *\n * @param value - A value to check.\n *\n * @returns `true` if the given `value` is an array consisting of exactly two elements, where the first element is a\n * non-empty string, and the second element is an instance of {@link NamespaceDef}. Or `false` otherwise.\n */\nexport function isNameAndNamespace(value: unknown): value is NameAndNamespace {\n  return Array.isArray(value)\n      && value.length === 2\n      && typeof value[0] === 'string'\n      && value[1] instanceof NamespaceDef;\n}\n\n/**\n * Checks whether the given `value` is a qualified name.\n *\n * @param value - A value to check.\n *\n * @returns `true` if the given `value` is a non-empty string or an array consisting of exactly two elements,\n * where the first element is a non-empty string, and the second element is an instance of {@link NamespaceDef}.\n * Or `false` otherwise.\n */\nexport function isQualifiedName(value: unknown): value is QualifiedName {\n  return typeof value === 'string' || isNameAndNamespace(value);\n}\n\n/**\n * Detects a namespace of the given qualified `name`\n *\n * @param name - Qualified name to detect a namespace of.\n *\n * @returns A namespace if the given `name` has it, or {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function namespaceOf(name: QualifiedName): NamespaceDef {\n  return typeof name !== 'string' ? name[1] : DEFAULT__NS;\n}\n\n/**\n * Converts the given qualified `name` to local name and namespace tuple.\n *\n * @param name - Qualified name to convert.\n *\n * @returns The `name` itself if it has a namespace, or a tuple consisting of `name` and\n * {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function nameAndNamespace(name: QualifiedName): NameAndNamespace {\n  return typeof name !== 'string' ? name : [name, DEFAULT__NS];\n}\n\n/**\n * Checks whether two qualified names are equal to each other.\n *\n * @param first - First qualified name to compare.\n * @param second - Second qualified name to compare.\n *\n * @returns `true` if both names are equal, or `false` otherwise.\n */\nexport function namesEqual(first: QualifiedName, second: QualifiedName): boolean {\n  if (typeof first === 'string') {\n    return typeof second === 'string' ? first === second : !second[1].url && second[0] === first;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    return !firstUrl && firstName === second;\n  }\n\n  return firstName === second[0] && firstUrl === second[1].url;\n}\n\n/**\n * Compares two qualified names.\n *\n * Names in default namespace considered less than other names. Namespaces are compared by their URLs.\n *\n * @param first - First qualified name to compare.\n * @param second - Second qualified name to compare.\n *\n * @returns `-1` if the `first` name is less than the `second` one, `0` if they are equal, or `1` if the `first` name\n * is greater than the `second` one.\n */\nexport function compareNames(first: QualifiedName, second: QualifiedName): -1 | 0 | 1 {\n  if (typeof first === 'string') {\n    if (typeof second === 'string') {\n      return compareStrings(first, second);\n    }\n    if (!second[1].url) {\n      return compareStrings(first, second[0]);\n    }\n    return -1;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    if (!firstUrl) {\n      return compareStrings(firstName, second);\n    }\n    return 1;\n  }\n\n  return compareStrings(firstUrl, second[1].url) || compareStrings(firstName, second[0]);\n}\n\n/**\n * @internal\n */\nfunction compareStrings(first: string, second: string): -1 | 0 | 1 {\n  return first < second ? -1 : first > second ? 1 : 0;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/namespace-aliaser\n */\nimport type { NamespaceDef } from './namespace';\n\n/**\n * Namespace aliaser function interface.\n *\n * Maps namespaces to their unique aliases.\n */\nexport type NamespaceAliaser =\n/**\n * @param ns - A definition of namespace to find alias for.\n *\n * @returns Namespace alias.\n */\n    (ns: NamespaceDef) => string;\n\n/**\n * Creates a namespace aliaser.\n *\n * The returned function tries to find a registered alias for the given namespace. If not found then tries to use one\n * of its preferred aliases. If all of them are reserved already for another namespaces, generates a new unique alias.\n *\n * @returns New instance of namespace aliaser.\n */\nexport function newNamespaceAliaser(): NamespaceAliaser {\n\n  const aliasesByNs = new Map<string, string>();\n  const nsNumPerAlias = new Map<string, number>();\n\n  return function nsAlias(ns: NamespaceDef): string {\n\n    const found = aliasesByNs.get(ns.url);\n\n    if (found) {\n      return found;\n    }\n\n    const mostPreferred = ns.alias;\n    let nsNumRegistered = 0;\n\n    for (const preferred of [mostPreferred, ...ns.aliases]) {\n\n      const ids = nsNumPerAlias.get(preferred);\n\n      if (!ids) {\n        aliasesByNs.set(ns.url, preferred);\n        nsNumPerAlias.set(preferred, 1);\n        return preferred;\n      }\n      if (!nsNumRegistered) {\n        // Use the first one\n        nsNumRegistered = ids;\n      }\n    }\n\n    const generated = `${mostPreferred}${++nsNumRegistered}`;\n\n    aliasesByNs.set(ns.url, generated);\n    nsNumPerAlias.set(mostPreferred, nsNumRegistered);\n\n    return generated;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent } from '../after-event';\n\n/**\n * A key of {@link EventKeeper} method returning its {@link AfterEvent} instance.\n *\n * @category Core\n */\nexport const AfterEvent__symbol = (/*#__PURE__*/ Symbol('after-event'));\n\n/**\n * An event supplier that keeps the last event sent.\n *\n * The registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface EventKeeper<TEvent extends any[]> {\n\n  /**\n   * Returns an {@link AfterEvent} instance of this event keeper.\n   *\n   * @returns {@link AfterEvent} instance registering event receivers sent by this keeper.\n   */\n  [AfterEvent__symbol](): AfterEvent<TEvent>;\n\n}\n\nexport namespace EventKeeper {\n\n  /**\n   * A type of events sent by the given event keeper.\n   *\n   * @typeParam TKeeper - Target event keeper.\n   */\n  export type Event<TKeeper extends EventKeeper<any>> = TKeeper extends EventKeeper<infer TEvent> ? TEvent : never;\n\n}\n\n/**\n * Checks whether the given object implements an {@link EventKeeper} interface.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param value - An object to check.\n *\n * @returns `true` if `value` contains an {@link AfterEvent__symbol} property, or `false` otherwise.\n */\nexport function isEventKeeper<TEvent extends any[]>(value: object): value is EventKeeper<TEvent> {\n  return AfterEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\n\n/**\n * Event receiver is called on each event sent by {@link EventSender} when registered.\n *\n * A receiver may be represented either by {@link EventReceiver.Function function}, or by\n * {@link EventReceiver.Object object}. The former is a simplest form. The latter allows control all aspects of event\n * processing.\n *\n * To register an event receiver just call the event sender's `[OnEvent__symbol]` or event keeper's\n * `[AfterEvent__symbol]` method with this event receiver as argument.\n *\n * A _recurrent event_ is an event sent from inside event receiver and targeted the same receiver. Recurrent event\n * processing is scheduled until after the current event processing finishes. To handle recurrent events in a specific\n * way the event receiver may utilize an {@link EventReceiver.Context event processing context} available as\n * a first parameter of {@link EventReceiver.Object.receive} method.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n */\nexport type EventReceiver<TEvent extends any[]> = EventReceiver.Function<TEvent> | EventReceiver.Object<TEvent>;\n\nexport namespace EventReceiver {\n\n  /**\n   * Event receiver function signature.\n   *\n   * It never receives event processing context.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export type Function<TEvent extends any[]> =\n  /**\n   * @param event - An event represented by function call arguments.\n   */\n      (this: void, ...event: TEvent) => void;\n\n  /**\n   * Event receiver object.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Object<TEvent extends any[]> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link Supply.off cut off}.\n     *\n     * When omitted a new supply will be created per receiver registration within event supplier.\n     */\n    readonly supply?: Supply;\n\n    /**\n     * Receives an event.\n     *\n     * @param context - An event processing context.\n     * @param event - An event represented as the rest of arguments.\n     */\n    receive(context: Context<TEvent>, ...event: TEvent): void;\n\n  }\n\n  /**\n   * The most generic event receiver form.\n   *\n   * Any event receiver may be converted to generic form by {@link eventReceiver} function.\n   *\n   * In contrast to {@link EventReceiver.Object} this one always has a supply.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Generic<TEvent extends any[]> extends Object<TEvent> {\n\n    readonly supply: Supply;\n\n  }\n\n  /**\n   * Event processing context.\n   *\n   * It is passed to {@link EventReceiver.Object} receivers.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Context<TEvent extends any[]> {\n\n    /**\n     * Schedules the given event receiver to be called to process recurrent event(s).\n     *\n     * If called during event processing the recurrent events will be sent to the given `receiver` after current event\n     * processed instead of original one.\n     *\n     * If called multiple times the latest `receiver` will be used.\n     *\n     * If not called the recurrent events will be sent to original event receiver.\n     *\n     * > This method should be called __before__ the recurrent event issued. Otherwise it may happen that recurrent\n     * > event will be ignored in some situations. E.g. when it is issued during receiver registration.\n     *\n     * @param receiver - Recurrent events receiver function.\n     */\n    onRecurrent(receiver: EventReceiver.Function<TEvent>): void;\n\n  }\n\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n * @param receiver - An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nexport function eventReceiver<TEvent extends any[]>(receiver: EventReceiver<TEvent>): EventReceiver.Generic<TEvent> {\n\n  let generic: {\n    readonly supply: Supply;\n    receive: (context: EventReceiver.Context<TEvent>, ...event: TEvent) => void;\n  };\n\n  if (typeof receiver === 'function') {\n    generic = {\n      supply: new Supply(),\n      receive(_context, ...event) {\n        receiver(...event);\n      },\n    };\n  } else {\n    generic = {\n      supply: receiver.supply || new Supply(),\n      receive(context, ...event) {\n        if (!this.supply.isOff) {\n          // Supply cut off callback may be called before the receiver disabled.\n          // Such callback may send an event that should not be received.\n          receiver.receive(context, ...event);\n        }\n      },\n    };\n  }\n\n  // Disable receiver when event supply is cut off. But see the comment above.\n  // For function receiver this callback is always the first one.\n  generic.supply.whenOff(() => generic.receive = noop);\n\n  return generic;\n}\n","import { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @internal\n * @param receivers - An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nexport function receiveByEach<TEvent extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<TEvent>>,\n): (this: void, ...event: TEvent) => void {\n\n  let send: (this: void, event: TEvent) => void = sendNonRecurrent;\n\n  return (...event) => send(event);\n\n  function sendNonRecurrent(event: TEvent): void {\n\n    let actualReceivers = receivers;\n    const received: TEvent[] = [];\n\n    send = (recurrent: TEvent) => received.push(recurrent);\n\n    try {\n      for (; ;) {\n        actualReceivers = processEvent(actualReceivers, event);\n\n        const recurrent = received.shift();\n\n        if (!recurrent) {\n          break;\n        }\n\n        event = recurrent;\n      }\n    } finally {\n      send = sendNonRecurrent;\n    }\n  }\n}\n\n/**\n * @internal\n */\nfunction processEvent<TEvent extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<TEvent>>,\n    event: TEvent,\n): EventReceiver.Generic<TEvent>[] {\n\n  const recurrentReceivers: EventReceiver.Generic<TEvent>[] = [];\n\n  for (const receiver of receivers) {\n\n    const idx = recurrentReceivers.length;\n\n    recurrentReceivers.push(receiver);\n\n    const context: EventReceiver.Context<TEvent> = {\n      onRecurrent(recurrentReceiver) {\n        recurrentReceivers[idx] = eventReceiver({\n          supply: receiver.supply,\n          receive(_context, ...recurrentEvent) {\n            recurrentReceiver(...recurrentEvent);\n          },\n        });\n      },\n    };\n\n    receiver.receive(context, ...event);\n  }\n\n  return recurrentReceivers;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an {@link EventSender} interface though. Use an {@link EventEmitter} if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link Supply.off cut off}.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport class EventNotifier<TEvent extends any[]> implements SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _rcs?: Set<EventReceiver.Generic<TEvent>>;\n\n  readonly supply: Supply;\n\n  /**\n   * Sends the given `event` to all registered receivers.\n   *\n   * @param event - An event to send represented by function call arguments.\n   */\n  readonly send: (this: this, ...event: TEvent) => void;\n\n  constructor() {\n\n    const rcs = this._rcs = new Set<EventReceiver.Generic<TEvent>>();\n\n    this.send = receiveByEach(rcs);\n    this.supply = new Supply(() => {\n      rcs.clear();\n      delete this._rcs;\n    });\n  }\n\n  /**\n   * The number of currently registered event receivers.\n   */\n  get size(): number {\n    return this._rcs ? this._rcs.size : 0;\n  }\n\n  /**\n   * Registers an event receiver.\n   *\n   * Receivers registered with this method will receive the {@link send emitted} events.\n   *\n   * @param receiver - A receiver of events to register.\n   *\n   * @returns A supply of events to the given `receiver`.\n   */\n  on(receiver: EventReceiver<TEvent>): Supply {\n\n    const generic = eventReceiver(receiver);\n    const supply = generic.supply.needs(this);\n    const receivers = this._rcs;\n\n    if (receivers && !supply.isOff) {\n      receivers.add(generic);\n      supply.whenOff(() => receivers.delete(generic));\n    }\n\n    return supply;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { OnEvent } from '../on-event';\n\n/**\n * A key of {@link EventSender} method returning its {@link OnEvent} instance.\n *\n * @category Core\n */\nexport const OnEvent__symbol = (/*#__PURE__*/ Symbol('on-event'));\n\n/**\n * A sender of events.\n *\n * Contains an {@link OnEvent} instance registering event receivers.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n */\nexport interface EventSender<TEvent extends any[]> {\n\n  /**\n   * Returns an {@link OnEvent} instance of this event sender.\n   *\n   * @returns {@link OnEvent} instance registering event receivers sent by this sender.\n   */\n  [OnEvent__symbol](): OnEvent<TEvent>;\n\n}\n\nexport namespace EventSender {\n\n  /**\n   * A type of events sent by the given event sender.\n   *\n   * @typeParam TSender - Target event sender.\n   */\n  export type Event<TSender extends EventSender<any>> = TSender extends EventSender<infer TEvent> ? TEvent : never;\n\n}\n\n/**\n * Checks whether the given object implements an {@link EventSender} interface.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param value - An object to check.\n *\n * @returns `true` if `value` contains {@link OnEvent__symbol} property, or `false` otherwise.\n */\nexport function isEventSender<TEvent extends any[]>(value: object): value is EventSender<TEvent> {\n  return OnEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/primitives';\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event sender targeted specific receiver.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n *\n * @param receiver - Target event receiver.\n *\n * @returns A function accepting events and sending them to target `receiver`.\n */\nexport function sendEventsTo<TEvent extends any[]>(\n    receiver: EventReceiver<TEvent>,\n): (this: void, ...event: TEvent) => void {\n\n  const generic = eventReceiver(receiver);\n  let send: (...event: TEvent) => void = receiveByEach([generic]);\n\n  generic.supply.whenOff(() => send = noop);\n\n  return (...event) => send(...event);\n}\n","/**\n * @internal\n */\nexport function AfterEvent$noFallback(): never {\n  throw new Error('No events to send');\n}\n","import { neverSupply, Supply } from '@proc7ts/primitives';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function eventDig<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    input: OnEvent<TInEvent>,\n    extract: (this: void, ...event: TInEvent) => OnEvent<TOutEvent> | void | undefined,\n): (receiver: EventReceiver.Generic<TOutEvent>) => void {\n  return (receiver: EventReceiver.Generic<TOutEvent>) => {\n\n    let nestedSupply = neverSupply();\n\n    input({\n\n      supply: receiver.supply,\n\n      receive: (_context, ...event: TInEvent) => {\n\n        const prevSupply = nestedSupply;\n        const extracted = extract(...event);\n\n        try {\n          nestedSupply = extracted\n              ? extracted({\n\n                supply: new Supply().needs(receiver.supply),\n\n                receive(context, ...event: TOutEvent) {\n                  receiver.receive(context, ...event);\n                },\n\n              })\n              : neverSupply();\n        } finally {\n          prevSupply.off();\n        }\n      },\n    });\n  };\n}\n","import { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function OnEvent$do<TEvent extends any[]>(\n    this: OnEvent<TEvent>,\n    ...processors: ((this: void, arg: any) => any)[]\n): any {\n  return processors.reduce((arg, action) => action(arg), this);\n}\n","import { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function OnEvent$supplier<T extends OnEvent<any>>(this: T): T {\n  return this;\n}\n","import { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function onceEvent<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n  return (receiver: EventReceiver.Generic<TEvent>): void => {\n    supplier({\n      supply: receiver.supply,\n      receive: (context, ...event) => {\n        receiver.receive(context, ...event);\n        receiver.supply.off();\n      },\n    });\n  };\n}\n","import { Supply } from '@proc7ts/primitives';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\nimport { onceEvent } from './once-event';\n\n/**\n * @internal\n */\nexport function OnEvent$then<TEvent extends any[], TResult1 = TEvent[0], TResult2 = never>(\n    this: OnEvent<TEvent>,\n    onEvent?: ((...value: TEvent) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n): Promise<TResult1 | TResult2> {\n  return new Promise((resolve, reject) => {\n    onceEvent(this)({\n      supply: onCutOff\n          ? new Supply(reason => {\n            try {\n              resolve(onCutOff(reason));\n            } catch (e) {\n              reject(e);\n            }\n          })\n          : new Supply(reject),\n      receive: onEvent\n          ? (_ctx, ...event): void => {\n            try {\n              resolve(onEvent(...event));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          : ((_ctx, event: TEvent[0]) => resolve(event)) as (\n              _ctx: EventReceiver.Context<TEvent>,\n              ...event: TEvent[]\n          ) => void,\n    });\n  });\n}\n","import { Supply } from '@proc7ts/primitives';\nimport { EventNotifier, EventReceiver, sendEventsTo } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function shareEvents<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n\n  const shared = new EventNotifier<TEvent>();\n  let sharedSupply: Supply;\n  let initialEvents: TEvent[] | undefined;\n\n  return (receiver: EventReceiver.Generic<TEvent>): void => {\n    if (!shared.size) {\n      initialEvents = [];\n      sharedSupply = new Supply(() => initialEvents = undefined);\n\n      supplier({\n        supply: sharedSupply,\n        receive(_ctx, ...event) {\n          if (initialEvents) {\n            if (shared.size) {\n              // More events received\n              // Stop sending initial ones\n              initialEvents = undefined;\n            } else {\n              // Record events received during first receiver registration\n              // to send them to all receivers until more event received\n              initialEvents.push(event);\n            }\n          }\n          shared.send(...event);\n        },\n      });\n    }\n\n    receiver.supply.needs(sharedSupply);\n    shared.on(receiver).whenOff((reason?: any) => {\n      if (!shared.size) {\n        sharedSupply.off(reason);\n      }\n    });\n\n    if (initialEvents) {\n      // Send initial events to just registered receiver\n\n      const dispatch = sendEventsTo(receiver);\n\n      initialEvents.forEach(event => dispatch(...event));\n    }\n  };\n}\n","import { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function supplyEvents<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n  return (receiver: EventReceiver.Generic<TEvent>): void => {\n    if (dependentSupply) {\n      supplier({\n        supply: new Supply().needs(required).cuts(dependentSupply),\n        receive: (receiver.receive as (...args: any[]) => void).bind(receiver),\n      });\n    } else {\n      receiver.supply.needs(required);\n      supplier(receiver);\n    }\n  };\n}\n","import { EventReceiver, sendEventsTo } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function translateEvents<TInEvent extends any[], TOutEvent extends any[]>(\n    supplier: OnEvent<TInEvent>,\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (receiver: EventReceiver.Generic<TOutEvent>) => void {\n  return receiver => {\n\n    const dispatch = sendEventsTo(receiver);\n\n    supplier({\n      supply: receiver.supply,\n      receive: (_ctx, ...event: TInEvent) => {\n        translate(dispatch, ...event);\n      },\n    });\n  };\n}\n","import { EventReceiver } from '../event-receiver';\n\n/**\n * @internal\n */\nexport function neverReceiveBecause(reason?: any): (receiver: EventReceiver.Generic<any>) => void {\n  return ({ supply }) => supply.off(reason);\n}\n\n/**\n * @internal\n */\nexport function neverReceive({ supply }: EventReceiver.Generic<any>): void {\n  supply.off();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { AfterEvent__symbol, EventKeeper, eventReceiver, EventReceiver, OnEvent__symbol } from './base';\nimport { AfterEvent$noFallback, OnEvent$do, OnEvent$supplier, OnEvent$then } from './impl';\nimport { OnEvent } from './on-event';\n\n/**\n * Signature of {@link EventKeeper} implementation able to register the receivers of kept and upcoming events.\n *\n * The registered event receiver receives the kept event immediately upon registration, and all upcoming events\n * after that until the returned event supply is cut off.\n *\n * To convert a plain event receiver registration function to {@link AfterEvent} an {@link afterEventBy} function can\n * be used.\n *\n * May be constructed using {@link afterEventBy} function.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface AfterEvent<TEvent extends any[]> extends OnEvent<TEvent>, EventKeeper<TEvent> {\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver - Target receiver of events.\n   *\n   * @returns A supply of events from this keeper to the given `receiver`.\n   */\n  (receiver: EventReceiver<TEvent>): Supply;\n\n  [AfterEvent__symbol](): this;\n\n}\n\n/**\n * Converts a plain event receiver registration function to {@link AfterEvent} keeper with a fallback.\n *\n * The event constructed by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param register - Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper registering event receivers with the given `register` function.\n */\nexport function afterEventBy<TEvent extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<TEvent>) => void,\n    fallback: (this: void) => TEvent = AfterEvent$noFallback,\n): AfterEvent<TEvent> {\n\n  let lastEvent: TEvent | undefined;\n  let numReceivers = 0;\n\n  const afterEvent = ((receiver: EventReceiver<TEvent>): Supply => {\n\n    let dest: (context: EventReceiver.Context<TEvent>, ...event: TEvent) => void = noop;\n    const generic = eventReceiver(receiver);\n\n    if (generic.supply.isOff) {\n      return generic.supply;\n    }\n\n    const supply = new Supply().needs(generic.supply);\n    let reported = false;\n\n    register({\n      supply,\n      receive: (context, ...event: TEvent) => {\n        reported = true;\n        lastEvent = event;\n        dest(context, ...event);\n      },\n    });\n    ++numReceivers;\n\n    if (!supply.isOff || reported) {\n      generic.receive(\n          {\n            onRecurrent(recurrent) {\n              dest = (_context, ...event) => recurrent(...event);\n            },\n          },\n          ...(lastEvent || (lastEvent = fallback())),\n      );\n      dest = (context, ...event) => generic.receive(context, ...event);\n    }\n\n    supply.whenOff(reason => {\n      if (!--numReceivers) {\n        lastEvent = undefined;\n      }\n      generic.supply.off(reason);\n    });\n\n    return supply;\n  }) as AfterEvent<TEvent>;\n\n  afterEvent[OnEvent__symbol] = OnEvent$supplier;\n  afterEvent.do = OnEvent$do;\n  afterEvent.then = OnEvent$then;\n  afterEvent[AfterEvent__symbol] = OnEvent$supplier;\n\n  return afterEvent;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { onceEvent, shareEvents } from '../impl';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeParam TSrcMap - A type of `sources` map.\n * @param sources - A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each source keeper. Each event in this map has the\n * same key as its source keeper in `sources`.\n */\nexport function afterAll<TSrcMap extends { readonly [key: string]: EventKeeper<any> }>(\n    sources: TSrcMap,\n): AfterEvent<[{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }]> {\n\n  const keys = Object.keys(sources);\n\n  const registerReceiver = (\n      receiver: EventReceiver.Generic<[{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }]>,\n  ): void => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result = {} as { [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> };\n\n    keys.forEach(<TSrcKey extends keyof TSrcMap>(key: TSrcKey) => {\n      supply.needs(sources[key][AfterEvent__symbol]()((...event: EventKeeper.Event<TSrcMap[TSrcKey]>) => {\n        result[key] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(result);\n    }\n  };\n\n  const latestEvent = (): [{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }] => {\n\n    const result = {} as { [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> };\n\n    keys.forEach(\n        <TSrcKey extends keyof TSrcMap>(key: TSrcKey) => onceEvent(sources[key][AfterEvent__symbol]())({\n          supply: new Supply(),\n          receive: (_ctx, ...event: EventKeeper.Event<TSrcMap[TSrcKey]>) => result[key as keyof TSrcMap] = event,\n        }),\n    );\n\n    return [result];\n  };\n\n  return afterEventBy(shareEvents(afterEventBy(registerReceiver, latestEvent)));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { onceEvent, shareEvents } from '../impl';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeParam TEvent - A type of events sent by each source.\n * @param sources - An array of source event keepers.\n *\n * @returns An event keeper sending events received from each source keeper. Each event item is an event tuple\n * originated from source keeper under its index in `sources` array.\n */\nexport function afterEach<TEvent extends any[]>(...sources: EventKeeper<TEvent>[]): AfterEvent<TEvent[]> {\n\n  const registerReceiver = (receiver: EventReceiver.Generic<TEvent[]>): void => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result: TEvent[] = [];\n\n    sources.forEach((source, index) => {\n      supply.needs(source[AfterEvent__symbol]()((...event) => {\n        result[index] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(...result);\n    }\n  };\n\n  const latestEvent = (): TEvent[] => {\n\n    const result: TEvent[] = [];\n\n    sources.forEach(\n        source => onceEvent(source[AfterEvent__symbol]())({\n          supply: new Supply(),\n          receive: (_ctx, ...event) => result.push(event),\n        }),\n    );\n\n    return result;\n  };\n\n  return afterEventBy(shareEvents(afterEventBy(registerReceiver, latestEvent)));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { EventSender, OnEvent__symbol } from '../base';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param sender - An event sender.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSent<TEvent extends any[]>(\n    sender: EventSender<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent> {\n  return afterEventBy(receiver => sender[OnEvent__symbol]()(receiver), fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventSupplier, isEventKeeper } from '../base';\nimport { afterSent } from './after-sent';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `keeper`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param keeper - A keeper of events.\n *\n * @returns An {@link AfterEvent} keeper of events originated from the given `keeper`.\n */\nexport function afterSupplied<TEvent extends any[]>(keeper: EventKeeper<TEvent>): AfterEvent<TEvent>;\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `supplier`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `supplier` sends one.\n *\n * This is a synonym of {@link afterSent}, unless `supplier` is an {@link EventKeeper}.\n *\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - An event supplier.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `supplier`. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper of events either originated from the given `supplier`, or `initial` one.\n */\nexport function afterSupplied<TEvent extends any[]>(\n    supplier: EventSupplier<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent>;\n\nexport function afterSupplied<TEvent extends any[]>(\n    supplier: EventSupplier<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent> {\n  return isEventKeeper(supplier) ? supplier[AfterEvent__symbol]() : afterSent(supplier, fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, valueProvider } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\n\n/**\n * Builds an {@link AfterEvent} keeper of the given `event`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param event - An event that will be sent to all receivers upon registration.\n *\n * @returns An {@link AfterEvent} keeper that always sends the given `event`.\n */\nexport function afterThe<TEvent extends any[]>(...event: TEvent): AfterEvent<TEvent> {\n  return afterEventBy(noop, valueProvider(event));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { eventReceiver, EventReceiver, EventSender, OnEvent__symbol } from './base';\nimport { OnEvent$do, OnEvent$supplier, OnEvent$then } from './impl';\n\n/**\n * Signature of {@link EventSender} implementation able to register event receivers.\n *\n * The registered event receiver starts receiving upcoming events until the returned event supply is cut off.\n *\n * Contains additional event processing methods.\n *\n * May be constructed using {@link onEventBy} function.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface OnEvent<TEvent extends any[]> extends EventSender<TEvent> {\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver - Target receiver of events.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  (receiver: EventReceiver<TEvent>): Supply;\n\n  [OnEvent__symbol](): this;\n\n  /**\n   * Applies the given processor to events.\n   *\n   * @typeParam TResult - Action result type.\n   * @param processor - An event processor accepting this supplier as its only parameter, and returning application\n   * result.\n   *\n   * @returns Processing result.\n   */\n  do<TResult>(\n      processor: (this: void, supplier: this) => TResult,\n  ): TResult;\n\n  /**\n   * Applies the given processors to events.\n   *\n   * The value returned from each processor application is passed as argument to the next one. The value returned from\n   * the last processor application is the result of this method call.\n   *\n   * @typeParam TResult1 - The first processor application result type.\n   * @typeParam TResult1 - The second processor application result type.\n   * @param processor1 - An event processor accepting this supplier as its only parameter, and returning application\n   * result.\n   * @param processor2 - An event processor accepting the first one's application result as its only parameter, and\n   * returning its own application result.\n   *\n   * @returns The last processor application result.\n   */\n  do<\n      TResult1,\n      TResult2,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n  ): TResult2;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n  ): TResult3;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n  ): TResult4;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n  ): TResult5;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n  ): TResult6;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n  ): TResult7;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n  ): TResult8;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n  ): TResult9;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n  ): TResult10;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n  ): TResult11;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      TResult12,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n      processor12: (this: void, arg: TResult11) => TResult12,\n  ): TResult12;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      TResult12,\n      TResult13,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n      processor12: (this: void, arg: TResult11) => TResult12,\n      processor13: (this: void, arg: TResult12) => TResult13,\n  ): TResult13;\n\n  /**\n   * Attaches callbacks to the next event and/or supply cut off reason.\n   *\n   * This method makes event sender act as promise-like for the first parameter of the next event. Thus it is possible\n   * e.g. to use it in `await` expression.\n   *\n   * @param onEvent - The callback to execute when next event received.\n   * @param onCutOff - The callback to execute when supply is cut off before the next event received.\n   *\n   * @returns A Promise for the next event.\n   */\n  then<TResult1 = TEvent extends [infer F, ...any[]] ? F : undefined, TResult2 = never>(\n      onEvent?: ((...event: TEvent) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n      onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2>;\n\n}\n\n/**\n * Converts a plain event receiver registration function to {@link OnEvent} sender.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param register - Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An {@link OnEvent} sender registering event receivers with the given `register` function.\n */\nexport function onEventBy<TEvent extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<TEvent>) => void,\n): OnEvent<TEvent> {\n\n  const onEvent = ((receiver: EventReceiver<TEvent>): Supply => {\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (!supply.isOff) {\n      register(generic);\n    }\n\n    return supply;\n  }) as OnEvent<TEvent>;\n\n  onEvent[OnEvent__symbol] = OnEvent$supplier;\n  onEvent.do = OnEvent$do;\n  onEvent.then = OnEvent$then;\n\n  return onEvent;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { neverSupply, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { OnEvent } from '../on-event';\n\n/**\n * Creates an event processor that consumes incoming events.\n *\n * @category Core\n * @typeParam TEvent - Incoming event type. This is a list of consumer function parameter types.\n * @param consume - A function consuming events. This function may return a {@link SupplyPeer peer of event supply},\n * e.g. when registers a nested event receiver. This supply will be cut off on new event, unless returned again.\n *\n * @returns A function accepting incoming event supplier and returning event supply that will stop consuming events once\n * cut off.\n */\nexport function consumeEvents<TEvent extends any[]>(\n    consume: (this: void, ...event: TEvent) => SupplyPeer | void | undefined,\n): (this: void, input: OnEvent<TEvent>) => Supply {\n  return input => {\n\n    let consumerSupply = neverSupply();\n\n    // Do not use `.cuts()` here as `consumerSupply` is mutable\n    const supply = new Supply(reason => consumerSupply.off(reason));\n\n    input({\n      supply,\n      receive(_ctx, ...event: TEvent) {\n\n        const prevSupply = consumerSupply;\n\n        try {\n          consumerSupply = (consume(...event) || neverSupply()).supply;\n        } finally {\n          if (consumerSupply !== prevSupply) {\n            prevSupply.off();\n          }\n        }\n      },\n    });\n\n    return supply;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { shareEvents } from '../impl';\n\n/**\n * A processor of events incoming from {@link AfterEvent} keeper that shares outgoing events supply among all registered\n * receivers.\n *\n * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n * event supplies do.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event keeper to share events from.\n *\n * @returns An {@link AfterEvent} keeper sharing a common supply of events.\n */\nexport function shareAfter<TEvent extends any[]>(supplier: AfterEvent<TEvent>): AfterEvent<TEvent> {\n  return afterEventBy(shareEvents(supplier));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { EventKeeper } from '../base';\nimport { eventDig } from '../impl';\nimport { afterSupplied } from '../keepers';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that extracts event keepers from events incoming from `{@link AfterEvent} keeper.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event keeper from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function digAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const processor = digAfter_(extract);\n\n  return input => shareAfter(processor(input));\n}\n\n/**\n * Creates an event processor that extracts event keepers from events incoming from `{@link AfterEvent} keeper,\n * and does not share the outgoing events supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event keeper from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function digAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const extractKeeper = (...events: TInEvent): AfterEvent<TOutEvent> | void => {\n\n    const extracted = extract(...events);\n\n    return extracted && afterSupplied(extracted);\n  };\n\n  return input => afterEventBy(eventDig(input, extractKeeper));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventNotifier, EventSender, OnEvent__symbol } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Event emitter is a handy implementation of {@link OnEvent} sender.\n *\n * Extends {@link EventNotifier} by making its {@link EventNotifier.on} method implement an {@link OnEvent} interface.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport class EventEmitter<TEvent extends any[]> extends EventNotifier<TEvent> implements EventSender<TEvent> {\n\n  /**\n   * {@link OnEvent} sender of {@link send emitted} events.\n   *\n   * The `[OnEvent__symbol]` method is an alias of this one.\n   */\n  readonly on: OnEvent<TEvent> = onEventBy(receiver => super.on(receiver));\n\n  [OnEvent__symbol](): OnEvent<TEvent> {\n    return this.on;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { neverReceive } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * An {@link OnEvent} sender that never sends any events.\n *\n * @category Core\n */\nexport const onNever: OnEvent<any> = (/*#__PURE__*/ onEventBy(neverReceive));\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent__symbol, EventSupplier, isEventSender, OnEvent__symbol } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * Builds an {@link OnEvent} sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - An event supplier.\n *\n * @returns An {@link OnEvent} sender of events originated from the given `supplier`.\n */\nexport function onSupplied<TEvent extends any[]>(supplier: EventSupplier<TEvent>): OnEvent<TEvent> {\n  return isEventSender(supplier) ? supplier[OnEvent__symbol]() : supplier[AfterEvent__symbol]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { EventReceiver, EventSupplier } from '../base';\nimport { shareEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onNever } from './on-never';\nimport { onSupplied } from './on-supplied';\n\n/**\n * Builds an {@link OnEvent} sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param suppliers - Original event suppliers.\n *\n * @returns An {@link OnEvent} sender of all supplied events.\n */\nexport function onAny<TEvent extends any[]>(...suppliers: EventSupplier<TEvent>[]): OnEvent<TEvent> {\n  if (!suppliers.length) {\n    return onNever as OnEvent<TEvent>;\n  }\n\n  return onEventBy(shareEvents(onEventBy<TEvent>(receiver => {\n\n    const { supply } = receiver;\n    let remained = suppliers.length;\n    const removeSupplier = (reason?: any): void => {\n      if (!--remained) {\n        supply.off(reason);\n      }\n    };\n    const receive = (context: EventReceiver.Context<TEvent>, ...event: TEvent): void => {\n      receiver.receive(context, ...event);\n    };\n\n    suppliers.forEach(\n        supplier => onSupplied(supplier)({\n          supply: new Supply(removeSupplier).needs(supply),\n          receive,\n        }),\n    );\n  })));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventReceiver } from '../base';\nimport { alwaysReceiveValue, neverReceiveBecause } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Represents a promise as event sender.\n *\n * When the `promise` resolves successfully the resolved value is sent to registered event receivers. The events\n * supply is {@link Supply.off cut off} immediately after that without any reason specified.\n *\n * When the `promise` is rejected the events supply is {@link Supply.off cut off} with promise rejection reason.\n *\n * @category Core\n * @typeParam T - A type of value the promise is resolved to.\n * @param promise - The promise to represent as event sender.\n *\n * @returns An {@link OnEvent} sender of the given `promise` settlement event.\n */\nexport function onPromise<T>(promise: Promise<T>): OnEvent<[T]> {\n\n  let receive = (receiver: EventReceiver.Generic<[T]>): void => {\n    promise.then(() => receive(receiver), () => receive(receiver));\n  };\n\n  promise.then(value => {\n    receive = alwaysReceiveValue(value);\n  }).catch(e => {\n    receive = neverReceiveBecause(e);\n  });\n\n  return onEventBy(receiver => receive(receiver));\n}\n","import { EventReceiver } from '../event-receiver';\nimport { sendEventsTo } from '../send-events-to';\n\n/**\n * @internal\n */\nexport function alwaysReceiveValue<T>(value: T): (receiver: EventReceiver.Generic<[T]>) => void {\n  return receiver => {\n    try {\n      sendEventsTo(receiver)(value);\n      receiver.supply.off();\n    } catch (e) {\n      receiver.supply.off(e);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { shareEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor of events incoming from {@link OnEvent} sender that shares outgoing events supply among all registered\n * receivers.\n *\n * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n * supplies do.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event sender to share events from.\n *\n * @returns An {@link OnEvent} sender sharing a common supply of events.\n */\nexport function shareOn<TEvent extends any[]>(supplier: OnEvent<TEvent>): OnEvent<TEvent> {\n  return onEventBy(shareEvents(supplier));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { translateEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event sender to another one.\n */\nexport function translateOn<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const mapper = translateOn_(translate);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender, and does not share the\n * outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event sender to another one.\n */\nexport function translateOn_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n  return input => onEventBy(translateEvents(input, translate));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { translateEvents } from '../impl';\nimport { OnEvent } from '../on-event';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that converts events incoming from {@link AfterEvent} keeper with the given converter\n * function.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]>;\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function and fallback.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n * @param fallback - A function creating a fallback of outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback: () => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]>;\n\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback?: () => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]> {\n\n  const mapper = mapAfter_(convert, fallback!);\n\n  return input => shareAfter(mapper(input));\n}\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function, and does not share the outgoing events supply.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n *\n * @returns New event mapper.\n */\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]>;\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function and fallback, and does not share the outgoing events supply.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n * @param fallback - A function creating a fallback of outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback: () => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]>;\n\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback?: () => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]> {\n  return input => afterEventBy(\n      translateEvents(\n          input,\n          (send, ...event) => send(convert(...event)),\n      ),\n      fallback && (() => [fallback()]),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { translateEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapOn<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TResult]> {\n\n  const mapper = mapOn_(convert);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function, and does not share the outgoing events supply.\n *\n * @category Core\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n *\n * @returns New event mapper.\n */\nexport function mapOn_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TResult]> {\n  return input => onEventBy(translateEvents(\n      input,\n      (send, ...event) => send(convert(...event)),\n  ));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { onceEvent } from '../impl';\n\n/**\n * A processor of the first event incoming from {@link AfterEvent} keeper.\n *\n * Cuts off the outgoing events supply after sending the first event.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event keeper to receive an event from.\n *\n * @returns New keeper of the first event.\n */\nexport function onceAfter<TEvent extends any[]>(supplier: AfterEvent<TEvent>): AfterEvent<TEvent> {\n  return afterEventBy(onceEvent(supplier));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent } from '../after-event';\nimport { onceEvent } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor of the first event incoming from {@link OnEvent} sender.\n *\n * Cuts off the outgoing event supply after sending the first event.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event sender to receive an event from.\n *\n * @returns New sender of the first event.\n */\nexport function onceOn<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): OnEvent<TEvent> | AfterEvent<TEvent> {\n  return onEventBy(onceEvent(supplier));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { supplyEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Creates an event processor that passes events incoming from {@link OnEvent} sender until the `required` supply is\n * cut off.\n *\n * The outgoing events supply will be cut off once incoming event supply does, unless a second supply passed in.\n * In the latter case that supply will be cut off instead.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param required - A peer of required event supply.\n * @param dependentSupply - The supply to cut off on cutting off the incoming events supply.\n *\n * @returns New event mapper.\n */\nexport function supplyOn<TEvent extends any[]>(\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<TEvent> {\n  return (input: OnEvent<TEvent>) => onEventBy(supplyEvents(input, required, dependentSupply));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { mapOn } from './map-on';\nimport { resolveOn } from './resolve-on';\nimport { supplyOn } from './supply-on';\n\n/**\n * A processor that asynchronously resolves incoming events and sends them in the order they are received.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved in the same\n * order as they have been received. Mat send events in batches, e.g. when events resolved out of order.\n *\n * The resulting events supply is cut off if some of incoming event promises rejected. In this case the rejection reason\n * is used as a reason to cut off. If incoming events supply is cut off, then the resulting event supply will be cut off\n * too, but only after all incoming events resolved and sent.\n *\n * @category Core\n * @typeParam TEvent - Resolved event type.\n * @param from - A sender of events or promise-like instances resolved to ones.\n *\n * @returns New `OnEvent` sender of resolved events.\n */\nexport function resolveOnOrdered<TEvent>(\n    from: OnEvent<[PromiseLike<TEvent> | TEvent]>,\n): OnEvent<[TEvent, ...TEvent[]]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    const sourceSupply = new Supply();\n    let numInProcess = 0;\n    const source = from.do(\n        supplyOn(supply, sourceSupply),\n        mapOn(event => {\n          ++numInProcess;\n          return event;\n        }),\n    );\n    let received: TEvent[] = [];\n    let numSent = 1;\n    let numReceived = 0;\n\n    sourceSupply.whenOff(reason => {\n      if (!numInProcess) {\n        supply.off(reason);\n      }\n    });\n\n    resolveOn(source)({\n      supply,\n      receive(_ctx, event, index) {\n\n        const i = index - numSent;\n\n        received[i] = event;\n        ++numReceived;\n        if (numReceived > i) {\n\n          let toSend: TEvent[];\n\n          if (numReceived === received.length) {\n            // Can send all received events\n            toSend = received;\n            received = [];\n          } else {\n            // Can send events up to `i`\n            toSend = received.splice(0, i + 1);\n          }\n          numSent += toSend.length;\n          numReceived -= toSend.length;\n          numInProcess -= toSend.length;\n\n          dispatch(...(toSend as [TEvent, ...TEvent[]]));\n          if (!numInProcess && sourceSupply.isOff) {\n            receiver.supply.needs(sourceSupply);\n          }\n        }\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor that asynchronously resolves incoming events and sends then in the order of their resolution.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved. The original\n * order of events is not preserved. Instead each resolved event is sent along with its index in original order.\n *\n * The resulting events supply is cut off immediately once unresolved events supply is cut off, or some of incoming\n * event promises rejected. In the latter case the rejection reason is used as a reason to cut off.\n *\n * @category Core\n * @typeParam T - A type of values the promises resolve to.\n * @param from - A sender of events or promise-like instances resolved to ones.\n *\n * @returns New `OnEvent` sender of resolved events and their indices in original order starting from `1`.\n */\nexport function resolveOn<T>(from: OnEvent<[PromiseLike<T> | T]>): OnEvent<[T, number]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    let lastIndex = 0;\n\n    from({\n      supply,\n      receive(_ctx, promise) {\n\n        const index = ++lastIndex;\n\n        Promise.resolve()\n            .then(() => promise)\n            .then(\n                event => dispatch(event, index),\n                reason => supply.off(reason),\n            );\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { supplyEvents } from '../impl';\n\n/**\n * Creates an event processor that passes events incoming from {@link AfterEvent} keeper until the `required` supply\n * is cut off.\n *\n * The outgoing events supply will be cut off once incoming event supply does, unless a second supply passed in.\n * In the latter case that supply will be cut off instead.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param required - A peer of required event supply.\n * @param dependentSupply - The supply to cut off on cutting off the incoming events supply.\n *\n * @returns New event mapper.\n */\nexport function supplyAfter<TEvent extends any[]>(\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent> {\n  return (input: AfterEvent<TEvent>) => afterEventBy(supplyEvents(input, required, dependentSupply));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { translateEvents } from '../impl';\nimport { OnEvent } from '../on-event';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that translates events incoming from {@link AfterEvent} keeper.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating outgoing event fallback.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback?: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const mapper = translateAfter_(translate, fallback!);\n\n  return input => shareAfter(mapper(input));\n}\n\n/**\n * Creates an event processor that translates events incoming from {@link AfterEvent} keeper, and does not share the\n * outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback, and does not\n * share the outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating outgoing event fallback.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback, and does not\n * share the outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Core\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `translate` function. A receiver registration would lead to an error otherwise.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback?: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent> {\n  return input => afterEventBy(translateEvents(input, translate), fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { OnEvent } from '../on-event';\nimport { shareOn } from './share-on';\nimport { translateOn_ } from './translate-on';\n\n/**\n * Creates an event processor that sends the values of incoming events.\n *\n * Events are valued by provided `value` function. The `null`, `undefined`, and `false` values are dropped.\n *\n * @category Core\n * @typeParam TEvent - Incoming event type.\n * @typeParam TValue - Event value type.\n * @param valueOf - Event value detector function. Accepts incoming event as parameters and returns either its value,\n * or `false`/`null`/`undefined` to ignore it.\n *\n * @returns New event processor.\n */\nexport function valueOn<TEvent extends any[], TValue>(\n    valueOf: (this: void, ...event: TEvent) => TValue | false | null | undefined,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TValue]> {\n\n  const mapper = valueOn_(valueOf);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that sends the values of incoming events, and does not share the outgoing events supply.\n *\n * @category Core\n * @typeParam TEvent - Incoming event type.\n * @typeParam TValue - Event value type.\n * @param valueOf - Event value detector function. Accepts incoming event as parameters and returns either its value,\n * or `false`/`null`/`undefined` to ignore it.\n *\n * @returns New event processor.\n */\nexport function valueOn_<TEvent extends any[], TValue>(// eslint-disable-line @typescript-eslint/naming-convention\n    valueOf: (this: void, ...event: TEvent) => TValue | false | null | undefined,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TValue]> {\n  return translateOn_((send, ...event) => {\n\n    const value = valueOf(...event);\n\n    if (value != null && value !== false) {\n      send(value);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\n/**\n * A path to state or its part. E.g. property value.\n *\n * May consist of one or more property keys.\n *\n * An array consisting of the only one property key is the same as this property key.\n *\n * An empty array is a path to the state itself.\n *\n * @category State Tracking\n */\nexport type StatePath = PropertyKey | StatePath.Normalized;\n\nexport namespace StatePath {\n\n  /**\n   * Normalized state path.\n   *\n   * This is always an array of property keys.\n   */\n  export type Normalized = readonly PropertyKey[];\n\n}\n\n/**\n * Normalizes a state path consisting of single key.\n *\n * @category State Tracking\n * @typeParam TKey - A type of path key.\n * @param key - A path key.\n *\n * @return Normalized state path.\n */\nexport function statePath<TKey extends PropertyKey>(key: TKey): readonly [TKey];\n\n/**\n * Normalizes arbitrary state path. I.e. converts it to array.\n *\n * @param path - Arbitrary state path.\n *\n * @return Normalized state path.\n */\nexport function statePath(path: StatePath): StatePath.Normalized;\n\nexport function statePath(path: StatePath): StatePath.Normalized {\n  return (Array.isArray(path) ? path : [path]) as StatePath.Normalized;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { EventSender, OnEvent__symbol } from '../base';\nimport { onEventBy } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { OnStateUpdate } from './on-state-update';\nimport { statePath, StatePath } from './state-path';\nimport { StateUpdateReceiver } from './state-update-receiver';\n\n/**\n * @internal\n */\nclass PathEntry {\n\n  readonly emitter = new EventEmitter<[StatePath.Normalized, any, any]>();\n  private readonly _nested = new Map<PropertyKey, PathEntry>();\n\n  constructor(private readonly _drop: () => void) {\n    this.emitter.on((path, newValue, oldValue) => {\n\n      const key = path[0];\n      const nested = this._nested.get(key);\n\n      if (nested) {\n        nested.emitter.send(path.slice(1), newValue, oldValue);\n      }\n    });\n  }\n\n  on(receiver: StateUpdateReceiver): Supply {\n\n    const supply = this.emitter.on(receiver);\n\n    return new Supply(reason => {\n      supply.off(reason);\n      this._dropIfEmpty();\n    }).needs(supply);\n  }\n\n  nest(key: PropertyKey): PathEntry;\n\n  nest(key: PropertyKey, dontCreateMissing: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined {\n\n    const found = this._nested.get(key);\n\n    if (found || dontCreateMissing) {\n      return found;\n    }\n\n    const created = new PathEntry(() => this._remove(key));\n\n    this._nested.set(key, created);\n\n    return created;\n  }\n\n  done(reason?: unknown): void {\n    for (const nested of this._nested.values()) {\n      nested.done(reason);\n    }\n    this.emitter.supply.off(reason);\n  }\n\n  private _remove(key: PropertyKey): void {\n    this._nested.delete(key);\n    this._dropIfEmpty();\n  }\n\n  private _dropIfEmpty(): void {\n    if (!this._nested.size && this.emitter.size <= 1) {\n      this._drop();\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nclass Trackers {\n\n  private readonly _root = new PathEntry(noop);\n\n  on(path: StatePath.Normalized, receiver: StateUpdateReceiver): Supply {\n    return this._entry(path).on(receiver);\n  }\n\n  send<T>(path: StatePath.Normalized, newValue: T, oldValue: T): void {\n    this._root.emitter.send(path, newValue, oldValue);\n  }\n\n  done(path: StatePath.Normalized, reason?: unknown): void {\n\n    const entry = this._entry(path, true);\n\n    if (entry) {\n      entry.done(reason);\n    }\n  }\n\n  private _entry(path: StatePath.Normalized): PathEntry;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing: true): PathEntry | undefined;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing?: true): PathEntry | undefined {\n\n    let entry = this._root;\n\n    for (const key of path) {\n\n      const nested = entry.nest(key, dontCreateMissing);\n\n      if (!nested) {\n        return;\n      }\n\n      entry = nested;\n    }\n\n    return entry;\n  }\n\n}\n\n/**\n * @internal\n */\nclass SubStateTracker implements StateTracker {\n\n  readonly update: <T>(\n      this: void,\n      path: StatePath,\n      newValue: T,\n      oldValue: T,\n  ) => void;\n\n  readonly onUpdate: OnStateUpdate = onEventBy<[StatePath.Normalized, any, any]>(\n      receiver => this._trackers.on(this._path, receiver),\n  );\n\n  constructor(private readonly _trackers: Trackers, private readonly _path: StatePath.Normalized) {\n    this.update = <T>(path: StatePath, newValue: T, oldValue: T) => {\n      this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n    };\n  }\n\n  get _tracker(): this {\n    return this;\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  track(path: StatePath): SubStateTracker {\n    path = statePath(path);\n    if (!path.length) {\n      return this; // Path to itself.\n    }\n    return new SubStateTracker(this._trackers, [...this._path, ...path]);\n  }\n\n  done(reason?: unknown): void {\n    this._trackers.done(this._path, reason);\n  }\n\n}\n\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under {@link StatePath}.\n *\n * When node modified a {@link StateTracker.update} should be called. Then all state update receivers registered by\n * {@link StateTracker.onUpdate} will receive this update.\n *\n * @category State Tracking\n */\nexport class StateTracker implements EventSender<[StatePath.Normalized, any, any]> {\n\n  /**\n   * @internal\n   */\n  readonly _tracker: SubStateTracker = new SubStateTracker(new Trackers(), []);\n\n  /**\n   * {@link OnStateUpdate state updates sender}.\n   *\n   * A state update will be sent to it whenever an `update()` function is called.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns State updates sender.\n   */\n  get onUpdate(): OnStateUpdate {\n    return this._tracker.onUpdate;\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  // noinspection JSCommentMatchesSignature\n  /**\n   * Updates the component state.\n   *\n   * All receivers registered with {@link onUpdate} will receive this update.\n   *\n   * @typeParam T - A type of changed value.\n   * @param key - Changed value key.\n   * @param newValue - New value.\n   * @param oldValue - Previous value.\n   */\n  get update(): <T>(\n      this: void,\n      path: StatePath,\n      newValue: T,\n      oldValue: T,\n  ) => void {\n    return this._tracker.update;\n  }\n\n  /**\n   * Starts tracking of partial state under the given path.\n   *\n   * @param path - A path to state part.\n   *\n   * @return New partial state tracker.\n   */\n  track(path: StatePath): StateTracker {\n\n    const subTracker = this._tracker.track(path);\n\n    return subTracker === this._tracker ? this : subTracker;\n  }\n\n  /**\n   * Unregisters updates receivers and cuts off their supplies.\n   *\n   * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n   *\n   * @param reason - An optional reason to stop tracking.\n   */\n  done(reason?: unknown): void {\n    this._tracker.done(reason);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { neverSupply, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  isEventKeeper,\n  OnEvent__symbol,\n} from '../base';\nimport { OnEvent } from '../on-event';\nimport { consumeEvents } from '../processors';\nimport { onSupplied } from '../senders';\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an {@link EventSender} interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an {@link EventKeeper} interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeParam T - Tracked value type.\n */\nexport abstract class ValueTracker<T> implements EventSender<[T, T]>, EventKeeper<[T]>, SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _by = neverSupply();\n\n  /**\n   * {@link OnEvent} sender of value changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Value changes sender.\n   */\n  abstract readonly on: OnEvent<[T, T]>;\n\n  /**\n   * {@link AfterEvent} keeper of current value.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Current value keeper.\n   */\n  readonly read: AfterEvent<[T]> = afterEventBy(\n      receiver => this.on(receiveNewValue(receiver)),\n      () => [this.it],\n  );\n\n  [OnEvent__symbol](): OnEvent<[T, T]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * An event supply of this value tracker.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * The tracked value.\n   */\n  abstract it: T;\n\n  /**\n   * Updates the tracked value by the given value `supplier`.\n   *\n   * If the value is already updated by another supplier, then unbinds from the old one first.\n   *\n   * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @param supplier - The source value sender or keeper.\n   *\n   * @returns `this` instance.\n   */\n  by(supplier: EventSupplier<[T]>): this;\n\n  /**\n   * Updates the tracked value by value suppliers extracted from events sent by the given `supplier`.\n   *\n   * If the value is already updated by another value supplier, then unbinds from the old one first.\n   *\n   * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @typeParam TSrcEvent - Source event type.\n   * @param supplier - The event supplier to extract value suppliers from.\n   * @param extract - A function extracting value supplier from event received from `supplier`.\n   * May return `undefined` to suspend receiving values.\n   *\n   * @returns `this` instance.\n   */\n  by<TSrcEvent extends any[]>(\n      supplier: EventSupplier<TSrcEvent>,\n      extract: (this: void, ...event: TSrcEvent) => EventSupplier<[T]> | undefined,\n  ): this;\n\n  by<TSrcEvent extends any[]>(\n      supplier: EventSupplier<TSrcEvent> | EventSupplier<[T]>,\n      extract?: (this: void, ...event: TSrcEvent) => EventSupplier<[T]> | undefined,\n  ): this {\n\n    const acceptValuesFrom = (sender: EventSupplier<[T]>): Supply => {\n\n      const onValue = isEventKeeper(sender) ? sender[AfterEvent__symbol]() : sender[OnEvent__symbol]();\n\n      return onValue(value => this.it = value);\n    };\n\n    this.byNone();\n    if (!extract) {\n\n      const sender = supplier as EventSupplier<[T]>;\n\n      this._by = acceptValuesFrom(sender);\n    } else {\n\n      const container = supplier as EventSupplier<TSrcEvent>;\n\n      this._by = onSupplied(container).do(consumeEvents((...event) => {\n\n        const sender = extract(...event);\n\n        if (sender) {\n          return acceptValuesFrom(sender);\n        }\n\n        return;\n      }));\n    }\n\n    this._by.whenOff(() => this._by = neverSupply());\n\n    return this;\n  }\n\n  /**\n   * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n   *\n   * If the tracker is not bound then does nothing.\n   *\n   * @param reason - Arbitrary reason of unbinding the value.\n   *\n   * @returns `this` instance.\n   */\n  byNone(reason?: any): this {\n    this._by.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction receiveNewValue<T>(\n    valueReceiver: EventReceiver.Generic<[T]>,\n): EventReceiver.Generic<[T, T]> {\n  return {\n    supply: valueReceiver.supply,\n    receive(context, newValue) {\n      valueReceiver.receive(\n          {\n            onRecurrent(recurrentReceiver) {\n              context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n            },\n          },\n          newValue,\n      );\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { EventKeeper } from '../base';\nimport { OnEvent } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * @internal\n */\nclass TrackedValue<T> extends ValueTracker<T> {\n\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  constructor(private _it: T) {\n    super();\n  }\n\n  get supply(): Supply {\n    return this._on.supply;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._on.on;\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const oldValue = this._it;\n\n    if (oldValue !== value) {\n      this._it = value;\n      this._on.send(value, oldValue);\n    }\n  }\n\n}\n\n/**\n * Constructs a value which changes can be tracked.\n *\n * @category Value Tracking\n * @param initial - Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial: T): ValueTracker<T>;\n\n/**\n * Constructs an optional value which changes can be tracked.\n *\n * @param initial - Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial?: T): ValueTracker<T | undefined>;\n\nexport function trackValue<T>(initial: T): ValueTracker<T> {\n  return new TrackedValue<T>(initial);\n}\n\n/**\n * Constructs a tracked value updated by the given value `supplier`.\n *\n * If the value is already updated by another supplier, then unbinds from the old one first.\n *\n * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @category Value Tracking\n * @param supplier - The source value keeper.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T>(supplier: EventKeeper<[T]>): ValueTracker<T>;\n\n/**\n * Constructs a tracked value updated by value keepers extracted from events sent by the given `supplier`.\n *\n * If the value is already updated by another value supplier, then unbinds from the old one first.\n *\n * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @typeParam TSrc - Source value type.\n * @param supplier - The event keeper to extract value keepers from.\n * @param extract - A function extracting value keeper from event received from `supplier`.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T, TSrc extends any[]>(\n    supplier: EventKeeper<TSrc>,\n    extract: (this: void, ...event: TSrc) => EventKeeper<[T]>,\n): ValueTracker<T>;\n\nexport function trackValueBy<T, TSrc extends any[]>(\n    supplier: EventKeeper<TSrc> | EventKeeper<[T]>,\n    extract?: (this: void, ...event: TSrc) => EventKeeper<[T]>,\n): ValueTracker<T> {\n  return (trackValue() as ValueTracker<T>).by(\n      supplier as EventKeeper<TSrc>,\n      extract as (this: void, ...event: TSrc) => EventKeeper<[T]>,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { EventKeeper, EventSender, EventSupplier, isEventKeeper } from '../base';\nimport { afterSupplied } from '../keepers';\nimport { OnEvent } from '../on-event';\nimport { consumeEvents } from '../processors';\nimport { EventEmitter, onSupplied } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * Synchronizes tracked values with each other.\n *\n * Any change to any of the added tracked values would update all the others.\n *\n * @category Value Tracking\n */\nexport class ValueSync<T> extends ValueTracker<T> {\n\n  /**\n   * @internal\n   */\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  /**\n   * @internal\n   */\n  private _it: T;\n\n  constructor(initial: T) {\n    super();\n    this._it = initial;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._on.on;\n  }\n\n  get supply(): Supply {\n    return this._on.supply;\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const old = this.it;\n\n    if (old !== value) {\n      this._it = value;\n      this._on.send(value, old);\n    }\n  }\n\n  /**\n   * Synchronizes the tracked value with the others.\n   *\n   * Applies the value from this sync to the given tracker first.\n   *\n   * @param tracker - A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link Supply.off Cut it off} to break synchronization.\n   */\n  sync(tracker: ValueTracker<T>): Supply;\n\n  /**\n   * Synchronizes the tracked value with the others in the given direction.\n   *\n   * @param direction - If set to `\"in\"` the value from the given tracker takes precedence over the one in\n   * {@link ValueSync}. Otherwise the value from the sync is applied to the given tracker first.\n   * @param tracker - A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link Supply.off Cut it off} to break synchronization.\n   */\n  sync(direction: 'in' | 'out', tracker: ValueTracker<T>): Supply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * Applies the value from this sync to extracted trackers.\n   *\n   * @typeParam TSrcEvent - A type of supplied events to extract value trackers from.\n   * @param supplier - The event supplier to extract value trackers from.\n   * @param extract - A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link Supply.off Cut it off} to break synchronization.\n   */\n  sync<TSrcEvent extends any[]>(\n      supplier: EventSupplier<TSrcEvent>,\n      extract: (this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined,\n  ): Supply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`\n   * in the given direction.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * @typeParam TSrcEvent - A type of supplied events to extract value trackers from.\n   * @param direction - If set to `\"in\"` the value from extracted tracker takes precedence over the one in\n   * {@link ValueSync}. Otherwise the value from the sync is applied to extracted trackers first.\n   * @param supplier - The event supplier to extract value trackers from.\n   * @param extract - A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link Supply.off Cut it off} to break synchronization.\n   */\n  sync<TSrcEvent extends any[]>(\n      direction: 'in' | 'out',\n      supplier: EventSupplier<TSrcEvent>,\n      extract: (this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined,\n  ): Supply;\n\n  sync<TSrcEvent extends any[]>(\n      first: 'in' | 'out' | ValueTracker<T> | EventSupplier<TSrcEvent>,\n      second?: ValueTracker<T>\n          | EventSender<TSrcEvent>\n          | EventKeeper<TSrcEvent>\n          | ((this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined),\n      third?: (this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined,\n  ): Supply {\n\n    let syncWithTracker = (tracker: ValueTracker<T>): Supply => syncTrackers(this, tracker);\n    let source: ValueTracker<T> | EventSupplier<TSrcEvent>;\n    let extract: ((this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined) | undefined;\n\n    if (typeof first === 'string') {\n      if (first === 'in') {\n        syncWithTracker = tracker => syncTrackers(tracker, this);\n      }\n      source = second as ValueTracker<T> | EventSender<TSrcEvent> | EventKeeper<TSrcEvent>;\n      extract = third;\n    } else {\n      source = first;\n      extract = second as (this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined;\n    }\n\n    const extractTracker = extract;\n\n    if (!extractTracker) {\n      return syncWithTracker(source as ValueTracker<T>);\n    }\n\n    const supplier = source as EventSupplier<TSrcEvent>;\n\n    return (isEventKeeper(supplier) ? afterSupplied(supplier) : onSupplied(supplier)).do(consumeEvents(\n        (...event) => {\n\n          const tracker = extractTracker(...event);\n\n          return tracker && syncWithTracker(tracker);\n        },\n    ));\n\n    function syncTrackers(tracker1: ValueTracker<T>, tracker2: ValueTracker<T>): Supply {\n\n      const supply1 = tracker1.read(value => {\n        tracker2.it = value;\n      });\n      const supply2 = tracker2.on(value => {\n        tracker1.it = value;\n      });\n\n      return new Supply(reason => {\n        supply2.off(reason);\n        supply1.off(reason);\n      }).needs(supply1).needs(supply2);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/dom-events\n */\nimport { eventReceiver, EventReceiver, OnEvent, OnEvent__symbol, onEventBy } from '@proc7ts/fun-events';\nimport { noop, Supply } from '@proc7ts/primitives';\n\n/**\n * DOM event listener.\n *\n * DOM events are never recurrent.\n *\n * May be constructed using {@link onDomEventBy} function.\n *\n * @typeParam TEvent - Supported DOM event type.\n */\nexport type DomEventListener<TEvent extends Event> = EventReceiver<[TEvent]>;\n\n/**\n * Signature of {@link EventSender} implementation able to register DOM event listeners.\n *\n * @typeParam TEvent - Supported DOM event type.\n */\nexport interface OnDomEvent<TEvent extends Event> extends OnEvent<[TEvent]> {\n\n  /**\n   * Starts sending DOM events to the given `listener`.\n   *\n   * @param listener - Target listener of DOM events.\n   * @param opts - DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events from this sender to the given `listener`.\n   */\n  (listener: DomEventListener<TEvent>, opts?: AddEventListenerOptions | boolean): Supply;\n\n}\n\n/**\n * @internal\n * @hidden\n */\nconst OnDomEvent$sample = (/*#__PURE__*/ onEventBy<any>(noop));\n\n/**\n * Converts a plain DOM event listener registration function to {@link OnDomEvent} sender.\n *\n * @typeParam TEvent - Supported DOM event type.\n * @param register - A generic DOM event listener registration function.\n *\n * @returns An {@link OnDomEvent} sender registering event listeners with the given `register` function.\n */\nexport function onDomEventBy<TEvent extends Event>(\n    register: (\n        this: void,\n        listener: EventReceiver.Generic<[TEvent]>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => void,\n): OnDomEvent<TEvent> {\n\n  const onDomEvent = ((listener: DomEventListener<TEvent>, opts?: AddEventListenerOptions | boolean): Supply => {\n\n    const receiver = eventReceiver(listener);\n    const { supply } = receiver;\n\n    if (!supply.isOff) {\n      register(receiver, opts);\n    }\n\n    return supply;\n  }) as OnDomEvent<TEvent>;\n\n  onDomEvent[OnEvent__symbol] = OnDomEvent$sample[OnEvent__symbol];\n  onDomEvent.do = OnDomEvent$sample.do;\n  onDomEvent.then = OnDomEvent$sample.then;\n\n  return onDomEvent;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/dom-events\n */\nimport type { EventReceiver } from '@proc7ts/fun-events';\nimport { noop, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { OnDomEvent, onDomEventBy } from './on-dom-event';\n\n/**\n * @internal\n * @hidden\n */\nconst OnDomEvent$context: EventReceiver.Context<any> = {\n  onRecurrent: noop,\n};\n\n/**\n * DOM event dispatcher can be used to register event listeners of particular event types and dispatch events.\n */\nexport class DomEventDispatcher implements SupplyPeer {\n\n  readonly supply: Supply = new Supply();\n\n  /**\n   * @internal\n   */\n  private readonly _target: EventTarget;\n\n  /**\n   * Constructs DOM event dispatcher for the given event target.\n   *\n   * @param target - Event target to construct event dispatcher for.\n   */\n  constructor(target: EventTarget) {\n    this._target = target;\n  }\n\n  /**\n   * Returns a sender of DOM events of the given `type`.\n   *\n   * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n   * But, in contrast, it allows to register the same listener many times.\n   *\n   * The {@link Supply event supply} returned upon event listener registration unregisters it with\n   * `EventTarget.removeEventListener()` once {@link Supply.off cut off}.\n   *\n   * @typeParam TEvent - Supported DOM event type.\n   * @param type - DOM event type name.\n   *\n   * @returns {@link OnDomEvent} sender of DOM events of the given `type`.\n   */\n  on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n    return onDomEventBy<TEvent>((listener, opts) => {\n\n      const { supply } = listener;\n\n      supply.needs(this);\n\n      if (!supply.isOff) {\n\n        // Create unique DOM listener instance\n        const domListener: EventListener = event => listener.receive(OnDomEvent$context, event as TEvent);\n\n        this._target.addEventListener(type, domListener, opts);\n        listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n      }\n    });\n  }\n\n  /**\n   * Dispatches the given DOM event to event target.\n   *\n   * Calls `EventTarget.dispatchEvent()` method.\n   *\n   * @param event - An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise. Also returns `false` when {@link supply} is cut off.\n   */\n  dispatch(event: Event): boolean {\n    return !this.supply.isOff && this._target.dispatchEvent(event);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\n/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason - Context destruction reason.\n */\nexport function contextDestroyed(reason?: any): () => never {\n  return () => {\n    throw reason ?? new TypeError('Context destroyed');\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport {\n  afterEach,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  isEventKeeper,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { itsElements, mapIt, overElementsOf, overIterator } from '@proc7ts/push-iterator';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueSlot } from '../context-key';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextSeeder } from '../context-seeder';\nimport { ContextSupply } from '../context-supply';\nimport type { ContextValueProvider } from '../context-value-spec';\nimport type { ContextValues } from '../context-values';\n\n/**\n * @internal\n */\nconst flatUpSources: <TSrc>(this: void, input: AfterEvent<TSrc[][]>) => AfterEvent<TSrc[]> = translateAfter(\n    (send, ...sources) => send(...itsElements(overElementsOf(...sources))),\n);\n\n/**\n * @internal\n */\nclass ContextUpSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n  private readonly _providers = trackValue<[Map<Supply, ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>>]>(\n      [new Map()],\n  );\n\n  provide(provider: ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>): Supply {\n\n    const [providers] = this._providers.it;\n    const supply = new Supply();\n\n    providers.set(supply, provider);\n    this._providers.it = [providers];\n\n    return supply.whenOff(() => {\n\n      const [providers] = this._providers.it;\n\n      providers.delete(supply);\n\n      this._providers.it = [providers];\n    });\n  }\n\n  seed(context: TCtx, initial: AfterEvent<TSrc[]> = afterThe<TSrc[]>()): AfterEvent<TSrc[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<TSrc[]>, second: AfterEvent<TSrc[]>): AfterEvent<TSrc[]> {\n    return afterEach(first, second).do(flatUpSources);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providersTracker: ValueTracker<[Map<Supply, ContextValueProvider<TCtx, TSrc | EventKeeper<TSrc[]>>>]>,\n): AfterEvent<TSrc[]> {\n  return providersTracker.read.do(\n      digAfter_(\n          ([providers]): AfterEvent<TSrc[][]> => !providers.size\n              ? afterThe()\n              : afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overIterator(() => providers.values()),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n      ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<TSrc>(src: null | undefined | TSrc | EventKeeper<TSrc[]>): AfterEvent<TSrc[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<TSrc>(src: TSrc | EventKeeper<TSrc[]>): src is EventKeeper<TSrc[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as object);\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<TSrc>\n    extends ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SeedKey<TSrc> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport interface ContextUpRef<TValue, TSrc> extends ContextRef<TValue, TSrc | EventKeeper<TSrc[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<TValue, TSrc>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<TValue, TSrc>\n    extends ContextKey<ContextUpKey.Up<TValue>, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n  readonly grow: (\n      slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n  ) => void;\n\n  get seedKey(): ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<TValue, TSrc>,\n      grow: (\n          slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n      ) => void,\n  ) {\n    super(_key.name + ':up');\n    this.grow = slot => {\n\n      const value: AfterEvent<[TValue]> | null | undefined = slot.fillBy(grow);\n\n      if (value) {\n\n        const supply = slot.context.get(ContextSupply, { or: null });\n\n        if (supply) {\n          slot.insert(value.do(supplyAfter(supply)) as ContextUpKey.Up<TValue>);\n        }\n      }\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class ContextUpKey<TValue, TSrc>\n    extends ContextKey<TValue, TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>>\n    implements ContextUpRef<TValue, TSrc> {\n\n  readonly seedKey: ContextUpKey.SeedKey<TSrc>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by {@link grow} function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<TValue, TSrc>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TSrc>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey<TSrc>(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow - A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: (\n          slot: ContextValueSlot<ContextUpKey.Up<TValue>, EventKeeper<TSrc[]> | TSrc, AfterEvent<TSrc[]>>,\n      ) => void,\n  ): ContextUpKey.UpKey<TValue, TSrc> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeParam TValue - Original context value type.\n   */\n  export type Up<TValue> = TValue extends AfterEvent<any>\n      ? TValue\n      : (TValue extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[TValue]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export type UpKey<TValue, TSrc> = ContextKey<ContextUpKey.Up<TValue>, TSrc>;\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SeedKey<TSrc> extends ContextSeedKey<TSrc | EventKeeper<TSrc[]>, AfterEvent<TSrc[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { AfterEvent, afterThe, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport type { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport type { ContextValues } from '../context-values';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport type FnContextRef<TArgs extends any[], TRet = void> =\n    ContextUpRef<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an {@link ContextKeyError}.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport class FnContextKey<TArgs extends any[], TRet = void>\n    extends ContextUpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>\n    implements FnContextRef<TArgs, TRet> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<TArgs, TRet>) =>\n      (this: void, ...args: TArgs) => TRet;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: TArgs) => TRet)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: TArgs) => TRet, FnContextKey<TArgs, TRet>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key)\n        || (() => {\n          throw new ContextKeyError(this);\n        });\n    this.upKey = this.createUpKey(\n        slot => {\n          slot.insert(slot.seed.do(digAfter(\n              (...fns): AfterEvent<[(this: void, ...args: TArgs) => TRet]> => {\n                if (fns.length) {\n                  return afterThe(fns[fns.length - 1]);\n                }\n\n                if (slot.hasFallback && slot.or) {\n                  return slot.or;\n                }\n\n                return afterThe(this.byDefault(slot.context, this));\n              },\n          )));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          (this: void, ...args: TArgs) => TRet,\n          EventKeeper<((this: void, ...args: TArgs) => TRet)[]> | ((this: void, ...args: TArgs) => TRet),\n          AfterEvent<((this: void, ...args: TArgs) => TRet)[]>>,\n  ): void {\n\n    let delegated: (this: void, ...args: TArgs) => TRet;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { AfterEvent, afterEventBy, afterThe, digAfter, EventKeeper, supplyAfter } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport type { ContextKeyDefault, ContextValueSlot } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextSupply } from '../context-supply';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextUpRef<TValue> = ContextUpRef<AfterEvent<[TValue]>, TValue>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an {@link ContextKeyError} error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextUpKey<TValue>\n    extends ContextUpKey<AfterEvent<[TValue]>, TValue>\n    implements SingleContextUpRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TValue>;\n        byDefault?: ContextKeyDefault<TValue, ContextUpKey<AfterEvent<[TValue]>, TValue>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<AfterEvent<[TValue]>, EventKeeper<TValue[]> | TValue, AfterEvent<TValue[]>>,\n  ): void {\n\n    const value = slot.seed.do(digAfter((...sources: TValue[]): AfterEvent<TValue[]> => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return afterThe(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect a backup value.\n      let backup: AfterEvent<[TValue]> | null | undefined;\n\n      if (slot.hasFallback) {\n        backup = slot.or;\n      } else {\n\n        const defaultValue = this.byDefault(slot.context, this);\n\n        backup = defaultValue && afterThe(defaultValue);\n      }\n      if (backup != null) {\n        return backup; // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return afterEventBy<[TValue]>(() => {\n        throw new ContextKeyError(this);\n      });\n    }));\n\n    const supply = slot.context.get(ContextSupply, { or: null });\n\n    slot.insert(supply ? value.do<AfterEvent<TValue[]>>(supplyAfter(supply)) : value);\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @frontmeans/render-scheduler\n */\nimport type { RenderShot } from './render-shot';\n\n/**\n * Render schedule signature.\n *\n * This function accepts a {@link RenderShot render shot} to schedule. All scheduled render shots are meant to update\n * the same rendering target. If multiple render shots scheduled before execution starts, only the last one will be\n * executed to limit rendering rate.\n *\n * The render shot execution may fail. This should not prevent other scheduled or postponed render shots from being\n * executed. The render shot execution failure reason is expected to be reported with {@link RenderScheduleConfig.error}\n * method.\n *\n * Render schedules are constructed by {@link RenderScheduler render schedulers}, or by {@link newRenderSchedule}\n * function that uses the {@link setRenderScheduler default scheduler} for that.\n */\nexport type RenderSchedule =\n/**\n * @param shot - A render shot to schedule.\n */\n    (this: void, shot: RenderShot) => void;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link RenderScheduler render scheduler} when constructing new {@link RenderSchedule schedule}.\n *\n * A {@link RenderScheduleConfig render configuration} can be constructed based on the options with\n * {@link RenderScheduleConfig.by} function.\n */\nexport interface RenderScheduleOptions {\n\n  /**\n   * A window for constructed schedule.\n   *\n   * Detected by {@link nodeWindow} by default, if {@link node} is specified. Falls back to current `window`.\n   *\n   * The schedulers that don't need a window never access this option value.\n   */\n  window?: Window;\n\n  /**\n   * A DOM node for constructed schedule.\n   *\n   * Used to detect missing {@link window} option.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * Reports errors with `console.error()` by default.\n   *\n   * @param messages - Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * Render schedule configuration.\n *\n * This is based on {@link RenderScheduleOptions render options}, but has all properties present.\n *\n * The configuration ought to be constructed out of render options by {@link RenderScheduleConfig.by} function.\n */\nexport interface RenderScheduleConfig {\n\n  /**\n   * A window the schedule is constructed for.\n   *\n   * The schedulers that don't need a window should never access this option value.\n   */\n  window: Window;\n\n  /**\n   * A DOM node the schedule is constructed for.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * @param messages - Error messages to report.\n   */\n  error(...messages: any[]): void;\n\n}\n\nexport const RenderScheduleConfig = {\n\n  /**\n   * Constructs a configuration of render scheduler by its options.\n   *\n   * @param options - Render scheduler options the configuration should be base on.\n   */\n  by(this: void, options: RenderScheduleOptions = {}): RenderScheduleConfig {\n\n    let win: Window | undefined;\n\n    return {\n      get node(): Node | undefined {\n        return options.node;\n      },\n      get window(): Window {\n        return win || (win = options.window || (options.node && nodeWindow(options.node)) || window);\n      },\n      error(...messages: any[]): void {\n        if (options && options.error) {\n          options.error(...messages);\n        } else {\n          console.error(...messages);\n        }\n      },\n    };\n  },\n\n};\n\n/**\n * Detects a window the given DOM node is attached to.\n *\n * @param node - Target DOM node.\n *\n * @returns A window of the owner document, or `null` if absent.\n */\nexport function nodeWindow(node: Node): Window | null {\n\n  const document = node.ownerDocument || node as Document;\n\n  return document.defaultView;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/render-scheduler\n */\nimport type { RenderQueue } from './render-queue';\nimport { RenderSchedule, RenderScheduleConfig, RenderScheduleOptions } from './render-schedule';\nimport type { RenderScheduler } from './render-scheduler';\nimport type { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Custom render scheduler options.\n *\n * This is passed to {@link customRenderScheduler} function to construct new custom scheduler.\n */\nexport interface CustomRenderSchedulerOptions {\n\n  /**\n   * Obtains a queue for render schedule.\n   *\n   * This is called once per render schedule.\n   *\n   * Render schedules may share the queue.\n   *\n   * @param config - Render schedule configuration.\n   *\n   * @returns  A queue of scheduled render shots.\n   */\n  newQueue(config: RenderScheduleConfig): RenderQueue;\n\n}\n\n/**\n * @internal\n */\nconst RenderQ__symbol = Symbol('render-q');\n\n/**\n * @internal\n */\ninterface InternalRenderQueue extends RenderQueue {\n  [RenderQ__symbol]?: RenderQ;\n}\n\n/**\n * @internal\n */\nclass RenderQ {\n\n  readonly ref: [RenderQ, RenderQ];\n  schedule: (this: RenderQ, config: RenderScheduleConfig) => void;\n  private scheduled?: RenderScheduleConfig;\n\n  static by(queue: InternalRenderQueue, ref?: [RenderQ, RenderQ]): RenderQ {\n    return queue[RenderQ__symbol]\n        || (queue[RenderQ__symbol] = new RenderQ(queue, ref));\n  }\n\n  private constructor(private readonly q: RenderQueue, ref?: [RenderQ, RenderQ]) {\n    this.schedule = this.doSchedule;\n    this.ref = ref || [this, this];\n  }\n\n  add(shot: RenderShot): void {\n    this.q.add(shot);\n  }\n\n  private doSchedule(config: RenderScheduleConfig): void {\n    this.schedule = () => {/* do not schedule */};\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.unshift(shot);\n      },\n    };\n\n    this.q.schedule(() => {\n\n      const next = this.reset();\n\n      next.suspend();\n      this.exec(execution);\n      // Activate next queue\n      this.ref[1] = this.ref[0];\n      // Schedule postponed shots (in reverse order)\n      postponed.forEach(shot => this.q.add(shot));\n      // Recurrently postponed shots are executed immediately after their initiators\n      execution.postpone = shot => this.q.post(shot);\n      this.exec(execution);\n      next.resume();\n    });\n  }\n\n  private exec(execution: RenderExecution): void {\n    for (; ;) {\n\n      const shot = this.q.pull();\n\n      if (!shot) {\n        break;\n      }\n      shot(execution);\n    }\n  }\n\n  private reset(): RenderQ {\n    // Update next queue. Current queue remains active\n    return this.ref[0] = RenderQ.by(this.q.reset(), this.ref);\n  }\n\n  private suspend(): void {\n    this.schedule = config => {\n      this.scheduled = config;\n      this.schedule = () => {/* do not schedule */};\n    };\n  }\n\n  private resume(): void {\n    if (this.scheduled) {\n      this.doSchedule(this.scheduled);\n    } else {\n      this.schedule = this.doSchedule;\n    }\n  }\n\n}\n\n/**\n * Builds custom render scheduler.\n *\n * @param options - Render scheduler options.\n *\n * @returns New render scheduler.\n */\nexport function customRenderScheduler(\n    options: CustomRenderSchedulerOptions,\n): RenderScheduler {\n  return (scheduleOptions?: RenderScheduleOptions): RenderSchedule => {\n\n    const config = RenderScheduleConfig.by(scheduleOptions);\n    const queueRef: readonly [RenderQ, RenderQ] = RenderQ.by(options.newQueue(config)).ref;\n    let enqueued: [RenderQ, RenderShot, true?] | [] = [];\n\n    return (shot: RenderShot): void => {\n\n      const [lastQueue,, executed] = enqueued;\n      const [nextQueue, activeQueue] = queueRef;\n      let queue = lastQueue || activeQueue;\n\n      if (lastQueue === activeQueue && !executed || lastQueue === nextQueue) {\n        enqueued[1] = shot;\n      } else {\n\n        // Add to active queue initially, unless a shot executed in it already.\n        // Add to the next queue otherwise.\n        const nextEnqueued: [RenderQ, RenderShot, true?] = enqueued = [\n          queue = executed ? nextQueue : activeQueue,\n          shot,\n        ];\n\n        queue.add((execution: RenderExecution) => {\n          nextEnqueued[2] = true; // Switch to next queue\n          try {\n            nextEnqueued[1]({\n              get config() {\n                return config;\n              },\n              postpone(postponed) {\n                execution.postpone(postponed);\n              },\n            });\n          } catch (e) {\n            config.error(e);\n          }\n        });\n      }\n\n      queue.schedule(config);\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/render-scheduler\n */\nimport type { RenderShot } from './render-shot';\n\n/**\n * A queue of scheduled render shots.\n *\n * Utilized by render scheduler in order to collect render shots and schedule their execution.\n *\n * The default implementation may be constructed using {@link RenderQueue.by} function.\n */\nexport interface RenderQueue {\n\n  /**\n   * Adds a render shot to this queue.\n   *\n   * @param shot - Scheduled render shot to add.\n   */\n  add(shot: RenderShot): void;\n\n  /**\n   * Adds a render shot to the head of this queue.\n   *\n   * @param shot - Scheduled render shot to add.\n   */\n  post(shot: RenderShot): void;\n\n  /**\n   * Retrieves the first added render shot and removes it from the queue.\n   *\n   * @returns  Either pulled out render shot, or `undefined` when there is no more render shots.\n   */\n  pull(): RenderShot | undefined;\n\n  /**\n   * Schedules queued render shots execution.\n   *\n   * @param task - A function that performs render shots execution task.\n   */\n  schedule(task: (this: void) => void): void;\n\n  /**\n   * Resets the queue for the next execution.\n   *\n   * @returns  Another (empty) queue that will collect scheduled render shots from now on.\n   */\n  reset(): RenderQueue;\n\n}\n\nexport const RenderQueue = {\n\n  /**\n   * Builds the default implementation of render queue.\n   *\n   * @param schedule - Schedules queued render shots execution. This is an implementation of\n   * {@link RenderQueue.schedule} method.\n   * @param replace - Called right after {@link RenderQueue.reset} method in order to inform on the queue that will\n   * collect scheduled render shots from now.\n   *\n   * @returns New render queue.\n   */\n  by(\n      this: void,\n      {\n        schedule,\n        replace = (): void => {/* do not replace */},\n      }: {\n        schedule(this: RenderQueue, task: (this: void) => void): void;\n        replace?(this: void, replacement: RenderQueue): void;\n      },\n  ): RenderQueue {\n\n    const shots: RenderShot[] = [];\n\n    return {\n      schedule,\n      add(shot: RenderShot): void {\n        shots.push(shot);\n      },\n      post(shot: RenderShot): void {\n        shots.unshift(shot);\n      },\n      pull(): RenderShot | undefined {\n        return shots.shift();\n      },\n      reset(): RenderQueue {\n\n        const next = RenderQueue.by({ schedule, replace });\n\n        replace(next);\n\n        return next;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @frontmeans/render-scheduler\n */\nimport { customRenderScheduler } from './custom-render-scheduler';\nimport { RenderQueue } from './render-queue';\nimport type { RenderScheduler } from './render-scheduler';\n\n/**\n * @internal\n */\nconst animationRenderQueues = (/*#__PURE__*/ new WeakMap<Window, RenderQueue>());\n\n/**\n * A render scheduler that executes scheduled render shots within animation frame.\n *\n * Utilizes [requestAnimationFrame()] function for that.\n *\n * The render shots scheduled by different schedules created for the same window are all executed in the same animation\n * frame. The {@link RenderExecution.postpone postponed} render shots are executed only after all scheduled ones\n * complete.\n *\n * [requestAnimationFrame()]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n */\nexport const animationRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue({ window }) {\n\n    const existing = animationRenderQueues.get(window);\n\n    if (existing) {\n      return existing;\n    }\n\n    const newQueue = RenderQueue.by({\n      schedule: task => window.requestAnimationFrame(task),\n      replace: replacement => animationRenderQueues.set(window, replacement),\n    });\n\n    animationRenderQueues.set(window, newQueue);\n\n    return newQueue;\n  },\n}));\n","import { RenderSchedule, RenderScheduleConfig, RenderScheduleOptions } from './render-schedule';\nimport type { RenderScheduler } from './render-scheduler';\nimport type { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Render scheduler that executes render shots immediately.\n *\n * @param options\n */\nexport const immediateRenderScheduler: RenderScheduler = (options?: RenderScheduleOptions): RenderSchedule => {\n\n  const config = RenderScheduleConfig.by(options);\n\n  return (shot: RenderShot): void => {\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.push(shot);\n      },\n    };\n\n    execute(shot);\n    for (; ;) {\n\n      const last = postponed.pop();\n\n      if (!last) {\n        break;\n      }\n\n      execute(last);\n    }\n\n    function execute(shot: RenderShot): void {\n      try {\n        shot(execution);\n      } catch (e) {\n        config.error(e);\n      }\n    }\n  };\n};\n","/**\n * @packageDocumentation\n * @module @frontmeans/render-scheduler\n */\nimport { animationRenderScheduler } from './animation-render-scheduler';\nimport type { RenderSchedule, RenderScheduleOptions } from './render-schedule';\n\n/**\n * Render scheduler signature.\n *\n * This function constructs a {@link RenderSchedule render schedule} according to the given options.\n *\n * The default render scheduler is always available as {@link newRenderSchedule} function.\n *\n * There are several scheduler implementations exist:\n * - {@link animationRenderScheduler} (used by default),\n * - {@link asyncRenderScheduler},\n * - {@link immediateRenderScheduler},\n * - {@link ManualRenderScheduler},\n * - {@link noopRenderScheduler}.\n *\n * Custom scheduler implementations could be created using {@link customRenderScheduler} function.\n */\nexport type RenderScheduler =\n/**\n * @param options - Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: RenderScheduleOptions) => RenderSchedule;\n\n/**\n * @internal\n */\nlet defaultRenderScheduler = animationRenderScheduler;\n\n/**\n * Assigns or resets the default render scheduler.\n *\n * An {@link animationRenderScheduler animation frame render scheduler} is used bu default.\n *\n * @param scheduler - New default render scheduler. {@link animationRenderScheduler animation frame render scheduler}\n * will be used if `null`, `undefined`, or omitted.\n *\n * @returns New default render scheduler.\n */\nexport function setRenderScheduler(\n    scheduler?: RenderScheduler | null,\n): RenderScheduler {\n  return defaultRenderScheduler = scheduler || animationRenderScheduler;\n}\n\n/**\n * Constructs {@link RenderSchedule render schedule} using {@link setRenderScheduler default render scheduler}.\n *\n * @param options - Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\nexport function newRenderSchedule(options?: RenderScheduleOptions): RenderSchedule {\n  return defaultRenderScheduler(options);\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = (/*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { ComponentClass, DefinitionContext } from '../component/definition';\nimport { FeatureRef } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to {@link FeatureDef.Options.init} method so that the feature can configure\n * itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * An `OnEvent` sender of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[BootstrapContext]>;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Component class constructor.\n   *\n   * @return An `OnEvent` sender of definition context sent when the given `componentType` is registered.\n   */\n  abstract whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]>;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * @param feature - The feature to load.\n   *\n   * @returns  Loaded feature reference.\n   */\n  abstract load(feature: Class): FeatureRef;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKeyDefault } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @typeParam TValue - Context value type.\n * @typeParam TKey - Context key type.\n * @param provide - A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<TValue, TKey extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: TKey) => TValue | null | undefined,\n): ContextKeyDefault<TValue, TKey> {\n  return (context, key): TValue | null | undefined => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext\n        ? provide(bootstrapContext, key)\n        : bootstrapContext.get(key) as TValue;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport {\n  Class,\n  fieldAccessorDescriptor,\n  PropertyAccessorDescriptor,\n  toPropertyAccessorDescriptor,\n} from '@proc7ts/primitives';\n\n/**\n * Typed class decorator.\n *\n * @category Utility\n * @typeParam T - A type of class to decorate.\n */\nexport type TypedClassDecorator<T extends Class> = (type: T) => T | void;\n\n/**\n * Typed property decorator.\n *\n * @category Utility\n * @typeParam T - A type of class the decorated property belongs to.\n */\nexport type TypedPropertyDecorator<T extends Class> =\n    <TValue>(\n        target: InstanceType<T>,\n        propertyKey: string | symbol,\n        descriptor?: TypedPropertyDescriptor<TValue>,\n    ) => any | void;\n\n/**\n * Property decorator helper converting a field or property to the one with accessor (`get` and optionally `set`).\n *\n * @category Utility\n * @typeParam T - A type of target object.\n * @typeParam TValue - A property value type.\n * @param target - Target object containing the property.\n * @param propertyKey - Target property key.\n * @param desc - Target property descriptor, or `undefined` for object fields.\n * @param updateDescriptor - Descriptor updater. Accepts the accessor descriptor as the only argument. If returns\n * a descriptor, then it is applied to the property. Otherwise the target property descriptor is never updated.\n *\n * @returns Updated property descriptor to return from decorator to apply to the property, or `undefined` if there is\n * nothing to update.\n */\nexport function decoratePropertyAccessor<T, TValue>(\n    target: T,\n    propertyKey: string | symbol,\n    desc: TypedPropertyDescriptor<TValue> | undefined,\n    updateDescriptor: (desc: PropertyAccessorDescriptor<TValue>) => PropertyAccessorDescriptor<TValue>,\n): PropertyAccessorDescriptor<TValue> | undefined {\n\n  const isField = !desc;\n  const accessorDesc = desc\n      ? toPropertyAccessorDescriptor(desc)\n      : fieldAccessorDescriptor(target, propertyKey as keyof T) as unknown as PropertyAccessorDescriptor<TValue>;\n  const updatedDesc = updateDescriptor(accessorDesc);\n\n  if (isField && updatedDesc) {\n    Object.defineProperty(target, propertyKey, updatedDesc);\n    return;\n  }\n\n  return updatedDesc;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\n/**\n * Property accessor descriptor. I.e. the one with `get` and `set` functions.\n *\n * @typeParam TValue - Property value type.\n */\nexport interface PropertyAccessorDescriptor<TValue> extends TypedPropertyDescriptor<TValue> {\n  enumerable?: boolean;\n  configurable?: boolean;\n  writable?: undefined;\n  value?: undefined;\n  get?: () => TValue;\n  set?: (value: TValue) => void;\n}\n\n/**\n * Detects whether the given property descriptor is the one of property accessor.\n *\n * @typeParam TValue - Property value type.\n * @param desc - Target property descriptor.\n *\n * @return `true` if the descriptor has no `value` or `writable` attributes set.\n */\nexport function isPropertyAccessorDescriptor<TValue>(\n    desc: TypedPropertyDescriptor<TValue>,\n): desc is PropertyAccessorDescriptor<TValue> {\n  return desc.value === undefined && desc.writable === undefined;\n}\n\n/**\n * Converts a property descriptor to property accessor descriptor.\n *\n * @typeParam TValue - Property value type.\n * @param desc - Target property descriptor.\n *\n * @return Either an accessor descriptor constructed from data descriptor, or `desc` if it is an accessor descriptor\n * already.\n */\nexport function toPropertyAccessorDescriptor<TValue>(\n    desc: TypedPropertyDescriptor<TValue>,\n): PropertyAccessorDescriptor<TValue> {\n  if (isPropertyAccessorDescriptor(desc)) {\n    return desc;\n  }\n\n  const value__symbol = Symbol('value');\n\n  interface ValueHost {\n    [value__symbol]: TValue;\n  }\n\n  const initial = desc.value as TValue;\n\n  const accessorDesc: PropertyAccessorDescriptor<TValue> = {\n    ...desc,\n    writable: undefined,\n    value: undefined,\n    get(this: ValueHost) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n  };\n\n  if (desc.writable) {\n    accessorDesc.set = function (this: ValueHost, newValue: TValue) {\n      this[value__symbol] = newValue;\n    };\n  }\n\n  delete accessorDesc.writable;\n  delete accessorDesc.value;\n\n  return accessorDesc;\n}\n\n/**\n * Creates an property accessor descriptor for the given field.\n *\n * @typeParam TObject - The type of target object.\n * @typeParam TKey - Target object property keys type.\n * @param target - The object containing target field.\n * @param fieldKey - Target field key.\n */\nexport function fieldAccessorDescriptor<TObject, TKey extends keyof TObject>(\n    target: TObject,\n    fieldKey: TKey,\n): PropertyAccessorDescriptor<TObject[TKey]> {\n\n  const value__symbol = Symbol(`${String(fieldKey)}:value`);\n\n  interface ValueHost {\n    [value__symbol]: TObject[TKey];\n  }\n\n  const initial: TObject[TKey] = target[fieldKey];\n\n  return {\n    configurable: true,\n    enumerable: true,\n    get(this: ValueHost): TObject[TKey] {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n    set(this: ValueHost, newValue) {\n      this[value__symbol] = newValue;\n    },\n  };\n}\n\n/**\n * Converts an object field to property accessor.\n *\n * Defines a new property with the given name in the target object and returns its descriptor.\n *\n * The converted descriptor is always configurable, enumerable, and writable.\n *\n * @typeParam TObject - The type of target object.\n * @typeParam TKey - Target object property keys type.\n * @param target - The object containing target field.\n * @param fieldKey - Target field key.\n *\n * @return New property accessor descriptor.\n */\nexport function field2accessor<TObject, TKey extends keyof TObject>(\n    target: TObject,\n    fieldKey: TKey,\n): PropertyAccessorDescriptor<TObject[TKey]> {\n\n  const desc = fieldAccessorDescriptor(target, fieldKey);\n\n  Object.defineProperty(target, fieldKey, desc);\n\n  return desc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Checks whether the given DOM node is element.\n *\n * @category Utility\n * @param node - A DOM node to check.\n *\n * @returns `true` is `node` is element, or `false` otherwise.\n */\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class, superClassOf } from '@proc7ts/primitives';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<TMeta, TSrc = TMeta> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  own(type: Class): TMeta | undefined {\n    // eslint-disable-next-line no-prototype-builtins,@typescript-eslint/no-unsafe-member-access\n    return type.hasOwnProperty(this.symbol) ? (type as any)[this.symbol] as TMeta : undefined;\n  }\n\n  of(type: Class): TMeta | undefined {\n\n    const ownDef: TMeta | undefined = this.own(type);\n    const superType = superClassOf(type);\n    const superDef = superType && this.of(superType);\n\n    return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n  }\n\n  define<T extends Class>(type: T, sources: readonly TSrc[]): T {\n\n    const prevMeta = this.own(type);\n    const updates = sources.map(source => this.meta(source, type));\n    const newMeta: TMeta = this.merge(prevMeta ? [prevMeta, ...updates] : updates);\n\n    Object.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: newMeta,\n        },\n    );\n\n    return type;\n  }\n\n  abstract merge(metas: readonly TMeta[]): TMeta;\n\n  protected abstract meta(source: TSrc, type: Class): TMeta;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class, elementOrArray, extendSetOfElements, mergeFunctions, setOfElements } from '@proc7ts/primitives';\nimport { BootstrapSetup } from '../boot';\nimport { MetaAccessor } from '../common';\nimport { FeatureContext } from './feature-context';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = (/*#__PURE__*/ Symbol('feature-def'));\n\n/**\n * Feature definition.\n *\n * This can be one of:\n * - feature definition options object,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n */\nexport type FeatureDef =\n    | FeatureDef.Options\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace FeatureDef {\n\n  /**\n   * Feature definition options.\n   */\n  export interface Options {\n\n    readonly [FeatureDef__symbol]?: undefined;\n\n    /**\n     * Features this one requires.\n     */\n    readonly needs?: Class | readonly Class[];\n\n    /**\n     * Features this one provides.\n     *\n     * The feature always provides itself.\n     */\n    readonly has?: Class | readonly Class[];\n\n    /**\n     * Sets up bootstrap.\n     *\n     * This method is called before bootstrap context created.\n     *\n     * @param setup - Bootstrap setup.\n     */\n    setup?(setup: BootstrapSetup): void;\n\n    /**\n     * Bootstraps this feature by calling the given bootstrap context constructed.\n     *\n     * @param context - Feature initialization context.\n     */\n    init?(context: FeatureContext): void;\n\n  }\n\n  /**\n   * Feature definition holder.\n   */\n  export interface Holder {\n\n    /**\n     * The feature definition this holder contains.\n     */\n    readonly [FeatureDef__symbol]: FeatureDef;\n\n  }\n\n  /**\n   * Feature definition factory.\n   */\n  export interface Factory {\n\n    /**\n     * Builds feature definition.\n     *\n     * @param featureType - A feature class constructor to build definition for.\n     *\n     * @returns Built feature definition.\n     */\n    [FeatureDef__symbol](featureType: Class): FeatureDef;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor<FeatureDef.Options, FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return defs.reduce<FeatureDef.Options>(\n        (prev, def) => ({\n          needs: elementOrArray(extendSetOfElements(setOfElements(prev.needs), def.needs)),\n          has: elementOrArray(extendSetOfElements(setOfElements(prev.has), def.has)),\n          setup: mergeFunctions<[BootstrapSetup], void, Class>(prev.setup, def.setup),\n          init: mergeFunctions<[FeatureContext], void, Class>(prev.init, def.init),\n        }),\n        {},\n    );\n  }\n\n  meta(source: FeatureDef, type: Class): FeatureDef.Options {\n\n    const def = source[FeatureDef__symbol];\n\n    return def == null\n        ? source as FeatureDef.Options\n        : this.meta(\n            typeof def === 'function' ? (source as FeatureDef.Factory)[FeatureDef__symbol](type) : def,\n            type,\n        );\n  }\n\n}\n\n/**\n * @internal\n */\nconst featureMeta = (/*#__PURE__*/ new FeatureMeta());\n\n/**\n * @internal\n */\nconst noFeatureDef: FeatureDef.Factory = {\n  [FeatureDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts feature definition options from its type.\n   *\n   * @param featureType - Target feature class constructor.\n   *\n   * @returns Feature definition options. May be empty when there is no feature definition found in the given\n   * `featureType`.\n   */\n  of(this: void, featureType: Class): FeatureDef.Options {\n    return featureMeta.of(featureType) || {};\n  },\n\n  /**\n   * Builds feature definition options for the given feature class.\n   *\n   * @param featureType - Target feature class constructor.\n   * @param def - A feature definition.\n   *\n   * @returns Feature definition options.\n   */\n  for(this: void, featureType: Class, def: FeatureDef): FeatureDef.Options {\n    return featureMeta.meta(def, featureType);\n  },\n\n  /**\n   * Merges multiple feature definition options.\n   *\n   * @param defs - Feature definition options to merge.\n   *\n   * @returns Merged feature definition options.\n   */\n  merge(this: void, ...defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return featureMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple feature definitions.\n   *\n   * @param defs - Feature definitions to merge.\n   *\n   * @returns Merged feature definition.\n   */\n  all(this: void, ...defs: readonly FeatureDef[]): FeatureDef {\n    return defs.reduce(\n        (prev, def) => ({\n          [FeatureDef__symbol](featureType: Class) {\n            return FeatureDef.merge(\n                FeatureDef.for(featureType, prev),\n                FeatureDef.for(featureType, def),\n            );\n          },\n        }),\n        noFeatureDef,\n    );\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeParam T - Feature type.\n   * @param featureType - Feature class constructor.\n   * @param defs - Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends Class>(this: void, featureType: T, ...defs: readonly FeatureDef[]): T {\n    return featureMeta.define(featureType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '@proc7ts/primitives';\nimport { TypedClassDecorator } from '../common';\nimport { FeatureDef } from './feature-def';\n\n/**\n * Feature class decorator.\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to {@link bootstrapComponents} function or referenced by other features.\n *\n * This is an alternative to direct call to {@link FeatureDef.define} method.\n *\n * @category Core\n * @typeParam T - A type of decorated feature class.\n * @param defs - Feature definitions.\n *\n * @returns A feature class decorator.\n */\nexport function Feature<T extends Class = any>(...defs: FeatureDef[]): TypedClassDecorator<T> {\n  return (type: T) => FeatureDef.define(type, ...defs);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { BootstrapContext, BootstrapSetup } from '../boot';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../component/definition';\nimport { FeatureRef } from './feature-ref';\n\n/**\n * @internal\n */\nconst FeatureContext__key = (/*#__PURE__*/ new SingleContextKey<FeatureContext>('feature-context'));\n\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nexport abstract class FeatureContext\n    extends BootstrapContext\n    implements BootstrapSetup, SupplyPeer {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext__key;\n  }\n\n  /**\n   * Feature class this context is created for.\n   */\n  abstract readonly feature: Class;\n\n  /**\n   * An `OnEvent` sender of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[FeatureContext]>;\n\n  /**\n   * An `OnEvent` sender of component definition events.\n   *\n   * The registered receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   */\n  abstract readonly onDefinition: OnEvent<[DefinitionContext]>;\n\n  /**\n   * An `OnEvent` sender of component construction events.\n   *\n   * The registered receiver will be notified right before component is constructed.\n   */\n  abstract readonly onComponent: OnEvent<[ComponentContext]>;\n\n  /**\n   * Feature supply.\n   *\n   * Cut off once feature unloaded.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * Provides bootstrap context value.\n   *\n   * Note that this happens when bootstrap context already exists. To provide a value before bootstrap context created\n   * a {@link BootstrapSetup.provide} method can be used.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   * @param spec - Context value specifier.\n   *\n   * @returns A value supply that removes the given context value specifier once cut off.\n   */\n  abstract provide<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<BootstrapContext, any, TDeps, TSrc, TSeed>,\n  ): Supply;\n\n  abstract perDefinition<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<DefinitionContext, any, TDeps, TSrc, TSeed>,\n  ): Supply;\n\n  abstract perComponent<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<ComponentContext, any, TDeps, TSrc, TSeed>,\n  ): Supply;\n\n  abstract setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]>;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  load(feature: Class): FeatureRef {\n    return this.get(BootstrapContext).load(feature);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '@proc7ts/primitives';\n\n/**\n * Feature need.\n *\n * Indicates why one feature needs another one. The reason can be one of:\n *\n * - `needs` when feature {@link FeatureDef.Options.needs depends} on another one, or\n * - `has` when feature {@link FeatureDef.Options.has provides} another one.\n *\n * @category Core\n */\nexport type FeatureNeed = [Class, 'needs' | 'has', Class];\n\n/**\n * An error in feature needs. I.e. circular dependency.\n *\n * @category Core\n */\nexport class FeatureNeedsError extends Error {\n\n  /**\n   * Feature needs causing this error.\n   */\n  readonly needs: readonly FeatureNeed[];\n\n  /**\n   * Constructs feature needs error.\n   *\n   * @param needs - Feature needs causing the error.\n   */\n  constructor(needs: readonly FeatureNeed[]) {\n    super(\n        'Circular feature needs: ' + needs.reduce(\n        (\n            prev,\n            [feature, reason, need],\n        ) => (prev ? prev : feature.name) + ` ${reason} ${need.name}`,\n        '',\n        ),\n    );\n    this.needs = needs;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper } from '@proc7ts/fun-events';\nimport { FeatureStatus } from './feature-status';\n\n/**\n * Dynamically loaded feature reference.\n *\n * It is returned from {@link BootstrapContext.load} and can be used to read feature load status and unload it.\n *\n * Implements an `EventKeeper` interface by sending a feature load status updates.\n *\n * @category Core\n */\nexport abstract class FeatureRef implements EventKeeper<[FeatureStatus]> {\n\n  /**\n   * A promise resolved when feature is unloaded.\n   *\n   * This happens after all feature references dismissed.\n   */\n  abstract readonly down: Promise<void>;\n\n  /**\n   * An `AfterEvent` keeper of feature load status.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[FeatureStatus]>;\n\n  [AfterEvent__symbol](): AfterEvent<[FeatureStatus]> {\n    return this.read;\n  }\n\n  /**\n   * Dismisses feature reference.\n   *\n   * When all feature references dismissed, then unloads the feature. This removes everything set up by the\n   * feature via {@link BootstrapSetup} and {@link DefinitionSetup}.\n   *\n   * @param reason - Arbitrary reason of feature reference dismiss. This will be reported by load status supplies\n   * as their cut off reason.\n   *\n   * @returns A promise resolved when feature is unloaded. This happens only after all feature references dismissed.\n   */\n  abstract dismiss(reason?: any): Promise<void>;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { mergeFunctions } from '@proc7ts/primitives';\nimport { MetaAccessor } from '../common';\nimport { FeatureDef, FeatureDef__symbol } from '../feature';\nimport { ComponentClass, DefinitionContext, DefinitionSetup, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = (/*#__PURE__*/ Symbol('component-def'));\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * This can be one of:\n * - custom element name (possibly qualified),\n * - component definition options,\n * - component definition holder,\n * - component definition factory,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport type ComponentDef<T extends object = any> =\n    | QualifiedName\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace ComponentDef {\n\n  /**\n   * Component definition options.\n   */\n  export interface Options<T extends object = any> {\n\n    readonly [ComponentDef__symbol]?: undefined;\n\n    /**\n     * Custom element name.\n     *\n     * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n     * name/namespace tuple.\n     *\n     * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n     * still can be mounted.\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Existing element to extend by custom one.\n     */\n    readonly extend?: ElementDef.Extend;\n\n    /**\n     * Additional feature definition options.\n     */\n    readonly feature?: FeatureDef.Options;\n\n    /**\n     * Sets up component definition.\n     *\n     * This method is called before component definition context constructed.\n     *\n     * @param setup - Component definition setup.\n     */\n    setup?(setup: DefinitionSetup<T>): void;\n\n    /**\n     * Defines this component by calling the given component definition context methods.\n     *\n     * This function is called before the custom element is defined.\n     *\n     * @param defContext - Component definition context.\n     */\n    define?(defContext: DefinitionContext<T>): void;\n\n  }\n\n  /**\n   * Component definition holder.\n   *\n   * @typeParam T - A type of component.\n   */\n  export interface Holder<T extends object = any> {\n\n    /**\n     * The component definition this holder contains.\n     */\n    readonly [ComponentDef__symbol]: ComponentDef<T>;\n\n  }\n\n  /**\n   * Component definition factory.\n   *\n   * @typeParam T - A type of component.\n   */\n  export interface Factory<T extends object = any> {\n\n    /**\n     * Builds component definition.\n     *\n     * @param componentType - A component class constructor to build definition for.\n     *\n     * @returns Built component definition.\n     */\n    [ComponentDef__symbol](componentType: ComponentClass<T>): ComponentDef<T>;\n\n  }\n\n}\n\n/**\n * @internal\n */\ntype ComponentDefHolder<T extends object> =\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | { [ComponentDef__symbol]?: undefined };\n\n/**\n * @internal\n */\ntype FeatureDefHolder =\n    | FeatureDef.Holder\n    | FeatureDef.Factory\n    | { [FeatureDef__symbol]?: undefined };\n\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor<ComponentDef.Options, ComponentDef> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(defs: readonly ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return defs.reduce(\n        (prev, def) => ({\n          ...prev,\n          ...def,\n          setup: mergeFunctions(prev.setup, def.setup),\n          define: mergeFunctions(prev.define, def.define),\n          feature: prev.feature\n              ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n              : def.feature,\n        }),\n        {},\n    );\n  }\n\n  meta<T extends object>(source: ComponentDef<T>, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n\n    const def = (source as ComponentDefHolder<T>)[ComponentDef__symbol];\n\n    if (def != null) {\n      return this.meta(\n          typeof def === 'function' ? (source as ComponentDef.Factory<T>)[ComponentDef__symbol](componentType) : def,\n          componentType,\n      );\n    }\n    if ((source as FeatureDefHolder)[FeatureDef__symbol] != null) {\n      return {\n        feature: FeatureDef.for(componentType, source as FeatureDef),\n      };\n    }\n    if (isQualifiedName(source)) {\n      return { name: source };\n    }\n\n    return source as ComponentDef.Options<T>;\n  }\n\n}\n\n/**\n * @internal\n */\nconst componentMeta = (/*#__PURE__*/ new ComponentMeta());\n\n/**\n * @internal\n */\nconst noComponentDef: ComponentDef.Factory = {\n  [ComponentDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts component definition options from its type.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Target component class constructor.\n   *\n   * @returns Component definition options. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(this: void, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n    return componentMeta.of(componentType) as ComponentDef.Options<T> || {};\n  },\n\n  /**\n   * Builds component definition options for the given component class.\n   *\n   * @param componentType - Target component class constructor.\n   * @param source - A source of component definition.\n   *\n   * @returns Component definition.\n   */\n  for<T extends object>(\n      this: void,\n      componentType: ComponentClass<T>,\n      source: ComponentDef<T>,\n  ): ComponentDef.Options<T> {\n    return componentMeta.meta(source, componentType);\n  },\n\n  /**\n   * Merges multiple component definition options.\n   *\n   * @typeParam T - A type of component.\n   * @param defs - Component definition options to merge.\n   *\n   * @returns Merged component definition options.\n   */\n  merge<T extends object>(this: void, ...defs: ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return componentMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple component definitions.\n   *\n   * @typeParam T - A type of component.\n   * @param defs - Component definitions to merge.\n   *\n   * @returns Merged component definition.\n   */\n  all<T extends object>(this: void, ...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return defs.reduce<ComponentDef.Factory<T>>(\n        (prev, def) => ({\n          [ComponentDef__symbol](componentType: ComponentClass<T>) {\n            return ComponentDef.merge(\n                ComponentDef.for(componentType, prev),\n                ComponentDef.for(componentType, def),\n            );\n          },\n        }),\n        noComponentDef,\n    );\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends existing component definition and stores it under {@link ComponentDef__symbol} key.\n   *\n   * Each component can be passed directly to {@link bootstrapComponents} function or added as a requirement\n   * of another feature.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Component class constructor.\n   * @param defs - Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends ComponentClass>(\n      this: void,\n      componentType: T,\n      ...defs: ComponentDef<InstanceType<T>>[]\n  ): T {\n    return componentMeta.define(componentType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '@proc7ts/primitives';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * Component decorator interface.\n *\n * In addition to being a decorator for component class, it may also serve as {@link ComponentDef component definition}.\n * Thus it can be added as parameter to {@link Component @Component} decorator, or used as class decorator by itself.\n *\n * Constructed by {@link Component} function.\n *\n * @category Core\n * @typeParam T - A type of decorated component class.\n */\nexport type ComponentDecorator<T extends ComponentClass = Class> =\n    & ((this: void, type: T) => T | void)\n    & ComponentDef<InstanceType<T>>;\n\n/**\n * Decorator of component class.\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with {@link FeatureContext.define} method or used as a feature, e.g. passed to\n * {@link bootstrapComponents} function, or added to {@link FeatureDef.Options.needs} property of another feature.\n *\n * This is an alternative to direct call to {@link ComponentDef.Options.define} method.\n *\n * @category Core\n * @typeParam T - A type of decorated component class.\n * @param defs - Component definitions.\n *\n * @returns A component class decorator.\n */\nexport function Component<T extends ComponentClass = Class>(\n    ...defs: ComponentDef<InstanceType<T>>[]\n): ComponentDecorator<T> {\n\n  const decorator = ((type: T) => ComponentDef.define(type, ...defs)) as ComponentDecorator<T>;\n  const def = decorator as ComponentDef.Factory<InstanceType<T>>;\n\n  def[ComponentDef__symbol] = () => ComponentDef.all(...defs);\n\n  return decorator;\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = (/*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context'));\n","import { DomEventDispatcher, OnDomEvent } from '@frontmeans/dom-events';\nimport { SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher } from './component-event';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = (/*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault(values) {\n\n        const context = values.get(ComponentContext__key);\n        const dispatcher = new DomEventDispatcher(context.element);\n\n        dispatcher.supply.needs(context);\n\n        return {\n          dispatch(event: Event): boolean {\n            return dispatcher.dispatch(event);\n          },\n          on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * Either element itself, or its shadow root.\n *\n * @category Core\n */\nexport type ContentRoot = Element | ShadowRoot;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = (/*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx): ContentRoot {\n        return ctx.get(ComponentContext__key).element as ContentRoot;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper, statePath, StatePath } from '@proc7ts/fun-events';\nimport { mergeFunctions, noop } from '@proc7ts/primitives';\n\n/**\n * Component state updater signature.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeParam TValue - Updated value type\n * @param path - Updated state node path.\n * @param newValue - New value.\n * @param oldValue - Replaced value.\n */\n    <TValue>(this: void, path: StatePath, newValue: TValue, oldValue: TValue) => void;\n\nexport namespace StateUpdater {\n\n  /**\n   * Normalized component state updater signature.\n   *\n   * Accepts normalized state path.\n   */\n  export type Normalized =\n  /**\n   * @typeParam TValue - Updated value type\n   * @param path - Normalized path of updated state node.\n   * @param newValue - New value.\n   * @param oldValue - Replaced value.\n   */\n      <TValue>(this: void, path: StatePath.Normalized, newValue: TValue, oldValue: TValue) => void;\n\n}\n\n/**\n * @internal\n */\nclass StateUpdaterKey extends ContextUpKey<StateUpdater, StateUpdater.Normalized> {\n\n  readonly upKey: ContextUpKey.UpKey<StateUpdater, StateUpdater.Normalized>;\n\n  constructor() {\n    super('state-updater');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...fns) => {\n              if (fns.length) {\n\n                const combined: StateUpdater.Normalized = fns.reduce(\n                    (prev, fn) => mergeFunctions(fn, prev),\n                    noop,\n                );\n\n                return afterThe((path, newValue, oldValue) => combined(statePath(path), newValue, oldValue));\n              }\n\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n\n              return afterThe(noop);\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          StateUpdater,\n          EventKeeper<StateUpdater.Normalized[]> | StateUpdater.Normalized,\n          AfterEvent<StateUpdater.Normalized[]>>,\n  ): void {\n\n    let delegated: StateUpdater;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        fn => delegated = fn,\n    ).whenOff(\n        () => delegated = noop,\n    );\n\n    slot.insert((path, newValue, oldValue) => delegated(path, newValue, oldValue));\n  }\n\n}\n\n/**\n * A key of component context value containing a component {@link StateUpdater state updater} function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Does nothing by default and after component destruction.\n *\n * When multiple state updaters provided, they all will be called on each state update, in reverse order.\n *\n * @category Core\n */\nexport const StateUpdater: ContextUpRef<StateUpdater, StateUpdater.Normalized> = (/*#__PURE__*/ new StateUpdaterKey());\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { OnDomEvent } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport { OnEvent, StatePath } from '@proc7ts/fun-events';\nimport { Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentMount } from './component-mount';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of a custom element and component properties containing a reference to component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = (/*#__PURE__*/ Symbol('component-context'));\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * {@link BootstrapSetup.perComponent}} and {@link DefinitionSetup.perComponent} methods.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues implements SupplyPeer {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Extracts component context from its custom element or from component itself.\n   *\n   * @param element - Custom element instance created for the component or the component itself.\n   *\n   * @return Component context reference stored under {@link ComponentContext__symbol} key.\n   *\n   * @throws TypeError  When the given `element` does not contain component context reference.\n   */\n  static of<T extends object>(element: any): ComponentContext<T> {\n\n    const context = (element as ComponentContextHolder<T>)[ComponentContext__symbol];\n\n    if (!context) {\n      throw TypeError(`No component context found in ${String(element)}`);\n    }\n\n    return context;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.whenComponent component instantiation event} receiver. A {@link whenReady} callback\n   * could be utilized to work this around.\n   */\n  abstract readonly component: T;\n\n  /**\n   * Component mount.\n   *\n   * This is set when component is mounted to arbitrary element by {@link DefinitionContext.mountTo}. It is `undefined`\n   * for components created in standard way.\n   */\n  abstract readonly mount: ComponentMount<T> | undefined;\n\n  /**\n   * Whether the component is settled.\n   *\n   * Component settlement happens:\n   * - when {@link settle} method is called,\n   * - when component is {@link DefinitionContext.mountTo mounted} to element, or\n   * - when component's element is {@link connected}.\n   *\n   * It is guaranteed that component settlement won't happen inside custom element's constructor. So the settlement\n   * event may be used e.g. to start DOM manipulations, as the latter is prohibited inside custom element constructor.\n   *\n   * This becomes `true` right before {@link whenSettled} event is sent.\n   */\n  abstract readonly settled: boolean;\n\n  /**\n   * Whether the component's element is connected.\n   *\n   * This becomes `true` right before {@link whenConnected} event is sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An `OnEvent` sender of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component settlement event.\n   *\n   * The registered receiver is called when component is {@link settled}. If settled already the receiver is called\n   * immediately.\n   */\n  abstract readonly whenSettled: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. I.e. when custom element's\n   * `connectedCallback()` method is called, or when the element this component is {@link mount mounted to} is\n   * {@link ComponentMount.connect connected}.\n   *\n   * If connected already the receiver is called immediately.\n   */\n  abstract readonly whenConnected: OnEvent<[this]>;\n\n  /**\n   * An event supply that {@link destroy destroys} component when cut off.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * @typeParam TValue - A type of changed value.\n   * @param key - Changed value key.\n   * @param newValue - New value.\n   * @param oldValue - Previous value.\n   */\n  readonly updateState: StateUpdater;\n\n  constructor() {\n    super();\n    this.updateState = <TValue>(key: StatePath, newValue: TValue, oldValue: TValue): void => {\n      this.get(StateUpdater)(key, newValue, oldValue);\n    };\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): ContentRoot {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Settles component.\n   *\n   * Calling this method has no effect if component is {@link settled} already, when component is not\n   * {@link whenReady ready} yet, or custom element's constructor is not exited.\n   *\n   * Calling this method may trigger DOM manipulations (the latter is prohibited inside custom element's constructor).\n   * This may be desired for rendering optimizations. E.g. to render element's content _before_ adding it to document.\n   *\n   * This method is called automatically when {@link DefinitionContext.mountTo mounting} component to element.\n   */\n  abstract settle(): void;\n\n  /**\n   * Returns a DOM event producer for the given event type.\n   *\n   * This is a shorthand for invoking a component event producer function available under\n   * `[ComponentEventProducer.key]` key.\n   *\n   * @typeParam TEvent - DOM event type.\n   * @param type - An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n    return this.get(ComponentEventDispatcher__key).on(type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * This is a shorthand for invoking a component {@link ComponentEventDispatcher event dispatcher}.\n   *\n   * @param event - An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(ComponentEventDispatcher__key).dispatch(event);\n  }\n\n  /**\n   * Destroys the component.\n   *\n   * Removes element from the DOM tree. I.e. disconnects custom element first.\n   *\n   * After this method call the component should no longer be used.\n   *\n   * Note that component destruction is virtual. It is up to developer to decide when component is no longer needed.\n   * However the component is destroyed automatically once disconnected, i.e. when custom element's\n   * `disconnectedCallback()` method is called.\n   *\n   * @param reason - Optional reason of destruction.\n   */\n  abstract destroy(reason?: any): void;\n\n}\n\n/**\n * An object potentially containing component context.\n *\n * Either element or component instance.\n */\nexport interface ComponentContextHolder<T extends object = any> {\n  [ComponentContext__symbol]?: ComponentContext<T>;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { OnDomEvent } from '@frontmeans/dom-events';\nimport { SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\n\n/**\n * Component event.\n *\n * Events of this type are thrown by various services to inform on component status changes.\n *\n * It is illegal to dispatch such events for elements not bound to components. It is reasonable to dispatch events\n * using {@link ComponentEventDispatcher} available in component context.\n *\n * The following event types supported:\n * - `wesib:component` is dispatched when component is bound to element. I.e. when HTML element is upgraded to custom\n *   one defined by component, or component is mounted to element. The event is dispatched when component is connected\n *   for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Core\n * @event ComponentEvent#wesib:component\n */\nexport class ComponentEvent extends Event {\n\n  /**\n   * Target component context.\n   */\n  get context(): ComponentContext {\n    return ComponentContext.of(this.target);\n  }\n\n}\n\n/**\n * Component event dispatcher is used to listen for and dispatch component events.\n *\n * It is available in bootstrap context context.\n *\n * By default treats a component element as event target.\n *\n * @category Core\n */\nexport interface ComponentEventDispatcher {\n\n  /**\n   * Dispatches the DOM event for the given component.\n   *\n   * @param event - An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(event: Event): boolean;\n\n  /**\n   * Returns an `OnDomEvent` sender of DOM events of the given type.\n   *\n   * @typeParam TEvent - DOM event type.\n   * @param type - An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<TEvent extends Event>(type: string): OnDomEvent<TEvent>;\n\n}\n\n/**\n * A key of component context value containing component event dispatcher.\n *\n * @category Core\n */\nexport const ComponentEventDispatcher: SingleContextRef<ComponentEventDispatcher> = ComponentEventDispatcher__key;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class, PropertyAccessorDescriptor, valueProvider } from '@proc7ts/primitives';\nimport { decoratePropertyAccessor } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { Component, ComponentDecorator } from './component.decorator';\nimport { ComponentClass } from './definition';\n\n/**\n * Component property decorator interface.\n *\n * Allows to construct a {@link ComponentDecorator component decorator} by declaring a virtual property to use instead\n * of decorated one.\n *\n * Constructed by {@link ComponentProperty} function.\n *\n * @category Core\n * @typeParam TValue - Property value type.\n * @typeParam T - A type of decorated component class.\n */\nexport interface ComponentPropertyDecorator<TValue, T extends ComponentClass = Class> {\n\n  /**\n   * Decorates component method.\n   *\n   * @typeParam TPropValue - Property value type.\n   * @param proto - Decorated class prototype.\n   * @param propertyKey - Decorated property key.\n   * @param descriptor - Decorated property descriptor.\n   *\n   * @returns  Either updated property descriptor, or nothing.\n   */\n  // eslint-disable-next-line\n  <TPropValue extends TValue>(\n      this: void,\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<TPropValue>,\n  ): any | void;\n\n  /**\n   * Builds component decorator assuming the virtual property has the given value.\n   *\n   * @param value - Virtual property value.\n   * @param key - Virtual property key. Defaults to {@link AnonymousComponentProperty__symbol}.\n   *\n   * @returns New component decorator.\n   */\n  As(\n      this: void,\n      value: TValue,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the virtual property value is provided by the given `provider`.\n   *\n   * @param provider - Virtual property read-only value provider.\n   * @param key - Virtual property key. Defaults to {@link AnonymousComponentProperty__symbol}.\n   *\n   * @returns New component decorator.\n   */\n  By(\n      this: void,\n      provider: ComponentProperty.Provider<TValue, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is available via the given `accessor`.\n   *\n   * @param accessor - Virtual property accessor.\n   * @param key - Virtual property key. Defaults to {@link AnonymousComponentProperty__symbol}.\n   *\n   * @returns New component decorator.\n   */\n  With(\n      this: void,\n      accessor: ComponentProperty.Accessor<TValue, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is bound to component with by the given `binder`.\n   *\n   * @param binder - A binder of virtual property accessor\n   * @param key - Virtual property key. Defaults to {@link AnonymousComponentProperty__symbol}..\n   *\n   * @returns New component decorator.\n   */\n  Bind(\n      this: void,\n      binder: ComponentProperty.Binder<TValue, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n}\n\nexport namespace ComponentProperty {\n\n  /**\n   * Component property value provider signature.\n   *\n   * This function will be called each time the property value is requested.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component.\n   */\n  export type Provider<TValue, T extends object = any> =\n  /**\n   * @param component - Component instance.\n   * @param key - Target property key.\n   *\n   * @returns Property value.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => TValue;\n\n  /**\n   * Component property accessor.\n   *\n   * Allows to read and write property value.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component.\n   */\n  export interface Accessor<TValue, T extends object = any> {\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component - Target component instance.\n     * @param key - Property key.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: T, key: string | symbol): TValue;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component - Target component instance.\n     * @param value - New property value.\n     * @param key - Property key.\n     */\n    set(this: void, component: T, value: TValue, key: string | symbol): void;\n\n  }\n\n  /**\n   * Property accessor binder signature.\n   *\n   * This is a function that binds a {@link BoundAccessor property accessor} to target component.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component.\n   */\n  export type Binder<TValue, T extends object = any> =\n  /**\n   * @param component - Target component to bind property accessor to.\n   * @param key - Property key.\n   *\n   * @returns Property accessor bound to `component`.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => BoundAccessor<TValue>;\n\n  export interface BoundAccessor<TValue> {\n\n    /**\n     * Reads bound component's property value.\n     *\n     * An attempt to read the value would throw when omitted.\n     *\n     * @returns Property value.\n     */\n    get?(): TValue;\n\n    /**\n     * Assigns bound component's new property value.\n     *\n     * An attempt to assign the value would throw when omitted.\n     *\n     * @param value - New property value.\n     */\n    set?(value: TValue): void;\n\n  }\n\n  /**\n   * Component property descriptor.\n   *\n   * Passed to {@link Definer property definer} by {@link ComponentProperty} function to construct a {@link Definition\n   * property definition}.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component class.\n   */\n  export interface Descriptor<TValue, T extends ComponentClass = Class> {\n\n    /**\n     * Component class constructor.\n     */\n    readonly type: T;\n\n    /**\n     * Component property key.\n     */\n    readonly key: string | symbol;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.get property read definition}.\n     */\n    readonly readable: boolean;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.set property assignment definition}.\n     */\n    readonly writable: boolean;\n\n    /**\n     * Whether the property is initially enumerable.\n     *\n     * This can be changed by {@link Definition.enumerable property definition}.\n     */\n    readonly enumerable: boolean;\n\n    /**\n     * Whether the property is initially configurable.\n     *\n     * This can be changed by {@link Definition.configurable property definition}.\n     */\n    readonly configurable: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component - Target component instance.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: InstanceType<T>): TValue;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component - Target component instance.\n     * @param value - New property value.\n     */\n    set(this: void, component: InstanceType<T>, value: TValue): void;\n\n  }\n\n  /**\n   * Component property definition builder signature.\n   *\n   * This is a function called by {@link ComponentProperty} to define the property.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component class.\n   */\n  export type Definer<TValue, T extends ComponentClass = Class> =\n  /**\n   * @param descriptor - Component property descriptor.\n   *\n   * @returns Component property definition. Or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<TValue, T>,\n      ) => Definition<TValue, T> | void;\n\n  /**\n   * Property definition to apply to existing property.\n   *\n   * When applying to decorated property, this definition updates its definition.\n   *\n   * When applying to virtual property assumed by one of {@link ComponentPropertyDecorator} methods, most of returned\n   * values ignored. Except for {@link Definition.componentDef component definition}, {@link Definition.get value\n   * reader}, and {@link Definition.set value setter}.\n   *\n   * @typeParam TValue - Property value type.\n   * @typeParam T - A type of component class.\n   */\n  export interface Definition<TValue, T extends ComponentClass = Class> {\n\n    /**\n     * Component definition to apply to component.\n     *\n     * When specified, it is used to enable certain functionality for decorated (or virtual) property.\n     */\n    readonly componentDef?: ComponentDef<InstanceType<T>>;\n\n    /**\n     * Whether to make the property enumerable.\n     *\n     * When specified, it is used as `enumerable` attribute value of decorated property descriptor.\n     */\n    readonly enumerable?: boolean;\n\n    /**\n     * Whether to make the property configurable.\n     *\n     * When specified, it is used as `configurable` attribute value of decorated property descriptor.\n     */\n    readonly configurable?: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * When specified it changes how the property value is read.\n     *\n     * When neither {@link get}, nor {@link set} specified, the property access does not change.\n     *\n     * @param component - Target component instance.\n     * @param key - Property key.\n     *\n     * @returns Property value.\n     */\n    get?(this: void, component: InstanceType<T>, key: string | symbol): TValue;\n\n    /**\n     * Assigns new property value.\n     *\n     * When specified it changes how the property value is assigned.\n     *\n     * When neither {@link get}, nor {@link set} specified, the property access does not change.\n     *\n     * @param component - Target component instance.\n     * @param value - New property value.\n     * @param key - Property key.\n     */\n    set?(this: void, component: InstanceType<T>, value: TValue, key: string | symbol): void;\n\n  }\n\n}\n\n/**\n * Anonymous component property key.\n *\n * Used as a default virtual property key.\n *\n * @category Core\n */\nexport const AnonymousComponentProperty__symbol = (/*#__PURE__*/ Symbol('anonymous-component-property'));\n\n/**\n * Decorator of component property.\n *\n * Updates decorated property and component definition. Can be converted to {@link ComponentDecorator component\n * decorator} by calling appropriate method of returned decorator instance.\n *\n * @category Core\n * @typeParam TValue - Decorated property value type.\n * @typeParam T - A type of decorated component class.\n * @param define - Component property definition builder.\n *\n * @returns Component property decorator.\n */\nexport function ComponentProperty<TValue, T extends ComponentClass = Class>(\n    define: ComponentProperty.Definer<TValue, T>,\n): ComponentPropertyDecorator<TValue, T> {\n\n  const decorator = (\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<TValue>,\n  ): any | void => decoratePropertyAccessor(\n      proto,\n      propertyKey,\n      descriptor,\n      desc => {\n\n        const { get: getValue, set: setValue } = desc;\n        const type = proto.constructor as T;\n        const { get, set, configurable, enumerable, componentDef = {} } = define({\n          type,\n          key: propertyKey,\n          readable: !!desc.get,\n          writable: !!desc.set,\n          enumerable: !!desc.enumerable,\n          configurable: !!desc.configurable,\n          get: getValue\n              ? ((component: InstanceType<T>) => getValue.call(component))\n              : notReadableAccessor(propertyKey),\n          set: setValue\n              ? ((component, value) => setValue.call(component, value))\n              : notWritableAccessor(propertyKey),\n        }) || {};\n\n        ComponentDef.define(type, componentDef);\n\n        const updated: PropertyAccessorDescriptor<TValue> = {\n          ...desc,\n          configurable: configurable ?? desc.configurable,\n          enumerable: enumerable ?? desc.enumerable,\n        };\n\n        if (get || set) {\n          updated.get = get && function (this: InstanceType<T>) {\n            return get(this, propertyKey);\n          };\n          updated.set = set && function (this: InstanceType<T>, value: TValue) {\n            set(this, value, propertyKey);\n          };\n        }\n\n        return updated;\n      },\n  );\n  const decorateWith = (\n      { get, set }: ComponentProperty.Accessor<TValue, InstanceType<T>>,\n      key: string | symbol = AnonymousComponentProperty__symbol,\n      writable: boolean,\n  ): ComponentDecorator<T> => Component({\n    [ComponentDef__symbol](type: InstanceType<T>) {\n\n      const def = define({\n        type,\n        key,\n        readable: true,\n        writable,\n        enumerable: false,\n        configurable: false,\n        get: component => get(component, key),\n        set: (component, value) => set(component, value, key),\n      });\n\n      return (def && def.componentDef) || {};\n    },\n  });\n  const By = (\n      provider: ComponentProperty.Provider<TValue, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T> => decorateWith(\n      {\n        get(component, key) {\n          return provider(component, key);\n        },\n      } as ComponentProperty.Accessor<TValue>,\n      key,\n      false,\n  );\n\n  const result = decorator as ComponentPropertyDecorator<TValue, T>;\n\n  result.With = (access, key) => decorateWith(access, key, true);\n  result.By = By;\n  result.As = (value, key?) => By(valueProvider(value), key);\n  result.Bind = (binder, key = AnonymousComponentProperty__symbol) => {\n\n    const accessor__symbol = Symbol(`${String(key)}:accessor`);\n\n    interface HostComponent {\n      [accessor__symbol]?: {\n        get(): TValue;\n        set(value: TValue): void;\n      };\n    }\n\n    const accessor = (component: HostComponent): {\n      get(): TValue;\n      set(value: TValue): void;\n    } => {\n\n      const existing = component[accessor__symbol];\n\n      if (existing) {\n        return existing;\n      }\n\n      const accessor = binder(component as InstanceType<T>, key);\n\n      return component[accessor__symbol] = {\n        get: accessor.get ? accessor.get.bind(accessor) : notReadableAccessor(key),\n        set: accessor.set ? accessor.set.bind(accessor) : notWritableAccessor(key),\n      };\n    };\n\n    return decorateWith(\n        {\n          get(component) {\n            return accessor(component).get();\n          },\n          set(component, value) {\n            return accessor(component).set(value);\n          },\n        },\n        key,\n        true,\n    );\n  };\n\n  return result;\n}\n\n/**\n * @internal\n */\nfunction notReadableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not readable`); };\n}\n\n/**\n * @internal\n */\nfunction notWritableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not writable`); };\n}\n","import {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  SingleContextKey,\n} from '@proc7ts/context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapContextRegistry__key = (\n    /*#__PURE__*/ new SingleContextKey<BootstrapContextRegistry>('bootstrap-context-registry')\n);\n\n/**\n * @internal\n */\nexport class BootstrapContextRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapContextRegistry> {\n    return BootstrapContextRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapContextRegistry {\n    return new BootstrapContextRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapContextRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextRef, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nexport type PerComponentRegistry = ComponentContextRegistry;\n\nexport const PerComponentRegistry: ContextRef<PerComponentRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentContextRegistry>(\n    'per-component-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n    },\n));\n\n/**\n * @internal\n */\nexport class ComponentContextRegistry extends ContextRegistry<ComponentContext> {\n}\n","import { ContextRef, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\n/**\n * @internal\n */\nexport type PerDefinitionRegistry = DefinitionContextRegistry;\n\n/**\n * @internal\n */\nexport const PerDefinitionRegistry: ContextRef<PerDefinitionRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<DefinitionContextRegistry>(\n    'per-definition-registry',\n    {\n      byDefault: bootstrapDefault(bsContext => new DefinitionContextRegistry(bsContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class DefinitionContextRegistry extends ContextRegistry<DefinitionContext> {\n}\n","import { EventEmitter, onAny, OnEvent, onEventBy, supplyOn, trackValue, valueOn } from '@proc7ts/fun-events';\nimport { asis, superClassOf, Supply } from '@proc7ts/primitives';\nimport { ComponentDef__symbol } from '../../component';\nimport { ComponentClass, DefinitionSetup } from '../../component/definition';\n\n/**\n * @internal\n */\nexport function onPostDefSetup(\n    componentType: ComponentClass,\n    supply: Supply,\n): OnEvent<[DefinitionSetup]> {\n\n  const { on } = postDefSetup(componentType);\n\n  return onEventBy(receiver => {\n    on({\n      supply: receiver.supply.needs(supply),\n      receive(ctx, setup) {\n\n        const whenReady = setup.whenReady.do(supplyOn(supply));\n        const whenComponent = setup.whenComponent.do(supplyOn(supply));\n\n        receiver.receive(ctx, {\n          get componentType() {\n            return setup.componentType;\n          },\n          get whenReady() {\n            return whenReady;\n          },\n          get whenComponent() {\n            return whenComponent;\n          },\n          perDefinition(spec) {\n            return setup.perDefinition(spec).needs(supply);\n          },\n          perComponent(spec) {\n            return setup.perComponent(spec).needs(supply);\n          },\n        });\n      },\n    });\n  });\n}\n\n/**\n * @internal\n */\nexport interface PostDefSetup<T extends object = any> {\n  readonly on: OnEvent<[DefinitionSetup<T>]>;\n  send(setup: DefinitionSetup): void;\n  setup(setup: DefinitionSetup<T>): void;\n}\n\nconst PostDefSetup__symbol = (/*#__PURE__*/ Symbol('post-def-setup'));\n\ninterface PostDefComponentClass<T extends object> extends ComponentClass<T> {\n  [PostDefSetup__symbol]?: PostDefSetup<T>;\n}\n\n/**\n * @internal\n */\nexport function postDefSetup<T extends object>(componentType: PostDefComponentClass<T>): PostDefSetup<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(PostDefSetup__symbol)) {\n    return componentType[PostDefSetup__symbol] as PostDefSetup<T>;\n  }\n\n  const tracker = trackValue<DefinitionSetup<T>>();\n  const emitter = new EventEmitter<[DefinitionSetup]>();\n  const onSetup: OnEvent<[DefinitionSetup<T>]> = tracker.read.do(valueOn(asis));\n  const on = onAny(onSetup, emitter);\n  const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n\n  if (superType) {\n\n    const superPostDefSetup = postDefSetup(superType);\n\n    on(setup => superPostDefSetup.send(setup));\n  }\n\n  const result: PostDefSetup<T> = {\n    on,\n    send(setup) {\n      emitter.send(setup);\n    },\n    setup(setup) {\n      tracker.it = setup;\n    },\n  };\n\n  Object.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window & typeof globalThis;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = (/*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * A window (e.g. DOM) element all bootstrapped components belong to.\n *\n * @category Core\n */\nexport type BootstrapRoot = Element;\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of {@link BootstrapWindow}.\n *\n * @category Core\n */\nexport const BootstrapRoot: SingleContextRef<BootstrapRoot> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> = (\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { ContextValues, ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * Default rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nclass DefaultRenderSchedulerKey extends ContextUpKey<DefaultRenderScheduler, RenderScheduler> {\n\n  readonly upKey: ContextUpKey.UpKey<DefaultRenderScheduler, RenderScheduler>;\n\n  constructor() {\n    super('default-render-scheduler');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...fns) => {\n              if (fns.length) {\n                return afterThe(toDefaultRenderScheduler(slot.context, fns[fns.length - 1]));\n              }\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n              return afterThe(toDefaultRenderScheduler(slot.context, newRenderSchedule));\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          DefaultRenderScheduler,\n          EventKeeper<RenderScheduler[]> | RenderScheduler,\n          AfterEvent<RenderScheduler[]>>,\n  ): void {\n\n    let delegated: DefaultRenderScheduler;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        scheduler => delegated = toDefaultRenderScheduler(slot.context, scheduler),\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toDefaultRenderScheduler(\n    context: ContextValues,\n    scheduler: RenderScheduler,\n): DefaultRenderScheduler {\n  return (options = {}) => scheduler({\n    ...options,\n    window: options.window || context.get(BootstrapWindow),\n  });\n}\n\n/**\n * A key of bootstrap, definition, or component context value containing {@link DefaultRenderScheduler} instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window}.\n *\n * @category Core\n */\nexport const DefaultRenderScheduler: ContextUpRef<DefaultRenderScheduler, RenderScheduler> = (\n    /*#__PURE__*/ new DefaultRenderSchedulerKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { ComponentContext, ComponentContext__symbol, ComponentContextHolder } from '../../component';\n\n/**\n * Element adapter is a function able to convert a raw element to component. E.g. mount a component to it.\n *\n * Features may use it internally. E.g. an `AutoConnectSupport` applies it to each added DOM element.\n *\n * Multiple element adapters can be registered in bootstrap context.\n *\n * @category Core\n */\nexport type ElementAdapter =\n/**\n * @param element - Target raw element to adapt.\n *\n * @returns An adapted component's context, or `undefined` if element can not be adapted.\n */\n    (this: void, element: any) => ComponentContext | undefined;\n\n/**\n * @internal\n */\nclass ElementAdapterKey extends ContextUpKey<ElementAdapter, ElementAdapter> {\n\n  readonly upKey: ContextUpKey.UpKey<ElementAdapter, ElementAdapter>;\n\n  constructor() {\n    super('element-adapter');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter((...adapters) => {\n\n          const combined: ElementAdapter = adapters.reduce(\n              (prev, adapter) => element => prev(element) || adapter(element),\n              defaultElementAdapter,\n          );\n\n          if (combined !== defaultElementAdapter) {\n            return afterThe(combined);\n          }\n          if (slot.hasFallback && slot.or) {\n            return slot.or;\n          }\n\n          return afterThe(defaultElementAdapter);\n        }))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          ElementAdapter,\n          EventKeeper<ElementAdapter[]> | ElementAdapter,\n          AfterEvent<ElementAdapter[]>>,\n  ): void {\n\n    let delegated: ElementAdapter;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        adapter => delegated = adapter,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert(element => delegated(element));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultElementAdapter(element: ComponentContextHolder): ComponentContext | undefined {\n  return element[ComponentContext__symbol];\n}\n\n/**\n * A key of bootstrap context value containing combined {@link ElementAdapter} instance.\n *\n * @category Core\n */\nexport const ElementAdapter: ContextUpRef<ElementAdapter, ElementAdapter> = (/*#__PURE__*/ new ElementAdapterKey());\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FnContextKey } from '@proc7ts/context-values/updatable';\nimport { filterArray, itsEach, overArray } from '@proc7ts/push-iterator';\nimport { isElement } from '../../common';\nimport { ComponentContext__symbol, ComponentContextHolder, ComponentMount } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ElementAdapter } from './element-adapter';\n\n/**\n * Element mutations observer.\n *\n * It is a `MutationObserver` implementation that:\n * - always observes target's children,\n * - applies {@link ElementAdapter element adapter} to added elements,\n * - tracks mounted components {@link ComponentMount.connected connection state}.\n *\n * A function constructing element observer instance could be obtained from bootstrap context.\n *\n * @category Core\n */\nexport interface ElementObserver extends MutationObserver {\n\n  /**\n   * Configures the observer callback to begin receiving notifications of changes to the DOM that match the given\n   * options.\n   * To stop the MutationObserver (so that none of its callbacks will be triggered any longer), call\n   * {@link disconnect}.\n   *\n   * @param target - A DOM node within the DOM tree to watch for changes, and to be the root of a subtree of nodes\n   * to be watched.\n   * @param options - An options that describe what DOM mutations should be reported to the observer's callback.\n   */\n  observe(target: Node, options?: ElementObserverInit): void;\n\n}\n\n/**\n * A key of bootstrap context value containing a function constructing a new {@link ElementObserver} instance.\n *\n * @category Core\n */\nexport const ElementObserver: FnContextKey<[MutationCallback], ElementObserver> = (/*#__PURE__*/ new FnContextKey(\n    'element-observer',\n    {\n      byDefault: bootstrapDefault(bsContext => {\n\n        const adapter = bsContext.get(ElementAdapter);\n        class DefaultElementObserver extends MutationObserver implements ElementObserver {\n\n          constructor(callback: MutationCallback) {\n            super(mutations => {\n              mutations.forEach(mutation => {\n                itsEach(\n                    overArray(mutation.removedNodes),\n                    node => mountOf(node as ComponentContextHolder)?.checkConnected(),\n                );\n                itsEach(\n                    filterArray(mutation.addedNodes, isElement),\n                    element => adapter(element)?.mount?.checkConnected(),\n                );\n              });\n              callback(mutations, this);\n            });\n          }\n\n          observe(target: Node, options?: ElementObserverInit): void {\n            super.observe(target, { ...options, childList: true });\n          }\n\n        }\n\n        return callback => new DefaultElementObserver(callback);\n      }),\n    },\n));\n\n/**\n * Element observer initialization options.\n *\n * @category Core\n */\nexport interface ElementObserverInit extends MutationObserverInit {\n\n  /**\n   * Whether mutations to target's children are to be observed.\n   *\n   * Always `true`.\n   */\n  childList?: true;\n\n}\n\n/**\n * @internal\n */\nfunction mountOf(node: ComponentContextHolder): ComponentMount | undefined {\n  return node[ComponentContext__symbol]?.mount;\n}\n","import { ComponentClass, DefinitionContext } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const DefinitionContext__symbol = (/*#__PURE__*/ Symbol('definition-context'));\n\n/**\n * @internal\n */\nexport interface ComponentDefinitionClass<T extends object> extends ComponentClass<T> {\n  [DefinitionContext__symbol]?: DefinitionContext<T>;\n}\n\n/**\n * @internal\n */\nexport function definitionContextOf<T extends object>(\n    componentType: ComponentDefinitionClass<T>,\n): DefinitionContext<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (!componentType.hasOwnProperty(DefinitionContext__symbol)) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n  return componentType[DefinitionContext__symbol] as DefinitionContext<T>;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { html__naming, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { Class, newPromiseResolver, PromiseResolver } from '@proc7ts/primitives';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { definitionContextOf } from '../../boot/impl/definition-context.symbol.impl';\nimport { ComponentClass } from './component-class';\n\n/**\n * @internal\n */\nconst CustomElements__key = (/*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: bootstrapDefault(createCustomElements),\n    },\n));\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName - A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType - A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName - Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\n/**\n * @internal\n */\nfunction createCustomElements(bsContext: BootstrapContext): CustomElements {\n\n  const customElements: CustomElementRegistry = bsContext.get(BootstrapWindow).customElements;\n  const nsAlias = bsContext.get(DefaultNamespaceAliaser);\n\n  class CustomElements$ extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | string, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name, extend } = defContext.elementDef;\n\n      if (!name) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            html__naming.name(name, nsAlias),\n            elementType,\n            {\n              extends: extend.name,\n            },\n        );\n      } else {\n        customElements.define(html__naming.name(name, nsAlias), elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name } = defContext.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise();\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new CustomElements$();\n}\n\n/**\n * @internal\n */\nconst ComponentResolver__symbol = (/*#__PURE__*/ Symbol('component-resolver'));\n\n/**\n * @internal\n */\ninterface CustomComponentClass<T extends object = any> extends ComponentClass<T> {\n  [ComponentResolver__symbol]?: PromiseResolver;\n}\n\n/**\n * @internal\n */\nfunction componentResolver(componentType: CustomComponentClass): PromiseResolver {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(ComponentResolver__symbol)) {\n    return componentType[ComponentResolver__symbol] as PromiseResolver;\n  }\n  return componentType[ComponentResolver__symbol] = newPromiseResolver();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\nimport { noop } from '../fn';\nimport { lazyValue } from '../value';\n\n/**\n * A resolver of promise that can be created later or not created at all.\n *\n * Creates the promise only on demand.\n *\n * The methods of this object do not require `this` context and can be called as functions.\n */\nexport interface PromiseResolver<T = void> {\n\n  /**\n   * Resolves the promise.\n   *\n   * Has no effect when the promised is already settled.\n   *\n   * Can be called before the promise constructed.\n   *\n   * @param resolution - Either a promise value, or a promise-like instance resolving to one.\n   */\n  resolve(this: void, resolution: T | PromiseLike<T>): void;\n\n  /**\n   * Rejects the promise.\n   *\n   * Has no effect when the promised is already settled.\n   *\n   * Can be called before the promise constructed.\n   *\n   * @param reason - Promise rejection reason.\n   */\n  reject(this: void, reason?: any): void;\n\n  /**\n   * Creates a promise resolved by {@link resolve}, or rejected by {@link reject}.\n   *\n   * The subsequent calls to this method return the same promise instance.\n   *\n   * @returns Created promise.\n   */\n  promise(this: void): Promise<T>;\n\n}\n\n/**\n * Creates a promise resolver.\n *\n * @returns New promise resolver.\n */\nexport function newPromiseResolver<T = void>(): PromiseResolver<T> {\n\n  let resolvePromise: (value: T | PromiseLike<T>) => void;\n  let rejectPromise: (reason?: any) => void;\n  let buildPromise = lazyValue(() => new Promise<T>((resolve, reject) => {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n  }));\n  const settle = (resolution: () => Promise<T>): void => {\n    buildPromise = lazyValue(resolution);\n    resolvePromise = noop;\n    rejectPromise = noop;\n  };\n\n  resolvePromise = value => {\n    settle(() => Promise.resolve(value));\n  };\n  rejectPromise = error => {\n    settle(() => Promise.reject(error));\n  };\n\n  return {\n    resolve(value?) {\n      resolvePromise(value);\n    },\n    reject(reason) {\n      rejectPromise(reason);\n    },\n    promise() {\n      return buildPromise();\n    },\n  };\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n */\nexport const ElementDef: SingleContextRef<ElementDef> = (/*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || values.get(BootstrapWindow).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n));\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class, Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '../component-context';\nimport { ComponentMount } from '../component-mount';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * {@link BootstrapSetup.perDefinition} and {@link DefinitionSetup.perDefinition} methods. All {@link BootstrapContext}\n * values are available too.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * {@link ComponentDef.define} function. In such case you may wish to add a `whenReady()` callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * An `OnEvent` sender of component definition context upon its readiness.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component context upon its instantiation.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenConnected connected}. This is to prevent resource\n   * leaks on destroyed components.\n   */\n  abstract readonly whenComponent: OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a `ComponentContext.mount` property to check\n   * whether the component is mounted or is constructed in standard way.\n   *\n   * The constructed component will be in disconnected state. To update its connection state either update a\n   * `ComponentMount.connected` property, or use a `connectTo()` method.\n   *\n   * @param element - Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: any): ComponentMount<T>;\n\n  /**\n   * Connects a component to arbitrary element.\n   *\n   * This method does the same as `mountTo()`, but also marks the mounted component as connected.\n   *\n   * @param element - Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  connectTo(element: any): ComponentMount<T> {\n\n    const mount = this.mountTo(element);\n\n    mount.connect();\n\n    return mount;\n  }\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeParam TDeps - A type of dependencies.\n   * @typeParam TSrc - The type of context value sources.\n   * @typeParam TSeed - Value seed type.\n   * @param spec - Component context value specifier.\n   *\n   * @returns A value supply that removes the given context value specifier once cut off.\n   */\n  abstract perComponent<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, TDeps, TSrc, TSeed>,\n  ): Supply;\n\n}\n","import { onceOn, OnEvent, trackValue, valueOn_ } from '@proc7ts/fun-events';\nimport { Supply, valueProvider } from '@proc7ts/primitives';\nimport { ComponentContext, ComponentContext__symbol, ComponentContextHolder, ComponentEvent } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nconst enum ComponentStatus {\n  Building,\n  Ready,\n  Built,\n  Settled,\n  Connected,\n}\n\n/**\n * @internal\n */\nexport abstract class ComponentContext$<T extends object> extends ComponentContext<T> {\n\n  readonly whenReady: OnEvent<[this]>;\n  readonly whenSettled: OnEvent<[this]>;\n  readonly whenConnected: OnEvent<[this]>;\n  readonly get: ComponentContext<T>['get'];\n  private _status = trackValue<ComponentStatus>(ComponentStatus.Building);\n\n  constructor(\n      readonly _definitionContext: DefinitionContext$<T>,\n      readonly element: any,\n  ) {\n    super();\n\n    this.whenReady = this._status.read.do(\n        valueOn_(status => !!status && this),\n        onceOn,\n    );\n    this.whenSettled = this._status.read.do(\n        valueOn_(status => status >= ComponentStatus.Settled && this),\n        onceOn,\n    );\n    this.whenConnected = this._status.read.do(\n        valueOn_(status => status >= ComponentStatus.Connected && this),\n        onceOn,\n    );\n\n    const registry = _definitionContext._newComponentRegistry();\n\n    registry.provide({ a: ComponentContext, is: this });\n    this.get = registry.newValues().get;\n  }\n\n  get componentType(): ComponentClass<T> {\n    return this._definitionContext.componentType;\n  }\n\n  get component(): T {\n    return this._component();\n  }\n\n  get settled(): boolean {\n    return this._status.it >= ComponentStatus.Settled && !this.supply.isOff;\n  }\n\n  get connected(): boolean {\n    return this._status.it >= ComponentStatus.Connected && !this.supply.isOff;\n  }\n\n  get supply(): Supply {\n    return this._status.supply;\n  }\n\n  _component(): T {\n    throw new TypeError('Component is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  settle(): void {\n    if (this._status.it === ComponentStatus.Built) {\n      // Prevent settling until exiting custom element constructor\n      this._status.it = ComponentStatus.Settled;\n    }\n  }\n\n  destroy(reason?: any): void {\n    try {\n      this._status.supply.off(reason);\n    } finally {\n      delete (this.component as ComponentContextHolder)[ComponentContext__symbol];\n      delete (this.element as ComponentContextHolder)[ComponentContext__symbol];\n      this._component = componentDestroyed;\n      removeElement(this.element);\n    }\n  }\n\n  _createComponent(): this {\n\n    const whenComponent = this._definitionContext._whenComponent;\n\n    let lastRev = 0;\n\n    (this.element as ComponentContextHolder)[ComponentContext__symbol] = this;\n    whenComponent.readNotifier.do(onceOn)(notifier => lastRev = notifier(this, lastRev));\n    this.whenConnected(() => {\n      whenComponent.readNotifier({\n        supply: new Supply().needs(this),\n        receive: (_, notifier) => {\n          lastRev = notifier(this, lastRev);\n        },\n      });\n    });\n    this._definitionContext._elementBuilder.components.send(this);\n\n    const component = newComponent(this);\n\n    this._component = valueProvider(component);\n    this._status.it = ComponentStatus.Ready; // Issue `whenReady` event\n\n    return this;\n  }\n\n  _connect(): void {\n    this._status.it = ComponentStatus.Connected;\n  }\n\n  _created(): void {\n    if (this._status.it < ComponentStatus.Built) { // Mounted component can be connected already\n      this._status.it = ComponentStatus.Built; // Can settle now\n    }\n    this.whenConnected(\n        () => this.dispatchEvent(new ComponentEvent('wesib:component', { bubbles: true })),\n    );\n  }\n\n}\n\nfunction newComponent<T extends object>(context: ComponentContext<T>): T {\n\n  type ComponentProto = T & {\n    [ComponentContext__symbol]?: ComponentContext<T>;\n  };\n\n  const type = context.componentType;\n  const proto = type.prototype as ComponentProto;\n  const prevContext = proto[ComponentContext__symbol];\n\n  proto[ComponentContext__symbol] = context;\n  try {\n\n    const component = new type(context);\n\n    (component as ComponentContextHolder)[ComponentContext__symbol] = context;\n\n    return component;\n  } finally {\n    proto[ComponentContext__symbol] = prevContext;\n  }\n}\n\nfunction removeElement(element: Element): void {\n\n  const { parentNode } = element;\n\n  if (parentNode) {\n    parentNode.removeChild(element);\n  }\n}\n\nfunction componentDestroyed(): never {\n  throw new TypeError('Component destroyed already');\n}\n","import { ComponentMount } from '../../component';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass ComponentMount$<T extends object> extends ComponentMount<T> {\n\n  constructor(readonly context: ComponentContext$<T>) {\n    super();\n  }\n\n  get connected(): boolean {\n    return this.context.connected;\n  }\n\n  connect(): void {\n    this.context._connect();\n  }\n\n  checkConnected(): boolean {\n\n    const el = this.context.element as Element;\n    const doc = el.ownerDocument;\n    const connected = doc != null && doc.contains(el);\n\n    if (connected !== this.connected) {\n      if (connected) {\n        this.connect();\n      } else {\n        this.context.destroy();\n      }\n    }\n\n    return connected;\n  }\n\n}\n\n/**\n * @internal\n */\nexport class MountComponentContext$<T extends object> extends ComponentContext$<T> {\n\n  readonly mount: ComponentMount<T>;\n\n  constructor(definitionContext: DefinitionContext$<T>, element: any) {\n    super(definitionContext, element);\n    this.mount = this.mount = new ComponentMount$<T>(this);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext } from './component-context';\n\n/**\n * A mount of the component to an element.\n *\n * This is constructed when a component is mounted to arbitrary element by {@link DefinitionContext.mountTo} method.\n *\n * Mounted components do not maintain their connection state automatically. It is a calling code responsibility to set\n * their connection state by updating {@link ComponentMount.connected} property. E.g. by calling a\n * {@link ComponentMount.checkConnected} method. An {@link ElementObserver} and {@link AutoConnectSupport} feature\n * could be used to do it automatically.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport abstract class ComponentMount<T extends object = any> {\n\n  /**\n   * Mounted component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Component connection state.\n   *\n   * The initial state is set by {@link checkConnected} method.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * Mounted component.\n   */\n  get component(): T {\n    return this.context.component;\n  }\n\n  /**\n   * An element the component is mounted to.\n   */\n  get element(): any {\n    return this.context.element as unknown;\n  }\n\n  /**\n   * Forcibly connects mounted component element to the document.\n   */\n  abstract connect(): void;\n\n  /**\n   * Checks whether the mounted component element is actually connected to its owning document.\n   *\n   * Updates the `connected` property and returns its value.\n   *\n   * When component is disconnected after it has been connected, the component is {@link ComponentContext.destroy\n   * destroyed}.\n   *\n   * @returns `true` if the component element is connected, or `false` otherwise.\n   */\n  abstract checkConnected(): boolean;\n\n}\n","import { Class } from '@proc7ts/primitives';\nimport { CustomElementClass } from '../../common';\nimport { ComponentContext__symbol } from '../../component';\nimport { ElementDef } from '../../component/definition';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass CustomComponentContext$<T extends object> extends ComponentContext$<T> {\n\n  get mount(): undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nexport function customElementType<T extends object>(\n    definitionContext: DefinitionContext$<T>,\n): Class {\n\n  const elementDef = definitionContext.get(ElementDef);\n\n  class CustomElement$ extends (elementDef.extend.type as CustomElementClass) {\n\n    // Component context reference\n    [ComponentContext__symbol]: CustomComponentContext$<T>;\n\n    constructor() {\n      super();\n\n      const context = new CustomComponentContext$(definitionContext, this);\n\n      context._createComponent();\n      context._created();\n    }\n\n    connectedCallback(): void {\n      super.connectedCallback?.();\n      this[ComponentContext__symbol]._connect();\n    }\n\n    disconnectedCallback(): void {\n      this[ComponentContext__symbol].destroy();\n      super.disconnectedCallback?.();\n    }\n\n  }\n\n  return CustomElement$;\n}\n","import { AfterEvent, EventEmitter, mapAfter_, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\n\nexport class WhenComponent<T extends object> {\n\n  readonly onCreated: OnEvent<[ComponentContext<T>]>;\n  readonly readNotifier: AfterEvent<[ComponentNotifier<T>]>;\n\n  constructor() {\n\n    const currentRev = trackValue(0);\n    const created = new EventEmitter<[ComponentContext<T>, number]>();\n\n    this.onCreated = onEventBy(receiver => {\n\n      const receiverRev = currentRev.it + 1;\n\n      created.on({\n        supply: receiver.supply,\n        receive: (eventContext, componentContext, notifiedRev) => {\n          if (notifiedRev < receiverRev) {\n            // Notify only receivers added after the last notification\n            receiver.receive(\n                {\n                  onRecurrent(recurrentReceiver) {\n                    eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                  },\n                },\n                componentContext,\n            );\n          }\n        },\n      });\n\n      ++currentRev.it;\n    });\n    this.readNotifier = currentRev.read.do(\n        mapAfter_(\n            rev => (context, notifiedRev) => {\n              created.send(context, notifiedRev);\n              return rev;\n            },\n        ),\n    );\n  }\n\n}\n\nexport type ComponentNotifier<T extends object> = (\n    this: void,\n    context: ComponentContext<T>,\n    notifiedRev: number,\n) => number;\n","import { ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { mapOn_, onceOn, OnEvent, trackValue, translateOn, ValueTracker } from '@proc7ts/fun-events';\nimport { Class, Supply, valueProvider } from '@proc7ts/primitives';\nimport {\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentContextHolder,\n  ComponentDef,\n  ComponentMount,\n} from '../../component';\nimport { DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { ComponentContextRegistry, PerComponentRegistry } from './component-context-registry.impl';\nimport { MountComponentContext$ } from './component-mount.impl';\nimport { customElementType } from './custom-element.impl';\nimport { DefinitionContextRegistry, PerDefinitionRegistry } from './definition-context-registry.impl';\nimport { ComponentDefinitionClass, DefinitionContext__symbol } from './definition-context.symbol.impl';\nimport { ElementBuilder } from './element-builder.impl';\nimport { postDefSetup } from './post-def-setup.impl';\nimport { WhenComponent } from './when-component.impl';\n\n/**\n * @internal\n */\nexport class DefinitionContext$<T extends object> extends DefinitionContext<T> {\n\n  readonly whenReady: OnEvent<[this]>;\n  readonly get: ContextValues['get'];\n  private readonly _def: ComponentDef.Options<T>;\n  readonly _whenComponent = new WhenComponent<T>();\n  private readonly _ready: ValueTracker<boolean>;\n  private readonly _whenReady: OnEvent<[]>;\n  private readonly _perComponentRegistry: ComponentContextRegistry;\n\n  constructor(\n      readonly _bsContext: BootstrapContext,\n      readonly _elementBuilder: ElementBuilder,\n      readonly componentType: ComponentDefinitionClass<T>,\n  ) {\n    super();\n    this._ready = trackValue(false);\n    this._whenReady = this._ready.read.do(translateOn((send, ready) => ready && send()));\n    this._def = ComponentDef.of(componentType);\n\n    const definitionContextRegistry = new DefinitionContextRegistry(_bsContext.get(PerDefinitionRegistry).seeds());\n\n    definitionContextRegistry.provide({ a: DefinitionContext, is: this });\n\n    this.get = definitionContextRegistry.newValues().get;\n\n    const parentPerComponentRegistry = _bsContext.get(PerComponentRegistry).append(seedKey => this.get(seedKey));\n    this._perComponentRegistry = new ComponentContextRegistry(parentPerComponentRegistry.seeds());\n\n    this.whenReady = this._whenReady.do(mapOn_(valueProvider(this)), onceOn);\n\n    const definitionSetup: DefinitionSetup<T> = {\n      get componentType() {\n        return componentType;\n      },\n      whenReady: this.whenReady,\n      whenComponent: this.whenComponent,\n      perDefinition: spec => definitionContextRegistry.provide(spec),\n      perComponent: spec => this._perComponentRegistry.provide(spec),\n    };\n\n    this._def.setup?.(definitionSetup);\n    postDefSetup(componentType).setup(definitionSetup);\n  }\n\n  get elementType(): Class {\n    return this._elementType();\n  }\n\n  get whenComponent(): OnEvent<[ComponentContext<T>]> {\n    return this._whenComponent.onCreated;\n  }\n\n  mountTo(element: ComponentContextHolder): ComponentMount<T> {\n    if (element[ComponentContext__symbol]) {\n      throw new Error(`Element ${String(element)} already bound to component`);\n    }\n\n    const context = new MountComponentContext$(this, element);\n\n    context._createComponent();\n\n    const { mount } = context;\n\n    mount.checkConnected();\n    context._created();\n    context.settle();\n\n    return mount;\n  }\n\n  perComponent<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, TDeps, TSrc, TSeed>,\n  ): Supply {\n    return this._perComponentRegistry.provide(spec);\n  }\n\n  _newComponentRegistry(): ComponentContextRegistry {\n    return new ComponentContextRegistry(this._perComponentRegistry.seeds());\n  }\n\n  _elementType(): Class {\n    throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  _define(): void {\n    this._def.define?.(this);\n    this._elementBuilder.definitions.send(this);\n    this._elementType = valueProvider(customElementType(this));\n    this.componentType[DefinitionContext__symbol] = this;\n    this._ready.it = true;\n  }\n\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { EventEmitter } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { DefinitionContext$ } from './definition-context.impl';\n\n/**\n * @internal\n */\nexport interface ElementBuilder {\n  readonly definitions: EventEmitter<[DefinitionContext]>;\n  readonly components: EventEmitter<[ComponentContext]>;\n  buildElement<T extends object>(this: void, componentType: ComponentClass<T>): DefinitionContext<T>;\n}\n\n/**\n * @internal\n */\nexport const ElementBuilder: SingleContextRef<ElementBuilder> = (/*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(newElementBuilder),\n    },\n));\n\nfunction newElementBuilder(bsContext: BootstrapContext): ElementBuilder {\n  return {\n    definitions: new EventEmitter<[DefinitionContext]>(),\n    components: new EventEmitter<[ComponentContext]>(),\n    buildElement<T extends object>(componentType: ComponentClass<T>) {\n\n      const definitionContext = new DefinitionContext$(bsContext, this, componentType);\n\n      definitionContext._define();\n\n      return definitionContext;\n    },\n  };\n\n}\n","import { ElementBuilder } from '../../boot/impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _definitionQueue?: (() => void)[] = [];\n\n  constructor(private readonly _context: FeatureContext) {\n    _context.whenReady(() => {\n      this._definitionQueue!.forEach(definition => definition());\n      delete this._definitionQueue;\n    });\n  }\n\n  get customElements(): CustomElements {\n    return this._context.get(CustomElements);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._definitionQueue!.push(() => {\n\n      const elementBuilder = this._context.get(ElementBuilder);\n      const defContext = elementBuilder.buildElement(componentType);\n\n      this.customElements.define(componentType, defContext.elementType);\n    });\n  }\n\n}\n","import { ContextRegistry, ContextValueSpec } from '@proc7ts/context-values';\nimport { afterAll, onceOn, OnEvent, supplyOn, trackValue, valueOn } from '@proc7ts/fun-events';\nimport { Class, Supply } from '@proc7ts/primitives';\nimport { BootstrapContext } from '../../boot';\nimport {\n  BootstrapContextRegistry,\n  ElementBuilder,\n  onPostDefSetup,\n  PerComponentRegistry,\n  PerDefinitionRegistry,\n} from '../../boot/impl';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\nimport { FeatureLoader } from './feature-loader.impl';\n\n/**\n * @internal\n */\nexport class FeatureContext$ extends FeatureContext {\n\n  readonly whenReady: OnEvent<[FeatureContext]>;\n  readonly onDefinition: OnEvent<[DefinitionContext]>;\n  readonly onComponent: OnEvent<[ComponentContext]>;\n  readonly supply = new Supply();\n  readonly get: FeatureContext['get'];\n  private readonly _componentRegistry: ComponentRegistry;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      private readonly _loader: FeatureLoader,\n  ) {\n    super();\n\n    const registry = new ContextRegistry<FeatureContext>(_bsContext);\n\n    registry.provide({ a: FeatureContext, is: this });\n    this.get = registry.newValues().get;\n\n    this.whenReady = afterAll({\n      st: this._loader.state,\n      bs: trackValue<BootstrapContext>().by(_bsContext.whenReady),\n    }).do(\n        valueOn(({ st: [ready], bs: [bs] }) => bs && ready && this),\n        onceOn,\n    );\n    this.onDefinition = _bsContext.get(ElementBuilder).definitions.on.do(supplyOn(this));\n    this.onComponent = this._bsContext.get(ElementBuilder).components.on.do(supplyOn(this));\n\n    this._componentRegistry = new ComponentRegistry(this);\n  }\n\n  get feature(): Class {\n    return this._loader.request.feature;\n  }\n\n  provide<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<BootstrapContext, any, TDeps, TSrc, TSeed>,\n  ): Supply {\n    return this._bsContext.get(BootstrapContextRegistry).provide(spec).needs(this);\n  }\n\n  perDefinition<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<DefinitionContext, any, TDeps, TSrc, TSeed>,\n  ): Supply {\n    return this._bsContext.get(PerDefinitionRegistry).provide(spec).needs(this);\n  }\n\n  perComponent<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<ComponentContext, any, TDeps, TSrc, TSeed>,\n  ): Supply {\n    return this._bsContext.get(PerComponentRegistry).provide(spec).needs(this);\n  }\n\n  setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]> {\n    return onPostDefSetup(componentType, this.supply);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._componentRegistry.define(componentType);\n  }\n\n}\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  mapAfter_,\n  shareAfter,\n  trackValue,\n  translateAfter,\n  translateAfter_,\n} from '@proc7ts/fun-events';\nimport { Class, isPresent, setOfElements } from '@proc7ts/primitives';\nimport { BootstrapContext } from '../../boot';\nimport { FeatureContext } from '../feature-context';\nimport { FeatureContext$ } from './feature-context.impl';\nimport { FeatureClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureKey__symbol = (/*#__PURE__*/ Symbol('feature-key'));\n\ninterface FeatureClass extends Class {\n  [FeatureKey__symbol]?: FeatureKey;\n}\n\n/**\n * @internal\n */\nexport class FeatureKey extends ContextUpKey<AfterEvent<[FeatureLoader?]>, FeatureClause> {\n\n  static of(feature: Class): FeatureKey {\n    // eslint-disable-next-line no-prototype-builtins\n    return feature.hasOwnProperty(FeatureKey__symbol)\n        ? ((feature as FeatureClass)[FeatureKey__symbol] as FeatureKey)\n        : ((feature as FeatureClass)[FeatureKey__symbol] = new FeatureKey(feature));\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  private constructor(feature: Class) {\n    super(`feature:${feature.name}`);\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          AfterEvent<[FeatureLoader?]>,\n          EventKeeper<FeatureClause[]> | FeatureClause,\n          AfterEvent<FeatureClause[]>>,\n  ): void {\n    slot.insert(loadFeature(\n        slot.context.get(BootstrapContext),\n        slot.seed.do(mapAfter(preferredFeatureClause)),\n    ));\n  }\n\n}\n\nfunction preferredFeatureClause(...clauses: FeatureClause[]): FeatureClause | undefined {\n\n  let required = false;\n  let preferred: FeatureClause | undefined;\n\n  for (const clause of clauses) {\n    switch (clause[1]) {\n    case 'is':\n      required = true;\n      if (!preferred) {\n        preferred = clause;\n      }\n      break;\n    case 'has':\n      preferred = clause;\n      break;\n    case 'needs':\n      required = true;\n    }\n  }\n\n  return required ? preferred : undefined;\n}\n\nfunction loadFeature(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<[FeatureLoader?]> {\n  return afterEventBy<[FeatureLoader?]>(receiver => {\n\n    let origin: Class | undefined;\n    let source: AfterEvent<[FeatureLoader?]> = afterThe();\n    let stageId: Promise<FeatureStageId> = Promise.resolve('idle');\n\n    return afterAll({\n      clause: from,\n      deps: loadFeatureDeps(bsContext, from),\n    }).do(digAfter_(({ clause: [clause], deps }): AfterEvent<[FeatureLoader?]> => {\n      if (!clause) {\n        return afterThe();\n      }\n\n      const [request, , target] = clause;\n\n      if (request.feature === origin) {\n        return source; // Origin didn't change. Reuse the source.\n      }\n\n      origin = request.feature;\n\n      if (target !== origin) {\n        // Originated from replacement feature provider. Reuse its loader.\n        return source = bsContext.get(FeatureKey.of(origin)).do(mapAfter_(\n            loader => {\n              if (loader) {\n                loader.to(stageId);\n                stageId = loader.stage;\n              }\n              return loader;\n            },\n        ));\n      }\n\n      // Create feature's own loader\n      const ownLoader = new FeatureLoader(bsContext, request, deps).to(stageId);\n      const ownSource = afterThe(ownLoader);\n\n      return source = afterEventBy<[FeatureLoader]>(\n          rcv => ownSource(rcv).whenOff(() => {\n            stageId = ownLoader.unload();\n          }),\n      ).do(shareAfter); // Can be accessed again when reused\n    }))(receiver);\n  }).do(\n      translateAfter(preventDuplicateLoader()),\n  );\n}\n\nfunction preventDuplicateLoader():\n    (\n        send: (loader?: FeatureLoader) => void,\n        loader?: FeatureLoader,\n    ) => void {\n\n  let lastLoader: FeatureLoader | null | undefined = null; // Initially `null` to differ from `undefined`\n\n  return (send, loader?: FeatureLoader): void => {\n    if (lastLoader !== loader) {\n      lastLoader = loader;\n\n      if (loader) {\n        send(loader);\n      } else {\n        send();\n      }\n    }\n  };\n}\n\nfunction loadFeatureDeps(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<FeatureLoader[]> {\n  return from.do(digAfter_(clause => {\n    if (!clause) {\n      return afterThe();\n    }\n\n    const [{ def }] = clause;\n    const needs = setOfElements(def.needs);\n\n    if (!needs.size) {\n      return afterThe();\n    }\n\n    return afterEach(\n        ...[...needs].map(dep => bsContext.get(FeatureKey.of(dep))),\n    ).do(\n        translateAfter_(presentFeatureDeps),\n    );\n  }));\n}\n\nfunction presentFeatureDeps(send: (...loaders: FeatureLoader[]) => void, ...deps: [FeatureLoader?][]): void {\n  return send(...deps.map(([dep]) => dep).filter(isPresent));\n}\n\n/**\n * @internal\n */\nexport class FeatureLoader {\n\n  readonly down: Promise<void>;\n  private _stage: Promise<FeatureStage>;\n  private _down!: () => void;\n  readonly state = trackValue(false);\n\n  constructor(\n      readonly bsContext: BootstrapContext,\n      readonly request: FeatureRequest,\n      readonly deps: FeatureLoader[],\n  ) {\n    this.down = new Promise(resolve => this._down = resolve);\n    this._stage = Promise.resolve(new SetupFeatureStage(this));\n  }\n\n  get stage(): Promise<FeatureStageId> {\n    return this._stage.then(stage => stage.after);\n  }\n\n  get ready(): boolean {\n    return this.state.it;\n  }\n\n  to(stageId: Promise<FeatureStageId>): this {\n\n    const lastStage = this._stage;\n\n    this._stage = stageId.then(id => lastStage.then(stage => stage[id]()));\n\n    return this;\n  }\n\n  async setup(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.setup()));\n  }\n\n  async init(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.init()));\n  }\n\n  async unload(): Promise<FeatureStageId> {\n\n    const prevStage = this._stage;\n\n    // Unloaded feature should never be accessed again.\n    delete (this as unknown as { _stage?: Promise<FeatureStage> })._stage;\n\n    const stage = await prevStage;\n    const stageId = await stage.stop();\n\n    this._down();\n\n    return stageId;\n  }\n\n}\n\ntype FeatureStageId = 'idle' | 'setup' | 'init';\ntype FeatureStageStop = (this: void) => Promise<any>;\n\nabstract class FeatureStage {\n\n  abstract readonly after: FeatureStageId;\n\n  constructor(\n      readonly loader: FeatureLoader,\n      private readonly _stop: FeatureStageStop = () => Promise.resolve(),\n  ) {}\n\n  idle(): Promise<this> {\n    return Promise.resolve(this);\n  }\n\n  abstract setup(): Promise<FeatureStage>;\n\n  abstract init(): Promise<FeatureStage>;\n\n  stop(): Promise<FeatureStageId> {\n    return this._stop().then(() => this.after);\n  }\n\n  protected perDep(action: (dep: FeatureLoader) => Promise<void>): Promise<any> {\n\n    const { deps } = this.loader;\n\n    return Promise.all(deps.map(dep => action(dep)));\n  }\n\n}\n\nclass SetupFeatureStage extends FeatureStage {\n\n  get after(): 'idle' {\n    return 'idle';\n  }\n\n  async setup(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.setup());\n\n    const { bsContext, request: { def } } = this.loader;\n    const context = new FeatureContext$(bsContext, this.loader);\n    const supply = context.supply;\n\n    def.setup?.(context);\n\n    return new InitFeatureStage(\n        this.loader,\n        context,\n        () => Promise.resolve(supply.off()),\n    );\n  }\n\n  init(): Promise<FeatureStage> {\n    return this.setup().then(stage => stage.init());\n  }\n\n}\n\nclass InitFeatureStage extends FeatureStage {\n\n  get after(): 'setup' {\n    return 'setup';\n  }\n\n  constructor(\n      state: FeatureLoader,\n      private readonly _context: FeatureContext,\n      stop: FeatureStageStop,\n  ) {\n    super(state, stop);\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  async init(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.init());\n\n    const { request: { def } } = this.loader;\n\n    def.init?.(this._context);\n\n    return new ActiveFeatureStage(this);\n  }\n\n}\n\nclass ActiveFeatureStage extends FeatureStage {\n\n  get after(): 'init' {\n    return 'init';\n  }\n\n  constructor(prev: InitFeatureStage) {\n    super(prev.loader, () => prev.stop());\n    prev.loader.state.it = true;\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  init(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n}\n","import { Class, setOfElements, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { ComponentDef, ComponentDef__symbol } from '../../component';\nimport { FeatureDef } from '../feature-def';\nimport { FeatureNeedsError } from '../feature-needs-error';\nimport { FeatureKey } from './feature-loader.impl';\nimport { FeatureRequester } from './feature-requester.impl';\n\n/**\n * @internal\n */\nexport type FeatureClause = [FeatureRequest, 'is' | 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport type FeatureNeedClause = [FeatureRequest, 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport class FeatureRequest implements SupplyPeer {\n\n  readonly def: FeatureDef.Options;\n  readonly supply = new Supply();\n  private _uses = 0;\n\n  constructor(\n      private readonly _requester: FeatureRequester,\n      readonly feature: Class,\n  ) {\n    this.def = featureDef(feature);\n  }\n\n  request(clauses: readonly FeatureNeedClause[]): this {\n\n    const requester = this._requester;\n    const { registry } = requester;\n    const isClause: FeatureClause = [this, 'is', this.feature];\n\n    registry.provide({\n      a: FeatureKey.of(this.feature),\n      is: isClause,\n    }).needs(this);\n\n    for (const feature of setOfElements(this.def.has)) {\n\n      const clause: FeatureNeedClause = [this, 'has', feature];\n\n      registry.provide({ a: FeatureKey.of(feature), is: clause }).needs(this);\n\n      // Request the provided feature _after_ provider\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this.supply.whenOff(() => request.unuse());\n    }\n\n    for (const feature of setOfElements(this.def.needs)) {\n\n      const clause: FeatureNeedClause = [this, 'needs', feature];\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this.supply.whenOff(() => request.unuse());\n      registry.provide({ a: FeatureKey.of(feature), is: clause }).needs(this);\n    }\n\n    this._uses = 1;\n\n    return this;\n  }\n\n  reuse(clauses: readonly FeatureNeedClause[]): this {\n    if (!this._uses) {\n      throw new FeatureNeedsError(clauses.map(\n          ([{ feature }, reason, need]) => [feature, reason, need],\n      ));\n    }\n\n    ++this._uses;\n\n    return this;\n  }\n\n  unuse(): void {\n    if (!--this._uses) {\n      this.supply.off();\n    }\n  }\n\n}\n\nfunction featureDef(featureType: Class): FeatureDef.Options {\n\n  let def = FeatureDef.of(featureType);\n\n  if (ComponentDef__symbol in featureType) {\n    def = FeatureDef.merge(\n        def,\n        {\n          init(context) {\n            context.define(featureType);\n          },\n        },\n    );\n\n    const { feature } = ComponentDef.of(featureType);\n\n    if (feature) {\n      def = FeatureDef.merge(def, feature);\n    }\n\n  }\n\n  return def;\n}\n\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapContextRegistry } from '../../boot/impl';\nimport { FeatureNeedClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureRequester__key = (/*#__PURE__*/ new SingleContextKey<FeatureRequester>(\n    'feature-requester',\n    {\n      byDefault: bootstrapDefault(context => new FeatureRequester(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class FeatureRequester {\n\n  static get [ContextKey__symbol](): ContextKey<FeatureRequester> {\n    return FeatureRequester__key;\n  }\n\n  readonly registry: BootstrapContextRegistry;\n  private readonly _map = new Map<Class, FeatureRequest>();\n\n  constructor(context: BootstrapContext) {\n    this.registry = context.get(BootstrapContextRegistry);\n  }\n\n  request(feature: Class, clauses: readonly FeatureNeedClause[] = []): FeatureRequest {\n\n    const existing = this._map.get(feature);\n\n    if (existing) {\n      return existing.reuse(clauses);\n    }\n\n    const request = new FeatureRequest(this, feature);\n\n    this._map.set(feature, request);\n    request.supply.whenOff(() => this._map.delete(feature));\n\n    return request.request(clauses);\n  }\n\n}\n","import { OnEvent, onPromise } from '@proc7ts/fun-events';\nimport { ComponentClass, CustomElements, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { definitionContextOf } from './definition-context.symbol.impl';\n\n/**\n * @internal\n */\nexport const WhenDefined__symbol = (/*#__PURE__*/ Symbol('when-defined'));\n\ninterface WhenDefinedComponentClass<T extends object> extends ComponentClass<T> {\n  [WhenDefined__symbol]?: OnEvent<[DefinitionContext<T>]>;\n}\n\n/**\n * @internal\n */\nexport function whenDefined<T extends object>(\n    bsContext: BootstrapContext,\n    componentType: WhenDefinedComponentClass<T>,\n): OnEvent<[DefinitionContext<T>]> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(WhenDefined__symbol)) {\n    return componentType[WhenDefined__symbol] as OnEvent<[DefinitionContext<T>]>;\n  }\n\n  const result: OnEvent<[DefinitionContext<T>]> = onPromise(\n      Promise.resolve(bsContext.whenReady)\n          .then(() => bsContext.get(CustomElements).whenDefined(componentType))\n          .then(() => definitionContextOf(componentType)),\n  );\n\n  return componentType[WhenDefined__symbol] = result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nexport const AttributePath__root = (/*#__PURE__*/ Symbol('attribute'));\n\n/**\n * A path to the named attribute state.\n *\n * @category Feature\n */\nexport type AttributePath = readonly [keyof AttributePath.RootKeys, string];\n\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name - Target attribute name.\n *\n * @return Attribute state path.\n */\nexport function attributePathTo(name: string): AttributePath {\n  return [AttributePath__root, name];\n}\n\n/**\n * @category Feature\n */\nexport namespace AttributePath {\n  export interface RootKeys {\n    [AttributePath__root]: true;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { StatePath } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeChangedCallback } from './attribute-descriptor';\nimport { attributePathTo } from './attribute-path';\n\n/**\n * @internal\n */\nexport function attributeStateUpdate<T extends object>(\n    name: string,\n    updateState: boolean | AttributeUpdateReceiver<T> | StatePath = true,\n): AttributeChangedCallback<T> {\n  if (updateState === false) {\n    return noop;\n  }\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = attributePathTo(name);\n    const update: AttributeUpdateReceiver<T> = updateState === true ? updateAttributeState : updateState;\n\n    return (component: T, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component: T, newValue, oldValue) => updateAttributeState(\n      component,\n      updateState,\n      newValue,\n      oldValue,\n  );\n}\n\nfunction updateAttributeState<T extends object>(\n    component: T,\n    path: StatePath,\n    newValue: string | null,\n    oldValue: string | null,\n): void {\n  ComponentContext.of(component).updateState(path, newValue, oldValue);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Converts property name to _dash-style_ attribute name.\n *\n * - Any ASCII uppercase letter A to Z is transformed into a dash followed by its lowercase counterpart;\n * - other characters are left unchanged.\n *\n * @category Feature\n * @param name - Property name to convert.\n *\n * @returns  _dash-style_ attribute name.\n */\nexport function property2attributeName(name: string): string {\n\n  let result: string | undefined;\n\n  for (let i = 0; i < name.length; ++i) {\n\n    const c = name[i];\n\n    if (c <= 'Z' && c >= 'A') {\n      if (!result) {\n        // Allocate result on first conversion\n        result = name.substring(0, i);\n      }\n      result += '-' + c.toLowerCase();\n    } else if (result) {\n      result += c;\n    }\n  }\n\n  return result || name;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { mergeFunctions } from '@proc7ts/primitives';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { CustomElementClass } from '../../common';\nimport { ComponentContext, ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\n\n/**\n * A registry of component's element attributes.\n *\n * @category Feature\n */\nexport interface AttributeRegistry {\n\n  /**\n   * Declares component element's attribute.\n   *\n   * @param descriptor - Attribute descriptor.\n   */\n  declareAttribute(descriptor: AttributeDescriptor): void;\n\n}\n\n/**\n * A key of component definition context value containing {@link AttributeRegistry attribute registry}.\n *\n * @category Feature\n */\nexport const AttributeRegistry: ContextRef<AttributeRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<AttributeRegistry>(\n        'attribute-registry',\n        {\n          byDefault(context) {\n            return new AttributeRegistry$(context.get(DefinitionContext));\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nclass AttributeRegistry$ implements AttributeRegistry {\n\n  private readonly attrs = new Map<string, AttributeChangedCallback<any>>();\n\n  constructor(private readonly _context: DefinitionContext) {\n    _context.whenReady(({ elementType }) => this.define(elementType as CustomElementClass));\n    _context.whenComponent(({ mount }) => {\n      if (mount) {\n        // Mount element attributes\n        this.mount(mount);\n      }\n    });\n  }\n\n  declareAttribute({ name, change }: AttributeDescriptor): void {\n    this.attrs.set(name, mergeFunctions(this.attrs.get(name), change));\n  }\n\n  private define(elementType: CustomElementClass): void {\n\n    const { attrs } = this;\n\n    if (!attrs.size) {\n      return; // No attributes defined\n    }\n\n    Object.defineProperty(elementType, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      value: observedAttributes(elementType, [...attrs.keys()]),\n    });\n    Object.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n      configurable: true,\n      enumerable: true,\n      value: attributeChangedCallback(elementType, attrs),\n    });\n  }\n\n  private mount(mount: ComponentMount): void {\n\n    const { element } = mount as { element: Element };\n    const { attrs } = this;\n    const attributeFilter = [...attrs.keys()];\n\n    if (!attributeFilter.length) {\n      return; // No attributes defined\n    }\n\n    const MutationObserver = this._context.get(BootstrapWindow).MutationObserver;\n    const observer = new MutationObserver(\n        records => records.forEach(\n            record => {\n\n              const attributeName = record.attributeName as string;\n\n              return attrs.get(attributeName)!(\n                  ComponentContext.of(element).component,\n                  element.getAttribute(attributeName),\n                  record.oldValue,\n              );\n            },\n        ),\n    );\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter,\n      attributeOldValue: true,\n    });\n  }\n\n}\n\n/**\n * @internal\n */\ntype ElementAttributeChanged = (\n    this: any,\n    name: string,\n    oldValue: string | null,\n    newValue: string | null,\n) => void;\n\n/**\n * @internal\n */\nfunction observedAttributes(\n    elementType: CustomElementClass,\n    attrs: readonly string[],\n): readonly string[] {\n\n  const alreadyObserved = elementType.observedAttributes;\n\n  if (Array.isArray(alreadyObserved)) {\n\n    const newAttrs = new Set<string>(alreadyObserved);\n\n    attrs.forEach(attr => newAttrs.add(attr));\n\n    attrs = [...newAttrs];\n  }\n\n  return attrs;\n}\n\n/**\n * @internal\n */\nfunction attributeChangedCallback<T extends object>(\n    elementType: CustomElementClass,\n    attrs: Map<string, AttributeChangedCallback<T>>,\n): ElementAttributeChanged {\n\n  const prevCallback = elementType.prototype.attributeChangedCallback;\n\n  if (!prevCallback) {\n    return function (this: any, name, oldValue, newValue) {\n      attrs.get(name)!(ComponentContext.of<T>(this).component, newValue, oldValue);\n    };\n  }\n\n  return function (this: any, name, oldValue, newValue) {\n\n    const attrChanged = attrs.get(name);\n\n    if (attrChanged) {\n      attrChanged(ComponentContext.of<T>(this).component, newValue, oldValue);\n    } else {\n      prevCallback.call(this, name, oldValue, newValue);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributeRegistry } from './attribute-registry';\n\n/**\n * Creates a decorator for component's property that accesses custom element's attribute.\n *\n * The decorated property accesses corresponding attribute on read, and updates it on setting. `null` value corresponds\n * to absent attribute. Setting to `null` removes corresponding attribute.\n *\n * @category Feature\n * @typeParam T - A type of decorated component class.\n * @param def - Attribute definition or just an attribute name (either _camelCase_ or _dash-style_).\n *\n * @return Component property decorator.\n */\nexport function Attribute<T extends ComponentClass>(\n    def?: AttributeDef<InstanceType<T>> | string,\n): ComponentPropertyDecorator<string | null, T> {\n  return ComponentProperty(({ type, key }) => {\n\n    const descriptor = parseAttributeDescriptor(type.prototype, key, def);\n    const { name } = descriptor;\n\n    return {\n      componentDef: {\n        define(defContext) {\n          defContext.get(AttributeRegistry).declareAttribute(descriptor);\n        },\n      },\n      get(component: InstanceType<T>): string | null {\n        return (ComponentContext.of(component).element as Element).getAttribute(name);\n      },\n      set(component: InstanceType<T>, newValue: string | null) {\n\n        const { element } = ComponentContext.of(component) as { element: Element };\n\n        if (newValue != null) {\n          element.setAttribute(name, newValue);\n        } else {\n          element.removeAttribute(name);\n        }\n      },\n    };\n  });\n}\n","import { AttributeDef } from './attribute-def';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\nimport { property2attributeName } from './property2attribute-name';\n\n/**\n * @internal\n */\nexport function parseAttributeDescriptor<T extends object>(\n    target: T,\n    propertyKey: string | symbol,\n    opts?: AttributeDef<T> | string,\n): AttributeDescriptor<T> {\n\n  let name: string;\n  let change: AttributeChangedCallback<T>;\n\n  if (typeof opts === 'string') {\n    name = property2attributeName(opts);\n    change = attributeStateUpdate(name);\n  } else {\n    if (opts && opts.name) {\n      name = property2attributeName(opts.name);\n    } else if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n          'Attribute name is required as property key is not a string: '\n          + `${target.constructor.name}.prototype.${String(propertyKey)}`,\n      );\n    } else {\n      name = property2attributeName(propertyKey);\n    }\n\n    change = attributeStateUpdate(name, opts && opts.updateState);\n  }\n\n  return { name, change };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSlot, SimpleContextKey } from '@proc7ts/context-values';\nimport { StateTracker } from '@proc7ts/fun-events';\nimport { ComponentContext, StateUpdater } from '../../component';\n\nclass ComponentStateKey extends SimpleContextKey<ComponentState> {\n\n  constructor() {\n    super('component-state');\n  }\n\n  grow(\n      slot: ContextValueSlot<ComponentState, ComponentState, SimpleContextKey.Seed<ComponentState>>,\n  ): void {\n\n    const provided = slot.seed();\n    let state: ComponentState;\n\n    if (provided != null) {\n      state = provided;\n      slot.insert(state);\n    } else if (slot.hasFallback) {\n      return;\n    } else {\n      state = new ComponentState();\n      slot.context.get(ComponentContext).supply.whenOff(reason => state.done(reason));\n      slot.insert(state);\n    }\n\n    slot.setup(({ registry }) => {\n      registry.provide({ a: StateUpdater, is: state.update });\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nconst ComponentState__key = (/*#__PURE__*/ new ComponentStateKey());\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { OnEvent, StatePath, supplyOn, translateOn, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { attributePathTo } from './attribute-path';\n\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly on: OnEvent<[string | null, string | null]>;\n  readonly supply = new Supply();\n\n  constructor(\n      private readonly _context: ComponentContext,\n      private readonly _name: string,\n      path: StatePath,\n  ) {\n    super();\n    this.on = this._context.get(ComponentState).track(path).onUpdate.do(\n        translateOn((send, _path, newValue, oldValue) => send(newValue, oldValue)),\n        supplyOn(this),\n    );\n  }\n\n  get it(): string | null {\n    return (this._context.element as Element).getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (!this.supply.isOff) {\n      if (value == null) {\n        (this._context.element as Element).removeAttribute(this._name);\n      } else {\n        (this._context.element as Element).setAttribute(this._name, value);\n      }\n    }\n  }\n\n}\n\n/**\n * Creates a tracker of custom element's attribute value.\n *\n * Requires attribute to be defined. E.g. with {@link Attribute @Attribute}, {@link AttributeChanged @AttributeChanged},\n * or {@link Attributes @Attributes} decorator.\n *\n * @category Feature\n * @param context - Target component context.\n * @param name - Attribute name.\n * @param path - Custom attribute state path.\n *\n * @returns New attribute value tracker.\n */\nexport function trackAttribute(\n    context: ComponentContext,\n    name: string,\n    path: StatePath = attributePathTo(name),\n): ValueTracker<string | null> {\n  return new AttributeTracker(context, name, path);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const DomPropertyPath__root = (/*#__PURE__*/ Symbol('dom-property'));\n\n/**\n * A path to the named DOM property state.\n *\n * @category Feature\n * @typeParam TKey - Property key type.\n */\nexport type DomPropertyPath<TKey extends PropertyKey = PropertyKey> = readonly [keyof DomPropertyPath.RootKeys, TKey];\n\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @typeParam TKey - Property key type.\n * @param key - Target property key.\n *\n * @return DOM property state path.\n */\nexport function domPropertyPathTo<TKey extends PropertyKey = PropertyKey>(key: TKey): DomPropertyPath<TKey> {\n  return [DomPropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\nexport namespace DomPropertyPath {\n  export interface RootKeys {\n    [DomPropertyPath__root]: true;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport {\n  EventSender,\n  isEventSender,\n  OnEvent,\n  onSupplied,\n  StatePath,\n  supplyOn,\n  translateOn_,\n} from '@proc7ts/fun-events';\nimport { valueByRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\n\n/**\n * Element rendering definition.\n *\n * This is either a {@link RenderDef.Spec rendering specifier}, or its {@link RenderDef.Provider provider function}.\n *\n * @category Feature\n */\nexport type RenderDef =\n    | RenderDef.Spec\n    | RenderDef.Provider;\n\nexport namespace RenderDef {\n\n  /**\n   * Rendering options.\n   */\n  export interface Options {\n\n    /**\n     * When to start the rendering.\n     *\n     * One of:\n     * - `settled` (the default) - start rendering when component is {@link ComponentContext.settled settled}.\n     * - `connected` - start rendering when component's element is {@link ComponentContext.connected connected}\n     *   to document.\n     */\n    readonly when?: 'settled' | 'connected';\n\n    /**\n     * Reports rendering error. E.g. a render shot execution failure.\n     *\n     * @param messages - Error messages to report.\n     */\n    error?(...messages: any[]): void;\n\n  }\n\n  /**\n   * Rendering specifier.\n   */\n  export interface Spec extends Options {\n\n    /**\n     * A trigger that issues rendering.\n     *\n     * This can be useful e.g. when component has multiple independent sub-views.\n     *\n     * This can be one of the following:\n     * - A path to component state part the renderer should track. The rendering would trigger only when the target\n     *   state part is updated.\n     * - Arbitrary event sender. The rendering would be triggered on any event from this sender.\n     *\n     * A root state path is tracked when omitted.\n     *\n     * When trigger is a root path (the default value), then the rendering will be triggered by any state update.\n     * Except for updates of sub-states inside {@link RenderPath__root}.\n     */\n    readonly on?: StatePath | EventSender<[]>;\n\n  }\n\n  /**\n   * Rendering specifier provider signature.\n   */\n  export type Provider =\n  /**\n   * @param context - A context of component to render.\n   *\n   * @returns Rendering specifier.\n   */\n      (\n          this: void,\n          context: ComponentContext,\n      ) => RenderDef.Spec;\n\n}\n\n/**\n * A root path to sub-states updates to which will be ignored by default.\n *\n * This can be used to create sub-states that won't trigger rendering occasionally, but only when requested explicitly.\n *\n * @category Feature\n */\nexport const RenderPath__root = (/*#__PURE__*/ Symbol('render'));\n\n/**\n * @category Feature\n */\nexport const RenderDef = {\n\n  /**\n   * Builds a rendering specifier for component by its definition.\n   *\n   * @param context - A context of component to render.\n   * @param def - Arbitrary rendering definition.\n   *\n   * @returns Rendering specifier.\n   */\n  spec(\n      this: void,\n      context: ComponentContext,\n      def: RenderDef,\n  ): RenderDef.Spec {\n    return valueByRecipe(def, context);\n  },\n\n  /**\n   * Fulfills rendering specifier with the given defaults.\n   *\n   * @param base - Base rendering specifier to fulfill.\n   * @param defaults - Defaults that will be applied unless defined in `base` specifier.\n   *\n   * @return `base` rendering specifier fulfilled by `defaults`.\n   */\n  fulfill(this: void, base: RenderDef.Spec, defaults: RenderDef.Spec = {}): RenderDef.Spec {\n\n    const { on = defaults.on, error } = base;\n\n    return {\n      on,\n      error: error ? error.bind(base) : defaults.error && defaults.error.bind(defaults),\n    };\n  },\n\n  /**\n   * Builds a trigger issuing rendering updates.\n   *\n   * @param context - Rendered component context.\n   * @param spec - Rendering specifier.\n   *\n   * @returns `OnEvent` sender that sends an event each time the rendering required.\n   */\n  trigger(\n      this: void,\n      context: ComponentContext,\n      spec: RenderDef.Spec = {},\n  ): OnEvent<[]> {\n\n    const { on = [] } = spec;\n\n    if ((typeof on === 'object' || typeof on === 'function') && isEventSender(on)) {\n      return onSupplied(on).do(supplyOn(context));\n    }\n\n    const trigger = context\n        .get(ComponentState)\n        .track(on)\n        .onUpdate.do(\n            supplyOn(context),\n        );\n\n    if (Array.isArray(on) && !on.length) {\n      return trigger.do(translateOn_(\n          (send, path: StatePath.Normalized) => path[0] !== RenderPath__root && send(),\n      ));\n    }\n\n    return trigger;\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/primitives\n */\nimport { valueProvider } from './value-providers';\n\n/**\n * A recipe of value evaluation.\n *\n * This is either a value as-is, or its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n */\nexport type ValueRecipe<TValue, TArgs extends any[] = []> =\n    | TValue\n    | ValueRecipe.Evaluator<TValue, TArgs>;\n\nexport namespace ValueRecipe {\n\n  /**\n   * Value evaluator signature.\n   *\n   * @typeParam TValue - Evaluated value type. This can not be a function.\n   * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n   */\n  export type Evaluator<TValue, TArgs extends any[] = []> =\n  /**\n   * @param args - Parameters required for value evaluation.\n   *\n   * @returns Evaluated value.\n   */\n      (this: void, ...args: TArgs) => TValue;\n\n}\n\n/**\n * @internal\n */\nfunction isValueEvaluator<TValue, TArgs extends any[]>(\n    value: ValueRecipe<TValue, TArgs>,\n): value is ValueRecipe.Evaluator<TValue, TArgs> {\n  return typeof value === 'function';\n}\n\n/**\n * Evaluates a value by its recipe.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Value evaluation recipe.\n * @param args - Parameters required for value evaluation.\n *\n * @returns Either the value itself, or the one evaluated by the given evaluator recipe.\n */\nexport function valueByRecipe<TValue, TArgs extends any[]>(\n    recipe: ValueRecipe<TValue, TArgs>,\n    ...args: TArgs\n): TValue {\n  return (/*#__INLINE__*/ isValueEvaluator(recipe)) ? recipe(...args) : recipe;\n}\n\n/**\n * Converts a value recipe to its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Value recipe to convert.\n *\n * @returns Either evaluator itself, or the one evaluating to the given value.\n */\nexport function valueRecipe<TValue, TArgs extends any[]>(\n    recipe: ValueRecipe<TValue, TArgs>,\n): ValueRecipe.Evaluator<TValue, TArgs> {\n  return (/*#__INLINE__*/ isValueEvaluator(recipe)) ? recipe : valueProvider(recipe);\n}\n","import { immediateRenderScheduler, RenderExecution } from '@frontmeans/render-scheduler';\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { DefaultRenderScheduler } from '../../boot/globals';\nimport { ComponentContext } from '../../component';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * @internal\n */\nconst enum RenderStatus {\n  Cancelled = -1,\n  Complete = 0,\n  Pending = 1,\n  Scheduled = 2,\n}\n\n/**\n * @internal\n */\nexport class ElementRenderCtl$ implements ElementRenderCtl {\n\n  private readonly _renders = new Set<() => void>();\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  renderBy(\n      renderer: ElementRenderer,\n      def: RenderDef = {},\n  ): Supply {\n\n    const spec = RenderDef.spec(this._context, def);\n    const trigger = RenderDef.trigger(this._context, spec);\n    const schedule = this._context.get(DefaultRenderScheduler)({\n      ...RenderDef.fulfill(spec),\n      node: this._context.element as Element,\n    });\n    const whenConnected = spec.when === 'connected';\n    let status = RenderStatus.Pending;\n    const startRendering = (): 0 | void => status /* there is an update to render */ && scheduleRenderer();\n    const onUpdate = whenConnected\n        ? () => this._context.connected && scheduleRenderer()\n        : () => this._context.settled && scheduleRenderer();\n    const supply = trigger(onUpdate)\n        .needs(this._context)\n        .whenOff(cancelRenderer);\n\n    (whenConnected ? this._context.whenConnected : this._context.whenSettled)(startRendering);\n\n    const immediateSchedule = immediateRenderScheduler();\n\n    this._renders.add(renderNow);\n\n    return supply.whenOff(() => this._renders.delete(renderNow));\n\n    function scheduleRenderer(): void {\n      status = RenderStatus.Scheduled;\n      schedule(renderElement);\n    }\n\n    function renderNow(): void {\n      immediateSchedule(renderElement);\n    }\n\n    function cancelRenderer(): void {\n      if (status === RenderStatus.Scheduled) { // Scheduled, but not rendered yet\n        schedule(noop);\n      }\n      status = RenderStatus.Cancelled;\n    }\n\n    function renderElement(execution: RenderExecution): void {\n      if (status > RenderStatus.Complete) { // Prevent excessive rendering\n        status = RenderStatus.Complete;\n        for (; ;) {\n\n          const newRenderer = renderer(execution);\n\n          if (newRenderer === renderer || typeof newRenderer !== 'function') {\n            break;\n          }\n\n          renderer = newRenderer;\n        }\n      }\n    }\n  }\n\n  renderNow(): void {\n    this._renders.forEach(render => render());\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { ElementRenderCtl$ } from './element-render-ctl.impl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A render control of component's element.\n *\n * Controls rendering by {@link ElementRenderer element renderers}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport interface ElementRenderCtl {\n\n  /**\n   * Enables component element rendering by the given `renderer`.\n   *\n   * A `renderer` call will be scheduled by {@link DefaultRenderScheduler} once component state updated.\n   *\n   * @param renderer - Element renderer function.\n   * @param def - Optional element rendering definition.\n   *\n   * @returns Render shots supply. Element `renderer` will stop rendering once this supply is cut off.\n   */\n  renderBy(\n      renderer: ElementRenderer,\n      def?: RenderDef,\n  ): Supply;\n\n  /**\n   * Executes scheduled element render shots immediately.\n   *\n   * Uses `immediateRenderScheduler` for that.\n   *\n   * Does not execute element renderers that are not scheduled. I.e. if no corresponding state updates happened.\n   */\n  renderNow(): void;\n\n}\n\n/**\n * A key of component context value containing {@link ElementRenderCtl element render control}.\n *\n * @category Feature\n */\nexport const ElementRenderCtl: ContextRef<ElementRenderCtl> = (\n    /*#__PURE__*/ new SingleContextKey<ElementRenderCtl>(\n        'element-render-ctl',\n        {\n          byDefault(values) {\n            return new ElementRenderCtl$(values.get(ComponentContext));\n          },\n        },\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { RenderSchedule, RenderScheduleOptions, RenderShot } from '@frontmeans/render-scheduler';\nimport { ContextRef, ContextValues, SingleContextKey } from '@proc7ts/context-values';\nimport { trackValue } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A signature of element render scheduler.\n *\n * Schedules render shots to be executed by {@link ElementRenderCtl element render control}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport type ElementRenderScheduler =\n/**\n * @param options - Options of constructed element render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: ElementRenderScheduleOptions) => RenderSchedule;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link ElementRenderScheduler element render scheduler} when constructing new render schedule.\n *\n * Generic `RenderSchedule` options are ignored.\n *\n * @category Feature\n */\nexport interface ElementRenderScheduleOptions extends RenderScheduleOptions, RenderDef.Options {\n\n  /**\n   * When to start the rendering.\n   *\n   * One of:\n   * - `settled` - start rendering when component is {@link ComponentContext.settled settled}.\n   * - `connected` (the default) - start rendering when component's element is {@link ComponentContext.connected\n   *   connected} to document.\n   */\n  readonly when?: 'settled' | 'connected';\n\n  /**\n   * Reports rendering error. E.g. a render shot execution failure.\n   *\n   * @param messages - Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * @internal\n */\nfunction newElementRenderScheduler(context: ContextValues): ElementRenderScheduler {\n\n  const renderCtl = context.get(ElementRenderCtl);\n\n  return (opts = {}): RenderSchedule => {\n\n    const recentShot = trackValue<RenderShot>(noop);\n    const renderer: ElementRenderer = execution => {\n      recentShot.it(execution);\n    };\n\n    renderCtl.renderBy(renderer, RenderDef.fulfill({ on: recentShot.on }, opts));\n\n    return (shot: RenderShot): void => {\n      recentShot.it = execution => shot(execution); // Ensure render shot always updated\n    };\n  };\n}\n\n/**\n * A key of component context value containing {@link ElementRenderScheduler element render scheduler}.\n *\n * @category Feature\n */\nexport const ElementRenderScheduler: ContextRef<ElementRenderScheduler> = (\n    /*#__PURE__*/ new SingleContextKey<ElementRenderScheduler>(\n        'element-render-scheduler',\n        {\n          byDefault: newElementRenderScheduler,\n        },\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { RenderExecution } from '@frontmeans/render-scheduler';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * Component property decorator that declares a rendering method for the component.\n *\n * The decorated method call will be scheduled by {@link DefaultRenderScheduler} once component state updated.\n *\n * The decorated method should have no arguments. It may return either nothing, or a function. In the latter case the\n * returned function will be called immediately to render the element. It may, in turn, return a renderer function,\n * and so on.\n *\n * Enables rendering with {@link ElementRenderCtl.renderBy element render control}.\n *\n * @category Feature\n * @typeParam T - A type of decorated component class.\n * @param def - Non-mandatory render definition.\n *\n * @returns Component method decorator.\n */\nexport function Render<T extends ComponentClass>(\n    def?: RenderDef,\n): ComponentPropertyDecorator<(execution: RenderExecution) => ElementRenderer | void, T> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(() => {\n\n            const { component } = context;\n            const renderer = get(component).bind(component);\n\n            context.get(ElementRenderCtl).renderBy(renderer, def);\n          });\n        });\n      },\n    },\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * Component shadow content root.\n *\n * @category Feature\n */\nexport type ShadowContentRoot = ShadowRoot;\n\n/**\n * A key of component context value containing a shadow content root instance.\n *\n * This is only available when the component is decorated with {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Feature\n */\nexport const ShadowContentRoot: SingleContextRef<ShadowContentRoot> = (\n    /*#__PURE__*/ new SingleContextKey<ShadowContentRoot>('shadow-content-root')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * An event related to element's shadow DOM.\n *\n * The following event types supported:\n * - `wesib:shadowAttached` is dispatched when a shadow root is attached to element.\n *   In particular, it is dispatched for components decorated with {@link AttachShadow @AttachShadow}.\n *   The event is dispatched when component is connected for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Feature\n */\nexport class ShadowDomEvent extends Event {\n\n  /**\n   * Shadow root this event relates to.\n   */\n  get shadowRoot(): ShadowRoot {\n    return (this.target as Element).shadowRoot as ShadowRoot;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { ComponentContext, ComponentContext__symbol, ComponentContextHolder } from '../../component';\nimport { ShadowContentDef } from './attach-shadow.decorator';\nimport { ShadowDomEvent } from './shadow-dom-event';\n\n/**\n * Shadow root builder function type.\n *\n * An instance of this function is available in component context and is used by {@link AttachShadow @AttachShadow}\n * decorator to attach shadow root to decorated component's custom element.\n *\n * By default, if shadow root already exists for the component's element, it uses one.\n *\n * Dispatches a `wesib:shadowAttached` event for the found or attached shadow root.\n *\n * @category Feature\n */\nexport type ShadowRootBuilder =\n/**\n * @param context - Target component context.\n * @param init - Shadow root initialization options.\n *\n * @returns A shadow root instance for target component, or `null`/`undefined` if one can not be attached.\n */\n    (context: ComponentContext, init: ShadowContentDef) => ShadowRoot | null | undefined;\n\n/**\n * A key of component context value containing a shadow root builder instance.\n *\n * @category Feature\n */\nexport const ShadowRootBuilder: FnContextRef<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>>(\n        'shadow-root-builder',\n        {\n          byDefault() {\n            return attachShadow;\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nfunction attachShadow(context: ComponentContext, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const element = context.element as Element;\n  const shadowRoot = shadowRootOf(element, init);\n\n  if (shadowRoot) {\n    (shadowRoot as ComponentContextHolder)[ComponentContext__symbol] = context;\n    context.whenConnected(() => context.dispatchEvent(new ShadowDomEvent(\n        'wesib:shadowAttached',\n        { bubbles: true },\n    )));\n  }\n\n  return shadowRoot;\n}\n\n/**\n * @internal\n */\nfunction shadowRootOf(element: Element, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const existing = element.shadowRoot;\n\n  if (existing) {\n    // Shadow root already attached. Using it.\n    return existing;\n  }\n  if ('attachShadow' in element) {\n    return element.attachShadow(init);\n  }\n\n  return; // Unable to attach shadow root.\n}\n\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '@proc7ts/primitives';\nimport { Component, ComponentContext, ComponentDecorator, ContentRoot } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ShadowContentRoot } from './shadow-content-root';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * @internal\n */\nconst defaultShadowContentDef: ShadowContentDef = { mode: 'open' };\n\n/**\n * Shadow content root definition.\n *\n * This is a readonly component shadow root initialization options.\n *\n * @category Feature\n */\nexport type ShadowContentDef = Readonly<ShadowRootInit>;\n\n/**\n * Creates a component decorator that attaches shadow root to decorated component instance.\n *\n * @category Feature\n * @typeParam T - A type of decorated component class.\n * @param def - Shadow content root definition. Uses `mode: 'open'` by default.\n *\n * @returns New component decorator.\n */\nexport function AttachShadow<T extends ComponentClass = Class>(\n    def: ShadowContentDef = defaultShadowContentDef,\n): ComponentDecorator<T> {\n  return Component({\n    setup(setup) {\n      setup.perComponent(\n          {\n            a: ShadowContentRoot,\n            by(ctx: ComponentContext<InstanceType<T>>) {\n              return ctx.get(ShadowRootBuilder)(ctx, def);\n            },\n          },\n      );\n      setup.perComponent({ // Content root is an alias of shadow root when present.\n        a: ContentRoot,\n        by(context: ComponentContext<InstanceType<T>>) {\n          return context.get(ShadowContentRoot, { or: null });\n        },\n      });\n    },\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { NamespaceDef } from '@frontmeans/namespace-aliaser';\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nexport const Wesib__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns',\n    'b',\n    'wesib',\n));\n","/**\n * @packageDocumentation\n * @module @proc7ts/delta-set\n */\nimport type { ReadonlyDeltaSet } from './readonly-delta-set';\n\n/**\n * A `Set` implementation that keeps a delta of changes made to it.\n *\n * @typeParam T - A type of elements of delta set.\n */\nexport class DeltaSet<T> extends Set<T> implements ReadonlyDeltaSet<T> {\n\n  /** @internal */\n  private readonly _added: Set<T>;\n\n  /** @internal */\n  private readonly _removed: Set<T>;\n\n  /**\n   * Constructs new delta set.\n   *\n   * @param values - An iterable of elements be add to constructed delta set. Or `null` to add nothing.\n   */\n  constructor(values?: Iterable<T> | null) {\n    super();\n    this._added = new Set<T>(values);\n    this._removed = new Set<T>();\n    this._added.forEach(value => this.add(value));\n  }\n\n  /**\n   * Appends a new element with a specified value to the end of this delta set. Unless the set contains this element\n   * already.\n   *\n   * Records element addition and forgets its removal unless the set contains it already.\n   *\n   * @param value - The value of the element to add.\n   *\n   * @returns `this` delta set.\n   */\n  add(value: T): this {\n    if (!this.has(value)) {\n      this._added.add(value);\n      this._removed.delete(value);\n      super.add(value);\n    }\n    return this;\n  }\n\n  /**\n   * Removes the specified element from this delta set.\n   *\n   * Records element removal and forgets its addition if removal succeed.\n   *\n   * @param value - The value of the element to remove.\n   *\n   * @returns `true` if element removed successfully; or `false` if this set did not contain the element.\n   */\n  delete(value: T): boolean {\n    if (super.delete(value)) {\n      this._added.delete(value);\n      this._removed.add(value);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all elements from this delta set.\n   *\n   * Records all elements removal and forgets all elements additions.\n   */\n  clear(): void {\n    this._added.clear();\n    this.forEach(value => this._removed.add(value));\n    super.clear();\n  }\n\n  /**\n   * Applies changes to this delta set.\n   *\n   * First removes elements to `remove`. Then appends elements to `add`.\n   *\n   * Records all changes made.\n   *\n   * @param add - An iterable of elements to add.\n   * @param remove - An iterable of elements to remove.\n   *\n   * @returns `this` delta set.\n   */\n  delta(add: Iterable<T>, remove: Iterable<T> = []): this {\n    deltaSetDeltaReceiver(this)(add, remove);\n    return this;\n  }\n\n  /**\n   * Replays the changes made to this set in target receiver.\n   *\n   * @param receiver - A receiver of changes delta. E.g. another `Set`.\n   *\n   * @returns `this` delta set.\n   */\n  redelta(receiver: DeltaSet.DeltaReceiver<T>): this {\n\n    const receive = typeof receiver === 'function' ? receiver : deltaSetDeltaReceiver(receiver);\n\n    receive([...this._added], [...this._removed]);\n\n    return this;\n  }\n\n  /**\n   * Forgets all changes made to this set.\n   *\n   * Does not alter the set contents.\n   *\n   * @returns `this` delta set.\n   */\n  undelta(): this {\n    this._added.clear();\n    this._removed.clear();\n    return this;\n  }\n\n}\n\nexport namespace DeltaSet {\n\n  /**\n   * A delta set changes receiver.\n   *\n   * This can be either an {@link DeltaReceiverObject object}, or a {@link DeltaReceiverFunction function}.\n   *\n   * @typeParam T - A type of elements of delta set.\n   */\n  export type DeltaReceiver<T> =\n      | DeltaReceiverFunction<T>\n      | DeltaReceiverObject<T>;\n\n  /**\n   * A delta set changes receiver function.\n   *\n   * @typeParam T - A type of elements of delta set.\n   */\n  export type DeltaReceiverFunction<T> =\n  /**\n   * @param added - An array of added elements.\n   * @param removed - An array of removed elements.\n   */\n      (this: void, added: T[], removed: T[]) => void;\n\n  /**\n   * A delta set changes receiver object.\n   *\n   * A `Set` class implements this interface.\n   *\n   * @typeParam T - A type of elements of delta set.\n   */\n  export interface DeltaReceiverObject<T> {\n\n    /**\n     * Receives an element that has been added to delta set.\n     *\n     * @param value - The value of the added element.\n     */\n    add(value: T): void;\n\n    /**\n     * Receives an element that has been remove from delta set.\n     *\n     * @param value - The value of the removed element.\n     */\n    delete(value: T): void;\n\n  }\n\n}\n\n/**\n * @internal\n */\nfunction deltaSetDeltaReceiver<T>(\n    receiver: DeltaSet.DeltaReceiverObject<T>,\n): (this: void, add: Iterable<T>, remove: Iterable<T>) => void {\n  return (add, remove) => {\n    for (const removed of remove) {\n      receiver.delete(removed);\n    }\n    for (const added of add) {\n      receiver.add(added);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n */\nexport interface InAspect<TInstance, TKind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeParam TValue - Input value type.\n   * @param control - Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, TInstance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   */\n  export interface Key<TInstance, TKind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<TInstance, TKind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeParam TValue - Input value type.\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TConvertedInstance - A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<TValue, TInstance, TConvertedInstance extends TInstance = TInstance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: TInstance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by {@link InControl.convert} method.\n     *\n     * @typeParam TTargetValue - Converted input value type.\n     * @param target - Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<TTargetValue>(target: InControl<TTargetValue>): Applied<TTargetValue, TConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of {@link convertTo} when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target - Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<TValue>): Applied<TValue, TInstance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     * @typeParam TKind - Aspect application kind.\n     */\n    export type Result<TInstance, TValue, TKind extends Kind> =\n        Applied<TValue, Instance<TInstance, TValue, TKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     * @typeParam TKind - Aspect application kind.\n     */\n    export type Instance<TInstance, TValue, TKind extends Kind> =\n        ReturnType<Map<TInstance, TValue>[TKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     */\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): TInstance;\n\n    }\n\n  }\n\n}\n","import { noop, valueProvider } from '@proc7ts/primitives';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectSameOrBuild<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance, TKind>,\n    build: <TValue>(this: void, control: InControl<TValue>, origin?: InControl<any>) => TInstance,\n    instance?: TInstance,\n    origin?: InControl<any>,\n): InAspect.Applied<TValue, TInstance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n  return {\n    instance,\n    convertTo<TTo>(target: InControl<TTo>): InAspect.Applied<TTo, TInstance> {\n      return inAspectSameOrBuild<TTo, TInstance, TKind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<TValue>): InAspect.Applied<TValue, TInstance> | undefined {\n      return inAspectSameOrBuild(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as TInstance | undefined) || build(target),\n      );\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function inAspectSameOrNull<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance | null, TKind>,\n    instance: TInstance | null = null,\n): InAspect.Applied<TValue, TInstance | null> {\n  return inAspectSameOrBuild(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * @internal\n */\nexport function inAspectValue<TInstance>(instance: TInstance): InAspect.Applied<any, TInstance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * {@link InNamespaceAliaser.to} converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return inAspectValue(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param nsAlias - Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? inAspectValue(nsAlias) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by {@link InRenderScheduler.to} converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return inAspectValue(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param scheduler - Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(scheduler: InRenderScheduler): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? inAspectValue(scheduler) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { isPresent, noop, valueProvider } from '@proc7ts/primitives';\nimport { filterArray, itsReduction, overElementsOf } from '@proc7ts/push-iterator';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n */\nexport type InConverter<TFrom, TTo> =\n    | InConverter.Conversion<TFrom, TTo>\n    | InConverter.Factory<TFrom, TTo>;\n\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo> = (\n      this: void,\n      from: InControl<TFrom>,\n      to: InControl<TTo>,\n  ) => Conversion<TFrom, TTo>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Conversion<TFrom, TTo> =\n      | InConverter.Value.Conversion<TFrom, TTo>\n      | InConverter.Aspect.Conversion<TTo>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Value<TFrom, TTo> =\n      | InConverter.Value.Factory<TFrom, TTo>\n      | InConverter.Value.Conversion<TFrom, TTo>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Aspect<TFrom, TTo = TFrom> =\n      | InConverter.Aspect.Conversion<TTo>\n      | InConverter.Aspect.Factory<TFrom, TTo>;\n\n}\n\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by {@link InControl.convert} to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo> =\n  /**\n   * @param from - Original input control.\n   * @param to - Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<TFrom>,\n          to: InControl<TTo>,\n      ) => Conversion<TFrom, TTo>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export interface Conversion<TFrom, TTo> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ): InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value - Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: TFrom): TTo;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value - A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: TTo): TFrom;\n\n  }\n\n}\n\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by {@link InControl.convert} to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo = TFrom> = (\n      this: void,\n      from: InControl<TFrom>,\n      to: InControl<TTo>,\n  ) => Conversion<TTo>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Conversion<TValue> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeParam TValue - Input value type.\n * @param converters - Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<TValue>(\n    ...converters: InConverter.Aspect<TValue, TValue>[]\n): InConverter.Aspect.Factory<TValue, TValue>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n * @param converter - Input control converter.\n * @param converters - Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<TFrom, TTo>(\n    converter: InConverter.Value<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Value.Factory<TFrom, TTo>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n * @param converter - Input control converter.\n * @param converters - Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<TFrom, TTo>(\n    converter?: InConverter<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Factory<TFrom, TTo>;\n\nexport function intoConvertedBy<TFrom, TTo>(\n    valueOrAspectConverter?: InConverter<TFrom, TTo> | InConverter.Aspect<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Factory<TFrom, TTo> {\n\n  type AspectApplicator = <TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = converters.map<InConverter.Aspect.Factory<TFrom, TTo>>(inConverter);\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<TFrom, TTo> => {\n\n    const conversion = converter(from, to);\n    const conversions = overElementsOf<InConverter.Conversion<TFrom, TTo>>(\n        [conversion],\n        filterArray<InConverter.Aspect.Conversion<TTo> | undefined, InConverter.Aspect.Conversion<TTo>>(\n            aspectConverters.map(acf => acf(from, to)),\n            isPresent,\n        ),\n    );\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev: AspectApplicator, cv: InConverter.Conversion<TFrom, TTo>) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeParam TValue - Input value type.\n * @param aspects - Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<TValue>(\n    aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[],\n): InConverter.Aspect.Factory<TValue> {\n  return aspects\n      ? ((/*#__INLINE__*/ isArray(aspects)) ? intoConvertedBy(...aspects) : intoConvertedBy(aspects))\n      : intoConvertedBy<TValue>();\n}\n\nfunction isArray<T>(value: T | readonly T[] | undefined): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nfunction noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion - Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<TFrom, TTo>(\n    conversion: InConverter.Conversion<TFrom, TTo>,\n): conversion is InConverter.Aspect.Conversion<TTo> {\n  return !(conversion as Partial<InConverter.Value.Conversion<TFrom, TTo>>).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter.Value<TFrom, TTo>,\n): InConverter.Value.Factory<TFrom, TTo>;\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter.Aspect<TFrom, TTo>,\n): InConverter.Aspect.Factory<TFrom, TTo>;\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter<TFrom, TTo>,\n): InConverter.Factory<TFrom, TTo>;\n\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter<TFrom, TTo> | InConverter.Aspect<TFrom, TTo>,\n): InConverter.Factory<TFrom, TTo> | InConverter.Aspect.Factory<TFrom, TTo> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { EventEmitter, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { asis, noop, Supply } from '@proc7ts/primitives';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InConverter, intoConvertedBy, isInAspectConversion } from './converter';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class InControl<TValue> extends ValueTracker<TValue> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: TValue;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get supply(): Supply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n  ): InAspect.Application.Instance<TInstance, TValue, TKind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup - A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to set up.\n   * @param setup - A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<TInstance, TValue, TKind>, control: this) => void,\n  ): this;\n\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<TInstance, TKind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<TInstance, TValue, TKind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeParam TTo - Converted input value type.\n   * @param by - Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<TValue, TValue>[]\n  ): InControl<TValue>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeParam TTo - Converted input value type.\n   * @param by - Input control converter.\n   * @param and - Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<TTo>(\n      by: InConverter<TValue, TTo>,\n      ...and: InConverter.Aspect<TValue, TTo>[]\n  ): InControl<TTo>;\n\n  convert<TTo>(\n      by?: InConverter<TValue, TTo>,\n      ...and: InConverter.Aspect<TValue, TTo>[]\n  ): InControl<TValue> | InControl<TTo> {\n    return new InConverted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<TInstance, TValue, TKind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<TInstance, TValue, TKind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param _aspect - An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      _aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isAspectKey<TInstance, TKind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<TInstance, TKind> {\n  return InAspect__symbol in value;\n}\n\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeParam TControl - Input control type.\n   */\n  export type ValueType<TControl extends InControl<any>> = TControl extends InControl<infer TValue> ? TValue : never;\n\n}\n\n/**\n * @internal\n */\nclass InConverted<TFrom, TTo> extends InControl<TTo> {\n\n  readonly supply: Supply;\n  private readonly _on = new EventEmitter<[TTo, TTo]>();\n  private readonly _it: ValueTracker<[TTo, number]>;\n  protected readonly _applyAspect: <TInstance, TKind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<TInstance, TKind>,\n  ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n  constructor(src: InControl<TFrom>, by: InConverter.Factory<TFrom, TTo>) {\n    super();\n    this.supply = new Supply().needs(src);\n\n    let lastRev = 0;\n    let backward: TFrom | undefined;\n\n    const conversion = by(src, this);\n    let set: (value: TFrom) => TTo;\n    let get: (value: TTo) => TFrom;\n    let convertAspect: <TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      set = asis as (value: TFrom) => TTo;\n      get = asis as (value: TTo) => TFrom;\n      convertAspect = <TInstance, TKind extends InAspect.Application.Kind>(aspect: InAspect<TInstance, TKind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <TInstance, TKind extends InAspect.Application.Kind>(aspect: InAspect<TInstance, TKind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    this._it.supply.needs(this.supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        this._on.send(newValue, oldValue);\n      }\n    }).cuts(this._on);\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).cuts(this);\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get it(): TTo {\n    return this._it.it[0];\n  }\n\n  set it(value: TTo) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  get on(): OnEvent<[TTo, TTo]> {\n    return this._on.on;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { InControl } from '../control';\n\n/**\n * @internal\n */\nclass InSameValueControl<TValue> extends InControl<TValue> {\n\n  private _supply?: Supply;\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n  }\n\n  get supply(): Supply {\n    return this._supply || (this._supply = new Supply().needs(this._control));\n  }\n\n  get it(): TValue {\n    return this._control.it;\n  }\n\n  set it(value: TValue) {\n    this._control.it = value;\n  }\n\n  get on(): OnEvent<[TValue, TValue]> {\n    return this._control.on;\n  }\n\n}\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @param control - Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<TValue>(control: InControl<TValue>): InControl<TValue> {\n  return new InSameValueControl(control);\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { InAspect } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter, intoConvertedAspects } from '../converter';\nimport { inValueOf } from './value-of.control';\n\n/**\n * Abstract input control implementation.\n *\n * Allows to define default input aspects.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class AbstractInControl<TValue> extends InControl<TValue> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspectConversion: InConverter.Aspect.Conversion<TValue>;\n\n  /**\n   * Constructs input control.\n   *\n   * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   */\n  protected constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[];\n      },\n  ) {\n    super();\n    this._aspectConversion = intoConvertedAspects(aspects)(inValueOf(this), this);\n  }\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return this._aspectConversion.applyAspect(aspect) || super._applyAspect(aspect);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { AbstractInControl } from '../controls';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class InContainer<TValue> extends AbstractInControl<TValue> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectSameOrNull(this, InContainer, this) as InAspect.Application.Result<TInstance, TValue, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * An `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  /**\n   * An `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InContainer.Snapshot]>;\n\n  [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read;\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<TValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return inAspectValue(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  /**\n   * An `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InParents.All]>;\n\n  [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read;\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry - Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): Supply;\n\n}\n\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  readonly read: AfterEvent<[InParents.All]>;\n  private readonly _map = new Map<InParents.Entry, Supply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    this._on.supply.needs(this._control);\n\n    const allParents = (): IterableIterator<InParents.Entry> => this._map.keys();\n\n    this.read = this.on.do(mapAfter(allParents, allParents));\n  }\n\n  add(entry: InParents.Entry): Supply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = new Supply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n  get on(): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this._on.on;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrNull } from './aspect.impl';\nimport { AbstractInControl } from './controls';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nexport abstract class InElement<TValue, TElt = HTMLElement> extends AbstractInControl<TValue> {\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: TElt;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  /**\n   * An `AfterEvent` keeper of user input.\n   */\n  abstract readonly input: AfterEvent<[InElement.Input<TValue>]>;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inAspectSameOrNull(\n            this,\n            InElement,\n            this as InElement<TValue, any>,\n        ) as InAspect.Application.Result<TInstance, TValue, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Input<TValue> {\n\n    /**\n     * The value user entered.\n     */\n    value: TValue;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<TValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  afterSupplied,\n  afterThe,\n  digAfter,\n  digAfter_,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  mapAfter,\n  mapOn,\n  OnEvent,\n  OnEvent__symbol,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  translateOn,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { Supply, valuesProvider } from '@proc7ts/primitives';\nimport { itsElements, overElementsOf } from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InMode> {\n    return inAspectSameOrBuild(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of input mode updates.\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n\n  /**\n   * An `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InMode.Value]>;\n\n  [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read;\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode - Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source - A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): Supply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason - Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.supply.off(reason);\n    return this;\n  }\n\n}\n\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get supply(): Supply {\n    return this._tracker.supply;\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n    case 'off':\n    case 'ro':\n    case '-on':\n    case '-ro':\n      break;\n    default:\n      value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  get on(): OnEvent<[InMode.Value, InMode.Value]> {\n    return this._tracker.on;\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterSent(\n        this._on.on.do(mapOn(() => this._all)),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.do(\n        digAfter_((set: Set<AfterEvent<[InMode.Value]>>) => afterEach(...set)),\n        mapAfter(mergeInModes),\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): Supply {\n\n    const supply = new Supply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    this.own.supply.needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read.do(digAfter(parentsInMode)));\n\n    let last: InMode.Value = 'on';\n\n    this.read = afterAll({\n      derived: this._derived.read,\n      own: this.own,\n    }).do(translateAfter(\n        (\n            send,\n            {\n              derived: [derived],\n              own: [own],\n            },\n        ) => {\n\n          let next: InMode.Value;\n\n          if (own === 'off' || derived === 'off') {\n            next = 'off';\n          } else {\n\n            let off = false;\n\n            if (own[0] === '-') {\n              off = true;\n              own = own.substring(1) as InMode.Value;\n            }\n            if (derived[0] === '-') {\n              off = true;\n              derived = derived.substring(1) as InMode.Value;\n            }\n            next = derived === 'ro' ? 'ro' : own;\n            if (off) {\n              next = '-' + next as InMode.Value;\n            }\n          }\n\n          if (last !== next) {\n            send(last = next);\n          }\n        },\n        valuesProvider<[InMode.Value]>(last),\n    ));\n\n    let lastUpdate: InMode.Value = 'on';\n\n    this.on = this.read.do(translateOn((send, value) => {\n\n      const old = lastUpdate;\n\n      if (old !== value) {\n        send(lastUpdate = value, old);\n      }\n    }));\n\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n  }\n\n  derive(source: InMode.Source): Supply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control)).do(supplyAfter(this._control)),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off'\n      : (element.getAttribute('readonly') != null ? 'ro' : 'on');\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n  case 'off':\n    element.setAttribute('disabled', '');\n    break;\n  case 'ro':\n  case '-ro':\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    element.setAttribute('readonly', '');\n    break;\n  default:\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('readonly', '');\n    element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): AfterEvent<[InMode.Value]> {\n\n  const parentList = itsElements(parents);\n\n  if (!parentList.length) {\n    return afterThe('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return afterEach(...parentModes).do(mapAfter(mergeInModes));\n}\n\n/**\n * @internal\n * @param modes\n */\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...overElementsOf<InMode.Value>(...modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes - Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n    case 'off':\n      return 'off';\n    case 'ro':\n      ro = true;\n      break;\n    case '-on':\n      off = true;\n      break;\n    case '-ro':\n      off = true;\n      ro = true;\n      break;\n    case 'on':\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { afterAll, AfterEvent, mapAfter } from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport type InData<TValue> = AfterEvent<[InData.DataType<TValue>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<TValue>(control: InControl<TValue>): Applied<TValue> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return inAspectSameOrBuild(control, InData, <TValue>(ctrl: InControl<TValue>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).do(mapAfter(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? value as any\n            : undefined,\n    )));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<TValue>(control: InControl<TValue>): Applied<TValue>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<TValue> extends InAspect.Applied<TValue, InData<TValue>, InData<any>> {\n\n  convertTo<TTo>(target: InControl<TTo>): Applied<TTo> | undefined;\n\n}\n\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export type DataType<TValue> =\n      | (TValue extends object ? { [K in keyof TValue]?: DataType<TValue[K]> } : TValue)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<TValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  digAfter_,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  onceAfter,\n  OnEvent,\n  OnEvent__symbol,\n  supplyAfter,\n  trackValue,\n  translateOn,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { neverSupply, noop, Supply } from '@proc7ts/primitives';\nimport {\n  iteratorOf,\n  itsEach,\n  mapIt,\n  overEntries,\n  overIterator,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nexport abstract class InGroup<TModel extends object> extends InContainer<TModel> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<TModel>;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<TInstance, TModel, TKind> | undefined {\n    return aspect === InGroup__aspect\n        ? inAspectSameOrNull(this, InGroup, this) as InAspect.Application.Result<TInstance, TModel, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   */\n  export type Controls<TModel> = {\n    readonly [K in keyof TModel]?: InControl<TModel[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   * @typeParam TKey - Model keys type.\n   */\n  export type Entry<TModel, TKey extends keyof TModel = any> = readonly [TKey, InControl<TModel[TKey]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   */\n  export interface Snapshot<TModel> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<TModel>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key - Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<TKey extends keyof TModel>(key: TKey): InGroup.Controls<TModel>[TKey] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<TModel>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>,\n        EventKeeper<[InGroup.Snapshot<TModel>]> {\n\n  abstract readonly on: OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n\n  abstract readonly read: AfterEvent<[InGroup.Snapshot<TModel>]>;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @typeParam TKey - Model key type.\n   * @param key - A key of input control to set. I.e. corresponding model property key.\n   * @param control - Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<TKey extends keyof TModel>(key: TKey, control: InControl<TModel[TKey]> | undefined): Supply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls - A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<TModel>): Supply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key - A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof TModel): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<TModel> {\n\n  [OnEvent__symbol](): OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InGroup.Snapshot<TModel>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, Supply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<TModel> implements InGroup.Snapshot<TModel>, PushIterable<InControl<any>> {\n\n  private readonly _it: PushIterable<InControl<any>>;\n  private readonly _entriesIt: PushIterable<InGroup.Entry<TModel>>;\n\n  constructor(private readonly _map: Map<keyof TModel, InGroupEntry>) {\n    this._it = mapIt(\n        overIterator(() => this._map.values()),\n        ([control]: InGroupEntry) => control,\n    );\n    this._entriesIt = mapIt(this._map, ([key, [control]]) => [key, control]);\n  }\n\n  get<TKey extends keyof TModel>(key: TKey): InGroup.Controls<TModel>[TKey] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<TModel>[TKey];\n  }\n\n  [Symbol.iterator](): PushIterator<InControl<any>> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<InControl<any>>): PushIterator<InControl<any>> {\n    return this._it[PushIterator__symbol](accept);\n  }\n\n  entries(): PushIterator<InGroup.Entry<TModel>> {\n    return iteratorOf(this._entriesIt);\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<TModel extends object> {\n\n  readonly _supply = new Supply();\n  private _map = new Map<keyof TModel, InGroupEntry>();\n  private _shot?: InGroupSnapshot<TModel>;\n\n  constructor(private readonly _controls: InGroupControlControls<TModel>) {\n  }\n\n  set<TKey extends keyof TModel>(\n      key: TKey,\n      control: InControl<TModel[TKey]> | undefined,\n      added: [keyof TModel, InGroupEntry][],\n      removed: [keyof TModel, InGroupEntry][],\n  ): Supply {\n\n    const replaced = this._map.get(key);\n    let supply: Supply;\n\n    if (control) {\n      supply = new Supply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = neverSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<TKey extends keyof TModel>(\n      key: TKey,\n      control: InControl<TModel[TKey]>,\n      supply: Supply,\n  ): InGroupEntry {\n    return [\n      control,\n      new Supply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof TModel, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof TModel, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<TModel> {\n    return this._shot || (this._shot = new InGroupSnapshot<TModel>(this._map));\n  }\n\n  clear(): [keyof TModel, InGroupEntry][] {\n\n    const added: [keyof TModel, InGroupEntry][] = [];\n    const removed: [keyof TModel, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<TModel extends object> extends InGroupControls<TModel> {\n\n  readonly on: OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n  readonly read: AfterEvent<[InGroup.Snapshot<TModel>]>;\n  private readonly _map: InGroupMap<TModel>;\n  private readonly _updates = new EventEmitter<[[keyof TModel, InGroupEntry][], [keyof TModel, InGroupEntry][]]>();\n\n  constructor(private readonly _group: InGroupControl<TModel>) {\n    super();\n\n    const applyModelToControls = (model: TModel): void => {\n      this.read.do(onceAfter)(snapshot => {\n\n        const withValues = new Set<keyof TModel>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    };\n\n    this._map = new InGroupMap<TModel>(this);\n\n    this.on = this._updates.on.do(translateOn(\n        (send, added, removed) => send(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    ));\n\n    const takeSnapshot = this._map.snapshot.bind(this._map);\n\n    this.read = this._updates.on.do(mapAfter(\n        takeSnapshot,\n        takeSnapshot,\n    ));\n\n    this._map._supply.needs(_group.read(applyModelToControls));\n  }\n\n  set<TKey extends keyof TModel>(\n      keyOrControls: TKey | InGroup.Controls<TModel>,\n      newControl?: InControl<TModel[TKey]> | undefined,\n  ): Supply {\n\n    const group = this._group;\n    const added: [keyof TModel, InGroupEntry][] = [];\n    const removed: [keyof TModel, InGroupEntry][] = [];\n    let supply: Supply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = new Supply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: TModel | undefined;\n\n      added.forEach(<TKey extends keyof TModel>(keyAndEntry: [keyof TModel, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [TKey, [InControl<TModel[TKey]>, Supply]];\n\n        control.aspect(InParents)\n            .add({ parent: group })\n            .needs(supply)\n            .cuts(supply);\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(<TKey extends keyof TModel>(keyAndEntry: [keyof TModel, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [TKey, [InControl<TModel[TKey]>, Supply]];\n\n        control.read.do(supplyAfter(supply))(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).cuts(supply);\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<TModel extends object>(\n    [key, [control]]: [keyof TModel, InGroupEntry],\n): InGroup.Entry<TModel> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<TModel extends object> extends InGroup<TModel> {\n\n  private readonly _model: ValueTracker<TModel>;\n  readonly controls: InGroupControlControls<TModel>;\n\n  constructor(\n      model: TModel,\n      opts: {\n        readonly aspects?: InConverter.Aspect<TModel> | readonly InConverter.Aspect<TModel>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    this.supply.whenOff(() => this.controls.clear());\n  }\n\n  get supply(): Supply {\n    return this._model.supply;\n  }\n\n  get it(): TModel {\n    return this._model.it;\n  }\n\n  set it(value: TModel) {\n    this._model.it = value;\n  }\n\n  get on(): OnEvent<[TModel, TModel]> {\n    return this._model.on;\n  }\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<TInstance, TModel, TKind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<TModel extends object>(group: InGroup<TModel>): InData<TModel> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).do(\n      digAfter_(readInGroupData),\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<TModel extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<TModel>];\n      model: [TModel];\n      mode: [InMode.Value];\n    },\n): AfterEvent<[InData.DataType<TModel>?]> {\n  if (!InMode.hasData(mode)) {\n    return afterThe();\n  }\n\n  const csData = {} as { [key in keyof TModel]: InData<any> };\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof TModel] = control.aspect(InData);\n  });\n\n  return afterAll(csData).do(mapAfter(controlsData => {\n\n    const data: Partial<TModel> = { ...model };\n\n    itsEach(\n        overEntries(controlsData),\n        <TKey extends keyof TModel>(keyAndControlData: readonly [keyof TModel, [InData.DataType<any>?]]) => {\n\n          const [key, [controlData]] = keyAndControlData as readonly [TKey, [TModel[TKey]?]];\n\n          data[key] = controlData;\n        },\n    );\n\n    return data as InData.DataType<TModel>;\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n * @param model - Initial model of the group.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<TModel extends object>(\n    model: TModel,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<TModel> | readonly InConverter.Aspect<TModel>[];\n    } = {},\n): InGroup<TModel> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<TValue extends object ? TValue : never> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { AfterEvent, afterThe } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nconst RequireNothing$ = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return RequireNothing$;\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  shareAfter,\n  supplyAfter,\n} from '@proc7ts/fun-events';\nimport { noop, Supply, valuesProvider } from '@proc7ts/primitives';\nimport { flatMapIt, itsEach } from '@proc7ts/push-iterator';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<TValue> implements EventKeeper<InValidation.Message[]> {\n\n  readonly _messages: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<TValue>) => Supply;\n\n  constructor(control: InControl<TValue>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, Supply>();\n    const validatorMessages = new Map<InValidator<TValue>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: Supply) => void = noop;\n\n    this._messages = afterEventBy<InValidation.Message[]>(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider())(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: Supply) => {\n\n        const supply = validator(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).do(\n        shareAfter,\n        supplyAfter(control),\n    );\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = new Supply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values());\n    }\n  }\n\n  [AfterEvent__symbol](): AfterEvent<InValidation.Message[]> {\n    return this._messages;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { AfterEvent, afterSupplied, EventKeeper, isEventKeeper, translateAfter } from '@proc7ts/fun-events';\nimport { arrayOfElements, valueProvider } from '@proc7ts/primitives';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n */\nexport type InValidator<TValue> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<TValue>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<TValue>;\n\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Simple<TValue> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control - Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<TValue>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validator - Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<TValue>(\n    validator: InValidator<TValue>,\n): (this: void, control: InControl<TValue>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n\n  return control => control.read.do(\n      translateAfter(send => send(...arrayOfElements(validator.validate(control)))),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport {\n  flatMapArray,\n  itsEach,\n  mapIt,\n  overArray,\n  overEntries,\n  overNone,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<TValue>(control: InControl<TValue>) {\n    return inAspectSameOrBuild<TValue, InValidation<TValue>, 'validation'>(\n        control,\n        InValidation,\n        <TValue>(ctrl: InControl<TValue>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<TValue>(ctrl);\n\n          if (origin) {\n            validation.by(\n                origin.aspect(InValidation).read.do(\n                    translateAfter((send, result) => send(...result.messages())),\n                ),\n            );\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport abstract class InValidation<TValue> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InValidation.Result]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read;\n  }\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators - Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<TValue>[]): Supply;\n\n}\n\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code - Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code - Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes - Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result & PushIterable<InValidation.Message> = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator](): PushIterator<InValidation.Message> {\n    return overNone();\n  },\n  [PushIterator__symbol](_accept): PushIterator<InValidation.Message> {\n    return overNone();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result, PushIterable<InValidation.Message> {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _it: PushIterable<InValidation.Message>;\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    this._it = overArray(this._all);\n    messages.forEach(message => {\n\n      let nonEmpty = false;\n\n      itsEach(overEntries(message), ([code, codePresent]) => {\n        if (codePresent) {\n          nonEmpty = true;\n\n          const prev = this._byCode.get(code);\n\n          if (prev) {\n            prev.push(message);\n          } else {\n            this._byCode.set(code, [message]);\n          }\n        }\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (nonEmpty) {\n        this._all.push(message);\n      }\n    });\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): PushIterator<InValidation.Message> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<InValidation.Message>): PushIterator<InValidation.Message> {\n    return this._it[PushIterator__symbol](accept);\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages - Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<TValue> extends InValidation<TValue> {\n\n  readonly _messages: InValidationMessages<TValue>;\n  readonly read: AfterEvent<[InValidation.Result]>;\n\n  constructor(control: InControl<TValue>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    this.read = afterSupplied(this._messages).do<AfterEvent<[InValidation.Result]>>(\n        mapAfter(inValidationResult),\n    );\n\n    const container = control.aspect(InContainer);\n\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n  }\n\n  by(...validators: InValidator<TValue>[]): Supply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read.do(\n      digAfter_(controls => afterEach(...mapIt(controls, control => control.aspect(InValidation)))),\n      translateAfter((send, ...results) => send(...flatMapArray(results, ([result]) => result))),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<TValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validators - Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<TValue>(...validators: InValidator<TValue>[]): InValidator<TValue> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<TValue>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { EventKeeper, translateAfter } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control\n      ? control.read.do(\n          translateAfter((send, value) => value ? send() : send({ missing: 'missing' })),\n      )\n      : requirePresent;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { AfterEvent, EventEmitter, mapAfter, OnEvent, translateOn } from '@proc7ts/fun-events';\nimport { asis, Supply } from '@proc7ts/primitives';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nexport class AbstractInElement<TValue, TElt extends HTMLElement> extends InElement<TValue, TElt> {\n\n  readonly events: DomEventDispatcher;\n  readonly input: AfterEvent<[InElement.Input<TValue>]>;\n  readonly on: OnEvent<[TValue, TValue]>;\n  private readonly _get: (this: AbstractInElement<TValue, TElt>) => TValue;\n  private readonly _set: (this: AbstractInElement<TValue, TElt>, value: TValue) => void;\n  private readonly _input: EventEmitter<[InElement.Input<TValue>, TValue]> = new EventEmitter();\n  private _value: TValue;\n  private _update: (value: TValue, oldValue: TValue) => void;\n\n  /**\n   * Constructs HTML input element control.\n   *\n   * @param element - HTML input element the constructed control is based on.\n   * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   * @param get - Input value getter.\n   * @param set - Input value setter.\n   */\n  constructor(\n      readonly element: TElt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[];\n        readonly get: (this: AbstractInElement<TValue, TElt>) => TValue;\n        readonly set: (this: AbstractInElement<TValue, TElt>, value: TValue) => void;\n      },\n  ) {\n    super({ aspects });\n\n    const self = this;\n\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const doUpdate = this._update = (value: TValue, oldValue: TValue): void => update({ value }, oldValue);\n\n    this.events = new DomEventDispatcher(element);\n    this.events.supply.needs(this);\n    this.listenForInput(input => update(input, this._value));\n\n    this.on = this._input.on.do(\n        translateOn((\n            send,\n            { value: newValue },\n            oldValue,\n        ) => newValue !== oldValue && send(newValue, oldValue)),\n    );\n    this.input = this._input.on.do(mapAfter(asis, () => ({ value: this.it })));\n\n    function update(input: InElement.Input<TValue>, oldValue: TValue): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<TValue>, TValue] | undefined;\n\n        // Record corrections\n        self._update = (newValue: TValue, old: TValue) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = doUpdate;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get supply(): Supply {\n    return this._input.supply;\n  }\n\n  get it(): TValue {\n    return this._get();\n  }\n\n  set it(value: TValue) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  /**\n   * Enables reaction to input input.\n   *\n   * By default listens for `input` and `change` events.\n   *\n   * @param update - Updates current value by user input and sends update event. This function is to be called by\n   * input event listeners.\n   */\n  protected listenForInput(update: (input: InElement.Input<TValue>) => void): void {\n\n    const onInput = (event: Event): void => update({ value: this.it, event });\n\n    this.events.on('input')(onInput);\n    this.events.on('change')(onInput);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { AbstractInElement } from './abstract-element.control';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element - Target text input element.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new AbstractInElement(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InFocus | null> {\n    return inAspectSameOrBuild(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when {@link InElement} aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot = element.getRootNode\n        ? element.getRootNode() as unknown as DocumentOrShadowRoot\n        : element.ownerDocument;\n\n    this._it = trackValue(owner.activeElement === element);\n    this.supply.needs(inElement);\n\n    events.on('focus')(() => this._it.it = true);\n    events.on('blur')(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get supply(): Supply {\n    return this._it.supply;\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n  get on(): OnEvent<[boolean, boolean]> {\n    return this._it.on;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  onceAfter,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { itsEach, mapIt } from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InStatus> {\n    return inAspectSameOrBuild(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InStatus.Flags]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched - Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited - Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  constructor(control: InControl<any>) {\n    super();\n    this._flags.supply.needs(control);\n    this._flags.by(elementInStatusFlags(this._flags, control));\n  }\n\n  get read(): AfterEvent<[InStatus.Flags]> {\n    return this._flags.read;\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input.do(mapAfter(({ event }) => !!event)) : afterThe(false),\n  }).do(mapAfter(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  ));\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n    this.read = containerInStatusFlags(this._container);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read.do(onceAfter)(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markEdited(edited),\n    ));\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read.do(onceAfter)(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markTouched(touched),\n    ));\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read.do(\n      supplyAfter(container),\n      digAfter_((snapshot: InContainer.Snapshot) => afterEach(...inControlStatuses(snapshot))),\n      mapAfter(combineInStatusFlags),\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectNull, inAspectValue } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull as InAspect.Applied<any, InStyledElement | null>;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param element - A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(element: InStyledElement | null = null): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? inAspectValue(element) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { css__naming, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { RenderSchedule } from '@frontmeans/render-scheduler';\nimport { DeltaSet } from '@proc7ts/delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  digAfter_,\n  EventKeeper,\n  EventNotifier,\n  isEventKeeper,\n  mapAfter,\n  mapAfter_,\n  shareAfter,\n  supplyAfter,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/push-iterator';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * An `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   */\n  abstract readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read;\n  }\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source - A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): Supply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source - A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source - A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element - Target element to apply CSS classes to.\n   * @param schedule - DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): Supply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason - An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by {@link InNamespaceAliaser} aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  readonly read: AfterEvent<[InCssClasses.Map]>;\n  readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n  private readonly _sources = trackValue<[Map<AfterEvent<[InCssClasses.Map]>, Supply>]>([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    _control.supply.whenOff(reason => this.done(reason));\n\n    this.read = this._sources.read.do(\n        supplyAfter(this._control),\n        digAfter_(([sources]) => afterEach(...sources.keys())),\n        mapAfter_((...classes: [InCssClasses.Map][]) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        }),\n    );\n\n    this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n      receiver.supply.needs(this._control);\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    });\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).do(\n        mapAfter((...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        }),\n    );\n  }\n\n  add(source: InCssClasses.Source): Supply {\n\n    const inSupply = this._control.supply;\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = new Supply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source)({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).do(shareAfter);\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): Supply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { translateAfter } from '@proc7ts/fun-events';\nimport { arrayOfElements } from '@proc7ts/primitives';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark - Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input\n * aspects namespace} is used by default.\n * @param when - {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | readonly InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  return control => control.aspect(InValidation).read.do(translateAfter(\n      (send, errors) => hasError(errors) ? send(...inCssErrorMarks(mark)) : send(),\n  ));\n}\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: readonly InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction inCssErrorMarks(mark?: InCssClasses.Spec | readonly InCssClasses.Spec[]): readonly InCssClasses.Spec[] {\n  if (!mark) {\n    return defaultInCssErrorMarks;\n  }\n\n  const marks = arrayOfElements(mark);\n\n  return marks.length ? marks : defaultInCssErrorMarks;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/input-aspects\n */\nimport { NamespaceDef, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { afterAll, translateAfter } from '@proc7ts/fun-events';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InValidation } from '../../validation';\nimport { InStatus } from '../focus';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns - A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).do(translateAfter(\n        (send, { md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          send(...names);\n        },\n    ));\n  };\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/httongue\n */\n/**\n * Escapes CSS identifier accordingly to the rules defined for [CSS.escape()](https://drafts.csswg.org/cssom/#the-css.escape%28%29-method)\n * utility method.\n *\n * Can be applied to CSS values as well, although it escapes characters that don't strictly need to be escaped.\n * A {@link escapeCSSVal} is a better alternative for that.\n *\n * @param text - A text to escape.\n *\n * @returns A string safe to be used as CSS identifier, e.g. as CSS selector.\n */\nexport function escapeCSS(text: string): string {\n\n  const len = text.length;\n  const first = text.charCodeAt(0);\n  let out = '';\n  let i = 0;\n\n  if (first === 0x2d) {\n    // If the first character is a \"-\" (U+002D)\n\n    const second = text.charCodeAt(1);\n\n    // ... and the second character is in the range [0-9] (U+0030 to U+0039).\n    if (second > 0x2f && second < 0x3a) {\n      // then '-' followed by the character escaped as code point.\n      out += `-\\\\${second.toString(16)} `;\n      i = 2;\n    } else {\n      out = '-';\n      i = 1;\n    }\n\n    if (len === 1) {\n      // ... and there is no second character, then the escaped character.\n      return '\\\\-';\n    }\n  } else if (first > 0x2f && first < 0x3a) {\n    // If the first character is in the range [0-9] (U+0030 to U+0039),\n    // then the character escaped as code point.\n    out += `\\\\${first.toString(16)} `;\n    i = 1;\n  }\n\n  for (; i < len; ++i) {\n\n    const c = text.charCodeAt(i);\n\n    if (\n        // Is in range [a-z] (U+0061 to U+007A),\n        (c > 0x60 && c < 0x7b)\n        // or is \"-\" (U+002D),\n        || c === 0x2d\n        // or is \"_\" (U+005F)\n        || c === 0x5f\n        // or is in range [0-9] (U+0030 to U+0039),\n        || (c > 0x2f && c < 0x3a)\n        // or is in range [A-Z] (U+0041 to U+005A)\n        || (c > 0x40 && c < 0x5b)\n    ) {\n      // then the character itself.\n      out += text[i];\n    } else if (c > 0x7e) {\n      out += c === 0x7f\n          // If the character is U+007F\n          // then the character escaped as code point.\n          ? `\\\\${c.toString(16)} `\n          // If the character is greater than or equal to U+0080,\n          // then the character itself\n          : text[i];\n    } else if (c < 0x20) {\n      out += c\n          // If the character is in the range [\\1-\\1f] (U+0001 to U+001F)\n          // then the character escaped as code point.\n          ? `\\\\${c.toString(16)} `\n          // If the character is NULL (U+0000)\n          // then the REPLACEMENT CHARACTER (U+FFFD).\n          : '\\uFFFD';\n    } else {\n      // Otherwise, the escaped character.\n      out += `\\\\${text[i]}`;\n    }\n  }\n\n  return out;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/httongue\n */\n/**\n * Escapes CSS value to be included into CSS string.\n *\n * Escapes accordingly to [serialize a string] algorithm.\n *\n * [serialize a string]: https://drafts.csswg.org/cssom/#serialize-a-string\n *\n * @param text - A text to escape.\n *\n * @returns A string safe to be included into CSS value, e.g. within CSS string.\n */\nexport function escapeCSSVal(text: string): string {\n\n  let out = '';\n  const len = text.length;\n\n  for (let i = 0; i < len; ++i) {\n\n    const c = text.charCodeAt(i);\n\n    out += c < 0x20 || c === 0x7f\n        ? (c\n                // If the character is in the range [\\1-\\1f] (U+0001 to U+001F),\n                // the character escaped as code point.\n                ? `\\\\${c.toString(16)} `\n                // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).;\n                : '\\uFFFD'\n        )\n        : (c === 0x22 || c === 0x5c\n                // If the character is '\"' (U+0022) or \"\\\" (U+005C),\n                // the escaped character.\n                ? `\\\\${text[i]}`\n                // Otherwise, the character itself.\n                : text[i]\n        );\n  }\n\n  return out;\n}\n","/**\n * @internal\n */\nexport const uppercasePattern = /[A-Z]+/g;\n\n/**\n * @internal\n */\nexport function toHyphenLower(letters: string, offset: number, str: string): string {\n\n  const lowerCase = letters.toLowerCase();\n\n  if ((lowerCase.length > 1) && (offset + lowerCase.length < str.length)) {\n    // More than one subsequent upper-case letters, unless at the end of the string.\n    return `-${lowerCase.slice(0, -1)}-${lowerCase.slice(-1)}`;\n  }\n\n  return '-' + lowerCase;\n}\n\n/**\n * @internal\n */\nexport const hyphenateCSSName$cache = (/*#__PURE__*/ new Map<string, string>());\n","/**\n * @packageDocumentation\n * @module @frontmeans/httongue\n */\nimport { hyphenateCSSName$cache, toHyphenLower, uppercasePattern } from './hyphenate.impl';\n\n/**\n * Hyphenates a camel-cased name.\n *\n * Applicable to CSS property names.\n *\n * Converts:\n *\n * - `backgroundColor` to `background-color`.\n *\n *    Uppercase letters converted to lower case and prepended by hyphen,\n *\n * - `MozTransition` to `-moz-transition`.\n *\n *   The very first uppercase letter is prepended by hyphen too.\n *\n * - `MSTransition` to `-ms-transition`.\n *\n *   Subsequent upper-case letters converted to lower case. The first and the last ones prepended by hyphen.\n *\n * - `someURL` to `some-url`\n *\n *   Subsequent upper-case letters in the very end of the string converted to lower case and prepended by hyphen.\n *\n * - `color` to `color`.\n *\n *   All lower-case names remain as is.\n *\n * - `padding-left` to `padding-left`\n *\n *   Hyphens remain in place.\n *\n * @param name - Camel-cased name to hyphenate.\n *\n * @returns Hyphenated name.\n */\nexport function hyphenateName(name: string): string {\n  return name.replace(uppercasePattern, toHyphenLower);\n}\n\n/**\n * De-capitalizes a camel-cased name and hyphenates it.\n *\n * Calls {@link hyphenateName}, then removes the leading hyphen.\n *\n * Thus, e.g. `MozTransition` would be converted to `moz-transition` rather to `-moz-transition`.\n *\n * @param name - Camel-cased name to hyphenate.\n *\n * @returns Hyphenated name.\n */\nexport function hyphenateDecapName(name: string): string {\n\n  const hyphenated = hyphenateName(name);\n\n  return hyphenated.startsWith('-') ? hyphenated.substr(1) : hyphenated;\n}\n\n/**\n * Hyphenates a camel-cased CSS property key.\n *\n * Applicable to the names of `HTMLElement.style` properties, including vendor-specific ones.\n *\n * Calls {@link hyphenateName}, then replaces `ms-` prefix with `-ms-` one. Other vendor-specific prefixes are\n * capitalized, so the hyphen prefix is added already.\n *\n * Caches hyphenated names for the sake of speed.\n *\n * @param name - Camel-cased CSS property name to hyphenate.\n *\n * @returns Hyphenated CSS property name.\n */\nexport function hyphenateCSSName(name: string): string {\n\n  const found = hyphenateCSSName$cache.get(name);\n\n  if (found) {\n    return found;\n  }\n\n  let hyphenated = hyphenateName(name);\n\n  if (hyphenated.startsWith('ms-')) {\n    hyphenated = '-' + hyphenated;\n  }\n\n  hyphenateCSSName$cache.set(name, hyphenated);\n\n  return hyphenated;\n}\n","/**\n * @internal\n */\nexport function isReadonlyArray<T>(value: any): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): array is readonly [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: T[]): array is [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): boolean {\n  return !!array.length;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { StypColor } from './color';\nimport { StypNumeric } from './numeric';\nimport { StypPriority } from './priority';\nimport { StypURL } from './url';\n\n/**\n * CSS property value.\n *\n * This is either a scalar value, or {@link StypValueStruct structured} one.\n *\n * @category CSS Value\n */\nexport type StypValue =\n    | string\n    | number\n    | boolean\n    | undefined\n    | StypNumeric<any>\n    | StypURL\n    | StypColor;\n\n/**\n * Structured property CSS value. E.g. [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length),\n * [percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/percentage),\n * [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value), etc.\n *\n * @category CSS Value\n * @typeParam TSelf - A type of itself.\n */\nexport abstract class StypValueStruct<TSelf extends StypValueStruct<TSelf>> {\n\n  /**\n   * CSS property value priority.\n   *\n   * The value {@link StypPriority.Important} and above means the property is `!important`. Everything else means normal\n   * priority.\n   *\n   * The property value with higher priority number takes precedence over the one with lower one.\n   */\n  readonly priority: number;\n\n  /**\n   * Constructs structured CSS property value.\n   *\n   * @param opts - Construction options.\n   */\n  protected constructor(opts?: StypValue.Opts) {\n    this.priority = opts && opts.priority || StypPriority.Default;\n  }\n\n  /**\n   * Checks whether this value equals to CSS property value.\n   *\n   * @param other - CSS property value to compare with.\n   */\n  abstract is(other: StypValue): boolean;\n\n  /**\n   * Creates structured CSS value with the given `priority`.\n   *\n   * @param priority - New priority.\n   *\n   * @returns Either a new value equal to this one but having the given `priority`, or this one if `priority` did\n   * not change.\n   */\n  abstract prioritize(priority: number): TSelf;\n\n  /**\n   * Creates `!important` variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to {@link StypPriority.Important},\n   * or this one if already the case.\n   */\n  important(): TSelf {\n    return this.prioritize(StypPriority.Important);\n  }\n\n  /**\n   * Creates usual (not `!important`) variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to {@link StypPriority.Usual},\n   * or this one if already the case.\n   */\n  usual(): TSelf {\n    return this.prioritize(StypPriority.Usual);\n  }\n\n  /**\n   * Maps the given CSS property value to the value of this one's type. Defaults to this value if mapping is not\n   * possible.\n   *\n   * This method allows to use an structured value instance as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source - A raw property value that should be converted.\n   *\n   * @returns Mapped property value.\n   */\n  abstract by(source: StypValue): StypValue;\n\n  /**\n   * Returns textual representation of this value.\n   *\n   * Textual representation never contains an `!important` suffix.\n   *\n   * @returns A textual representation of this value to use as CSS property value.\n   */\n  abstract toString(): string;\n\n}\n\nexport namespace StypValue {\n\n  /**\n   * Construction options of structured property CSS value.\n   */\n  export interface Opts {\n\n    /**\n     * Constructed value priority.\n     *\n     * The value {@link StypPriority.Important} and above means the property is `!important`. Everything else means\n     * normal priority.\n     */\n    readonly priority?: number;\n\n  }\n\n}\n\n/**\n * Checks whether two CSS property values are equal.\n *\n * Compares scalar values verbatim. Compares structured values using their {@link StypValueStruct.is} method. The latter\n * method is applied when at least one of the values is structured.\n *\n * @category CSS Value\n * @param first - The first CSS property value to compare.\n * @param second - The second CSS property value to compare.\n *\n * @returns `true` if `first` equals to `second`, or `false otherwise.\n */\nexport function stypValuesEqual(first: StypValue, second: StypValue): boolean {\n  if (first === second) {\n    return true;\n  }\n  if (typeof first === 'object') {\n    return first.is(second);\n  }\n  if (typeof second === 'object') {\n    return second.is(first);\n  }\n  return false;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { StypValue, StypValueStruct } from '../value';\n\n/**\n * Structured [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) CSS property value.\n *\n * Colors are represented by either `rgb()`, or `hsl()` functional notations.\n *\n * @category CSS Value\n */\nexport type StypColor = StypRGB | StypHSL;\n\n/**\n * Structured color CSS property value base.\n *\n * @category CSS Value\n */\nexport abstract class StypColorStruct<TSelf extends StypColorStruct<TSelf, TCoords>, TCoords>\n    extends StypValueStruct<TSelf> {\n\n  /**\n   * Color value type corresponding to color coordinates. Either `rgb` or `hsl`\n   */\n  abstract readonly type: 'rgb' | 'hsl';\n\n  /**\n   * This color in RGB coordinates.\n   */\n  abstract readonly rgb: StypRGB;\n\n  /**\n   * This color in HSL coordinates.\n   */\n  abstract readonly hsl: StypHSL;\n\n  /**\n   * Constructs another color value with updated coordinates.\n   *\n   * @param coords - Either partial color coordinates to apply or a function returning them and accepting this color\n   * instance as its only argument. Missing values are taken from this color.\n   *\n   * @returns Updated color value.\n   */\n  abstract set(coords: Partial<TCoords> | ((this: void, color: this) => Partial<TCoords>)): TSelf;\n\n}\n\n/**\n * CSS property value representing [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors)\n * in `rgb()` or `rgba()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypRGB extends StypColorStruct<StypRGB, StypRGB.Coords> implements StypRGB.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  /**\n   * `rgb` value type.\n   */\n  get type(): 'rgb' {\n    return 'rgb';\n  }\n\n  /**\n   * Red color value between `0` and `255`.\n   */\n  readonly r: number;\n\n  /**\n   * Green color value between `0` and `255`.\n   */\n  readonly g: number;\n\n  /**\n   * Blue color value between `0` and `255`.\n   */\n  readonly b: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs RGB color value.\n   *\n   * @param coords - Color coordinates.\n   * @param opts - Construction options.\n   */\n  constructor(coords: StypRGB.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.r = intCoord(coords.r, 255);\n    this.g = intCoord(coords.g, 255);\n    this.b = intCoord(coords.b, 255);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get rgb(): this {\n    return this;\n  }\n\n  /**\n   * This color in HSL coordinates.\n   */\n  get hsl(): StypHSL {\n\n    const { a } = this;\n    const r = this.r * 100 / 255;\n    const g = this.g * 100 / 255;\n    const b = this.b * 100 / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = Math.round((max + min) / 2);\n\n    if (max === min) {\n      return new StypHSL({ h: 0, s: 0, l, a }, this);\n    }\n\n    const d = max - min;\n    const s = Math.round(l > 50 ? d * 100 / (200 - max - min) : d * 100 / (max + min));\n    let h: number;\n\n    switch (max) {\n    case r:\n      h = ((g - b) / d) + (g < b ? 6 : 0);\n      break;\n    case g:\n      h = ((b - r) / d) + 2;\n      break;\n    default:\n      h = ((r - g) / d) + 4;\n      break;\n    }\n    h *= 60;\n    h = Math.round(h);\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  by(source: StypValue): StypColor {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.r === this.r\n        && other.g === this.g\n        && other.b === this.b\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypRGB {\n    return this.priority === priority ? this : new StypRGB(this, { priority });\n  }\n\n  set(coords: Partial<StypRGB.Coords> | ((this: void, color: this) => Partial<StypRGB.Coords>)): StypRGB {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { r = this.r, g = this.g, b = this.b, a = this.a } = coords;\n\n    return new StypRGB({ r, g, b, a }, this);\n  }\n\n  toString(): string {\n\n    const rgb = `${this.r}, ${this.g}, ${this.b}`;\n\n    return this.a === 1 ? `rgb(${rgb})` : `rgba(${rgb}, ${this.a})`;\n\n  }\n\n}\n\nexport namespace StypRGB {\n\n  /**\n   * [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Red color value between `0` and `255`.\n     */\n    r: number;\n\n    /**\n     * Green color value between `0` and `255`.\n     */\n    g: number;\n\n    /**\n     * Blue color value between `0` and `255`.\n     */\n    b: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * CSS property value representing [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors)\n * in `hsl()` or `hsla()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypHSL extends StypColorStruct<StypHSL, StypHSL.Coords> implements StypHSL.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'hsl' {\n    return 'hsl';\n  }\n\n  /**\n   * Hue angle value in degrees between `0` and `360`.\n   */\n  readonly h: number;\n\n  /**\n   * Saturation percentage.\n   */\n  readonly s: number;\n\n  /**\n   * Lightness percentage.\n   */\n  readonly l: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs HSL color value.\n   *\n   * @param coords - Color coordinates.\n   * @param opts - Construction options.\n   */\n  constructor(coords: StypHSL.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.h = angleCoord(coords.h);\n    this.s = coord(coords.s, 100);\n    this.l = coord(coords.l, 100);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   */\n  get rgb(): StypRGB {\n\n    const { a } = this;\n    const s = this.s / 100;\n    const l = this.l / 100;\n\n    if (!s) {\n\n      const c = l * 255;\n\n      return new StypRGB({ r: c, g: c, b: c, a }, this);\n    }\n\n    const q = l < 0.5 ? l * (1 + s) : (l + s) - (l * s);\n    const p = (2 * l) - q;\n    const hueAsFraction = this.h / 360;\n\n    return new StypRGB(\n        {\n          r: hueToRgb(p, q, hueAsFraction + (1.0 / 3.0)),\n          g: hueToRgb(p, q, hueAsFraction),\n          b: hueToRgb(p, q, hueAsFraction - (1.0 / 3.0)),\n          a,\n        },\n        this,\n    );\n  }\n\n  /**\n   * This color in HSL coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get hsl(): this {\n    return this;\n  }\n\n  by(source: StypValue): StypColor {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.h === this.h\n        && other.s === this.s\n        && other.l === this.l\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypHSL {\n    return this.priority === priority ? this : new StypHSL(this, { priority });\n  }\n\n  set(coords: Partial<StypHSL.Coords> | ((this: void, color: this) => Partial<StypHSL.Coords>)): StypHSL {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { h = this.h, s = this.s, l = this.l, a = this.a } = coords;\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  toString(): string {\n\n    const hsl = `${this.h}, ${this.s}%, ${this.l}%`;\n\n    return this.a === 1 ? `hsl(${hsl})` : `hsla(${hsl}, ${this.a})`;\n  }\n\n}\n\nexport namespace StypHSL {\n\n  /**\n   * [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Hue angle value in degrees.\n     */\n    h: number;\n\n    /**\n     * Saturation percentage.\n     */\n    s: number;\n\n    /**\n     * Lightness percentage.\n     */\n    l: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * @category CSS Value\n */\nexport const StypColor = {\n\n  /**\n   * Maps the given CSS property value to color. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a {@link StypColor} object as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source - A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  by(source: StypValue): StypColor | undefined {\n    if (typeof source === 'object' && (source.type === 'rgb' || source.type === 'hsl')) {\n      return source;\n    }\n    return;\n  },\n\n};\n\n/**\n * @internal\n */\nfunction angleCoord(value: number): number {\n  value = value % 360;\n  return value < 0 ? 360 + value : value;\n}\n\n/**\n * @internal\n */\nfunction intCoord(value: number, max: number): number {\n  return coord(Math.round(value), max);\n}\n\n/**\n * @internal\n */\nfunction coord(value: number, max: number): number {\n  return Math.max(Math.min(value, max), 0);\n}\n\n/**\n * @internal\n */\nfunction hueToRgb(p: number, q: number, t: number): number {\n\n  let newT = t;\n\n  if (newT < 0) {\n    newT += 1;\n  } else if (newT > 1) {\n    newT -= 1;\n  }\n\n  let result;\n\n  if (newT < 1.0 / 6.0) {\n    result = p + ((q - p) * (6 * newT));\n  } else if (newT < 1.0 / 2.0) {\n    result = q;\n  } else if (newT < 2.0 / 3.0) {\n    result = p + (((q - p) * ((2.0 / 3.0) - newT)) * 6);\n  } else {\n    result = p;\n  }\n\n  return result * 255;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { StypColor, StypRGB } from './color';\n\n/**\n * Mixes two colors.\n *\n * Both the `weight` and the relative opacity of each color determines how much of each color is in the result.\n *\n * @category CSS Value\n * @param color1 - First color to mix\n * @param color2 - Second color to mix.\n * @param weight - A number between `0` and `1`. A larger weight indicates that more of `color1` should be used, and a\n * smaller weight indicates that more of `color2` should be used.\n *\n * @returns Mixed color.\n */\nexport function mixStypColors(color1: StypColor, color2: StypColor, weight: number): StypColor {\n\n  const w = weight * 2 - 1;\n  const rgba1 = color1.rgb;\n  const rgba2 = color2.rgb;\n  const aDiff = rgba1.a - rgba2.a;\n  const w1 = (((w * aDiff === -1) ? w : (w + aDiff) / (1 + w * aDiff)) + 1) / 2.0;\n  const w2 = 1 - w1;\n  return new StypRGB(\n      {\n        r: rgba1.r * w1 + rgba2.r * w2,\n        g: rgba1.g * w1 + rgba2.g * w2,\n        b: rgba1.b * w1 + rgba2.b * w2,\n        a: rgba1.a * weight + rgba2.a * (1 - weight),\n      },\n      color1,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { StypValue, StypValueStruct } from '../value';\nimport { StypZero } from './zero';\n\n/**\n * Structured numeric CSS property value.\n *\n * This represents either dimension, zero value, or a `calc()` CSS function call.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed unit type.\n * @typeParam TZero - A type of zero value. {@link StypZero} by default.\n */\nexport type StypNumeric<TUnit extends string, TZero extends StypZero<TUnit> | StypDimension<TUnit> = StypZero<TUnit>> =\n    | StypDimension<TUnit>\n    | StypCalc<TUnit>\n    | TZero;\n\n/**\n * Base implementation of structured numeric CSS property value.\n *\n * @category CSS Value\n * @typeParam TSelf - A type of itself.\n * @typeParam TUnit - Allowed unit type.\n */\nexport abstract class StypNumericStruct<TSelf extends StypNumericStruct<TSelf, TUnit>, TUnit extends string>\n    extends StypValueStruct<TSelf> {\n\n  /**\n   * A type of structured numeric CSS property value.\n   */\n  abstract type: 'dimension' | 'calc' | 0;\n\n  readonly dim: StypDimension.Kind<TUnit>;\n\n  constructor(opts: StypDimension.Opts<TUnit>) {\n    super(opts);\n    this.dim = opts.dim;\n  }\n\n  /**\n   * Tries to converts this numeric value to another dimension.\n   *\n   * Does not actually construct a value in another dimension, as long as dimension unit supported by both dimensions.\n   *\n   * @typeParam TDimUnit - A unit type allowed in target dimension.\n   * @param dim - Target dimension.\n   *\n   * @returns Either a value in dimension compatible with `dim`, or `undefined` if this value's unit is not supported\n   * by `dim`.\n   */\n  abstract toDim<TDimUnit extends string>(dim: StypDimension.Kind<TDimUnit>): StypNumeric<TDimUnit> | undefined;\n\n  abstract add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  abstract add(addendum: number, unit: TUnit): StypNumeric<TUnit>;\n\n  abstract sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  abstract sub(subtrahend: number, unit: TUnit): StypNumeric<TUnit>;\n\n  abstract mul(multiplier: number): StypNumeric<TUnit>;\n\n  abstract div(divisor: number): StypNumeric<TUnit>;\n\n  abstract negate(): StypNumeric<TUnit>;\n\n  by(source: StypValue): StypNumeric<TUnit> {\n    return this.dim.by(source) || this as StypNumeric<TUnit>;\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns CSS value text without `!important` or `calc()`.\n   */\n  abstract toFormula(): string;\n\n  toString(): string {\n    return this.toFormula();\n  }\n\n}\n\n/**\n * Structured [dimension](https://developer.mozilla.org/en-US/docs/Web/CSS/dimension) value with unit.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed units type.\n */\nexport interface StypDimension<TUnit extends string>\n    extends StypValueStruct<StypDimension<TUnit>>, StypNumericStruct<StypDimension<TUnit>, TUnit> {\n\n  readonly type: 'dimension';\n\n  readonly dim: StypDimension.Kind<TUnit>;\n\n  /**\n   * Dimension value.\n   */\n  readonly val: number;\n\n  /**\n   * Dimension unit.\n   */\n  readonly unit: TUnit;\n\n  add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  add(addendum: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  sub(subtrahend: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  by(source: StypValue): StypNumeric<TUnit>;\n\n}\n\nexport namespace StypDimension {\n\n  /**\n   * A kind of dimensions. E.g. angle, length, percentage, etc.\n   *\n   * It is perfectly fine to use dimensions interchangeably as long as dimension units are compatible.\n   *\n   * @typeParam TUnit - Allowed units type.\n   */\n  export interface Kind<TUnit extends string> {\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports and, in addition, supporting percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if supports percents.\n     */\n    readonly pt?: Kind<TUnit | '%'>;\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports, except percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if does not support percents.\n     */\n    readonly noPt: Kind<Exclude<TUnit, '%'>>;\n\n    /**\n     * Zero value of this kind.\n     *\n     * Typically, this is unit-less {@link StypZero}. But some dimensions require units.\n     */\n    readonly zero: StypDimension<TUnit> | StypZero<TUnit>;\n\n    /**\n     * Constructs dimension value.\n     *\n     * @param val - Numeric dimension value.\n     * @param unit - Dimension unit.\n     *\n     * @returns Constructed dimension value. Either {@link StypDimension} instance, or {@link StypZero} if `val` is `0`\n     * and this dimension kind supports unitless zero.\n     */\n    of(val: number, unit: TUnit): StypDimension<TUnit> | StypZero<TUnit>;\n\n    /**\n     * Maps the given CSS property value to the one compatible with this dimension kind. Defaults to `undefined`\n     * if mapping is not possible.\n     *\n     * This method allows to use a dimension kind as {@link StypMapper.Mapping CSS property mapping}.\n     *\n     * Any scalar or non-numeric value is mapped to `undefined`. A numeric value is converted to this dimension by\n     * {@link StypNumericStruct.toDim} method.\n     *\n     * @param source - A raw property value that should be converted.\n     *\n     * @returns Mapped property value or `undefined`.\n     */\n    by(source: StypValue): StypNumeric<TUnit, StypDimension<TUnit> | StypZero<TUnit>> | undefined;\n\n  }\n\n  export namespace Kind {\n\n    /**\n     * A kind of dimension with unit-less zero. E.g. angle or length.\n     *\n     * @typeParam TUnit - Allowed units type.\n     */\n    export interface UnitlessZero<TUnit extends string> extends Kind<TUnit> {\n\n      readonly pt?: UnitlessZero<TUnit | '%'>;\n\n      readonly noPt: UnitlessZero<Exclude<TUnit, '%'>>;\n\n      /**\n       * Zero value of this kind without unit.\n       */\n      readonly zero: StypZero<TUnit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val - Numeric dimension value.\n       * @param unit - Dimension unit.\n       *\n       * @returns Constructed dimension value. Either {@link StypDimension} instance, or {@link StypZero} if `val` is\n       * `0`.\n       */\n      of(val: number, unit: TUnit): StypDimension<TUnit> | StypZero<TUnit>;\n\n      by(source: StypValue): StypNumeric<TUnit> | undefined;\n\n    }\n\n    /**\n     * A kind of dimension which zero value has unit. E.g. frequency or resolution.\n     *\n     * @typeParam TUnit - Allowed units type.\n     */\n    export interface UnitZero<TUnit extends string> extends Kind<TUnit> {\n\n      readonly pt?: UnitZero<TUnit | '%'>;\n\n      readonly noPt: UnitZero<Exclude<TUnit, '%'>>;\n\n      /**\n       * Zero value of this kind that has unit.\n       */\n      readonly zero: StypDimension<TUnit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val - Numeric dimension value.\n       * @param unit - Dimension unit.\n       *\n       * @returns Constructed dimension value as a {@link StypDimension} instance.\n       */\n      of(val: number, unit: TUnit): StypDimension<TUnit>;\n\n      by(source: StypValue): StypNumeric<TUnit, StypDimension<TUnit>> | undefined;\n\n    }\n\n  }\n\n  /**\n   * Construction options of dimensions.\n   *\n   * @typeParam TUnit - Allowed units type.\n   */\n  export interface Opts<TUnit extends string> extends StypValue.Opts {\n\n    /**\n     * A kind of dimension.\n     */\n    dim: Kind<TUnit>;\n\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation.\n *\n * This is either a {@link StypAddSub addition/subtraction}, or {@link StypMulDiv multiplication/division}.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed unit type.\n */\nexport type StypCalc<TUnit extends string> = StypAddSub<TUnit> | StypMulDiv<TUnit>;\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed unit type.\n */\nexport interface StypAddSub<TUnit extends string> extends StypNumericStruct<StypAddSub<TUnit>, TUnit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<TUnit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '+' | '-';\n\n  /**\n   * Right operand.\n   */\n  readonly right: StypNumeric<TUnit>;\n\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed unit type.\n */\nexport interface StypMulDiv<TUnit extends string> extends StypNumericStruct<StypMulDiv<TUnit>, TUnit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<TUnit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '*' | '/';\n\n  /**\n   * Right operand.\n   */\n  readonly right: number;\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { itsEach, overKeys } from '@proc7ts/push-iterator';\nimport { StypProperties } from '../rule';\nimport { StypValue } from './value';\n\n/**\n * A type of function that maps CSS properties to something else.\n *\n * @category CSS Value\n * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n */\nexport type StypMapper<TResult> =\n/**\n * @param from - CSS properties to map.\n *\n * @returns Mapping result.\n */\n    (this: void, from: StypProperties) => TResult;\n\nexport namespace StypMapper {\n\n  /**\n   * CSS property mapping.\n   *\n   * It is used to recognize raw property value and convert it to the one of the given type.\n   *\n   * It is one of:\n   * - Default property value. Replaces the source property value, unless the the have the same type.\n   * - A mapping function. Replaces the source property value with the result of this function call.\n   * - An object containing mapping method called `by()`. Replaces the source property value with the result of this\n   *   method call.\n   *\n   * @typeParam TResult - A type of mapped properties. This is an object containing mapped properties.\n   * @typeParam TResultKey - Type of mapped properties keys.\n   */\n  export type Mapping<TResult, TResultKey extends keyof TResult> =\n      | MappingFunction<TResult, TResultKey>\n      | MappingObject<TResult, TResultKey>\n      | TResult[TResultKey];\n\n  /**\n   * CSS property mapping function.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   * @typeParam TResultKey - Type of mapped properties keys.\n   */\n  export type MappingFunction<TResult, TResultKey extends keyof TResult> =\n  /**\n   * @param source - A raw property value that should be converted.\n   * @param mapped - An object granting access to other mapped properties.\n   * @param key - A key of converted property.\n   *\n   * @returns Mapped property value.\n   */\n      (this: void, source: StypValue, mapped: Mapped<TResult>, key: TResultKey) => TResult[TResultKey];\n\n  /**\n   * CSS property mapping object.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   * @typeParam TResultKey - Type of mapped properties keys.\n   */\n  export interface MappingObject<TResult, TResutKey extends keyof TResult> {\n\n    /**\n     * Maps CSS property value.\n     *\n     * @param source - A raw property value that should be converted.\n     * @param mapped - An object granting access to other mapped properties.\n     * @param key - A key of converted property.\n     *\n     * @returns Mapped property value.\n     */\n    by(source: StypValue, mapped: Mapped<TResult>, key: TResutKey): TResult[TResutKey];\n\n  }\n\n  /**\n   * Grants access to mapped values.\n   *\n   * Passed as a second argument to mapping function.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   */\n  export interface Mapped<TResultKey> {\n\n    /**\n     * Original properties to convert.\n     */\n    from: StypProperties;\n\n    /**\n     * Maps the property with the given type accordingly to mapping instruction.\n     *\n     * The mapping is performed at most once per property.\n     *\n     * @param key - Mapped property key.\n     *\n     * @returns Mapped property value.\n     */\n    get<TKey extends keyof TResultKey>(key: TKey): TResultKey[TKey];\n\n  }\n\n  /**\n   * Mappings of CSS properties.\n   *\n   * Contains mappings for each mapped CSS property with that property name as a key.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   */\n  export type Mappings<TResult> = { readonly [key in keyof TResult]: Mapping<TResult, key>; };\n\n}\n\nexport const StypMapper = {\n\n  /**\n   * Maps CSS properties accordingly to the given `mappings`.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   * @param mappings - Mappings of CSS properties.\n   * @param from - Raw CSS properties to map.\n   *\n   * @returns Mapped properties.\n   */\n  map<TResult>(mappings: StypMapper.Mappings<TResult>, from: StypProperties): TResult {\n\n    const result = {} as { [key in keyof TResult]: TResult[key] };\n    const mapped = {\n      from,\n      get<TKey extends keyof TResult>(key: TKey): TResult[TKey] {\n        if (key in result) {\n          return result[key];\n        }\n\n        const mapper = mappingBy<TResult, TKey>(mappings[key]);\n        const mappedValue = mapper(from[key as string], this, key);\n\n        result[key] = mappedValue;\n\n        return mappedValue;\n      },\n    };\n\n    itsEach(overKeys(mappings), key => mapped.get(key));\n\n    return result;\n  },\n\n  /**\n   * Creates CSS properties mapper function.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   * @param mappings - Mappings of CSS properties.\n   *\n   * @returns A function that maps CSS properties accordingly to the given `mappings`.\n   */\n  by<TResult>(mappings: StypMapper.Mappings<TResult>): StypMapper<TResult> {\n    return StypMapper.map.bind<void, StypMapper.Mappings<TResult>, [StypProperties], TResult>(undefined, mappings);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction mappingBy<TResult, TResultKey extends keyof TResult>(\n    mapping: StypMapper.Mapping<TResult, TResultKey> | undefined,\n): StypMapper.MappingFunction<TResult, TResultKey> {\n  switch (typeof mapping) {\n  case 'function':\n    return mapping as StypMapper.MappingFunction<TResult, TResultKey>;\n  case 'object':\n    return (mapping as StypMapper.MappingObject<TResult, TResultKey>).by.bind(mapping);\n  default:\n  }\n\n  const type = typeof mapping;\n\n  return (from: StypValue): TResult[TResultKey] => typeof from === type\n      ? from as unknown as TResult[TResultKey]\n      : mapping as TResult[TResultKey];\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue } from './value';\n\n/**\n * Predefined CSS property value priorities.\n *\n * @category CSS Value\n */\nexport const enum StypPriority {\n\n  /**\n   * Usual, non-important priority.\n   *\n   * This priority is assigned to values by {@link StypValueStruct.usual} method.\n   */\n  Usual = 0,\n\n  /**\n   * Default priority.\n   *\n   * The same as `Usual`. This priority is assigned to values by default.\n   */\n  Default = Usual,\n\n  /**\n   * Important priority.\n   *\n   * This priority corresponds to values with `!important` suffix. It is applied to string values with `!important`\n   * suffix, and can be assigned to structured values using {@link StypValueStruct.important} method.\n   *\n   * All numeric priorities with higher values are rendered as `!important` ones.\n   */\n  Important = 1,\n\n}\n\n/**\n * Splits undefined CSS property value onto non-prioritized value and priority.\n *\n * @category CSS Value\n * @param value - Undefined CSS property value to split.\n *\n * @returns An `[undefined, 0]` tuple.\n */\nexport function stypSplitPriority<T extends StypValue>(value: undefined): [undefined, 0];\n\n/**\n * Splits string CSS property value onto non-prioritized value and priority.\n *\n * @param value - CSS property value to split.\n *\n * @returns A tuple containing the value without `!priority` suffix, and numeric priority (0 or 1).\n */\nexport function stypSplitPriority(value: string): [string, 0 | 1];\n\n/**\n * Splits scalar CSS property value onto non-prioritized value and priority.\n *\n * @param value - CSS property value to split.\n *\n * @returns A tuple containing the value and `0` priority.\n */\nexport function stypSplitPriority<T extends number | boolean>(value: T): [T, 0];\n\n/**\n * Splits arbitrary CSS property value onto value non-prioritized value and priority.\n *\n * @param value - CSS property value to split.\n *\n * @returns A tuple containing the value and numeric priority.\n */\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number];\n\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number] {\n  if (value == null) {\n    return [undefined as T, StypPriority.Default];\n  }\n\n  switch (typeof value) {\n  case 'object':\n    return [value, value.priority];\n  case 'string':\n    if (value.endsWith(IMPORTANT_CSS_SUFFIX)) {\n      return [\n        value.substring(0, value.length - IMPORTANT_CSS_SUFFIX.length).trim() as T,\n        StypPriority.Important,\n      ];\n    }\n    break;\n  default:\n  }\n\n  return [value, StypPriority.Default];\n}\n","/**\n * @internal\n */\nexport const IMPORTANT_CSS_SUFFIX = '!important';\n","import { StypPriority } from '../priority';\nimport { StypValue, stypValuesEqual } from '../value';\nimport {\n  StypAddSub as StypAddSub_,\n  StypDimension as StypDimension_,\n  StypMulDiv as StypMulDiv_,\n  StypNumeric,\n  StypNumericStruct,\n} from './numeric';\nimport { StypZero } from './zero';\n\n/**\n * @internal\n */\nexport class StypDimension<TUnit extends string>\n    extends StypNumericStruct<StypDimension<TUnit>, TUnit>\n    implements StypDimension_<TUnit> {\n\n  get type(): 'dimension' {\n    return 'dimension';\n  }\n\n  /**\n   * The number value.\n   */\n  readonly val: number;\n\n  /**\n   * The unit.\n   */\n  readonly unit: TUnit;\n\n  /**\n   * Constructs new structured dimension value.\n   *\n   * @param val - The numeric value.\n   * @param unit - The unit.\n   * @param opts - CSS value options.\n   */\n  constructor(val: number, unit: TUnit, opts: StypDimension_.Opts<TUnit>) {\n    super(opts);\n    this.val = val;\n    this.unit = unit;\n  }\n\n  toDim<TDimUnit extends string>(dim: StypDimension_.Kind<TDimUnit>): StypDimension_<TDimUnit> | undefined {\n\n    const thisDim: StypDimension_.Kind<any> = this.dim;\n\n    if (dim === thisDim /* same dimension */\n        || dim === thisDim.pt /* !% to compatible +% */\n        || dim === (this.unit === '%' ? dim.pt /* % to any +% */ : thisDim.noPt /* !% to compatible -% */)) {\n      return this as StypDimension_<any>;\n    }\n\n    return;\n  }\n\n  is(other: StypValue): boolean {\n    if (other === this) {\n      return true;\n    }\n    return typeof other === 'object'\n        && other.type === this.type\n        && this.unit === other.unit\n        && this.val === other.val\n        && this.priority === other.priority;\n  }\n\n  prioritize(priority: number): StypDimension<TUnit> {\n    return this.priority === priority\n        ? this\n        : new StypDimension(this.val, this.unit, { dim: this.dim, priority });\n  }\n\n  add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  add(addendum: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  add(addendum: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit || this.unit, this);\n    }\n    if (addendum.type === 'dimension' && this.unit === addendum.unit) {\n      return stypDimension(this.val + addendum.val, this.unit, this);\n    }\n    return stypAddSub(this, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  sub(subtrahend: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  sub(subtrahend: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit || this.unit, this);\n    }\n    if (subtrahend.type === 'dimension' && this.unit === subtrahend.unit) {\n      return stypDimension(this.val - subtrahend.val, this.unit, this);\n    }\n    return stypAddSub(this, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<TUnit> {\n    return multiplier === 1 ? this : stypDimension(this.val * multiplier, this.unit, this);\n  }\n\n  div(divisor: number): StypNumeric<TUnit> {\n    return divisor === 1 ? this : stypDimension(this.val / divisor, this.unit, this);\n  }\n\n  negate(): StypNumeric<TUnit> {\n    return stypDimension(-this.val, this.unit, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `<value><unit>` or just `0`.\n   */\n  toFormula(): string {\n    return `${this.val}${this.unit}`;\n  }\n\n}\n\n/**\n * Constructs structured [dimension] CSS property value.\n *\n * @param val - Numeric value.\n * @param unit - Value unit.\n * @param opts - Construction options.\n *\n * @returns Either {@link StypDimension}, or {@link StypZero} if `val === 0`.\n *\n * [dimension]: https://developer.mozilla.org/en-US/docs/Web/CSS/dimension\n *\n * @internal\n */\nexport function stypDimension<TUnit extends string>(\n    val: number,\n    unit: TUnit,\n    opts: StypDimension_.Opts<TUnit>,\n): StypDimension_<TUnit> | StypZero<TUnit> {\n  return val\n      ? new StypDimension<TUnit>(val, unit, opts)\n      : opts.dim.zero.prioritize(opts.priority || StypPriority.Default);\n}\n\n/**\n * @internal\n */\nexport abstract class StypCalcBase<\n    TSelf extends StypCalcBase<TSelf, TOp, TRight, TUnit>,\n    TOp extends '+' | '-' | '*' | '/',\n    TRight extends number | StypNumeric<TUnit>,\n    TUnit extends string\n    > extends StypNumericStruct<TSelf, TUnit> {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'calc' {\n    return 'calc';\n  }\n\n  readonly left: StypNumeric<TUnit>;\n  readonly op: TOp;\n  readonly right: TRight;\n\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(\n      left: StypNumeric<TUnit>,\n      op: TOp,\n      right: TRight,\n      opts: StypDimension_.Opts<TUnit>,\n  ) {\n    super(opts);\n    this.left = left.usual();\n    this.op = op;\n    this.right = right;\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object' && other.type === this.type) {\n      return this.op === other.op\n          && this.left.is(other.left)\n          && stypValuesEqual(this.right, other.right)\n          && this.priority === other.priority;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  add(addendum: number, unit: TUnit): StypNumeric<TUnit>;\n\n  add(addendum: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as TUnit, this);\n    }\n    return stypAddSub(this as StypNumeric<TUnit>, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  sub(subtrahend: number, unit: TUnit): StypNumeric<TUnit>;\n\n  sub(subtrahend: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as TUnit, this);\n    }\n    return stypAddSub(this as StypNumeric<TUnit>, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<TUnit> {\n    return stypMul(this as StypNumeric<TUnit>, multiplier);\n  }\n\n  div(divisor: number): StypNumeric<TUnit> {\n    return stypDiv(this as StypNumeric<TUnit>, divisor);\n  }\n\n  abstract negate(): StypNumeric<TUnit>;\n\n  abstract prioritize(priority: number): TSelf;\n\n  abstract toFormula(): string;\n\n  toString(): string {\n    return 'calc' + super.toString();\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @typeParam TUnit - Allowed unit type.\n *\n * @internal\n */\nexport class StypAddSub<TUnit extends string>\n    extends StypCalcBase<StypAddSub<TUnit>, '+' | '-', StypNumeric<TUnit>, TUnit>\n    implements StypAddSub_<TUnit> {\n\n  constructor(left: StypNumeric<TUnit>, op: '+' | '-', right: StypNumeric<TUnit>, opts: StypDimension_.Opts<TUnit>) {\n    super(left, op, right.usual(), opts);\n  }\n\n  prioritize(priority: number): StypAddSub<TUnit> {\n    return this.priority === priority\n        ? this\n        : new StypAddSub(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<TDimUnit extends string>(dim: StypDimension_.Kind<TDimUnit>): StypAddSub<TDimUnit> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    const right = this.right.toDim(dim);\n\n    if (!right) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any> && right === this.right as StypNumeric<any>) {\n      return this as StypAddSub<any>;\n    }\n\n    return new StypAddSub<TDimUnit>(left, this.op, right, { dim, priority: this.priority });\n  }\n\n  negate(): StypNumeric<TUnit> {\n    return this.op === '-'\n        ? new StypAddSub(this.right, this.op, this.left, this)\n        : new StypAddSub(this.left.negate(), '-', this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right.toFormula()})`;\n  }\n\n}\n\nfunction stypAddSub<TUnit extends string>(\n    left: StypNumeric<TUnit>,\n    op: '+' | '-',\n    right: StypNumeric<TUnit>,\n): StypNumeric<TUnit> {\n  return !right.type ? left : new StypAddSub(left, op, right, left);\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @typeParam TUnit - Allowed unit type.\n *\n * @internal\n */\nexport class StypMulDiv<TUnit extends string>\n    extends StypCalcBase<StypMulDiv<TUnit>, '*' | '/', number, TUnit>\n    implements StypMulDiv_<TUnit> {\n\n  prioritize(priority: number): StypMulDiv<TUnit> {\n    return this.priority === priority\n        ? this\n        : new StypMulDiv(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<TDimUnit extends string>(dim: StypDimension_.Kind<TDimUnit>): StypMulDiv<TDimUnit> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any>) {\n      return this as StypMulDiv<any>;\n    }\n\n    return new StypMulDiv<TDimUnit>(left, this.op, this.right, { dim, priority: this.priority });\n  }\n\n  mul(multiplier: number): StypNumeric<TUnit> {\n    return (this.op === '*'\n        ? stypMul(this.left, this.right * multiplier)\n        : stypDiv(this.left, this.right / multiplier))\n        .prioritize(this.priority);\n  }\n\n  div(divisor: number): StypNumeric<TUnit> {\n    return (this.op === '/'\n        ? stypDiv(this.left, this.right * divisor)\n        : stypMul(this.left, this.right / divisor))\n        .prioritize(this.priority);\n  }\n\n  negate(): StypNumeric<TUnit> {\n    return new StypMulDiv(this.left, this.op, -this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right})`;\n  }\n\n}\n\nfunction stypMul<TUnit extends string>(left: StypNumeric<TUnit>, right: number): StypNumeric<TUnit> {\n  return !right\n      ? left.dim.zero.prioritize(left.priority)\n      : right === 1\n          ? left.prioritize(left.priority)\n          : new StypMulDiv(left, '*', right, left);\n}\n\nfunction stypDiv<TUnit extends string>(left: StypNumeric<TUnit>, right: number): StypNumeric<TUnit> {\n  return right === 1\n      ? left.prioritize(left.priority)\n      : new StypMulDiv(left, '/', right, left);\n}\n\n/**\n * @internal\n */\nexport function isStypNumeric(source: StypValue): source is StypNumeric<any, any> {\n  return typeof source === 'object' && (source.type === 'dimension' || source.type === 'calc' || source.type === 0);\n}\n","import { StypPriority } from '../priority';\nimport { StypValue } from '../value';\nimport { StypDimension, StypNumeric, StypNumericStruct } from './index';\nimport { stypDimension } from './numeric.impl';\nimport { StypZero } from './zero';\n\nclass Zero<TUnit extends string> extends StypNumericStruct<Zero<TUnit>, TUnit> implements StypZero<TUnit> {\n\n  constructor(private readonly _byPriority: ZeroByPriority<TUnit>, opts: StypDimension.Opts<TUnit>) {\n    super(opts);\n  }\n\n  get type(): 0 {\n    return 0;\n  }\n\n  toDim<TDimUnit extends string>(dim: StypDimension.Kind<TDimUnit>): StypDimension<TDimUnit> | StypZero<TDimUnit> {\n    return dim.zero.prioritize(this.priority);\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object') {\n      return other.type === this.type && other.priority === this.priority;\n    }\n    if (other === 0 || other === '0') {\n      return this.priority === StypPriority.Usual;\n    }\n    if (other === '0 !important') {\n      return this.priority === StypPriority.Important;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  add(addendum: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  add(addendum: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as TUnit, this);\n    }\n    return addendum.prioritize(this.priority);\n  }\n\n  sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  sub(subtrahend: number, unit: TUnit): StypNumeric<TUnit>;\n\n  sub(subtrahend: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as TUnit, this);\n    }\n    return subtrahend.negate().prioritize(this.priority);\n  }\n\n  mul(): this {\n    return this;\n  }\n\n  div(): this {\n    return this;\n  }\n\n  negate(): this {\n    return this;\n  }\n\n  prioritize(priority: number): Zero<TUnit> {\n    return this._byPriority.get(priority);\n  }\n\n  important(): Zero<TUnit> {\n    return this._byPriority.important;\n  }\n\n  usual(): Zero<TUnit> {\n    return this._byPriority.usual;\n  }\n\n  toFormula(): string {\n    return '0';\n  }\n\n}\n\nclass ZeroByPriority<TUnit extends string> {\n\n  readonly usual: Zero<TUnit>;\n  readonly important: Zero<TUnit>;\n\n  constructor(readonly dim: StypDimension.Kind<TUnit>) {\n    this.usual = new Zero(this, { dim });\n    this.important = new Zero(this, { dim, priority: StypPriority.Important });\n  }\n\n  get(priority: number): Zero<TUnit> {\n    switch (priority) {\n    case StypPriority.Usual: return this.usual;\n    case StypPriority.Important: return this.important;\n    }\n    return new Zero(this, { dim: this.dim, priority });\n  }\n\n}\n\n/**\n * @internal\n */\nexport function newStypZero<TUnit extends string>(dim: StypDimension.Kind.UnitlessZero<TUnit>): StypZero<TUnit> {\n  return new ZeroByPriority<TUnit>(dim).usual;\n}\n","import { StypValue } from '../value';\nimport { StypDimension, StypNumeric } from './numeric';\nimport { isStypNumeric, StypDimension as StypDimension_ } from './numeric.impl';\nimport { StypZero } from './zero';\nimport { newStypZero } from './zero.impl';\n\n/**\n * @internal\n */\nexport function unitlessZeroDimensionKind<TUnit extends string>(\n    {\n      pt,\n      noPt,\n    }: {\n      pt: () => StypDimension.Kind.UnitlessZero<TUnit | '%'>;\n      noPt: () => StypDimension.Kind.UnitlessZero<Exclude<TUnit, '%'>>;\n    },\n): StypDimension.Kind.UnitlessZero<TUnit> {\n\n  const dimension: StypDimension.Kind.UnitlessZero<TUnit> = {\n\n    get zero(): StypZero<TUnit> {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return zero;\n    },\n\n    get pt() {\n      return pt();\n    },\n\n    get noPt() {\n      return noPt();\n    },\n\n    of(val: number, unit: TUnit): StypDimension<TUnit> | StypZero<TUnit> {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return val ? new StypDimension_(val, unit, { dim: this }) : zero;\n    },\n\n    by(source: StypValue): StypNumeric<TUnit> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n      return (source as StypNumeric<TUnit>).toDim(this);\n    },\n\n  };\n\n  const zero = newStypZero<TUnit>(dimension);\n\n  return dimension;\n}\n\n/**\n * @internal\n */\nexport function unitZeroDimensionKind<TUnit extends string>(\n    {\n      zeroUnit,\n      withPercent,\n      noPercent,\n    }: {\n      zeroUnit: TUnit;\n      withPercent?: () => StypDimension.Kind.UnitZero<TUnit | '%'>;\n      noPercent?: () => StypDimension.Kind.UnitZero<Exclude<TUnit, '%'>>;\n    },\n): StypDimension.Kind.UnitZero<TUnit> {\n\n  const dim: StypDimension.Kind.UnitZero<TUnit> = {\n\n    get pt() {\n      return withPercent && withPercent();\n    },\n\n    get noPt() {\n      return noPercent ? noPercent() : this as StypDimension.Kind.UnitZero<Exclude<TUnit, '%'>>;\n    },\n\n    get zero(): StypDimension<TUnit> {\n      return zero;// eslint-disable-line @typescript-eslint/no-use-before-define\n    },\n\n    of(val: number, unit: TUnit): StypDimension<TUnit> {\n      return new StypDimension_(val, unit, { dim: this });\n    },\n\n    by(source: StypValue): StypNumeric<TUnit, StypDimension<TUnit>> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n      return (source as StypNumeric<TUnit>).toDim(this) as StypNumeric<TUnit, StypDimension<TUnit>>;\n    },\n\n  };\n\n  const zero = new StypDimension_(0, zeroUnit, { dim });\n\n  return dim;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { StypDimension, StypNumeric } from '../numeric';\nimport { unitlessZeroDimensionKind } from '../numeric/dimension-kind.impl';\n\n/**\n * Structured [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) property value.\n *\n * Can be constructed using `StypLength.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLength = StypNumeric<StypLength.Unit>;\n\nexport namespace StypLength {\n\n  /**\n   * Supported length units, excluding percent.\n   */\n  export type Unit = 'cap' | 'ch' | 'em' | 'ex' | 'ic' | 'lh' | 'rem' | 'rlh'\n      | 'vh' | 'vw' | 'vi' | 'vb' | 'vmin' | 'vmax'\n      | 'px' | 'cm' | 'mm' | 'Q' | 'in' | 'pc' | 'pt';\n\n}\n\nexport const StypLength: StypDimension.Kind.UnitlessZero<StypLength.Unit> = (/*#__PURE__*/ unitlessZeroDimensionKind({\n  pt() {\n    return StypLengthPt;// eslint-disable-line @typescript-eslint/no-use-before-define\n  },\n  noPt() {\n    return StypLength;\n  },\n}));\n\n/**\n * Structured [length-percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage) CSS property\n * value.\n *\n * Can be constructed using `StypLengthPt.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLengthPt = StypNumeric<StypLengthPt.Unit>;\n\nexport namespace StypLengthPt {\n\n  /**\n   * Supported length units, including percent.\n   */\n  export type Unit = StypLength.Unit | '%';\n\n}\n\nexport const StypLengthPt: StypDimension.Kind.UnitlessZero<StypLengthPt.Unit> = (\n    /*#__PURE__*/ unitlessZeroDimensionKind({\n      pt() {\n        return StypLengthPt;\n      },\n      noPt() {\n        return StypLength;\n      },\n    })\n);\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { escapeCSSVal } from '@frontmeans/httongue';\nimport { stypSplitPriority } from './priority';\nimport { StypValue, StypValueStruct } from './value';\n\n/**\n * Structured [URL](https://developer.mozilla.org/en-US/docs/Web/CSS/url) CSS property value.\n *\n * @category CSS Value\n */\nexport class StypURL extends StypValueStruct<StypURL> {\n\n  /**\n   * Target URL.\n   */\n  readonly url: string;\n\n  /**\n   * `url` value type.\n   */\n  get type(): 'url' {\n    return 'url';\n  }\n\n  /**\n   * Maps the given CSS property value to URL. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a {@link StypURL} class as [CSS property mapping]{@link StypMapper.Mapping}.\n   *\n   * Strings are treated as URLs (without `url()` functional syntax). `!important` suffix is respected.\n   *\n   * @param source - A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  static by(source: StypValue): StypURL | undefined {\n    switch (typeof source) {\n    case 'string': {\n\n      const [url, priority] = stypSplitPriority(source);\n\n      return new StypURL(url, { priority });\n    }\n    case 'object':\n      if (source.type === 'url') {\n        return source;\n      }\n      break;\n    default:\n    }\n    return;\n  }\n\n  /**\n   * Constructs URL value.\n   *\n   * @param url - Target URL.\n   * @param opts - Construction options.\n   */\n  constructor(url: string, opts?: StypValue.Opts) {\n    super(opts);\n    this.url = url;\n  }\n\n  by(source: StypValue): StypURL {\n    return StypURL.by(source) || this;\n  }\n\n  prioritize(priority: number): StypURL {\n    return priority === this.priority ? this : new StypURL(this.url, { priority });\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === 'url'\n        && other.url === this.url\n        && other.priority === this.priority;\n  }\n\n  toString(): string {\n    return `url(\"${escapeCSSVal(this.url)}\")`;\n  }\n\n}\n","import {\n  afterAll,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  isEventSender,\n  mapAfter,\n  mapAfter_,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { isPresent, valuesProvider } from '@proc7ts/primitives';\nimport { filterIt, itsIterator, itsReduction, overEntries } from '@proc7ts/push-iterator';\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue, stypValuesEqual } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * @internal\n */\nexport const noStypProperties: AfterEvent<[StypProperties]> = (/*#__PURE__*/ afterThe({}));\n\n/**\n * @internal\n */\nexport function noStypPropertiesSpec(): AfterEvent<[StypProperties]> {\n  return noStypProperties;\n}\n\n/**\n * @internal\n */\nexport function stypPropertiesBySpec(rule: StypRule, spec?: StypProperties.Spec): AfterEvent<[StypProperties]> {\n  if (!spec) {\n    return noStypProperties;\n  }\n  if (typeof spec !== 'string') {\n    if (isEventKeeper(spec)) {\n      return preventDuplicates(spec);\n    }\n    if (isEventSender(spec)) {\n      return preventDuplicates(propertiesKeeper(spec));\n    }\n    if (typeof spec === 'function') {\n\n      const senderOrProperties = spec(rule);\n\n      if (typeof senderOrProperties !== 'string') {\n        if (isEventKeeper(senderOrProperties)) {\n          return preventDuplicates(senderOrProperties);\n        }\n        if (isEventSender(senderOrProperties)) {\n          return preventDuplicates(propertiesKeeper(senderOrProperties));\n        }\n      }\n\n      return afterThe(propertiesMap(senderOrProperties));\n    }\n  }\n\n  return afterThe(propertiesMap(spec));\n}\n\nfunction propertiesKeeper(sender: EventSender<[string | StypProperties]>): AfterEvent<[string | StypProperties]> {\n  return afterSupplied(sender, valuesProvider({}));\n}\n\nfunction preventDuplicates(properties: EventKeeper<[string | StypProperties]>): AfterEvent<[StypProperties]> {\n  return afterSupplied(properties).do(\n      mapAfter_(propertiesMap),\n      translateAfter(passNonDuplicate()),\n  );\n}\n\nfunction passNonDuplicate(): (send: (properties: StypProperties) => void, update: StypProperties) => void {\n\n  let stored: StypProperties | undefined;\n\n  return (send, update) => {\n    if (!stored || !propertiesEqual(update, stored)) {\n      send(stored = { ...update });\n    }\n  };\n}\n\nfunction propertiesMap(properties: string | StypProperties): StypProperties {\n  return typeof properties === 'string' ? { $$css: properties } : properties;\n}\n\nfunction propertiesEqual(first: StypProperties, second: StypProperties): boolean {\n\n  const s = itsIterator(propertyEntries(second));\n\n  for (const [key, value] of propertyEntries(first)) {\n\n    const { value: sentry } = s.next() as IteratorResult<[keyof StypProperties, StypValue], undefined>;\n\n    if (!sentry || key !== sentry[0] || !stypValuesEqual(value, sentry[1])) {\n      return false;\n    }\n  }\n\n  return !s.next().value;\n}\n\nfunction propertyEntries(properties: StypProperties): Iterable<readonly [keyof StypProperties, StypValue]> {\n  return filterIt(\n      overEntries(properties),\n      ([, value]) => isPresent(value),\n  );\n}\n\n/**\n * @internal\n */\nexport function mergeStypProperties(\n    base: AfterEvent<[StypProperties]>,\n    addendum: AfterEvent<[StypProperties]>,\n): AfterEvent<[StypProperties]> {\n  return preventDuplicates(\n      afterAll({ base, addendum }).do(\n          mapAfter(\n              ({\n                base: [baseProperties],\n                addendum: [addendumProperties],\n              }) => addValues(baseProperties, addendumProperties),\n          ),\n      ),\n  );\n}\n\nfunction addValues(base: StypProperties, addendum: StypProperties): StypProperties {\n  return itsReduction(\n      overEntries(addendum),\n      (result, [k, v]) => addValue(result, k, v),\n      { ...base },\n  );\n}\n\nfunction addValue(\n    properties: StypProperties.Mutable,\n    key: keyof StypProperties,\n    value: StypValue,\n): StypProperties.Mutable {\n  if (priorityOf(properties[key]) <= priorityOf(value)) {\n    delete properties[key];\n    properties[key] = value;\n  }\n  return properties;\n}\n\nfunction priorityOf(value: StypValue): number {\n  switch (typeof value) {\n  case 'string':\n    return value.endsWith(IMPORTANT_CSS_SUFFIX) ? 1 : 0;\n  case 'object':\n    return value.priority;\n  default:\n    return 0;\n  }\n}\n","import { compareNames, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { flatMapIt } from '@proc7ts/push-iterator';\nimport { isNotEmptyArray, isReadonlyArray } from '../internal';\nimport { StypPureSelector } from './pure-selector';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSubSelector } from './sub-selector';\n\n/**\n * @internal\n */\nexport function isCombinator(\n    item: string | StypSelector.Part | StypSelector.Combinator,\n): item is StypSelector.Combinator {\n  return item === '>' || item === '+' || item === '~';\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized {\n  if (!isReadonlyArray(selector)) {\n    return [normalizeKey(selector)];\n  }\n\n  const normalized: StypSelector.Mutable = [];\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (const item of selector) {\n\n    const prevCombinator = combinator;\n\n    if (combinator) {\n      normalized.push(combinator);\n      combinator = undefined;\n    }\n\n    let part: StypSelector.NormalizedPart;\n\n    if (isCombinator(item)) {\n      combinator = item;\n      if (!prevCombinator) {\n        continue;\n      }\n      part = {};\n    } else {\n      part = normalizeKey(item);\n    }\n\n    normalized.push(part);\n  }\n  if (combinator) {\n    normalized.push(combinator, {});\n  }\n\n  return normalized;\n}\n\nfunction normalizeKey(key: StypSelector.Part | string): StypSelector.NormalizedPart {\n  if (typeof key === 'string') {\n    if (!key) {\n      return {};\n    }\n    return { s: key };\n  }\n  return normalizeStypSelectorPart(key);\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelectorPart(part: StypSelector.Part): StypSelector.NormalizedPart {\n\n  const ns = part.ns || undefined;\n  const i = part.i || undefined;\n  const c = normalizeClasses(part.c);\n  const u = normalizeSubSelectors(part.u);\n\n  return {\n    ns,\n    e: (part.e !== '*' || !ns && !i && !c && u && isPseudoSubSelector(u[0])) && part.e || undefined,\n    i,\n    c,\n    u,\n    s: part.s || undefined,\n    $: normalizeQualifiers(part.$),\n  };\n}\n\nfunction normalizeClasses(\n    classes: QualifiedName | readonly QualifiedName[] | undefined,\n): readonly [QualifiedName, ...QualifiedName[]] | undefined {\n  if (!classes) {\n    return;\n  }\n  if (isQualifiedName(classes)) {\n    return [classes];\n  }\n\n  const result = classes.filter(c => !!c);\n\n  return isNotEmptyArray(result) ? result.sort(compareNames) : undefined;\n}\n\nfunction normalizeSubSelectors(\n    subs: StypSubSelector | readonly StypSubSelector[] | undefined,\n): readonly [StypSubSelector.Normalized, ...StypSubSelector.Normalized[]] | undefined {\n  if (!subs) {\n    return;\n  }\n  if (/*#__INLINE__*/ isSubSelectorsArray(subs)) {\n\n    const result = subs.map(normalizeSubSelector);\n\n    return isNotEmptyArray(result) ? result : undefined;\n  }\n\n  return [normalizeSubSelector(subs)];\n}\n\nfunction isSubSelectorsArray(\n    subs: StypSubSelector | readonly StypSubSelector[],\n): subs is readonly StypSubSelector[] {\n  return typeof subs[0] !== 'string';\n}\n\nfunction normalizeSubSelector(sub: StypSubSelector): StypSubSelector.Normalized {\n  if (!isPseudoSubSelector(sub)) {\n    return sub;\n  }\n  if (sub.length < 3) {\n    return sub as StypSubSelector.Normalized;\n  }\n\n  const [prefix, name, ...params] = sub;\n\n  if (/*#__INLINE__*/ isSubSelectorParametersArray(params)) {\n    return [prefix, name, ...params.map(normalizeStypSelector)];\n  }\n\n  return [prefix, name, normalizeStypSelector(params)];\n}\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector.Normalized): sub is StypSubSelector.NormalizedPseudo;\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo;\n\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo {\n  return sub.length > 1 && (sub[0] === ':' || sub[0] === '::');\n}\n\nfunction isSubSelectorParametersArray(\n    param: StypSubSelector.Parameter | readonly StypSubSelector.Parameter[],\n): param is readonly StypSubSelector.Parameter[] {\n  return isReadonlyArray(param[0]);\n}\n\nfunction normalizeQualifiers(\n    qualifiers: string | readonly string[] | undefined,\n): readonly [string, ...string[]] | undefined {\n  if (!qualifiers) {\n    return;\n  }\n\n  if (!isReadonlyArray(qualifiers)) {\n    qualifiers = [...exposeQualifier(qualifiers)];\n  } else {\n    qualifiers = [...new Set(flatMapIt(qualifiers, exposeQualifier))].sort();\n  }\n\n  return isNotEmptyArray(qualifiers) ? qualifiers : undefined;\n}\n\nconst noQualifiers: ReadonlySet<string> = new Set();\n\nfunction exposeQualifier(qualifier: string): ReadonlySet<string> {\n  if (!qualifier) {\n    return noQualifiers;\n  }\n\n  const eqIdx = qualifier.indexOf('=');\n  const name = eqIdx < 0 ? qualifier : qualifier.substring(0, eqIdx);\n  const exposed = new Set<string>();\n  let lastExposed: string | undefined;\n\n  for (const part of name.split(':')) {\n    if (lastExposed) {\n      lastExposed += ':' + part;\n    } else {\n      lastExposed = part;\n    }\n    exposed.add(lastExposed);\n  }\n  if (eqIdx >= 0) {\n    exposed.add(qualifier);\n  }\n\n  return exposed;\n}\n\nconst noKeyAndTail: [[]] = [[]];\n\n/**\n * @internal\n */\nexport function stypRuleKeyAndTail(\n    selector: StypSelector.Normalized,\n): readonly [[]] | readonly [StypRuleKey.Nested, StypSelector.Normalized?] {\n  if (!selector.length) {\n    return noKeyAndTail;\n  }\n\n  let i = 0;\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (;;) {\n\n    const part = selector[i++];\n\n    if (isCombinator(part)) {\n      combinator = part;\n      continue;\n    }\n\n    const key: StypRuleKey = combinator ? [combinator, part] : [part];\n\n    return [key, selector.slice(i)];\n  }\n}\n\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * @internal\n */\nexport function stypOuterSelector(\n    selector: StypSelector.Normalized,\n): StypSelector.Normalized | undefined {\n\n  let i = selector.length - 1;\n\n  if (i <= 0) {\n    return i ? undefined : rootSelector;\n  }\n\n  do {\n    --i;\n    switch (selector[i]) {\n    case '>':\n      return selector.slice(0, i);\n    case '+':\n    case '~':\n      --i;\n      continue;\n    default:\n      return selector.slice(0, i + 1);\n    }\n  } while (i > 0);\n\n  return;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { namesEqual, NamespaceDef, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { normalizeStypSelectorPart } from './selector.impl';\n\n/**\n * CSS rule query.\n *\n * It may represent a selector like `element-name#id.class1.classN` with any of sub-parts omitted.\n *\n * Queries are used to grab a subset of matching rules from `StypRule`.\n *\n * All of its properties are optional.\n *\n * @category CSS Rule\n */\nexport interface StypQuery {\n\n  /**\n   * Element namespace.\n   */\n  readonly ns?: string | NamespaceDef;\n\n  /**\n   * Element name.\n   *\n   * This is the same as `*` when absent.\n   */\n  readonly e?: QualifiedName;\n\n  /**\n   * Element identifier.\n   */\n  readonly i?: QualifiedName;\n\n  /**\n   * Element class name or names.\n   */\n  readonly c?: QualifiedName | readonly QualifiedName[];\n\n  /**\n   * Qualifier or qualifiers.\n   */\n  readonly $?: string | readonly string[];\n\n}\n\nexport namespace StypQuery {\n\n  /**\n   * Normalized CSS rule query.\n   */\n  export type Normalized = StypQuery & StypSelector.NormalizedPart;\n\n}\n\n/**\n * Normalizes arbitrary CSS rule query.\n *\n * @category CSS Rule\n * @param query - CSS rule query to normalize.\n *\n * @returns Normalized CSS rule query.\n */\nexport function stypQuery(query: StypQuery): StypQuery.Normalized {\n  return normalizeStypSelectorPart(query);\n}\n\n/**\n * Checks whether the given structured CSS `selector` matches target `query`.\n *\n * @category CSS Rule\n * @param selector - Normalized structured CSS selector.\n * @param query - Normalized CSS rule query.\n *\n * @returns `true` if `selector` matches the `query`, or `false` otherwise.\n */\nexport function stypSelectorMatches(\n    selector: StypSelector.Normalized | StypPureSelector.Normalized,\n    query: StypQuery.Normalized,\n): boolean {\n  if (!selector.length) {\n    return false;\n  }\n\n  const part = selector[selector.length - 1] as StypSelector.NormalizedPart;\n\n  if (query.ns && part.ns !== query.ns) {\n    return false;\n  }\n  if (query.e && part.e !== query.e) {\n    return false;\n  }\n  if (query.i && part.i !== query.i) {\n    return false;\n  }\n  if (query.c && !classesMatch(part.c, query.c)) {\n    return false;\n  }\n  // noinspection RedundantIfStatementJS\n  if (query.$ && !classesMatch(part.$, query.$)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * @internal\n */\nfunction classesMatch(\n    classes: readonly QualifiedName[] | undefined,\n    query: readonly QualifiedName[],\n): boolean | undefined {\n  return classes && query.every(qClass => classes.find(mClass => namesEqual(qClass, mClass)));\n}\n","import { StypSelector } from './index';\nimport { StypPureSelector } from './pure-selector';\nimport { normalizeStypSelector } from './selector.impl';\n\n/**\n * Converts normalized pure CSS selector part to normalized pure CSS selector.\n *\n * @category CSS Rule\n * @param selector - Normalized pure CSS selector part.\n *\n * @returns Normalized pure CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * Converts normalized structured CSS selector part to normalized structured CSS selector.\n *\n * @category CSS Rule\n * @param selector - Normalized CSS selector part.\n *\n * @returns Normalized structured CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * Normalizes arbitrary pure CSS selector.\n *\n * @param selector - CSS selector to normalize.\n *\n * @returns Normalized pure CSS selector.\n */\nexport function stypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * Normalizes arbitrary structured CSS selector.\n *\n * @param selector - CSS selector to normalize.\n *\n * @returns Normalized structured CSS selector.\n */\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized {\n  return normalizeStypSelector(selector);\n}\n","import { escapeCSS, escapeCSSVal } from '@frontmeans/httongue';\nimport {\n  css__naming,\n  html__naming,\n  id__naming,\n  NamespaceAliaser,\n  NamespaceDef,\n  newNamespaceAliaser,\n} from '@frontmeans/namespace-aliaser';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSelectorFormat } from './selector-text';\nimport { isCombinator, isPseudoSubSelector } from './selector.impl';\nimport { StypSubSelector } from './sub-selector';\n\nconst ruleKeyTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${escapeCSS(qualifier)}`;\n  },\n};\n\n/**\n * @internal\n */\nexport function stypRuleKeyText(key: StypRuleKey): string {\n  return formatStypSelector(key, ruleKeyTextOpts);\n}\n\nconst displayTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${qualifier}`;\n  },\n};\n\n/**\n * @internal\n */\nexport function stypSelectorDisplayText(selector: StypSelector.Normalized): string {\n  return formatStypSelector(selector, displayTextOpts);\n}\n\nconst defaultFormat: StypSelectorFormat = {};\n\n/**\n * @internal\n */\nexport function formatStypSelector(\n    selector: StypSelector.Normalized,\n    {\n      qualify,\n      nsAlias = newNamespaceAliaser(),\n    }: StypSelectorFormat = defaultFormat,\n): string {\n\n  const format: ItemFormat = { qualify, nsAlias };\n\n  return selector.reduce(\n      (result, item) => {\n        if (isCombinator(item)) {\n          return result + item;\n        }\n        if (result && !isCombinator(result[result.length - 1])) {\n          result += ' ';\n        }\n        return result + formatItem(item, format);\n      },\n      '',\n  );\n}\n\ninterface ItemFormat extends StypSelectorFormat {\n  nsAlias: NamespaceAliaser;\n}\n\nfunction formatItem(\n    item: StypSelector.NormalizedPart,\n    {\n      qualify,\n      nsAlias,\n    }: ItemFormat,\n): string {\n\n  const { ns, e, i, c, s, u, $ } = item;\n  let hasProperties = false;\n  let out = '';\n\n  if (i) {\n    hasProperties = true;\n    out += `#${escapeCSS(id__naming.name(i, nsAlias))}`;\n  }\n  if (c) {\n    hasProperties = true;\n    out = c.reduce<string>(\n        (result, className) => `${result}.${escapeCSS(css__naming.name(className, nsAlias))}`,\n        out,\n    );\n  }\n  if (u) {\n    hasProperties = true;\n\n    const subFormat: ItemFormat = { nsAlias };\n\n    out = u.reduce(\n        (result, sub) => formatSubSelector(result, sub, subFormat),\n        out,\n    );\n  }\n  if (s) {\n    hasProperties = true;\n    out += s;\n  }\n  if (qualify && $) {\n    out = $.reduce((result, qualifier) => result + qualify(qualifier), out);\n  }\n  if (ns) {\n\n    const alias = xmlNs(ns, nsAlias);\n\n    if (alias) {\n      out = `${alias}|${e || '*'}${out}`;\n    } else {\n      out = qualifyElement();\n    }\n  } else {\n    out = qualifyElement();\n  }\n\n  return out;\n\n  function qualifyElement(): string {\n    if (hasProperties) {\n      return `${e ? html__naming.name(e, nsAlias) : ''}${out}`;\n    }\n    return `${e ? html__naming.name(e, nsAlias) : '*'}${out}`;\n  }\n}\n\nfunction formatSubSelector(\n    out: string,\n    sub: StypSubSelector.Normalized,\n    format: ItemFormat,\n): string {\n  if (isPseudoSubSelector(sub)) {\n    out += sub[0] + sub[1];\n\n    const len = sub.length;\n\n    if (len > 2) {\n      out += '(' + formatStypSelector(sub[2], format);\n      for (let i = 3; i < sub.length; ++i) {\n        out += ',' + formatStypSelector(sub[i] as StypSubSelector.NormalizedParameter, format);\n      }\n      out += ')';\n    }\n\n    return out;\n  }\n\n  const [attrName, attrOp, attrVal, attrFlag] = sub;\n\n  out += '[' + escapeCSS(attrName);\n  if (attrOp) {\n    out += `${attrOp}\"${escapeCSSVal(attrVal!)}\"`;\n  }\n  if (attrFlag) {\n    out += ' ' + attrFlag;\n  }\n\n  return out + ']';\n}\n\nfunction xmlNs(ns: string | NamespaceDef, nsAlias: NamespaceAliaser): string | undefined {\n  return typeof ns === 'string' ? ns : ns.url ? nsAlias(ns) : undefined;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { AfterEvent, mapAfter } from '@proc7ts/fun-events';\nimport { filterIt, itsReduction, ObjectEntry, overEntries } from '@proc7ts/push-iterator';\nimport { isNotEmptyArray } from '../../internal';\nimport { StypProperties, StypRule } from '../../rule';\nimport { mergeStypProperties } from '../../rule/properties.impl';\nimport { StypSelector, stypSelector } from '../../selector';\nimport { isCombinator } from '../../selector/selector.impl';\nimport { stypSplitPriority, StypValue } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * @internal\n */\nclass AtRulesRenderer implements StypRenderer.Spec {\n\n  constructor(private readonly _rule: StypRule) {\n  }\n\n  read(properties: AfterEvent<[StypProperties]>): AfterEvent<[StypProperties]> {\n\n    let outer = this._rule.outer;\n\n    while (outer) {\n      properties = mergeStypProperties(outer.read.do(mapAfter(onlyAtProperties)), properties);\n      outer = outer.outer;\n    }\n\n    return properties;\n  }\n\n  render(producer: StyleProducer, properties: StypProperties): void {\n\n    const { selector } = producer;\n    let { writer } = producer;\n\n    if (!writer.isGroup) {\n      producer.render(properties);\n      return;\n    }\n\n    let sheet = writer;\n    const extracted = extractAtSelectors(selector);\n\n    if (!extracted) {\n      producer.render(properties);\n      return;\n    }\n\n    const [atSelectors, restSelector] = extracted;\n\n    for (const atSelector of atSelectors) {\n\n      const [name, params] = buildAtSelector(properties, atSelector);\n\n      if (params) {\n        writer = sheet = sheet.addGroup(name, params);\n      } else {\n        writer = sheet.addStyle(name);\n        break;\n      }\n    }\n\n    producer.render(properties, { writer, selector: restSelector });\n  }\n\n}\n\n/**\n * @internal\n */\nfunction buildAtSelector(\n    properties: StypProperties,\n    [key, [names, customQuery]]: [string, [Set<string>, string?]],\n): [string, string?] {\n\n  let query = '';\n  const addQuery = (q?: StypValue): void => {\n    if (q) {\n      if (query) {\n        query += ' and ';\n      }\n      query += q;\n    }\n  };\n\n  for (const name of names) {\n\n    const [namedQuery] = stypSplitPriority(properties[name]);\n\n    addQuery(namedQuery);\n  }\n\n  addQuery(customQuery);\n\n  return query ? [key, query] : [key];\n}\n\n/**\n * CSS stylesheet renderer of at-rules like `@media` queries.\n *\n * At-rules are represented by qualifiers which names start with `@` symbol. Qualifier names are used as at-rules keys,\n * and their values - as queries. If the rest of the selector is not empty, then properties are rendered in CSS\n * rule nested inside at-rule. Otherwise the properties are rendered in at-rule.\n *\n * So, for example CSS rule with `{ c: 'screen-only', $: '@media=screen' }` selector would be rendered as\n * ```css\n * @media screen {\n *   .screen-only {\n *      \\/* CSS properties *\\/\n *   }\n * }\n * ```\n *\n * Another option is to use named at-rules qualifiers. When named qualifier is used, the corresponding property is\n * searched in CSS rule and all of its outer rules. The values of all matching properties are used as queries.\n *\n * So the above example could be written as: `{ c: 'screen-only', $: '@media:screen' }` if CSS rule (or its outer\n * one) contains property `@media:screen` with value `screen`.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nexport const stypRenderAtRules: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER,\n\n  create(rule) {\n    return new AtRulesRenderer(rule);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction onlyAtProperties(properties: StypProperties): StypProperties {\n  return itsReduction(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          isAtEntry,\n      ),\n      (result: StypProperties.Mutable, [key, value]: ObjectEntry<StypProperties, string>) => {\n        result[key] = value;\n        return result;\n      },\n      {},\n  );\n}\n\n/**\n * @internal\n */\nfunction isAtEntry(entry: ObjectEntry<StypProperties>): entry is ObjectEntry<StypProperties, string> {\n  return String(entry[0])[0] === '@';\n}\n\n/**\n * @internal\n */\nfunction extractAtSelectors(\n    selector: StypSelector.Normalized,\n): [Map<string, [Set<string>, string?]>, StypSelector.Normalized] | undefined {\n\n  const atSelectors = new Map<string, [Set<string>, string?]>();\n  const rest: StypSelector.Mutable = [];\n\n  for (const part of selector) {\n    if (isCombinator(part)) {\n      rest.push(part);\n    } else {\n      rest.push(extractPartAtSelectors(part, atSelectors));\n    }\n  }\n\n  if (!atSelectors.size) {\n    return; // No at-rule qualifiers found.\n  }\n\n  return [atSelectors, stypSelector(rest)];\n}\n\n/**\n * @internal\n */\nfunction extractPartAtSelectors(\n    part: StypSelector.NormalizedPart,\n    atSelectors: Map<string, [Set<string>, string?]>,\n): StypSelector.NormalizedPart {\n\n  const qualifiers = part.$;\n\n  if (!qualifiers) {\n    return part;\n  }\n\n  const restQualifies: string[] = [];\n\n  for (const qualifier of qualifiers) {\n    if (qualifier[0] === '@') {\n      addAtSelector(atSelectors, qualifier);\n    } else {\n      restQualifies.push(qualifier);\n    }\n  }\n\n  if (restQualifies.length === qualifiers.length) {\n    return part; // No at-rule qualifiers found\n  }\n  if (isNotEmptyArray(restQualifies)) {\n    return { ...part, $: restQualifies };\n  }\n\n  return { ...part, $: undefined };\n}\n\n/**\n * @internal\n */\nfunction addAtSelector(atSelectors: Map<string, [Set<string>, string?]>, qualifier: string): void {\n\n  const eqIdx = qualifier.indexOf('=');\n  let name: string;\n  let query: string | undefined;\n\n  if (eqIdx < 0) {\n    name = qualifier;\n  } else {\n    name = qualifier.substring(0, eqIdx);\n    query = qualifier.substring(eqIdx + 1);\n  }\n\n  const colonIdx = name.indexOf(':');\n  const key = colonIdx < 0 ? name : name.substring(0, colonIdx);\n  const atSelector = atSelectors.get(key);\n\n  if (!atSelector) {\n    atSelectors.set(key, [new Set<string>().add(name), query]);\n  } else {\n\n    const [names, prevQuery] = atSelector;\n\n    names.add(name);\n    if (query) {\n      atSelector[1] = prevQuery ? `${prevQuery} and ${query}` : query;\n    }\n  }\n}\n","/**\n * @internal\n */\nexport const FIRST_RENDER_ORDER = -0xffff;\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { overEntries } from '@proc7ts/push-iterator';\nimport { StypProperties } from '../../rule';\nimport { stypSplitPriority, StypURL, StypValue } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { StypWriter } from '../writer';\nimport { stypRenderAtRules } from './at-rules.renderer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * CSS stylesheet renderer of global at-rules.\n *\n * It renders at-rules that should stay at the top level:\n * - `@namespace`\n * - `@import`\n *\n * At-rule parameters are taken from root CSS rule properties and treated as following.\n *\n * **`@import:url`** property value is treated as media query and appended after stylesheet URL. I.e.\n * ```json\n * {\n *     \"@import:path/to/included.css\": \"screen\"\n * }\n * ```\n * becomes\n * ```css\n * @import url(path/to/included.css) screen;\n * ```\n *\n * **`@namespace`** property value is treated as default namespace URL. I.e.\n * ```json\n * {\n *     \"@namespace\": \"http://www.w3.org/1999/xhtml\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace url(http://www.w3.org/1999/xhtml);\n * ```\n *\n * **`@namespace:prefix`** property value is treated as namespace URL with the given prefix. I.e\n * ```json\n * {\n *     \"@namespace:svg\": \"http://www.w3.org/2000/svg\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace svg url(http://www.w3.org/2000/svg);\n * ```\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nexport const stypRenderGlobals: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER + 1,\n\n  needs: stypRenderAtRules,\n\n  render(producer: StyleProducer, properties: StypProperties) {\n\n    const rootRule = !producer.rule.selector.length;\n\n    const { sheet } = producer;\n    let importIndex = 0;\n    let nsIndex = 0;\n\n    for (const [k, v] of overEntries(properties)) {\n\n      const key = String(k);\n\n      if (key[0] === '@') {\n\n        const [value] = stypSplitPriority(v);\n        const importDelta = rootRule ? renderImport(sheet, importIndex, key, value) : 0;\n\n        importIndex += importDelta;\n        nsIndex += importDelta;\n\n        const url = StypURL.by(value);\n\n        if (url) {\n          nsIndex += renderDefaultNamespace(sheet, nsIndex, key, url);\n          nsIndex += renderNamespacePrefix(sheet, nsIndex, key, url);\n        }\n      }\n    }\n\n    producer.render(properties);\n  },\n\n};\n\n/**\n * @internal\n */\nconst IMPORT_PREFIX = '@import:';\n\n/**\n * @internal\n */\nfunction renderImport(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    value: StypValue,\n): number {\n  if (!key.startsWith(IMPORT_PREFIX)) {\n    return 0;\n  }\n\n  const url = new StypURL(key.substring(IMPORT_PREFIX.length));\n  let css = String(url);\n\n  if (value) {\n    css += ` ${value}`;\n  }\n\n  sheet.addGlobal('@import', css, index);\n\n  return 1;\n}\n\n/**\n * @internal\n */\nfunction renderDefaultNamespace(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    url: StypURL,\n): number {\n  if (key !== '@namespace') {\n    return 0;\n  }\n\n  sheet.addGlobal('@namespace', String(url), index);\n\n  return 1;\n}\n\n/**\n * @internal\n */\nconst NS_PREFIX = '@namespace:';\n\n/**\n * @internal\n */\nfunction renderNamespacePrefix(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    url: StypURL,\n): number {\n  if (!key.startsWith(NS_PREFIX)) {\n    return 0;\n  }\n\n  const prefix = key.substring(NS_PREFIX.length);\n\n  sheet.addGlobal('@namespace', `${prefix} ${url}`, index);\n\n  return 1;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { hyphenateCSSName } from '@frontmeans/httongue';\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/push-iterator';\nimport { StypProperties } from '../../rule';\nimport { stypSplitPriority } from '../../value';\nimport { StyleProducer } from '../style-producer';\n\n/**\n * Renders CSS properties.\n *\n * This renderer is always present, so there is typically no need to use it explicitly.\n *\n * @category Rendering\n */\nexport function stypRenderProperties(producer: StyleProducer, properties: StypProperties): void {\n\n  const style = producer.addStyle();\n\n  itsEach(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          notCustomProperty,\n      ),\n      ([k, v]) => {\n\n        const [value, priority] = stypSplitPriority(v);\n\n        style.set(hyphenateCSSName(k), `${value}`, priority);\n      },\n  );\n\n  producer.render(properties, { writer: style });\n}\n\n/**\n * @internal\n */\nfunction notCustomProperty(\n    entry: ObjectEntry<StypProperties>,\n): entry is ObjectEntry<Required<StypProperties>, string> {\n\n  const [key, value] = entry;\n\n  if (value == null) {\n    return false;\n  }\n\n  const first = String(key)[0];\n\n  return first >= 'a' && first <= 'z' || first >= 'A' && first <= 'Z';\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { StypProperties } from '../../rule';\nimport { StyleProducer } from '../style-producer';\n\n/**\n * Renders raw CSS text. I.e. the contents of {@link StypProperties.Generic.$$css} property.\n *\n * It should be rendered before CSS properties normally to add the rendered rule as a first one.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nexport function stypRenderText(producer: StyleProducer, properties: StypProperties): void {\n\n  const css = properties.$$css;\n\n  if (!css) {\n    producer.render(properties);\n  } else {\n\n    const style = producer.addStyle();\n\n    style.replace(css);\n    producer.render(properties, { writer: style });\n  }\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { NamespaceDef } from '@frontmeans/namespace-aliaser';\nimport { isPresent } from '@proc7ts/primitives';\nimport { StypProperties } from '../../rule';\nimport { StypSelector } from '../../selector';\nimport { isCombinator } from '../../selector/selector.impl';\nimport { StypURL } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { stypRenderGlobals } from './globals.renderer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * CSS stylesheet renderer of global XML namespace definitions.\n *\n * Renders `@namespace` declarations for CSS selectors containing namespace definitions.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nexport const stypRenderXmlNs: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER,\n\n  needs: stypRenderGlobals,\n\n  render(producer: StyleProducer, properties: StypProperties) {\n\n    const xmlNsDefs = extractXmlNsDefs(producer.selector);\n\n    if (xmlNsDefs.length) {\n\n      const declareNs = (result: StypProperties.Mutable, ns: NamespaceDef): StypProperties.Mutable => {\n\n        const alias = producer.nsAlias(ns);\n\n        result[`@namespace:${alias}`] = new StypURL(ns.url);\n\n        return result;\n      };\n\n      producer.render(xmlNsDefs.reduce(declareNs, { ...properties }));\n    } else {\n      producer.render(properties);\n    }\n  },\n\n};\n\n/**\n * @internal\n */\nfunction extractXmlNsDefs(selector: StypSelector.Normalized): readonly NamespaceDef[] {\n  return selector\n      .map(part => !isCombinator(part) && part.ns && typeof part.ns !== 'string' ? part.ns : null)\n      .filter(isPresent);\n}\n","import { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { isReadonlyArray } from '../../internal';\nimport { StypRule } from '../../rule';\nimport { StypFormat } from '../format';\nimport { StypRenderer } from '../renderer';\nimport { stypRenderProperties } from '../renderers';\n\n/**\n * @internal\n */\nexport interface StypRendererSpecFactory extends StypRenderer.Factory {\n  create(rule: StypRule): StypRenderer.Spec;\n}\n\n/**\n * @internal\n */\nexport function stypRenderFactories(format: StypFormat): readonly StypRendererSpecFactory[] {\n\n  const factories = new Map<StypRenderer, StypRendererSpecFactory>();\n\n  addRenderers(format.renderer);\n  factories.delete(stypRenderProperties);\n\n  return [...factories.values(), rendererFactory(stypRenderProperties)].sort(compareRenderers);\n\n  function addRenderers(renderers: StypRenderer | readonly StypRenderer[] | undefined): void {\n    if (renderers) {\n      if (isReadonlyArray(renderers)) {\n        renderers.forEach(addRenderer);\n      } else {\n        addRenderer(renderers);\n      }\n    }\n  }\n\n  function addRenderer(renderer: StypRenderer): void {\n    if (factories.has(renderer)) {\n      return;\n    }\n\n    const factory = rendererFactory(renderer);\n\n    factories.set(renderer, factory);\n    addRenderers(factory.needs);\n  }\n}\n\nfunction rendererFactory(renderer: StypRenderer): StypRendererSpecFactory {\n  if (typeof renderer === 'function') {\n    return {\n      create() {\n        return { render: renderer };\n      },\n    };\n  }\n  if (isRendererFactory(renderer)) {\n    return {\n      order: renderer.order,\n      needs: renderer.needs,\n      create(rule) {\n        return rendererSpec(renderer.create(rule));\n      },\n    };\n  }\n\n  const render = renderer.render.bind(renderer);\n\n  return {\n    order: renderer.order,\n    needs: renderer.needs,\n    create() {\n      return { render };\n    },\n  };\n}\n\nfunction isRendererFactory(renderer: StypRenderer): renderer is StypRenderer.Factory {\n  return 'create' in renderer;\n}\n\nfunction compareRenderers(first: StypRenderer.Factory, second: StypRenderer.Factory): number {\n\n  const firstOrder = first.order || 0;\n  const secondOrder = second.order || 0;\n\n  return firstOrder > secondOrder ? 1 : firstOrder < secondOrder ? -1 : 0;\n}\n\nfunction rendererSpec(renderer: ReturnType<StypRenderer.Factory['create']>): StypRenderer.Spec {\n  return typeof renderer === 'function' ? { render: renderer } : renderer;\n}\n\n/**\n * @internal\n */\nexport function stypRenderScheduler(\n    parent: Node,\n    scheduler: RenderScheduler = newRenderSchedule,\n): RenderScheduler {\n  return (options = {}) => {\n\n    const { node = parent, error } = options;\n\n    return scheduler({\n      ...options,\n      node,\n      error: error && error.bind(options),\n    });\n  };\n}\n\n/**\n * @internal\n */\nexport function removeStyleElement(element: HTMLStyleElement): void {\n  element.parentNode?.removeChild(element);\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { immediateRenderScheduler, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { EventEmitter, OnEvent } from '@proc7ts/fun-events';\nimport { StypPriority } from '../../value';\nimport { StypFormat, StypFormatConfig } from '../format';\nimport { StypWriter } from '../writer';\n\n/**\n * Textual CSS production format.\n *\n * Represents each style sheet in textual form and reports it to registered receivers. Such receivers should be\n * registered before {@link produceStyle style production} started in order to receive all style sheets.\n *\n * @category Rendering\n */\nexport interface StypTextFormat extends StypFormat, StypTextFormatConfig {\n\n  /**\n   * Detailed configuration of CSS text pretty print, or `false` for compact output.\n   */\n  readonly pretty: StypTextFormatConfig.PrettyPrint | false;\n\n  /**\n   * An `OnEvent` sender of style sheet textual representation.\n   *\n   * Sends textual representation of each rendered style sheet on each update.\n   */\n  readonly onSheet: OnEvent<[StypSheetText]>;\n\n}\n\n/**\n * Configuration of {@link stypTextFormat textual CSS production format}.\n *\n * @category Rendering\n */\nexport interface StypTextFormatConfig extends StypFormatConfig {\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `immediateRenderScheduler` by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n  /**\n   * How to pretty-print generated CSS text.\n   *\n   * - `false` to disable pretty print and generate compact output,\n   * - `true` (default value) for default pretty print,\n   * - {@link StypTextFormatConfig.PrettyPrint detailed configuration object}.\n   */\n  readonly pretty?: boolean | StypTextFormatConfig.PrettyPrint;\n\n}\n\nexport namespace StypTextFormatConfig {\n\n  /**\n   * Detailed configuration of CSS text pretty print.\n   */\n  export interface PrettyPrint {\n\n    /**\n     * Indentation string to use when formatting CSS text.\n     *\n     * Two spaces by default.\n     */\n    indent?: string;\n\n  }\n\n}\n\n/**\n * Style sheet textual representation.\n *\n * This is sent when producing styles in {@link StypTextFormat.onSheet textual format}.\n *\n * @category Rendering\n */\nexport interface StypSheetText {\n\n  /**\n   * Unique style sheet identifier.\n   *\n   * Style sheet is reported with the same identifier on each update.\n   */\n  readonly id: string;\n\n  /**\n   * The textual representation of style sheet formatted accordingly to {@link StypTextFormatConfig options},\n   * or `undefined` to inform that corresponding style sheet have been removed.\n   */\n  readonly css?: string;\n\n}\n\n/**\n * @internal\n */\ninterface StypTextFormatter {\n  readonly pre: string;\n  readonly nv: string;\n  readonly eol: string;\n  indent(): StypTextFormatter;\n}\n\n/**\n * @internal\n */\nconst defaultPrettyPrint: StypTextFormatConfig.PrettyPrint = {\n  indent: '  ',\n};\n\n/**\n * @internal\n */\nconst compactStypTextFormatter: StypTextFormatter = {\n  nv: '',\n  eol: '',\n  pre: '',\n  indent() {\n    return this;\n  },\n};\n\n/**\n * @internal\n */\nclass StypTextFormatter$ implements StypTextFormatter {\n\n  constructor(\n      private readonly _config: StypTextFormatConfig.PrettyPrint,\n      readonly pre = '',\n  ) {\n  }\n\n  get nv(): string {\n    return ' ';\n  }\n\n  get eol(): string {\n    return '\\n';\n  }\n\n  indent(): StypTextFormatter$ {\n    return new StypTextFormatter$(this._config, this.pre + this._config.indent!);\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypStyleTextWriter implements StypWriter.Style {\n\n  private readonly nf: StypTextFormatter;\n  private body = '';\n\n  constructor(\n      private readonly f: StypTextFormatter,\n      readonly selector: string,\n  ) {\n    this.nf = f.indent();\n  }\n\n  get isGroup(): false {\n    return false;\n  }\n\n  set(name: string, value: string, priority: number): void {\n\n    const p = priority >= StypPriority.Important ? ' !important' : '';\n    const { pre, nv, eol } = this.nf;\n\n    if (this.body) {\n      this.body += `;${eol}`;\n    }\n\n    this.body += `${pre}${name}:${nv}${value}${p}`;\n  }\n\n  replace(css: string): void {\n    this.body = css.trim();\n    if (this.body.endsWith(';')) {\n      this.body = this.body.substr(0, this.body.length - 1);\n    }\n  }\n\n  toString(): string {\n\n    const { pre, nv, eol } = this.f;\n\n    if (this.body) {\n\n      const afterBody = eol ? `;${eol}` : '';\n\n      return `${pre}${this.selector}${nv}{${eol}${this.body}${afterBody}${pre}}`;\n    }\n\n    return '';\n  }\n\n}\n\n/**\n * @internal\n */\nabstract class AbstractStypGroupTextWriter implements StypWriter.Group {\n\n  readonly _nested: any[] = [];\n\n  protected constructor(readonly nf: StypTextFormatter) {\n  }\n\n  get isGroup(): true {\n    return true;\n  }\n\n  addGroup(name: string, params: string, index?: number): StypWriter.Group {\n    return this._add(new StypGroupTextWriter(this.nf, name, params), index);\n  }\n\n  addStyle(selector: string, index?: number): StypWriter.Style {\n    return this._add(new StypStyleTextWriter(this.nf, selector), index);\n  }\n\n  toString(): string {\n\n    let out = '';\n\n    for (const nested of this._nested) {\n\n      const text = String(nested);\n\n      if (text) {\n        if (out) {\n          out += this.nf.eol;\n        }\n        out += text;\n      }\n    }\n\n    return out;\n  }\n\n  protected _add<TNested>(nested: TNested, index = this._nested.length): TNested {\n    this._nested.splice(index, 0, nested);\n    return nested;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypGroupTextWriter extends AbstractStypGroupTextWriter implements StypWriter.Group {\n\n  constructor(readonly f: StypTextFormatter, readonly name: string, readonly params: string) {\n    super(f.indent());\n  }\n\n  toString(): string {\n\n    const body = super.toString();\n\n    if (!body) {\n      return '';\n    }\n\n    const { pre, nv, eol } = this.f;\n\n    return `${pre}${this.name} ${this.params}${nv}{${eol}${body}${eol}${pre}}`;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypSheetTextWriter extends AbstractStypGroupTextWriter implements StypWriter.Sheet {\n\n  constructor(\n      readonly id: string,\n      readonly f: StypTextFormatter,\n      readonly sender: EventEmitter<[StypSheetText]>,\n  ) {\n    super(f);\n  }\n\n  addGlobal(name: string, value: string, index?: number): void {\n    this._add(`${this.f.pre}${name} ${value};`, index);\n  }\n\n  clear(): void {\n    this._nested.length = 0;\n  }\n\n  remove(): void {\n    this.clear();\n    this.sender.send({ id: this.id });\n  }\n\n  done(): void {\n    this.sender.send({\n      id: this.id,\n      css: this.toString(),\n    });\n  }\n\n}\n\n/**\n * Builds textual CSS production format.\n *\n * It is necessary to register {@link StypTextFormat.onSheet CSS text receiver(s)} prior to start {@link produceStyle\n * style production} in order to receive CSS text for style sheets.\n *\n * @category Rendering\n * @param config - Textual format config.\n *\n * @returns Textual CSS production format.\n */\nexport function stypTextFormat(config: StypTextFormatConfig = {}): StypTextFormat {\n\n  const pretty: StypTextFormatConfig.PrettyPrint | false = config.pretty === true || config.pretty == null\n      ? defaultPrettyPrint\n      : (config.pretty || false);\n  const { scheduler = immediateRenderScheduler } = config;\n  const sender = new EventEmitter<[StypSheetText]>();\n  const formatter: StypTextFormatter = pretty ? new StypTextFormatter$(pretty) : compactStypTextFormatter;\n  let idSeq = 0;\n\n  return {\n    ...config,\n    pretty,\n    scheduler,\n    onSheet: sender.on,\n    addSheet() {\n      return new StypSheetTextWriter(String(++idSeq), formatter, sender);\n    },\n  };\n}\n","import { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { StypFormat } from '../format';\nimport { removeStyleElement, stypRenderScheduler } from './format.impl';\n/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { stypTextFormat, StypTextFormatConfig } from './text.format';\n\n/**\n * Configuration of {@link stypDomFormat DOM style production format}.\n *\n * @category Rendering\n */\nexport interface StypDomFormatConfig extends StypTextFormatConfig {\n\n  /**\n   * Document to add style elements to.\n   *\n   * `parent.ownerDocument` or `window.document` by default.\n   */\n  readonly document?: Document;\n\n  /**\n   * Parent DOM node to add stylesheets to.\n   *\n   * `document.head` by default.\n   *\n   * This node don't have to be attached to document.\n   */\n  readonly parent?: Node;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `newRenderSchedule` for {@link parent} node by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n}\n\n/**\n * Builds DOM style production format.\n *\n * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and fills it with CSS text\n * generated by {@link stypTextFormat textual CSS production format}.\n *\n * This format is generally slower than {@link stypObjectFormat CSS object model production format}, but allows to add\n * `<style>` elements to DOM node outside document. E.g. to `DocumentFragment`.\n *\n * @category Rendering\n * @param config - DOM style format configuration.\n *\n * @returns CSS production format.\n */\nexport function stypDomFormat(\n    config: StypDomFormatConfig = {},\n): StypFormat {\n\n  const {\n    document = config.parent?.ownerDocument || window.document,\n    parent = document.head,\n  } = config;\n  const textFormat = stypTextFormat(config);\n  const scheduler = stypRenderScheduler(parent, config.scheduler);\n  const schedule = scheduler();\n  const elements = new Map<string, HTMLStyleElement>();\n  const supply = textFormat.onSheet(({ id, css }) => {\n    // CSS text is reported within schedule. No need to re-schedule DOM manipulations here.\n\n    let element = elements.get(id);\n\n    if (css == null) { // element exists here\n      elements.delete(id);\n      removeStyleElement(element!);\n    } else if (element) {\n      element.textContent = css;\n    } else {\n      element = document.createElement('style');\n      element.setAttribute('type', 'text/css');\n      element.textContent = css;\n      parent.appendChild(element);\n      elements.set(id, element);\n      supply.whenOff(\n          // Schedule element removal on style sheet removal instead of removing it right away.\n          () => schedule(() => removeStyleElement(element!)),\n      );\n    }\n  });\n\n  return {\n    ...config,\n    scheduler,\n    addSheet(producer) {\n      supply.needs(producer);\n      this.addSheet = textFormat.addSheet.bind(textFormat);\n      return this.addSheet(producer);\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { StypPriority } from '../../value';\nimport { StypFormat, StypFormatConfig } from '../format';\nimport { StypWriter } from '../writer';\nimport { removeStyleElement, stypRenderScheduler } from './format.impl';\n\n/**\n * @internal\n */\nclass StypStyleObjectWriter implements StypWriter.Style {\n\n  constructor(private readonly _target: CSSStyleRule) {\n  }\n\n  get isGroup(): false {\n    return false;\n  }\n\n  set(name: string, value: string, priority: number): void {\n    this._target.style.setProperty(name, value, priority >= StypPriority.Important ? 'important' : undefined);\n  }\n\n  replace(css: string): void {\n    this._target.style.cssText = css;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypGroupObjectWriter implements StypWriter.Group {\n\n  constructor(readonly _target: CSSStyleSheet | CSSGroupingRule) {\n  }\n\n  get isGroup(): true {\n    return true;\n  }\n\n  addGroup(name: string, params: string, index?: number): StypWriter.Group {\n    return new StypGroupObjectWriter(\n        this._add(\n            `${name} ${params}{}`,\n            index,\n        ) as CSSGroupingRule,\n    );\n  }\n\n  addStyle(selector: string, index?: number): StypWriter.Style {\n    return new StypStyleObjectWriter(this._add(`${selector}{}`, index) as CSSStyleRule);\n  }\n\n  protected _add(\n      ruleText: string,\n      index = this._target.cssRules.length,\n  ): CSSRule {\n\n    const idx = this._target.insertRule(ruleText, index);\n\n    return this._target.cssRules[idx];\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypSheetObjectWriter extends StypGroupObjectWriter implements StypWriter.Sheet {\n\n  constructor(private readonly _element: HTMLStyleElement) {\n    super(_element.sheet as CSSStyleSheet);\n  }\n\n  addGlobal(name: string, value: string, index?: number): void {\n    this._add(`${name} ${value};`, index);\n  }\n\n  clear(): void {\n\n    const { cssRules } = this._target;\n\n    while (cssRules.length) {\n      this._target.deleteRule(cssRules.length - 1);\n    }\n  }\n\n  remove(): void {\n    removeStyleElement(this._element);\n  }\n\n  done(): void {\n    /* do nothing */\n  }\n\n}\n\n/**\n * Configuration of {@link stypObjectFormat CSS object model production format}.\n *\n * @category Rendering\n */\nexport interface StypObjectFormatConfig extends StypFormatConfig {\n\n  /**\n   * Parent DOM node to add stylesheets to.\n   *\n   * `document.head` by default.\n   *\n   * This node has to be attached to document.\n   */\n  readonly parent?: Node;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `newRenderSchedule` for {@link parent} node by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n}\n\n/**\n * Builds CSS object model production format.\n *\n * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and builds its style sheet\n * with CSS object model methods.\n *\n * @category Rendering\n * @param config - Object format configuration.\n *\n * @returns CSS production format.\n */\nexport function stypObjectFormat(\n    config: StypObjectFormatConfig = {},\n): StypFormat {\n\n  const { parent = document.head } = config;\n\n  return {\n    ...config,\n    scheduler: stypRenderScheduler(parent, config.scheduler),\n    addSheet() {\n\n      const element = document.createElement('style');\n\n      element.setAttribute('type', 'text/css');\n      element.append(document.createTextNode(''));\n\n      parent.appendChild(element);\n\n      return new StypSheetObjectWriter(element);\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { NamespaceDef, newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { newRenderSchedule } from '@frontmeans/render-scheduler';\nimport { AfterEvent, afterSupplied, onSupplied } from '@proc7ts/fun-events';\nimport { noop, Supply } from '@proc7ts/primitives';\nimport { itsReduction, mapIt } from '@proc7ts/push-iterator';\nimport { StypProperties, StypRule, StypRules } from '../rule';\nimport { StypSelector, stypSelector, StypSelectorFormat, stypSelectorText } from '../selector';\nimport { isCombinator } from '../selector/selector.impl';\nimport { StypFormat } from './format';\nimport { stypRenderFactories } from './formats/format.impl';\nimport { StypRenderer } from './renderer';\nimport { StyleProducer } from './style-producer';\nimport { StypWriter } from './writer';\n\n/**\n * Produces and dynamically updates basic CSS stylesheets based on the given CSS rules.\n *\n * Unlike {@link produceStyle}, this function does not enable renderers but the basic one which just renders CSS\n * properties. This can be used to save the bundle size by enabling only select renderers.\n *\n * @category Rendering\n * @param rules - CSS rules to produce stylesheets for. This can be e.g. a {@link StypRule.rules} to render all rules,\n * or a result of {@link StypRuleList.grab} method call to render only matching ones.\n * @param format - Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceBasicStyle(rules: StypRules, format: StypFormat): Supply {\n\n  const {\n    rootSelector = { e: 'body' },\n    scheduler = newRenderSchedule,\n    nsAlias = newNamespaceAliaser(),\n  } = format;\n  const supply = new Supply();\n  const selectorFormat: StypSelectorFormat = { nsAlias };\n  const factories = stypRenderFactories(format);\n  const renderSupply = renderRules(rules);\n  const trackSupply = trackRules();\n\n  return supply.needs(renderSupply)\n      .needs(trackSupply)\n      .cuts(renderSupply)\n      .cuts(trackSupply);\n\n  function styleProducer(\n      rule: StypRule,\n      renderer: StypRenderer.Function,\n      production: {\n        sheet: StypWriter.Sheet;\n        writer: StypWriter;\n        selector: StypSelector.Normalized;\n      },\n  ): StyleProducer {\n\n    class StyleProducer$ implements StyleProducer {\n\n      get supply(): Supply {\n        return supply;\n      }\n\n      get rule(): StypRule {\n        return rule;\n      }\n\n      get sheet(): StypWriter.Sheet {\n        return production.sheet;\n      }\n\n      get writer(): StypWriter {\n        return production.writer;\n      }\n\n      get selector(): StypSelector.Normalized {\n        return production.selector;\n      }\n\n      nsAlias(ns: NamespaceDef): string {\n        return nsAlias(ns);\n      }\n\n      render(properties: StypProperties, options?: StypRenderer.Options): void {\n        if (!options) {\n          renderer(this, properties);\n        } else {\n          renderer(\n              styleProducer(\n                  rule,\n                  renderer,\n                  {\n                    sheet: production.sheet,\n                    writer: options.writer || production.writer,\n                    selector: options.selector || production.selector,\n                  },\n              ),\n              properties,\n          );\n        }\n      }\n\n      addStyle(_selector: StypSelector.Normalized = production.selector): StypWriter.Style {\n\n        const { writer } = production;\n\n        if (!writer.isGroup) {\n          return writer;\n        }\n\n        return writer.addStyle(selectorText(_selector));\n      }\n\n    }\n\n    return new StyleProducer$();\n  }\n\n  function selectorText(selector: StypSelector.Normalized): string {\n    return stypSelectorText(selector, selectorFormat);\n  }\n\n  function renderRules(rulesToRender: Iterable<StypRule>): Supply {\n    return itsReduction<Supply, Supply>(\n        mapIt(rulesToRender, renderRule),\n        (prev, supply) => new Supply().cuts(supply).cuts(prev),\n        new Supply(),\n    );\n  }\n\n  function trackRules(): Supply {\n\n    const supply = new Supply();\n\n    return onSupplied(rules)({\n      supply,\n      receive: (_ctx, added) => {\n        added.forEach(r => renderRule(r).needs(supply));\n      },\n    });\n  }\n\n  function renderRule(rule: StypRule): Supply {\n\n    const [reader, renderer] = rendererForRule(rule);\n    let sheet: StypWriter.Sheet | undefined;\n    const selector = ruleSelector(rule);\n    const schedule = scheduler();\n\n    return reader(renderProperties).whenOff(removeStyle);\n\n    function renderProperties(properties: StypProperties): void {\n      schedule(() => {\n        sheet?.clear();\n\n        const producer = styleProducer(\n            rule,\n            renderer,\n            {\n              get sheet(): StypWriter.Sheet {\n                if (!sheet) {\n                  sheet = format.addSheet(producer);\n                }\n                return sheet;\n              },\n              get writer(): StypWriter.Sheet {\n                return this.sheet;\n              },\n              selector,\n            },\n        );\n\n        producer.render(properties);\n        sheet?.done();\n      });\n    }\n\n    function removeStyle(): void {\n      schedule(() => {\n\n        const lastSheet = sheet;\n\n        if (lastSheet) {\n          sheet = undefined;\n          return lastSheet.remove();\n        }\n        // Otherwise element is removed before anything rendered.\n        // Should never happen for properly constructed rule.\n      });\n    }\n  }\n\n  function ruleSelector(rule: StypRule): StypSelector.Normalized {\n\n    const selector = rule.selector;\n\n    if (!selector.length) {\n      // Use configured root selector\n      return stypSelector(rootSelector);\n    }\n    if (isCombinator(selector[0])) {\n      // First combinator is relative to root selector\n      return [...stypSelector(rootSelector), ...selector];\n    }\n\n    return selector;\n  }\n\n  function rendererForRule(rule: StypRule): [AfterEvent<[StypProperties]>, StypRenderer.Function] {\n\n    const specs = factories.map(factory => factory.create(rule));\n    const reader = specs.reduce(\n        (read, spec) => spec.read ? afterSupplied(spec.read(read)) : read,\n        rule.read,\n    );\n\n    return [reader, renderAt(0)];\n\n    function renderAt(index: number): StypRenderer.Function {\n      return (producer, properties) => {\n\n        const nextIndex = index + 1;\n        let nextRenderer: StypRenderer.Function;\n\n        if (nextIndex === factories.length) {\n          nextRenderer = noop;\n        } else {\n          nextRenderer = renderAt(nextIndex);\n        }\n\n        const nextProducer = styleProducer(producer.rule, nextRenderer, producer);\n\n        specs[index].render(nextProducer, properties);\n      };\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { stypSelector } from './selector-constructor';\nimport { formatStypSelector } from './selector-text.impl';\n\n/**\n * Structured CSS selector textual format.\n *\n * @category CSS Rule\n */\nexport interface StypSelectorFormat {\n\n  /**\n   * Qualifier formatting function. When present, it is called for each qualifier to build its\n   * textual representation. When unspecified, the qualifiers won't be attached to resulting CSS selector text.\n   *\n   * @param qualifier - Qualifier to format.\n   *\n   * @returns Textual representation of `qualifier`.\n   */\n  qualify?: (qualifier: string) => string;\n\n  /**\n   * Namespace aliaser to use.\n   *\n   * New instance will be created if not specified.\n   */\n  nsAlias?: NamespaceAliaser;\n\n}\n\n/**\n * Converts structured CSS selector to its textual representation.\n *\n * @category CSS Rule\n * @param selector - Target CSS selector.\n * @param format - CSS selector format.\n *\n * @returns CSS selector string.\n */\nexport function stypSelectorText(selector: StypSelector | StypPureSelector, format?: StypSelectorFormat): string {\n  return formatStypSelector(stypSelector(selector), format);\n}\n","import { isReadonlyArray } from '../../internal';\nimport { StypRenderer } from '../renderer';\nimport { stypRenderAtRules } from './at-rules.renderer';\nimport { stypRenderGlobals } from './globals.renderer';\nimport { stypRenderText } from './text.renderer';\nimport { stypRenderXmlNs } from './xml-ns.renderer';\n\n/**\n * @internal\n */\nexport function defaultStypRenderers(\n    renderer: StypRenderer | readonly StypRenderer[] | undefined,\n): readonly StypRenderer[] {\n\n  const result: StypRenderer[] = [\n    stypRenderAtRules,\n    stypRenderXmlNs,\n    stypRenderGlobals,\n    stypRenderText,\n  ];\n\n  if (renderer) {\n    if (isReadonlyArray(renderer)) {\n      result.push(...renderer);\n    } else {\n      result.push(renderer);\n    }\n  }\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { Supply } from '@proc7ts/primitives';\nimport { StypRules } from '../rule';\nimport { StypFormat } from './format';\nimport { produceBasicStyle } from './produce-basic-style';\nimport { defaultStypRenderers } from './renderers/default-renderers.impl';\n\n/**\n * Produces and dynamically updates CSS stylesheets based on the given CSS rules.\n *\n * Appends `<style>` element(s) to the given parent DOM node (`document.head` by default) and updates them when CSS\n * rules change.\n *\n * This function enables all default renderers. E.g. the one supporting raw CSS text rules. If some of them are not\n * needed a {@link produceBasicStyle} variant of this function may be used instead.\n *\n * @category Rendering\n * @param rules - CSS rules to produce stylesheets for. This can be e.g. a {@link StypRule.rules} to render all rules,\n * or a result of {@link StypRuleList.grab} method call to render only matching ones.\n * @param format - Production format.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceStyle(rules: StypRules, format: StypFormat): Supply {\n  return produceBasicStyle(rules, { ...format, renderer: defaultStypRenderers(format.renderer) });\n}\n\n\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, OnEvent, OnEvent__symbol } from '@proc7ts/fun-events';\nimport { StypQuery, StypRuleKey, StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { StypRules } from './rules';\n\n/**\n * CSS rule.\n *\n * Represents CSS selector and corresponding CSS properties.\n *\n * @category CSS Rule\n */\nexport abstract class StypRule implements EventKeeper<[StypProperties]> {\n\n  /**\n   * A reference to the root CSS rule.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * A reference to outer CSS rule.\n   *\n   * The outer rule is the one for enclosing element.\n   * I.e. for the rule with selector is `a b+c` the parent one is `a b`, while the outer one is `a`.\n   *\n   * This is `null` for the root rule and may be `null` for the rule removed from hierarchy.\n   */\n  abstract readonly outer: StypRule | null;\n\n  /**\n   * CSS selector of this rule.\n   */\n  abstract readonly selector: StypSelector.Normalized;\n\n  /**\n   * A key of this rule in the enclosing one.\n   */\n  abstract readonly key: StypRuleKey;\n\n  /**\n   * Whether this rule's properties are empty.\n   *\n   * This is `true` when the rule properties are constant and empty.\n   *\n   * Empty CSS rules returned from `rule()` method when there is no matching rule found.\n   */\n  abstract readonly empty: boolean;\n\n  /**\n   * Dynamic list of all CSS rules in hierarchy starting from this one.\n   */\n  abstract readonly rules: StypRuleHierarchy;\n\n  /**\n   * An `AfterEvent` keeper of CSS properties of this rule.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[StypProperties]>;\n\n  [AfterEvent__symbol](): AfterEvent<[StypProperties]> {\n    return this.read;\n  }\n\n  /**\n   * Sets CSS properties of this rule.\n   *\n   * @param properties - CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: StypProperties.Spec): this;\n\n  /**\n   * Appends CSS properties to this rule.\n   *\n   * @param properties - CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  add(properties: StypProperties.Spec): this {\n    return this.rules.add([], properties) as this;\n  }\n\n  /**\n   * Clears CSS properties of this rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n  /**\n   * Removes this rule from hierarchy along with all nested rules.\n   *\n   * @param reason - Optional removal reason.\n   *\n   * @returns `this` (just removed) rule instance.\n   */\n  abstract remove(reason?: any): this;\n\n}\n\n/**\n * Dynamically updated list of CSS rules.\n *\n * This is an iterable of rules, an EventSender` of their updates, and an `EventKeeper` of itself.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleList implements StypRules, EventKeeper<[StypRuleList]> {\n\n  /**\n   * An `AfterEvent` keeper of rule list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[StypRuleList]>;\n\n  /**\n   * An `OnEvent` sender of this rule list updates.\n   *\n   * The list updates receiver accepts two arguments:\n   * - An array of added rules\n   * - An array of removed rules.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of rule list updates.\n   */\n  abstract readonly onUpdate: OnEvent<[StypRule[], StypRule[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[StypRuleList]> {\n    return this.read;\n  }\n\n  [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n    return this.onUpdate;\n  }\n\n  abstract [Symbol.iterator](): IterableIterator<StypRule>;\n\n  /**\n   * Grabs rules from this list matching the given `query`.\n   *\n   * @param query - CSS rule query to match.\n   *\n   * @returns Dynamic list of rules in this list matching the given query.\n   */\n  abstract grab(query: StypQuery): StypRuleList;\n\n}\n\n/**\n * Dynamic list of all CSS rules in hierarchy starting from its root.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleHierarchy extends StypRuleList {\n\n  /**\n   * Dynamic list containing only root CSS rule.\n   *\n   * This list never changes actually.\n   */\n  abstract readonly self: StypRuleList;\n\n  /**\n   * Dynamic list of all CSS rules directly nested within the root one.\n   */\n  abstract readonly nested: StypRuleList;\n\n  /**\n   * Appends CSS properties to nested rule.\n   *\n   * Creates target rule if necessary.\n   *\n   * @param selector - Target rule selector.\n   * @param properties - Optional CSS properties specifier.\n   *\n   * @returns Modified CSS rule.\n   */\n  abstract add(selector: StypSelector, properties?: StypProperties.Spec): StypRule;\n\n  /**\n   * Returns nested CSS rule matching the given `selector`.\n   *\n   * @param selector - Target rule selector.\n   *\n   * @returns Either matching CSS rule, or `undefined` if not found.\n   */\n  abstract get(selector: StypSelector): StypRule | undefined;\n\n  /**\n   * Watches for CSS rule properties.\n   *\n   * The properties are empty when the watched rule does not exist.\n   *\n   * @param selector - CSS selector of watched rule.\n   *\n   * @returns An `AfterEvent` registrar of CSS properties receiver.\n   */\n  abstract watch(selector: StypSelector): AfterEvent<[StypProperties]>;\n\n}\n","import { AfterEvent, mapAfter, OnEvent, onEventBy, onSupplied, shareOn } from '@proc7ts/fun-events';\nimport { asis, valueProvider } from '@proc7ts/primitives';\nimport { filterIt, itsIterator } from '@proc7ts/push-iterator';\nimport { stypQuery, StypQuery, stypSelectorMatches } from '../selector';\nimport { StypRule, StypRuleList } from './rule';\nimport { StypRules } from './rules';\n\n/**\n * @internal\n */\nexport class Rules extends StypRuleList {\n\n  readonly read: AfterEvent<[StypRuleList]>;\n  readonly onUpdate: OnEvent<[StypRule[], StypRule[]]>;\n  private readonly _buildList: () => Iterable<StypRule>;\n  // noinspection JSMismatchedCollectionQueryUpdate\n  private _ruleSet?: Set<StypRule>; // `undefined` updates are not tracked\n\n  constructor(private readonly _list: StypRules, ruleMatches?: (rule: StypRule) => boolean) {\n    super();\n\n    let filterArray: (rules: StypRule[]) => StypRule[];\n\n    if (ruleMatches) {\n      this._buildList = () => filterIt(_list, ruleMatches);\n      filterArray = rules => rules.filter(ruleMatches);\n    } else {\n      this._buildList = valueProvider(_list);\n      filterArray = asis;\n    }\n\n    this.onUpdate = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n      const rules = this._ruleSet || (this._ruleSet = new Set(this._buildList()));\n\n      onSupplied(this._list)({\n        supply: receiver.supply.whenOff(() => this._ruleSet = undefined),\n        receive: (context, added, removed) => {\n          added = filterArray(added);\n          removed = filterArray(removed);\n          if (removed.length || added.length) {\n            removed.forEach(rule => rules.delete(rule));\n            added.forEach(rule => rules.add(rule));\n            receiver.receive(context, added, removed);\n          }\n        },\n      });\n    }).do(shareOn);\n\n    const returnSelf = valueProvider(this);\n\n    this.read = this.onUpdate.do(mapAfter(returnSelf, returnSelf));\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    if (this._ruleSet) {\n      // List changes are tracked.\n      return this._ruleSet.values();\n    }\n    // List changes are not currently tracked.\n    // Request the rules explicitly.\n    return itsIterator(this._buildList());\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function grabRules(list: StypRuleList, query: StypQuery): StypRuleList {\n\n  const q = stypQuery(query);\n\n  return new Rules(list, rule => stypSelectorMatches(rule.selector, q));\n}\n","import {\n  AfterEvent,\n  afterEventBy,\n  consumeEvents,\n  digAfter,\n  EventEmitter,\n  mapAfter,\n  OnEvent,\n  OnEvent__symbol,\n  shareAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { lazyValue, valueProvider } from '@proc7ts/primitives';\nimport {\n  flatMapIt,\n  itsElements,\n  itsIterator,\n  overElementsOf,\n  overOne,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { StypQuery, StypRuleKey, stypSelector, StypSelector } from '../selector';\nimport { stypRuleKeyText } from '../selector/selector-text.impl';\nimport { stypOuterSelector, stypRuleKeyAndTail } from '../selector/selector.impl';\nimport { StypProperties } from './properties';\nimport { mergeStypProperties, noStypPropertiesSpec, stypPropertiesBySpec } from './properties.impl';\nimport { StypRule, StypRuleHierarchy, StypRuleList } from './rule';\nimport { StypRules } from './rules';\nimport { grabRules, Rules } from './rules.impl';\n\nclass AllRules extends StypRuleHierarchy implements PushIterable<StypRule$> {\n\n  readonly self: StypRuleList;\n  readonly read: AfterEvent<[AllRules]>;\n  private readonly _updates = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  private readonly _it: () => PushIterable<StypRule$>;\n\n  constructor(private readonly _root: StypRule$, readonly nested: NestedRules) {\n    super();\n    this.self = selfRuleList(_root, this);\n    this._it = lazyValue(() => iterateAllRules(_root));\n\n    const returnSelf = valueProvider(this);\n\n    this.read = this._updates.on.do(mapAfter(returnSelf, returnSelf));\n  }\n\n  get onUpdate(): OnEvent<[StypRule$[], StypRule$[]]> {\n    return this._updates.on;\n  }\n\n  [Symbol.iterator](): PushIterator<StypRule$> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<StypRule$>): PushIterator<StypRule$> {\n    return this._it()[PushIterator__symbol](accept);\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  add(selector: StypSelector, properties?: StypProperties.Spec): StypRule$ {\n    return extendRule(this._root, stypSelector(selector), properties, true);\n  }\n\n  get(selector: StypSelector): StypRule$ | undefined {\n    return this._get(stypSelector(selector));\n  }\n\n  private _get(selector: StypSelector.Normalized): StypRule$ | undefined {\n\n    const [key, tail] = stypRuleKeyAndTail(selector);\n\n    if (!tail) {\n      return this._root;\n    }\n\n    const found = this.nested._rule(stypRuleKeyText(key));\n\n    if (!found) {\n      return;\n    }\n\n    return found.rules.get(tail);\n  }\n\n  watch(selector: StypSelector): AfterEvent<[StypProperties]> {\n\n    const request = stypSelector(selector);\n\n    return afterEventBy<[StypProperties]>(receiver => {\n\n      const tracker = trackValue<StypProperties>({});\n      const propertiesSupply = this.read.do(consumeEvents(() => {\n\n        const found = this._get(request);\n\n        return found && found\n            .read(properties => tracker.it = properties)\n            .whenOff(() => tracker.it = {});\n      }));\n\n      return tracker.read(receiver).cuts(propertiesSupply);\n    }).do(shareAfter);\n  }\n\n  _add(rule: StypRule$, sendUpdate: boolean): void {\n    rule.rules.onUpdate((added, removed) => this._updates.send(added, removed));\n    if (sendUpdate) {\n      this._updates.send(itsElements(rule.rules), []);\n    }\n  }\n\n  _remove(reason?: any): void {\n\n    const removed = itsElements(this);\n\n    this._updates.send([], removed);\n    removed.forEach(rule => {\n      rule.rules._updates.supply.off(reason);\n      rule._spec.supply.off(reason);\n    });\n  }\n\n}\n\nfunction selfRuleList(rule: StypRule$, all: AllRules): StypRuleList {\n\n  const onUpdate = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  const rules = [rule];\n\n  all.onUpdate((_added, removed) => {\n    if (removed[0] === rule) {\n      rules.length = 0;\n      onUpdate.send([], [rule]);\n    }\n  }).cuts(onUpdate);\n\n  class Self implements StypRules {\n\n    [OnEvent__symbol](): OnEvent<[StypRule$[], StypRule$[]]> {\n      return onUpdate.on;\n    }\n\n    [Symbol.iterator](): IterableIterator<StypRule$> {\n      return itsIterator(rules);\n    }\n\n  }\n\n  return new Rules(new Self());\n}\n\nfunction iterateAllRules(rule: StypRule$): PushIterable<StypRule$> {\n  return overElementsOf(\n      overOne(rule),\n      flatMapIt(\n          rule.rules.nested,\n          nested => iterateAllRules(nested),\n      ),\n  );\n}\n\nclass NestedRules extends StypRuleList {\n\n  readonly read: AfterEvent<[NestedRules]>;\n  readonly _all: AllRules;\n  private readonly _updates = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  private readonly _byKey = new Map<string, StypRule$>();\n\n  constructor(root: StypRule$) {\n    super();\n    this._all = new AllRules(root, this);\n\n    const returnSelf = valueProvider(this);\n\n    this.read = this._updates.on.do(mapAfter(returnSelf, returnSelf));\n  }\n\n  get onUpdate(): OnEvent<[StypRule[], StypRule[]]> {\n    return this._updates.on;\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule$> {\n    return this._byKey.values();\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  _rule(key: string): StypRule$ | undefined {\n    return this._byKey.get(key);\n  }\n\n  _add(key: string, rule: StypRule$, sendUpdate: boolean): void {\n    this._byKey.set(key, rule);\n    rule.rules.onUpdate((_added, removed) => {\n      if (removed[0] === rule) {\n        this._byKey.delete(key);\n        this._updates.send([], [rule]);\n      }\n    });\n    if (sendUpdate) {\n      this._updates.send([rule], []);\n    }\n    this._all._add(rule, sendUpdate);\n  }\n\n}\n\n/**\n * @internal\n */\nexport class StypRule$ extends StypRule {\n\n  readonly read: AfterEvent<[StypProperties]>;\n  private readonly _root: StypRule$;\n  private _outer?: StypRule$ | null;\n  private readonly _selector: StypSelector.Normalized;\n  private readonly _key: StypRuleKey;\n  readonly _spec: ValueTracker<StypProperties.Builder>;\n  private readonly _nested: NestedRules;\n\n  get root(): StypRule$ {\n    return this._root;\n  }\n\n  get outer(): StypRule$ | null {\n    if (this._outer !== undefined) {\n      return this._outer;\n    }\n\n    const outerSelector = stypOuterSelector(this.selector);\n\n    return this._outer = outerSelector && this.root.rules.get(outerSelector) || null;\n  }\n\n  get selector(): StypSelector.Normalized {\n    return this._selector;\n  }\n\n  get key(): StypRuleKey {\n    return this._key;\n  }\n\n  get empty(): boolean {\n    return this._spec.it === noStypPropertiesSpec;\n  }\n\n  get rules(): AllRules {\n    return this._nested._all;\n  }\n\n  constructor(\n      root: StypRule$ | undefined,\n      selector: StypSelector.Normalized,\n      key: StypRuleKey,\n      spec: StypProperties.Builder = noStypPropertiesSpec,\n  ) {\n    super();\n    this._root = root || this;\n    this._selector = selector;\n    this._key = key;\n    this._spec = trackValue(spec);\n    this.read = this._spec.read.do(digAfter(builder => builder(this)));\n    this._nested = new NestedRules(this);\n  }\n\n  set(properties?: StypProperties.Spec): this {\n    this._spec.it = properties ? r => stypPropertiesBySpec(r, properties) : noStypPropertiesSpec;\n    return this;\n  }\n\n  remove(reason?: any): this {\n    this.rules._remove(reason);\n    return this;\n  }\n\n}\n\nfunction extendRule(\n    rule: StypRule$,\n    targetSelector: StypSelector.Normalized,\n    properties: StypProperties.Spec | undefined,\n    sendUpdate: boolean,\n): StypRule$ {\n\n  const [key, tail] = stypRuleKeyAndTail(targetSelector);\n\n  if (!tail) {\n    // Target rule\n    rule._spec.it = extendSpec(rule, properties);\n    return rule;\n  }\n\n  const keyText = stypRuleKeyText(key);\n  const found = rule.rules.nested._rule(keyText);\n\n  if (found) {\n    return extendRule(found, tail, properties, sendUpdate);\n  }\n\n  const newNested = new StypRule$(rule.root, [...rule.selector, ...key], key);\n  const result = extendRule(newNested, tail, properties, false); // Send only a top-level update\n\n  rule.rules.nested._add(keyText, newNested, sendUpdate);\n\n  return result;\n}\n\nfunction extendSpec(rule: StypRule$, properties: StypProperties.Spec | undefined): StypProperties.Builder {\n\n  const oldSpec = rule._spec.it;\n\n  if (!properties) {\n    return oldSpec;\n  }\n\n  if (rule.empty) {\n    return r => stypPropertiesBySpec(r, properties);\n  }\n\n  return r => mergeStypProperties(oldSpec(r), stypPropertiesBySpec(r, properties));\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { stypPropertiesBySpec } from './properties.impl';\nimport { StypRule } from './rule';\nimport { StypRule$ } from './rule.impl';\n\n/**\n * @internal\n */\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * Constructs root CSS rule representing global CSS declarations.\n *\n * All other rules are nested within single root.\n *\n * The root CSS rule selector is empty.\n *\n * @category CSS Rule\n * @param properties - Initial CSS rule properties specifier.\n *\n * @returns New root CSS rule.\n */\nexport function stypRoot(properties?: StypProperties.Spec): StypRule {\n  return new StypRule$(undefined, rootSelector, [], properties ? r => stypPropertiesBySpec(r, properties) : undefined);\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  mapAfter,\n} from '@proc7ts/fun-events';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { StypSelector } from '../selector';\nimport { StypMapper } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * A type safe reference to CSS rule.\n *\n * Allows to access an modify CSS properties of the rule in a type safe manner.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties structure of referenced rule.\n */\nexport abstract class StypRuleRef<T extends StypProperties<T>> implements EventKeeper<[T]> {\n\n  /**\n   * An `AfterEvent` keeper of CSS properties.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[T]>;\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * Sets CSS properties of the referenced rule.\n   *\n   * @param properties - CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Appends CSS properties to the references CSS rule.\n   *\n   * @param properties - CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract add(properties: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Clears CSS properties of the referenced rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n}\n\n/**\n * CSS rule referrer.\n *\n * This is a function that obtains CSS rule reference relative to the given root.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties interface of referenced rule.\n */\nexport type RefStypRule<T extends StypProperties<T>> =\n/**\n * @param root - Root CSS rule the constructed reference will be relative to.\n *\n * @returns CSS rule reference.\n */\n    (this: void, root: StypRule) => StypRuleRef<T>;\n\n\n/**\n * @internal\n */\nclass StypRuleRef$<T extends StypProperties<T>> extends StypRuleRef<T> {\n\n  readonly read: AfterEvent<[T]>;\n\n  constructor(\n      private readonly _root: StypRule,\n      private readonly _selector: StypSelector,\n      private readonly _map: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>,\n  ) {\n    super();\n    this.read = afterAll({\n      ms: this._map(this._root),\n      ps: this._root.rules.watch(this._selector),\n    }).do(mapAfter(\n        ({\n          ms: [_mappings],\n          ps: [_properties],\n        }) => StypMapper.map<T>(_mappings, _properties),\n    ));\n  }\n\n  add(properties: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n    this._root.rules.add(this._selector, properties);\n    return this;\n  }\n\n  set(properties?: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n    this._root.rules.add(this._selector).set(properties);\n    return this;\n  }\n\n}\n\n/**\n * @category CSS Rule\n */\nexport const RefStypRule = {\n\n  /**\n   * Constructs a CSS rule referrer that maps original CSS properties accordingly to the given `mappings`.\n   *\n   * @typeparam T  CSS properties structure of referenced rule.\n   * @param selector - CSS selector of target rule.\n   * @param mappings - Either a mappings of CSS properties, an event keeper sending such mappings, or a function\n   * returning one of them and accepting a root CSS rule as its only argument.\n   * The constructed reference will be relative to as its only parameter.\n   *\n   * @returns New CSS rule key instance.\n   */\n  by<T extends StypProperties<T>>(\n      selector: StypSelector,\n      mappings:\n          | StypMapper.Mappings<T>\n          | EventKeeper<[StypMapper.Mappings<T>]>\n          | ((this: void, root: StypRule) => StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>),\n  ): RefStypRule<T> {\n\n    let map: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>;\n\n    if (typeof mappings === 'function') {\n      map = root => mappingsKeeper(mappings(root));\n    } else {\n      map = valueProvider(mappingsKeeper(mappings));\n    }\n\n    return root => new StypRuleRef$(root, selector, map);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction mappingsKeeper<T extends StypProperties<T>>(\n    mappings: StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>,\n): EventKeeper<[StypMapper.Mappings<T>]> {\n  return isEventKeeper(mappings) ? mappings : afterThe(mappings);\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport { afterAll, AfterEvent, AfterEvent__symbol, EventKeeper, mapAfter } from '@proc7ts/fun-events';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\nimport { RefStypRule, StypRuleRef } from './rule-ref';\n\n/**\n * Named CSS rule references complying to the CSS properties structure.\n *\n * Implements an event keeper interface by sending named CSS properties structures for each CSS rule reference.\n *\n * @category CSS Rule\n * @typeParam TRefMap - A type of target map of named CSS properties structures.\n */\nexport class StypRuleRefs<TRefMap extends StypRuleRefs.Struct<TRefMap>> implements EventKeeper<[TRefMap]> {\n\n  /**\n   * Constructs named CSS rules by resolving CSS rule referrers.\n   *\n   * @typeParam TRefMap - A type of target map of named CSS properties structures.\n   * @param referrers - Named CSS rule referrers to resolve.\n   * @param root - A root CSS rule the references will be relative to.\n   *\n   * @returns New names CSS rules instance.\n   */\n  static by<TRefMap extends StypRuleRefs.Struct<TRefMap>>(\n      referrers: { readonly [K in keyof TRefMap]: RefStypRule<TRefMap[K]> },\n      root: StypRule,\n  ): StypRuleRefs<TRefMap>;\n\n  static by<TRefMap extends StypRuleRefs.Struct<TRefMap>>(\n      referrers: { readonly [name: string]: RefStypRule<any> },\n      root: StypRule,\n  ): StypRuleRefs<TRefMap> {\n\n    const refs: { [K in keyof TRefMap]?: StypRuleRef<any> } = {};\n\n    for (const key of Object.keys(referrers)) {\n      refs[key as keyof TRefMap] = referrers[key](root);\n    }\n\n    return new StypRuleRefs<TRefMap>(refs as { [K in keyof TRefMap]: StypRuleRef<TRefMap[K]> });\n  }\n\n  /**\n   * CSS rule references by name.\n   *\n   * Each property in this map is a CSS rule reference corresponding to the same named property in properties structure.\n   * I.e. it has the same name and the same properties structure of referenced rule.\n   */\n  readonly refs: { readonly [K in keyof TRefMap]: StypRuleRef<TRefMap[K]> };\n\n  /**\n   * An `AfterEvent` keeper of named CSS properties structures for each CSS rule reference.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  readonly read: AfterEvent<[TRefMap]>;\n\n  /**\n   * Constructs named CSS rules.\n   *\n   * @param refs - A map of named CSS rule references.\n   */\n  constructor(refs: { readonly [K in keyof TRefMap]: StypRuleRef<TRefMap[K]> }) {\n    this.refs = refs;\n\n    const fromAll: AfterEvent<[{ [K in keyof TRefMap]: [StypProperties<any>] }]> = afterAll(this.refs);\n\n    this.read = fromAll.do(mapAfter(flattenProperties)) as AfterEvent<[TRefMap]>;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[TRefMap]> {\n    return this.read;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction flattenProperties<TRefMap extends StypRuleRefs.Struct<TRefMap>>(\n    propertiesMap: { readonly [name: string]: [StypProperties<any>] },\n): TRefMap {\n\n  const result: { [name: string]: StypProperties<any> } = {};\n\n  for (const name of Object.keys(propertiesMap)) {\n    result[name] = propertiesMap[name][0];\n  }\n\n  return result as TRefMap;\n}\n\nexport namespace StypRuleRefs {\n\n  /**\n   * A map of named CSS properties structures.\n   *\n   * Each property in this map corresponds to CSS rule reference with the same CSS properties structure.\n   *\n   * @typeParam TRefMap - A type of target map of named CSS properties structures.\n   */\n  export type Struct<TRefMap = { readonly [name: string]: StypProperties<any> }> = {\n    readonly [K in keyof TRefMap]: StypProperties<any>;\n  };\n\n  /**\n   * A map of named CSS rule referrers.\n   *\n   * These referrers then resolved to the same named CSS rule references.\n   *\n   * @typeParam TRefMap - A type of target map of named CSS properties structures.\n   */\n  export type Referrers<TRefMap extends Struct<TRefMap>> = {\n    readonly [K in keyof TRefMap]: RefStypRule<TRefMap[K]>;\n  };\n\n}\n","/**\n * @packageDocumentation\n * @module @frontmeans/style-producer\n */\nimport {\n  EventNotifier,\n  EventReceiver,\n  EventSender,\n  isEventSender,\n  OnEvent,\n  OnEvent__symbol,\n  onEventBy,\n  onNever,\n  onSupplied,\n  shareOn,\n} from '@proc7ts/fun-events';\nimport { neverSupply, Supply } from '@proc7ts/primitives';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { StypRule, StypRuleList } from './rule';\nimport { Rules } from './rules.impl';\n\n/**\n * Dynamically updated CSS rule set.\n *\n * This is an iterable of rules, and an `EventSender` of their updates.\n *\n * @category CSS Rule\n */\nexport interface StypRules extends Iterable<StypRule>, EventSender<[StypRule[], StypRule[]]> {\n\n  [Symbol.iterator](): IterableIterator<StypRule>;\n\n}\n\nexport namespace StypRules {\n\n  /**\n   * A source of CSS rules.\n   *\n   * A dynamically updated CSS rule set can be constructed out of one or more sources by {@link stypRules} and\n   * {@link lazyStypRules} functions.\n   *\n   * This can be one of:\n   * - Single `StypRule` instance.\n   *   A `StypRule.rules.self` is used instead. I.e. a list containing only the rule itself.\n   * - A `StypRules` instance.\n   *   It is used as is.\n   * - A promise of one of the above.\n   *   The resolved value is used as an actual source.\n   *   No rules are available until resolution.\n   * - A function returning one of the above.\n   *   The function call result is used as an actual source.\n   *   The function will be called lazily upon rules access.\n   */\n  export type Source =\n      | StypRule\n      | StypRules\n      | Promise<StypRule | StypRules>\n      | ((this: void) => StypRule | StypRules | Promise<StypRule | StypRules>);\n\n}\n\n/**\n * @internal\n */\nconst noStypRules: StypRuleList = (/*#__PURE__*/ new Rules({\n  [OnEvent__symbol]() {\n    return onNever;\n  },\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    return [][Symbol.iterator]();\n  },\n}));\n\n/**\n * Constructs dynamically updated CSS rule list out of rule sources.\n *\n * @category CSS Rule\n * @param sources - CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function stypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(rulesFromSource)) : noStypRules;\n}\n\n/**\n * @internal\n */\nfunction rulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? evalRules(source) : rulesByValue(source);\n}\n\n/**\n * Constructs lazily updated CSS rule list out of rule sources.\n *\n * In contrast to {@link stypRules} this one does not evaluate sources (e.g. does not call source functions) until there\n * is an updates receiver registered.\n *\n * This means that the constructed rule set won't necessary contain the rules from all sources originally. It will\n * report them as updates instead.\n *\n * @category CSS Rule\n * @param sources - CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function lazyStypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(lazyRulesFromSource)) : noStypRules;\n}\n\n/**\n * @internal\n */\nfunction lazyRulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? lazyRules(source) : rulesByValue(source);\n}\n\n/**\n * @internal\n */\nfunction rulesByList(sources: StypRules[]): StypRuleList {\n  if (sources.length === 1) {\n\n    const source = sources[0];\n\n    return source instanceof StypRuleList ? source : new Rules(source);\n  }\n  return new Rules({\n    *[Symbol.iterator](): IterableIterator<StypRule> {\n      for (const rules of sources) {\n        yield* rules;\n      }\n    },\n    [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n      return onEventBy<[StypRule[], StypRule[]]>(receiver => {\n        sources.forEach(source => onSupplied(source)({\n          supply: new Supply().needs(receiver.supply),\n          receive(context, added, removed) {\n            receiver.receive(context, added, removed);\n          },\n        }));\n      }).do(shareOn);\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction evalRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  let rules: StypRules | undefined;\n  const getRules = (): StypRules => rules || (rules = rulesByValue(source()));\n\n  return {\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return getRules()[Symbol.iterator]();\n    },\n    [OnEvent__symbol]() {\n      return getRules()[OnEvent__symbol]();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction lazyRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    const rules = rulesByValue(source());\n\n    reportExistingRules(rules, ruleSet, receiver);\n    rules[OnEvent__symbol]()({\n      supply: receiver.supply.whenOff(() => ruleSet.clear()),\n      receive(context, added, removed) {\n        removed.forEach(rule => ruleSet.delete(rule));\n        added.forEach(rule => ruleSet.add(rule));\n        receiver.receive(context, added, removed);\n      },\n    });\n  }).do(shareOn);\n\n  return {\n    [OnEvent__symbol]() {\n      return onEvent;\n    },\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction rulesByValue(source: StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n  return source instanceof StypRule ? source.rules.self : isEventSender(source) ? source : asyncRules(source);\n}\n\n/**\n * @internal\n */\nfunction asyncRules(source: Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    let sourceSupply = neverSupply();\n    const { supply } = receiver;\n\n    supply.cuts(sourceSupply)\n        .whenOff(() => ruleSet.clear());\n\n    source.then(\n        resolution => {\n          if (!supply.isOff) {\n\n            const rules = resolution instanceof StypRule ? resolution.rules : resolution;\n\n            reportExistingRules(rules, ruleSet, receiver);\n\n            sourceSupply = onSupplied(rules)({\n              receive(context, added, removed) {\n                removed.forEach(rule => ruleSet.delete(rule));\n                added.forEach(rule => ruleSet.add(rule));\n                receiver.receive(context, added, removed);\n              },\n            }).needs(supply);\n          }\n        },\n    ).catch(\n        error => supply.off(error),\n    );\n  }).do(shareOn);\n\n  return {\n    [OnEvent__symbol]() {\n      return onEvent;\n    },\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction reportExistingRules(\n    rules: StypRules,\n    ruleSet: Set<StypRule>,\n    receiver: EventReceiver.Generic<[StypRule[], StypRule[]]>,\n): void {\n\n  const existing: StypRule[] = [];\n\n  itsEach(rules, rule => {\n    existing.push(rule);\n    ruleSet.add(rule);\n  });\n  if (existing.length) {\n\n    const dispatcher = new EventNotifier<[StypRule[], StypRule[]]>();\n\n    dispatcher.on(receiver);\n    dispatcher.send(existing, []); // Report existing rules as just added\n  }\n}\n","import type { HthvItem } from '../hthv-item';\nimport type { HthvPartial } from './hthv-partial';\n\n/**\n * @internal\n */\nexport function hthvItem<TItem extends HthvItem<any, any, any>>(\n    {\n      $ = 'raw',\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<TItem>,\n): TItem {\n  if (n) {\n    (p as Record<string, HthvPartial>)[n as string] = { $, n, v, x: [], p: {}, pl: [] };\n  }\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as TItem;\n}\n","import type { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam(\n    {\n      p,\n      pl,\n    }: HthvItem,\n    param: HthvParamItem,\n): void {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","/**\n * @internal\n */\nexport const parseNone = (): false => false;\n","import { parseNone } from './parse-none';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function dateTimeParser(\n    { dateTime }: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return dateTime ? parseDateTime : parseNone;\n}\n\nfunction parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (datePattern.test(input.s)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","import type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem({ delimiterOf }: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = delimiterOf(c);\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { dateTimeParser } from './date-time-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseNone } from './parse-none';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { quotedStringParser } from './quoted-string-parser';\n\n/**\n * @internal\n */\nexport interface ItemParserConfig {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserConfig = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseDateTime = dateTimeParser(config);\n  const parseQuotedString = quotedStringParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem))); // eslint-disable-line curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    { delimiterOf }: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    { delimiterOf }: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment({ delimiterOf }: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser({ delimiterOf }: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserConfig } from './item-parser';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserConfig = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport type { HthvParserConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  readonly dateTime?: boolean;\n  delimiterOf(this: void, char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n      dateTime,\n    }: HthvParserConfig = {},\n): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    dateTime,\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = (/*#__PURE__*/ buildParserConfig());\n\n/**\n * @internal\n */\nexport const commentParserConfig = (/*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n}));\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport type { HthvDelimiterChar } from './hthv-delimiter';\nimport type { HthvItem } from './hthv-item';\nimport { hthvItem } from './impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeParam TNameMode - Whether parsed items have {@link HthvItem.n names}.\n * @typeParam TTagMode - Whether parsed items have {@link HthvItem.t tags}.\n * @typeParam TParamsMode - Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    TNameMode extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    TTagMode extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    TParamsMode extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value - HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<TNameMode, TTagMode, TParamsMode>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse date/time values.\n   *\n   * @default `false`\n   */\n  readonly dateTime?: boolean;\n\n  /**\n   * Whether to parse comments.\n   *\n   * @default `false`.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config - New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // eslint-disable-line curly\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserConfig } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n  const commentParserConfig: ItemParserConfig = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserConfig);\n  const parseParam = paramParser(config, commentParserConfig);\n\n  return (input, out) => {\n    if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while ( // eslint-disable-line curly\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        );\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments or date/time values.\n *\n * Treats illegal characters as ASCII letters.\n *\n * @param value - HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser = (/*#__PURE__*/ newHthvParser());\n\n/**\n * Parses HTTP header value that may contain date/time.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default config except {@link HthvParserConfig.dateTime date/time parsing enabled}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value - HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParseDT: HthvParser = (/*#__PURE__*/ newHthvParser({ dateTime: true }));\n","/**\n * @packageDocumentation\n * @module @hatsy/http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string - A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  const { delimiterOf } = defaultParserConfig;\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper, EventSender, OnEvent, onSupplied } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\ntype FetchAgent<TResponse extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<TResponse>,\n    request: Request,\n) => EventSender<TResponse>;\n\n/**\n * @internal\n */\ntype CombinedFetchAgent<TResponse extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<TResponse>,\n    request: Request,\n) => OnEvent<TResponse>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<TResponse extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>>\n    implements ContextUpRef<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>> {\n\n  readonly upKey: ContextUpKey.UpKey<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...agents) => {\n              if (agents.length) {\n                return afterThe(combineFetchAgents(agents));\n              }\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n\n              return afterThe(defaultFetchAgent);\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          CombinedFetchAgent<TResponse>,\n          EventKeeper<FetchAgent<TResponse>[]> | FetchAgent<TResponse>,\n          AfterEvent<FetchAgent<TResponse>[]>>,\n  ): void {\n\n    let delegated: CombinedFetchAgent<TResponse>;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((next, request) => delegated(next, request));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultFetchAgent<TResponse extends any[]>(\n    next: (this: void, request: Request) => OnEvent<TResponse>,\n    request: Request,\n): OnEvent<TResponse> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<TResponse extends any[]>(\n    agents: FetchAgent<TResponse>[],\n): CombinedFetchAgent<TResponse> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<TResponse> = (\n        agentIdx,\n        agentRequest,\n    ) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter {@link HttpFetch} processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by {@link HttpFetch}.\n */\nexport type HttpFetchAgent =\n/**\n * @param next - Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request - HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * {@link HttpFetch} call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under {@link HttpFetchAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request - HTTP request.\n   *\n   * @returns An `OnEvent` sender of response object(s) receivers. It is returned as a result of {@link HttpFetch} call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an {@link HttpFetchAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent')\n);\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { EventEmitter, onceOn, OnEvent, onEventBy } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: Supply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new window.AbortController();\n        const { signal } = abortController;\n\n        supply = new Supply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal)\n              .on('abort')\n              .do(onceOn)(\n                  () => abortController.abort(),\n              );\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of {@link HttpFetch} is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input - The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init - Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an {@link HttpFetch} instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n        'http-fetch',\n        {\n          byDefault: bootstrapDefault(newHttpFetch),\n        },\n    )\n);\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { EventEmitter, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport {\n  BootstrapContext,\n  BootstrapRoot,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentContextHolder,\n  ComponentEvent,\n} from '@wesib/wesib';\n\n/**\n * @internal\n */\nexport type HierarchyRoot = ValueTracker<ComponentContext | undefined>;\n\n/**\n * @internal\n */\nexport const HierarchyRoot = (/*#__PURE__*/ new SingleContextKey<HierarchyRoot>(\n    'hierarchy-root',\n    {\n      byDefault: bsContext => {\n\n        const root = bsContext.get(BootstrapRoot);\n\n        new DomEventDispatcher(root).on<ComponentEvent>('wesib:component')(\n            ({ context }: ComponentEvent) => context.get(HierarchyUpdates).issue(),\n        );\n\n        return trackValue();\n      },\n    },\n));\n\nconst HierarchyUpdates__key = (/*#__PURE__*/ new SingleContextKey<HierarchyUpdates>(\n    'hierarchy-updates',\n    {\n      byDefault: context => new HierarchyUpdates(context.get(ComponentContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class HierarchyUpdates {\n\n  static get [ContextKey__symbol](): ContextKey<HierarchyUpdates> {\n    return HierarchyUpdates__key;\n  }\n\n  readonly on: OnEvent<[ComponentContext]>;\n  readonly send: (this: void) => void;\n  readonly issue: () => void;\n\n  constructor(context: ComponentContext) {\n\n    const updates = new EventEmitter<[ComponentContext]>();\n    const hierarchyRoot = context.get(BootstrapContext).get(HierarchyRoot);\n\n    this.on = updates.on;\n    this.send = () => updates.send(context);\n    this.issue = () => {\n\n      const parent = findParentContext(context);\n\n      if (parent) {\n        parent[0].get(HierarchyUpdates).send();\n      } else {\n        hierarchyRoot.it = context;\n      }\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport function findParentContext(of: ComponentContext): [ComponentContext, boolean] | undefined {\n\n  const root = of.get(BootstrapContext).get(BootstrapRoot);\n  let { element } = of as { element: Node };\n  let immediate = true;\n\n  if (element === root) {\n    return;\n  }\n  for (;;) {\n\n    const parent = element.parentNode;\n\n    if (!parent) {\n      return;\n    }\n\n    const ctx = (parent as ComponentContextHolder)[ComponentContext__symbol];\n\n    if (ctx) {\n      return [ctx, immediate];\n    }\n    if (parent === root) {\n      return;\n    }\n\n    immediate = false;\n    element = parent;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  ContextValueSpec,\n  SingleContextKey,\n} from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  afterEventBy,\n  consumeEvents,\n  shareAfter,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { noop, Supply, SupplyPeer } from '@proc7ts/primitives';\nimport { BootstrapContext, ComponentContext } from '@wesib/wesib';\nimport { newHierarchyRegistry } from './hierarchy-registry.impl';\nimport { findParentContext, HierarchyRoot, HierarchyUpdates } from './hierarchy-updates.impl';\n\n/**\n * @internal\n */\nconst HierarchyContext__key = (/*#__PURE__*/ new SingleContextKey<HierarchyContext>(\n    'hierarchy-context',\n    {\n      byDefault: context => new HierarchyContext$(context.get(ComponentContext)),\n    },\n));\n\n/**\n * Component's hierarchy context.\n *\n * Passes provided values to hierarchy contexts of nested components.\n *\n * Available as component context value.\n *\n * @typeParam T - A type of component.\n */\nexport abstract class HierarchyContext<T extends object = any> extends ContextValues implements SupplyPeer {\n\n  /**\n   * A key of component context value containing its hierarchy context instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<HierarchyContext> {\n    return HierarchyContext__key;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * An `AfterEvent` keeper of enclosing component's hierarchy context.\n   *\n   * May send `undefined` when component is outside of hierarchy. E.g. when it is disconnected.\n   */\n  abstract readonly up: AfterEvent<[HierarchyContext?]>;\n\n  get supply(): Supply {\n    return this.context.supply;\n  }\n\n  /**\n   * Assigns enclosing component to use by default.\n   *\n   * The provided component will be treated as enclosing one until component element connected. After that the real\n   * enclosing component will be used instead.\n   *\n   * @param enclosing - Enclosing component's context to assign, or nothing to remove one.\n   *\n   * @returns `this` instance.\n   */\n  abstract inside(enclosing?: ComponentContext): this;\n\n  /**\n   * Provides hierarchy context value.\n   *\n   * If provided value is updatable (i.e. its key implements `ContextUpKey`), then it will be available in this context,\n   * as well as in all nested hierarchy contexts. Otherwise the value will be available in this context only.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TSeed - Value seed type.\n   * @param spec - Context value specifier.\n   *\n   * @returns A value supply that that removes the given context value specifier once cut off.\n   */\n  abstract provide<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, TDeps, TSrc, TSeed>,\n  ): Supply;\n\n}\n\nclass HierarchyContext$<T extends object> extends HierarchyContext<T> {\n\n  private readonly _parent: ValueTracker<HierarchyContext | undefined>;\n  private readonly _registry: ContextRegistry<HierarchyContext<T>>;\n  readonly get: HierarchyContext<T>['get'];\n  readonly up: AfterEvent<[HierarchyContext?]>;\n\n  constructor(readonly context: ComponentContext<T>) {\n    super();\n\n    this.up = afterEventBy<[HierarchyContext?]>(\n        receiver => {\n\n          const { supply } = receiver;\n\n          supply.needs(this);\n\n          const parentHierarchy = trackValue<HierarchyContext>();\n\n          parentHierarchy.by(this._parent);\n          supply.cuts(parentHierarchy);\n\n          const rootSupply = new Supply().needs(supply);\n          const parentSupply = new Supply().needs(supply);\n          const updateParent = (): void => {\n\n            const parent = findParentContext(this.context);\n\n            if (parent) {\n\n              const [parentCtx, immediate] = parent;\n\n              parentHierarchy.it = parentCtx.get(HierarchyContext);\n              rootSupply.off();\n              if (immediate) {\n                parentSupply.off();\n              }\n            } else {\n              parentHierarchy.it = undefined;\n            }\n          };\n\n          this.context.get(BootstrapContext).get(HierarchyRoot).read({\n            supply: rootSupply,\n            receive: () => this.context.connected && updateParent(),\n          });\n          parentHierarchy.read.do(\n              supplyAfter(parentSupply),\n              consumeEvents(newParent => newParent && newParent.context.get(HierarchyUpdates).on(updateParent)),\n          );\n          parentHierarchy.read(receiver);\n          this.context.whenConnected({\n            supply: new Supply().needs(supply),\n            receive: updateParent,\n          });\n        },\n    ).do(shareAfter);\n\n    const parent = this._parent = trackValue<HierarchyContext>();\n\n    context.whenConnected(noop).cuts(parent);\n\n    const registry = this._registry = newHierarchyRegistry<T>(this.up);\n\n    this.get = registry.newValues().get;\n  }\n\n  provide<TDeps extends any[], TSrc, TSeed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, TDeps, TSrc, TSeed>,\n  ): Supply {\n    return this._registry.provide(spec).needs(this);\n  }\n\n  inside(enclosing?: ComponentContext): this {\n    this._parent.it = enclosing && enclosing.get(HierarchyContext);\n    return this;\n  }\n\n}\n","import { ContextRegistry, ContextSeedKey } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { HierarchyContext } from './hierarchy-context';\n\n/**\n * @internal\n */\nexport function newHierarchyRegistry<T extends object>(\n    up: AfterEvent<[HierarchyContext?]>,\n): ContextRegistry<HierarchyContext<T>> {\n  return new ContextRegistry(\n      <TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>) => isContextSeedUpKey(key)\n          ? up.do(digAfter(\n              upper => upper ? upper.get(key) : afterThe(),\n          )) as unknown as TSeed\n          : undefined,\n  );\n}\n\n/**\n * @internal\n */\nfunction isContextSeedUpKey<TSrc>(\n    key: ContextSeedKey<TSrc | EventKeeper<TSrc[]>, any>,\n): key is ContextUpKey.SeedKey<TSrc> {\n  return 'upKey' in key;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { ElementNode } from './element-node';\n\n/**\n * Dynamically updatable list of selected element nodes.\n *\n * It is an iterable of nodes.\n *\n * Implements an `EventSender` interface by sending added and removed nodes arrays.\n *\n * Implements an `EventKeeper` interface by sending updated node list.\n *\n * @typeParam TNode - A type of element nodes.\n */\nexport abstract class ElementNodeList<TNode extends ElementNode = ElementNode>\n    implements Iterable<TNode>, EventSender<[TNode[], TNode[]]>, EventKeeper<[ElementNodeList<TNode>]> {\n\n  /**\n   * An `OnEvent` sender of this list changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly onUpdate: OnEvent<[TNode[], TNode[]]>;\n\n  /**\n   * An `AfterEvent` keeper of current node list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[ElementNodeList<TNode>]>;\n\n  /**\n   * An `AfterEvent` keeper of tracked list changes.\n   *\n   * Sends current nodes immediately upon receiver registration as added ones.\n   */\n  abstract readonly track: AfterEvent<[readonly TNode[], readonly TNode[]]>;\n\n  /**\n   * An `AfterEvent` keeper of either the first node in this list, or `undefined` when the list is empty.\n   */\n  abstract readonly first: AfterEvent<[TNode?]>;\n\n  abstract [Symbol.iterator](): Iterator<TNode>;\n\n  [OnEvent__symbol](): OnEvent<[TNode[], TNode[]]> {\n    return this.onUpdate;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[ElementNodeList<TNode>]> {\n    return this.read;\n  }\n\n}\n","import { html__naming } from '@frontmeans/namespace-aliaser';\nimport {\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  mapAfter,\n  OnEvent,\n  onEventBy,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { isPresent, valueProvider } from '@proc7ts/primitives';\nimport {\n  filterArray,\n  filterIt,\n  flatMapArray,\n  iteratorOf,\n  itsEach,\n  itsElements,\n  itsFirst,\n  mapIt,\n  overArray,\n  overIterator,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport {\n  BootstrapContext,\n  ComponentClass,\n  DefaultNamespaceAliaser,\n  ElementObserver,\n  ElementObserverInit,\n  isElement,\n} from '@wesib/wesib';\nimport { ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * @internal\n */\nconst WATCH_DEEP: ElementObserverInit = { subtree: true };\n\n/**\n * @internal\n */\nexport function elementNodeList<TNode extends ElementNode>(\n    bsContext: BootstrapContext,\n    root: Element,\n    selectorOrType: string | ComponentClass<any>,\n    nodeOf: (node: Element, optional?: boolean) => TNode | undefined,\n    { deep, all }: ElementPickMode,\n): ElementNodeList<TNode> {\n\n  const updates = new EventEmitter<[TNode[], TNode[]]>();\n  const init = deep ? WATCH_DEEP : undefined;\n  let cache = new Set<Element>();\n  let selector: string | undefined;\n  const overNodes: (nodes: NodeList) => Iterable<Node> = deep ? overNodeSubtree : overArray;\n\n  if (typeof selectorOrType === 'string') {\n    selector = selectorOrType;\n  } else {\n    bsContext.whenDefined(selectorOrType).then(({ elementDef: { name } }) => {\n      if (name) {\n        selector = html__naming.name(name, bsContext.get(DefaultNamespaceAliaser));\n        if (updates.size) {\n          // Refresh selection after component name resolution.\n          // This is needed  when new document loaded.\n\n          const selected = refresh();\n\n          if (selected.size) {\n\n            const added = itsElements(\n                filterIt<TNode | undefined, TNode>(\n                    mapIt(selected, node => nodeOf(node)),\n                    isPresent,\n                ),\n            );\n\n            /* istanbul ignore if. Can not test native custom element */\n            if (added.length) {\n              updates.send(added, []);\n            }\n          }\n        }\n      }\n    }).catch(console.error);\n  }\n\n  if (!all) {\n    root.addEventListener('wesib:component', event => {\n\n      const element = event.target as Element;\n\n      if (cache.has(element)) {\n\n        const node = nodeOf(element) as TNode;\n\n        updates.send([node], []);\n      }\n    });\n  }\n\n  const iterable: PushIterable<TNode> = filterIt<TNode | undefined, TNode>(\n      mapIt(\n          overIterator(elements),\n          element => nodeOf(element),\n      ),\n      isPresent,\n  );\n\n  class ElementNodeList$ extends ElementNodeList<TNode> implements PushIterable<TNode> {\n\n    readonly onUpdate: OnEvent<[TNode[], TNode[]]>;\n    readonly read: AfterEvent<[ElementNodeList<TNode>]>;\n    readonly track: AfterEvent<[readonly TNode[], readonly TNode[]]>;\n    readonly first: AfterEvent<[TNode?]>;\n\n    constructor() {\n      super();\n\n      const observer = bsContext.get(ElementObserver)(update);\n\n      this.onUpdate = onEventBy<[TNode[], TNode[]]>(receiver => {\n\n        const firstReceiver = !updates.size;\n        const supply = updates.on(receiver);\n\n        if (firstReceiver) {\n          refresh();\n          observer.observe(root, init);\n        }\n\n        supply.whenOff(() => {\n          if (!updates.size) {\n            observer.disconnect();\n            clearCache(); // clear cache as there is no more receivers\n          }\n        }).needs(receiver.supply);\n      });\n\n      const returnSelf = valueProvider(this);\n\n      this.read = this.onUpdate.do(mapAfter(returnSelf, returnSelf));\n\n      this.track = afterEventBy<[readonly TNode[], readonly TNode[]]>(receiver => {\n\n        const initialEmitter = new EventEmitter<[readonly TNode[], readonly TNode[]]>();\n\n        initialEmitter.on(receiver);\n        initialEmitter.send(itsElements(this), []);\n\n        this.onUpdate(receiver);\n      });\n\n      this.first = afterSupplied(this.read).do(translateAfter(\n          (send, list) => send(itsFirst(list)),\n      ));\n    }\n\n    [Symbol.iterator](): PushIterator<TNode> {\n      return this[PushIterator__symbol]();\n    }\n\n    [PushIterator__symbol](accept?: PushIterator.Acceptor<TNode>): PushIterator<TNode> {\n      return iterable[PushIterator__symbol](accept);\n    }\n\n  }\n\n  return new ElementNodeList$();\n\n  function elements(): Iterator<Element> {\n    return iteratorOf(updates.size ? cache : refresh());\n  }\n\n  function clearCache(): void {\n    cache.clear();\n  }\n\n  function refresh(): Set<Element> {\n\n    const list = select();\n\n    if (updates.size) {\n      cache = list; // cache is for receivers only\n    }\n\n    return list;\n  }\n\n  function select(): Set<Element> {\n\n    const sel = selector;\n\n    if (!sel) {\n      return new Set();\n    }\n    if (deep) {\n      return new Set(overArray(root.querySelectorAll(sel)));\n    }\n\n    return new Set(filterArray(root.children, item => item.matches(sel)));\n  }\n\n  function update(mutations: MutationRecord[]): void {\n\n    const added: TNode[] = [];\n    const removed: TNode[] = [];\n\n    mutations.forEach(mutation => {\n      itsEach(\n          filterIt<TNode | undefined, TNode>(\n              mapIt(overNodes(mutation.removedNodes), removeNode),\n              isPresent,\n          ),\n          node => removed.push(node),\n      );\n      itsEach(\n          filterIt<TNode | undefined, TNode>(\n              mapIt(overNodes(mutation.addedNodes), addNode),\n              isPresent,\n          ),\n          node => added.push(node),\n      );\n    });\n    if (added.length || removed.length) {\n      updates.send(added, removed);\n    }\n  }\n\n  function addNode(node: Node): TNode | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (selector && node.matches(selector) && !cache.has(node)) {\n      cache.add(node);\n      return nodeOf(node);\n    }\n    return;\n  }\n\n  function removeNode(node: Node): TNode | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (!cache.delete(node)) {\n      return;\n    }\n    return nodeOf(node, true);\n  }\n\n}\n\nfunction overNodeSubtree(nodes: NodeList): Iterable<Node> {\n  return flatMapArray(\n      nodes,\n      node => overArray([node, ...overNodeSubtree(node.childNodes)]),\n  );\n}\n","import { EventEmitter, eventReceiver, EventReceiver, OnEvent, onEventBy, ValueTracker } from '@proc7ts/fun-events';\nimport { neverSupply, Supply } from '@proc7ts/primitives';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\n\n/**\n * @internal\n */\nclass AttributesObserver {\n\n  private readonly _emitters = new Map<string, EventEmitter<[string | null, string | null]>>();\n  private _observer?: MutationObserver;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n  }\n\n  private get observer(): MutationObserver {\n    if (this._observer) {\n      return this._observer;\n    }\n\n    const Observer = this._bs.get(BootstrapWindow).MutationObserver;\n\n    return this._observer = new Observer(mutations => this._update(mutations));\n  }\n\n  observe(name: string, receiver: EventReceiver<[string | null, string | null]>): Supply {\n\n    const self = this;\n    const observer = this.observer;\n    const emitter = this._emitter(name);\n    const rcv = eventReceiver(receiver);\n    const supply = emitter.on({\n      supply: new Supply(() => {\n        this._emitters.delete(name);\n        observer.disconnect();\n        if (this._emitters.size) {\n          reconnect();\n        } else {\n          this._observer = undefined;\n        }\n      }).needs(rcv.supply),\n      receive: (ctx, newValue, oldValue) => rcv.receive(ctx, newValue, oldValue),\n    });\n\n    observer.disconnect();\n    reconnect();\n\n    return supply;\n\n    function reconnect(): void {\n      self._update(observer.takeRecords());\n      observer.observe(self.element, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: [...self._emitters.keys()],\n      });\n    }\n  }\n\n  private _update(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n\n      const attributeName = mutation.attributeName as string;\n      const emitter = this._emitters.get(attributeName);\n\n      if (emitter) {\n        emitter.send(this.element.getAttribute(attributeName) as string, mutation.oldValue);\n      }\n    });\n  }\n\n  private _emitter(name: string): EventEmitter<[string | null, string | null]> {\n\n    const emitter = new EventEmitter<[string | null, string | null]>();\n\n    this._emitters.set(name, emitter);\n\n    return emitter;\n  }\n\n}\n\n/**\n * @internal\n */\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly on: OnEvent<[string | null, string | null]>;\n  private readonly _updates = new EventEmitter<[string | null, string | null]>();\n\n  constructor(\n      private readonly _observer: AttributesObserver,\n      private readonly _name: string,\n  ) {\n    super();\n\n    let observeSupply = neverSupply();\n\n    this.on = onEventBy(receiver => {\n      if (!this._updates.size) {\n        observeSupply = this._observer.observe(\n            this._name,\n            (newValue, oldValue) => this._updates.send(newValue, oldValue),\n        );\n      }\n      receiver.supply.needs(observeSupply);\n      this._updates.on(receiver).whenOff(reason => {\n        if (!this._updates.size) {\n          observeSupply.off(reason);\n        }\n      });\n    });\n  }\n\n  get supply(): Supply {\n    return this._updates.supply;\n  }\n\n  get it(): string | null {\n    return this._observer.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (value != null) {\n      this._observer.element.setAttribute(this._name, value);\n    } else {\n      this._observer.element.removeAttribute(this._name);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeAttributes {\n\n  private readonly _attrs = new Map<string, AttributeTracker>();\n  private readonly _observer: AttributesObserver;\n\n  constructor(bs: BootstrapContext, element: any) {\n    this._observer = new AttributesObserver(bs, element);\n  }\n\n  get(name: string): ValueTracker<string | null> {\n\n    const existing = this._attrs.get(name);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new AttributeTracker(this._observer, name);\n\n    this._attrs.set(name, created);\n\n    return created;\n  }\n\n}\n","import { EventEmitter, OnEvent, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext, ComponentState, domPropertyPathTo } from '@wesib/wesib';\n\n/**\n * @internal\n */\ntype ElementWithProperty<T> = {\n  [key in PropertyKey]: T;\n};\n\n/**\n * @internal\n */\nclass PropertyTracker<T> extends ValueTracker<T> {\n\n  private readonly _updates = new EventEmitter<[T, T]>();\n  private readonly _key: string;\n  constructor(\n      private readonly _element: ElementWithProperty<T>,\n      key: PropertyKey,\n  ) {\n    super();\n    this._key = key as string;\n  }\n\n  get supply(): Supply {\n    return this._updates.supply;\n  }\n\n  get it(): T {\n    return this._element[this._key];\n  }\n\n  set it(value: T) {\n    this._element[this._key] = value;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._updates.on;\n  }\n\n  bind(context: ComponentContext): void {\n\n    const propertyState = context.get(ComponentState).track(domPropertyPathTo(this._key));\n\n    propertyState.onUpdate({\n      supply: this.supply,\n      receive: (_ctx, _path, newValue: any, oldValue: any) => this._updates.send(newValue, oldValue),\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeProperties {\n\n  private readonly _props = new Map<PropertyKey, PropertyTracker<any>>();\n  private _context?: ComponentContext<any>;\n\n  constructor(private readonly _element: any) {\n  }\n\n  bind(context: ComponentContext): void {\n    this._context = context;\n    this._props.forEach(prop => prop.bind(context));\n  }\n\n  get<T>(key: PropertyKey): ValueTracker<T> {\n\n    const existing = this._props.get(key);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new PropertyTracker<any>(this._element, key);\n\n    if (this._context) {\n      created.bind(this._context);\n    }\n    this._props.set(key, created);\n\n    return created;\n  }\n\n}\n","import { ValueTracker } from '@proc7ts/fun-events';\nimport {\n  BootstrapContext,\n  ComponentClass,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentContextHolder,\n  ComponentEvent,\n  ElementAdapter,\n} from '@wesib/wesib';\nimport { ComponentNode, ComponentTreeNode, ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeList } from './element-node-list.impl';\nimport { NodeAttributes } from './node-attributes.impl';\nimport { NodeProperties } from './node-properties.impl';\n\n/**\n * @internal\n */\nconst ElementNode__symbol = (/*#__PURE__*/ Symbol('element-node'));\n\n/**\n * @internal\n */\ntype TreeElement = Element & ComponentContextHolder & {\n  [ElementNode__symbol]?: ComponentTreeNode;\n};\n\n/**\n * @internal\n */\nclass ElementNode$ implements ComponentTreeNode {\n\n  private readonly _attrs: NodeAttributes;\n  private readonly _props: NodeProperties;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: TreeElement) {\n    this._attrs = new NodeAttributes(_bs, element);\n    this._props = new NodeProperties(element);\n    element[ElementNode__symbol] = this;\n\n    const context = element[ComponentContext__symbol];\n\n    if (context) {\n      this._bind(context);\n    } else {\n      element.addEventListener('wesib:component', event => this._bind((event as ComponentEvent).context));\n    }\n  }\n\n  get context(): ComponentContext<any> | undefined {\n    return this.element[ComponentContext__symbol];\n  }\n\n  get parent(): ElementNode | null {\n\n    const parent = this.element.parentNode;\n\n    return parent && elementNodeOf(this._bs, parent as Element);\n  }\n\n  select(selector: string | ComponentClass<any>, mode?: ElementPickMode): ElementNodeList<any> {\n    return selectNodes(this._bs, this.element, selector, mode);\n  }\n\n  attribute(name: string): ValueTracker<string | null> {\n    return this._attrs.get(name);\n  }\n\n  property<TValue>(key: PropertyKey): ValueTracker<TValue> {\n    return this._props.get(key);\n  }\n\n  private _bind(context: ComponentContext): void {\n    this._props.bind(context);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional: true,\n): ElementNode | undefined;\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: false,\n): ElementNode;\n\n/**\n * @internal\n */\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: boolean,\n): ElementNode | undefined;\n\n\nexport function elementNodeOf(\n    bsContext: BootstrapContext,\n    element: TreeElement,\n    optional?: boolean,\n): ElementNode | undefined {\n\n  const existing = element[ElementNode__symbol];\n\n  return (existing || optional) ? existing : new ElementNode$(bsContext, element);\n}\n\n/**\n * @internal\n */\nfunction selectNodes(\n    bsContext: BootstrapContext,\n    root: Element,\n    selector: string | ComponentClass<any>,\n    mode: ElementPickMode = {},\n): ElementNodeList<any> {\n  if (mode.all) {\n    return elementNodeList<ElementNode>(\n        bsContext,\n        root,\n        selector,\n        (element, optional) => elementNodeOf(bsContext, element, optional),\n        mode,\n    );\n  }\n\n  const adapter = bsContext.get(ElementAdapter);\n\n  return elementNodeList<ComponentNode>(\n      bsContext,\n      root,\n      selector,\n      (element, optional) => adapter(element) && elementNodeOf(bsContext, element, optional) as ComponentNode,\n      mode,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { BootstrapContext, ComponentClass, ComponentContext } from '@wesib/wesib';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeOf } from './element-node.impl';\n\n/**\n * Arbitrary element node within component tree. Either bound to some component or not.\n */\nexport type ElementNode =\n    | RawElementNode\n    | ComponentNode;\n\n/**\n * Component tree node representing arbitrary element.\n *\n * This is a base interface of all element node implementations.\n */\nexport interface ComponentTreeNode {\n\n  /**\n   * The element itself.\n   */\n  readonly element: any;\n\n  /**\n   * A context of component bound to this element, if any.\n   */\n  readonly context?: ComponentContext<any>;\n\n  /**\n   * Parent element node, or `null` if element has no parent.\n   */\n  readonly parent: ElementNode | null;\n\n  /**\n   * Selects component nodes matching the given selector.\n   *\n   * @param selector - Simple CSS selector of nested components.\n   * @param mode - Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select(\n      selector: string,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode>;\n\n  /**\n   * Selects component nodes of the given type.\n   *\n   * @param componentType - Nested component type with custom element name.\n   * @param mode - Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select<T extends object>(\n      componentType: ComponentClass<T>,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode<T>>;\n\n  /**\n   * Selects element nodes matching the given selector.\n   *\n   * @param selector - Simple CSS selector of nested elements. E.g. CSS class selector.\n   * @param mode - A mode of node picking from component tree.\n   *\n   * @returns Dynamically updatable list of matching element nodes.\n   */\n  select(\n      selector: string,\n      mode: ElementPickMode,\n  ): ElementNodeList;\n\n  /**\n   * Tracks element attribute.\n   *\n   * `null` attribute value corresponds to its absence. Setting it to `null` removes attribute.\n   *\n   * @param name - Target attribute name.\n   *\n   * @returns Target attribute's value tracker.\n   */\n  attribute(name: string): ValueTracker<string | null>;\n\n  /**\n   * Tracks element element property.\n   *\n   * The changes are tracked with `StateTracker`. So it is expected that the target property notifies on its changes\n   * with state updater. E.g. when it is defined by `@DomProperty` decorator.\n   *\n   * @typeParam TValue - Property value type.\n   * @param key - Target property key.\n   *\n   * @returns Target property's value tracker.\n   */\n  property<TValue>(key: PropertyKey): ValueTracker<TValue>;\n\n}\n\n/**\n * Element node representing raw element not bound to any component.\n */\nexport interface RawElementNode extends ComponentTreeNode {\n\n  readonly context?: undefined;\n\n}\n\n/**\n * Element node representing an element bound to some component.\n */\nexport interface ComponentNode<T extends object = any> extends ComponentTreeNode {\n\n  readonly context: ComponentContext<T>;\n\n}\n\n/**\n * A key of component context value containing a component node instance.\n */\nexport const ComponentNode: SingleContextRef<ComponentNode> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentNode>(\n        'component-node',\n        {\n          byDefault(context) {\n            return elementNodeOf(\n                context.get(BootstrapContext),\n                context.get(ComponentContext).element,\n            ) as ComponentNode;\n          },\n        },\n    )\n);\n\n/**\n * A mode of node picking from component tree.\n */\nexport interface ElementPickMode {\n\n  /**\n   * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n   */\n  all?: boolean;\n\n  /**\n   * Set to `true` to select from entire subtree. Otherwise - select from element child nodes only.\n   */\n  deep?: boolean;\n\n}\n\n/**\n * A mode that picks component nodes from component tree.\n */\nexport interface ComponentPickMode extends ElementPickMode {\n\n  all?: false;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\n/**\n * Extracts URL contained in the hash of another URL.\n *\n * Extracted hash URL is based on origin of the original URL. Still, it may be absolute one.\n *\n * Input URL is never altered.\n *\n * @param url - An URL to extract hash from.\n *\n * @returns URL extracted from hash.\n */\nexport function getHashURL(url: URL): URL {\n  return new URL(url.hash.substring(1), url.origin);\n}\n\n/**\n * Creates an URL based on original one, but with hash substituted by the given hash URL.\n *\n * The hash URL is substituted as following:\n *\n * 1. If the hash URL's origin is not the same as the one of the base one, or if it contains a username,\n *    then absolute hash URL is substituted:\n * 2. Otherwise:\n *    - pathname is substituted, unless it is equal to `/` and no hash and search parameters present,\n *    - search parameters are substituted when at least one present,\n *    - hash is substituted only when present.\n *\n * Input URLs are never altered.\n *\n * @param url - Base URL.\n * @param hashURL - Hash URL to substitute.\n *\n * @returns URL with updated hash.\n */\nexport function setHashURL(url: URL, hashURL: URL): URL {\n  if (hashURL.origin !== url.origin || hashURL.username) {\n    return new URL(`#${hashURL}`, url);\n  }\n\n  const { pathname, search, hash } = hashURL;\n  const result = new URL('', url);\n\n  result.hash = (search || hash || pathname.length > 1) ? (pathname + search + hash) : (search + hash);\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = (/*#__PURE__*/ Symbol('page-param'));\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to {@link LeavePageEvent}). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeParam T - Parameter value type.\n * @typeParam TInput - Parameter input type.\n */\nexport abstract class PageParam<T, TInput> implements PageParam.Ref<T, TInput> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}. It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page - A page to assign navigation parameter to.\n   * @param input - Parameter input used to construct its initial value.\n   * @param context - Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: TInput, context: PageParamContext): PageParam.Handle<T, TInput>;\n\n  /**\n   * Creates default page parameter handle.\n   *\n   * This method is called when {@link Page.get requesting page parameter} which value is not present in the page.\n   * The value handle returned is assigned to the page.\n   *\n   * Returns nothing by default.\n   *\n   * @param _page - A page to assign navigation parameter to.\n   * @param _context - Page parameter context.\n   *\n   * @returns New page parameter value handle or nothing if there is no default value.\n   */\n  byDefault(_page: Page, _context: PageParamContext): PageParam.Handle<T, TInput> | undefined {\n    return;\n  }\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface Ref<T, TInput> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, TInput>;\n\n  }\n\n  /**\n   * Page navigation parameter that has default value.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface WithDefaults<T, TInput> extends PageParam<T, TInput> {\n\n    byDefault(page: Page, context: PageParamContext): PageParam.Handle<T, TInput>;\n\n  }\n\n  export namespace WithDefaults {\n\n    /**\n     * A reference to page navigation parameter that has default value.\n     *\n     * @typeParam T - Parameter value type.\n     * @typeParam TInput - Parameter input type.\n     */\n    export interface Ref<T, TInput> {\n\n      /**\n       * Referred page navigation parameter instance.\n       */\n      readonly [PageParam__symbol]: WithDefaults<T, TInput>;\n\n    }\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface Handle<T, TInput> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input - Parameter input to use when updating its value.\n     */\n    put(input: TInput): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before {@link LeavePageEvent} is fired for each parameter handle of current page.\n     *\n     * @param to - A page to transfer parameter to.\n     * @param when - When the transfer happens. Either `pretend`, `pre-open`, `pre-replace`, `open`, or `return`.\n     * `return` is used when return to page generated by another app version. E.g. from the page that has been\n     * reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(\n        to: Page, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return',\n    ): Handle<T, TInput> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page - Entered page.\n     * @param when - When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at - The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventKeeper } from '@proc7ts/fun-events';\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next - Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional {@link Navigation.Target} parameter. The original target will be used instead when omitted.\n * @param when - When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n * @param from - The page to leave.\n * @param to - Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pretend' | 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\n/**\n * @internal\n */\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent> {\n\n  readonly upKey: ContextUpKey.UpKey<NavigationAgent.Combined, NavigationAgent>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => {\n\n          const { document } = slot.context.get(BootstrapWindow);\n\n          slot.insert(slot.seed.do(\n              digAfter((...agents) => {\n                if (agents.length) {\n                  return afterThe(combinedAgent);\n                }\n                if (slot.hasFallback && slot.or) {\n                  return slot.or;\n                }\n\n                return afterThe(defaultNavigationAgent);\n\n                function combinedAgent(\n                    next: (this: void, target: Navigation.URLTarget) => void,\n                    when: 'pretend' | 'pre-open' | 'pre-replace',\n                    from: Page,\n                    to: Page,\n                ): void {\n\n                  return navigate(0, to);\n\n                  function navigate(agentIdx: number, agentTo: Page): void {\n\n                    const agent = agents[agentIdx];\n\n                    if (!agent) {\n                      return next(agentTo);\n                    }\n\n                    agent(\n                        (\n                            {\n                              url: nextURL = agentTo.url,\n                              title: nextTitle = agentTo.title,\n                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                              data: nextData = agentTo.data,\n                            }: Navigation.Target = agentTo,\n                        ) => navigate(\n                            agentIdx + 1,\n                            {\n                              url: new URL(String(nextURL), document.baseURI),\n                              title: nextTitle,\n                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                              data: nextData,\n                              get visited() {\n                                return agentTo.visited;\n                              },\n                              get current() {\n                                return agentTo.current;\n                              },\n                              get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n                                return agentTo.get(ref);\n                              },\n                              put(ref, input) {\n                                agentTo.put(ref, input);\n                              },\n                            },\n                        ),\n                        when,\n                        from,\n                        agentTo,\n                    );\n                  }\n                }\n              }),\n          ));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          NavigationAgent.Combined,\n          EventKeeper<NavigationAgent[]> | NavigationAgent,\n          AfterEvent<NavigationAgent[]>>,\n  ): void {\n\n    let delegated: NavigationAgent.Combined;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((next, when, from, to) => delegated(next, when, from, to));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavigationAgent(\n    next: (this: void, target: Navigation.URLTarget) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n  next(to);\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under {@link NavigationAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or applies the final navigation target if this agent is the\n   * last one. Not calling this function effectively prevents navigation.\n   * Accepts an optional {@link Navigation.Target} parameter. The original target will be used instead when omitted.\n   * @param when - When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n   * @param from - The page to leave.\n   * @param to - Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pretend' | 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an {@link NavigationAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> = (\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextValues } from '@proc7ts/context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * @internal\n */\nconst NavHistory__key = (/*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'nav-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n));\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\n/**\n * @internal\n */\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      ? { data: state }\n      : (state as NavDataEnvelope)[NAV_DATA_KEY] as PartialNavData;\n}\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol](): ContextKey<NavHistory> {\n    return NavHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry): void {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        data,\n      },\n    };\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      get url() {\n        return target.url;\n      },\n      get title() {\n        return target.title;\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      get data(): any {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return target.data;\n      },\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(param);\n\n    if (handle) {\n      return handle.get();\n    }\n\n    const newHandle = param.byDefault(this.page, this._newContext());\n\n    return newHandle && this._init(param, newHandle);\n  }\n\n  put<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, TInput> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    return this._init(param, param.create(this.page, input, this._newContext()));\n  }\n\n  private _newContext(): PageParamContext {\n\n    const registry = new ContextRegistry<ParamContext>(this._bsContext);\n\n    class ParamContext extends PageParamContext {\n\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n\n    }\n\n    return new ParamContext();\n  }\n\n  private _init<T, TInput>(param: PageParam<T, TInput>, handle: PageParam.Handle<T, TInput>): T {\n    this._params.set(param, handle);\n\n    if (this.page.current && handle.enter) {\n      handle.enter(this.page, 'init');\n    }\n\n    return handle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): void {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page): void {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave(): void {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget(): void {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void): void {\n    this._update = update;\n  }\n\n  apply(): void {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { DomEventDispatcher, OnDomEvent } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  onAny,\n  OnEvent,\n  OnEvent__symbol,\n  onSupplied,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { mergeFunctions, noop } from '@proc7ts/primitives';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\n/**\n * @internal\n */\nconst Navigation__key = (/*#__PURE__*/ new SingleContextKey<Navigation>(\n    'navigation',\n    {\n      byDefault: bootstrapDefault(createNavigation),\n    },\n));\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * Current page.\n   */\n  abstract readonly page: Page;\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * An `OnDomEvent` sender of {@link EnterPageEvent enter page events}.\n   */\n  abstract readonly onEnter: OnDomEvent<EnterPageEvent>;\n\n  /**\n   * An `OnDomEvent` sender of {@link LeavePageEvent leave page events}.\n   *\n   * The registered listener may cancel navigation by calling `preventDefault()` method of received event.\n   */\n  abstract readonly onLeave: OnDomEvent<LeavePageEvent>;\n\n  /**\n   * An `OnDomEvent` {@link StayOnPageEvent stay on page events}.\n   *\n   * The registered listener is informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   *\n   * @returns `OnDomEvent` sender of {@link StayOnPageEvent stay on page events}.\n   */\n  abstract readonly onStay: OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * An `OnEvent` sender of {@link NavigationEvent navigation events}.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[NavigationEvent]>;\n\n  [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of {@link page current page}.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[Page]>;\n\n  [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read;\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta - Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target - Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target - Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url - An URL to replace the the current one with.\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   * @param ref - A reference to page navigation parameter to apply.\n   * @param input - Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeParam T - Parameter value type.\n     * @typeParam TInput - Parameter input type.\n     * @param ref - A reference to page navigation parameter to apply.\n     * @param input - Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target - Either navigation target or URL to navigate to. Navigates to current page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target - Either navigation target or URL to replace the latest history entry with. Navigates to current\n     * page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Pretends navigation.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target - Either navigation target or URL to pretend navigation to.\n     * @param callback - A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        target: Navigation.Target | string | URL,\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation to the same page.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param callback - A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation and builds navigation target.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target - Either navigation target or URL to pretend navigation to. Prepends navigation to current page\n     * when omitted.\n     *\n     * @returns Either Navigation target with URL value, or `undefined` when navigation failed.\n     */\n    pretend(\n        target?: Navigation.Target | string | URL,\n    ): URLTarget | undefined;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to {@link Navigation.open} and {@link Navigation.replace} methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n\nfunction createNavigation(context: BootstrapContext): Navigation {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate')(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange')(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  type NavTarget = { -readonly [K in keyof Navigation.URLTarget]: Navigation.URLTarget[K] };\n\n  class Navigation$ extends Navigation {\n\n    readonly onEnter: OnDomEvent<EnterPageEvent>;\n    readonly onLeave: OnDomEvent<LeavePageEvent>;\n    readonly onStay: OnDomEvent<StayOnPageEvent>;\n    readonly on: OnEvent<[NavigationEvent]>;\n    readonly read: AfterEvent<[Page]>;\n\n    constructor() {\n      super();\n      this.onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage);\n      this.onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage);\n      this.onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage);\n      this.on = onAny<[NavigationEvent]>(\n          onSupplied(this.onEnter),\n          onSupplied(this.onLeave),\n          onSupplied(this.onStay),\n      );\n      this.read = nav.read.do(\n          mapAfter(({ page }) => page),\n      );\n    }\n\n    get page(): Page {\n      return nav.it.page;\n    }\n\n    get length(): number {\n      return history.length;\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation$();\n\n  function withParam(applyParams: (page: Page) => void): Navigation.Parameterized {\n    return {\n      with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target?: Navigation.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target?: Navigation.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n      pretend<T>(\n          targetOrCallback?: Navigation.Target | string | URL | ((this: void, from: Page, to: Page) => T),\n          callback: (this: void, from: Page, to: Page) => T = (_from, to) => to as unknown as T,\n      ): T | undefined {\n\n        let target: Navigation.Target | string | URL | undefined;\n\n        if (typeof targetOrCallback === 'function') {\n          callback = targetOrCallback;\n          target = undefined;\n        } else {\n          target = targetOrCallback;\n        }\n\n        const navTarget = navTargetOf(target);\n        const fromEntry = nav.it;\n        const toEntry = newEntry('pretend', fromEntry, navTarget, applyParams);\n\n        try {\n          return applyAgent('pretend', fromEntry, navTarget, toEntry)\n              ? callback(fromEntry.page, toEntry.page)\n              : undefined;\n        } finally {\n          toEntry.stay(nav.it.page);\n        }\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function navTargetOf(target?: Navigation.Target | string | URL): NavTarget {\n    if (target == null || typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target?: Navigation.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const navTarget = navTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined = undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n        navHistory[when](toEntry, nav);\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = newEntry(whenLeave, fromEntry, navTarget, applyParams);\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      if (!dispatcher.dispatch(leavePage)\n          || next !== promise\n          || !applyAgent(whenLeave, fromEntry, navTarget, toEntry)) {\n        return stay(toEntry);\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: navTarget,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n\n  function newEntry(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      applyParams: (page: Page) => void,\n  ): PageEntry {\n\n    const toEntry = navHistory.newEntry(navTarget);\n\n    try {\n      fromEntry.transfer(toEntry, whenLeave);\n      applyParams(toEntry.page);\n    } catch (e) {\n      toEntry.stay(nav.it.page);\n      throw e;\n    }\n\n    return toEntry;\n  }\n\n  function applyAgent(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      toEntry: PageEntry,\n  ): boolean {\n\n    let navigated = false;\n\n    agent(\n        ({ url, data, title }) => {\n          navigated = true;\n          navTarget.url = url;\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          navTarget.data = data;\n          navTarget.title = title;\n        },\n        whenLeave,\n        fromEntry.page,\n        toEntry.page,\n    );\n\n    return navigated;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { css__naming, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { RenderSchedule } from '@frontmeans/render-scheduler';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  consumeEvents,\n  digAfter_,\n  EventKeeper,\n  supplyAfter,\n  translateAfter_,\n} from '@proc7ts/fun-events';\nimport { Class, noop, Supply } from '@proc7ts/primitives';\nimport { mapIt } from '@proc7ts/push-iterator';\nimport {\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultNamespaceAliaser,\n  ElementRenderScheduler,\n  RenderDef,\n  Wesib__NS,\n} from '@wesib/wesib';\nimport { ComponentNode, ElementNode, ElementPickMode } from '../tree';\nimport { getHashURL } from './hash-url';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * @internal\n */\ninterface ActiveNavLink {\n  supply(): Supply;\n}\n\n/**\n * Creates component decorator that marks navigation link(s) inside decorated component active.\n *\n * Marks navigation links with highest weight.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Navigation link activation definition.\n *\n * @returns New component decorator.\n */\nexport function ActivateNavLink<T extends ComponentClass = Class>(\n    def: ActivateNavLinkDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const { select = 'a', pick = { all: true, deep: true } } = def;\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const activate = activateNavLink(context, def);\n        const weigh = navLinkWeight(def);\n        const navigation = context.get(Navigation);\n        const componentNode = context.get(ComponentNode);\n\n        context.whenConnected(() => {\n\n          let active = new Map<ElementNode, ActiveNavLink>();\n\n          navigation.read.do(\n              supplyAfter(context),\n              consumeEvents(\n                  page => componentNode.select(select, pick).read.do(\n                      digAfter_(nodes => afterEach(\n                          ...mapIt(nodes, node => weigh({ node, context, page })),\n                      )),\n                      consumeEvents((...weights: NavLinkWeight[]) => {\n\n                        const selected = selectActiveNavLinks(weights);\n                        const newActive = new Map<ElementNode, ActiveNavLink>();\n                        const result = new Supply();\n\n                        selected.forEach(node => {\n\n                          let activeLink: ActiveNavLink;\n                          const existing = active.get(node);\n\n                          if (existing) {\n                            newActive.set(node, existing);\n                            activeLink = existing;\n                          } else {\n                            activeLink = activate({ node, context, page });\n                            newActive.set(node, activeLink);\n                          }\n\n                          activeLink.supply().needs(result);\n                        });\n\n                        active = newActive;\n\n                        return result;\n                      }),\n                  ),\n              ),\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation link activation definition.\n *\n * Defines a set of element nodes considered to be navigation links. Each matching node is {@link weigh weighed}\n * against {@link Navigation.read current page}, and the link with highest weight is marked {@link active}.\n *\n * @typeParam T - A type of component.\n */\nexport interface ActivateNavLinkDef<T extends object = any> {\n\n  /**\n   * Navigation links CSS selector.\n   *\n   * `a` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of navigation link node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Qualified name of CSS class to mark the active element with.\n   *\n   * The `active` class in Wesib namespace is used by default.\n   */\n  readonly active?: QualifiedName;\n\n  /**\n   * Rendering definition options to pass to nav links render scheduler.\n   */\n  readonly render?: RenderDef.Options;\n\n  /**\n   * Weighs matching navigation link.\n   *\n   * This method will be called for each navigation link on each current page update.\n   *\n   * By default:\n   * 1. If the link path has neither hash, nor search parameters, then:\n   * 1.1. Checks whether page URL path starts with the link's one.\n   * 1.2. If so, then uses link path length as weight.\n   * 2. If the link path has search parameters, but has no hash, then requires the page path to be the same as link's\n   *    one, and page search parameters include all of the link's ones. The number of link search parameters plus the\n   *    link path length is used as weight.\n   * 3. If the link path has a hash, then requires the page path and search parameters to be the same as link's ones,\n   *    and their hashes are treated as {@link getHashURL URLs}. The weight is calculated by applying steps 1, 2, and 3\n   *    to hash URLs increased by the link path length and the number of search parameters.\n   *\n   * Ignores search parameters with names starting and ending with double underscores. Like `__wesib_app_rev__`.\n   *\n   * @param node - Navigation link node to weigh.\n   * @param page - Current navigation page.\n   * @param context - Decorated component context.\n   *\n   * @returns Either navigation link weight, or its keeper. Non-positive wights means the page URL doesn't match\n   * the link at all.\n   */\n  weigh?(\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): number | EventKeeper<[number]>;\n\n  /**\n   * Changes navigation link activity state.\n   *\n   * This method is called each time the active link changed.\n   *\n   * @param active - Whether to make target link active (`true`), or inactive (`false`).\n   * @param node - Navigation link node to update activity state of.\n   * @param page - Current navigation page.\n   * @param context - Decorated component context.\n   */\n  activate?(\n      active: boolean,\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n}\n\n/**\n * @internal\n */\ntype NavLinkWeight = [ElementNode, number];\n\n/**\n * @internal\n */\ninterface NavLinkOpts {\n  node: ElementNode;\n  page: Page;\n  context: ComponentContext;\n}\n\n/**\n * @internal\n */\nfunction selectActiveNavLinks(weights: NavLinkWeight[]): ElementNode[] {\n\n  let maxWeight = 0;\n  let active: ElementNode[] = [];\n\n  weights.forEach(([node, weight]) => {\n    if (weight > maxWeight) {\n      maxWeight = weight;\n      active = [node];\n    } else if (weight === maxWeight) {\n      active.push(node);\n    }\n  });\n\n  return active;\n}\n\n/**\n * @internal\n */\nfunction navLinkWeight(\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => AfterEvent<NavLinkWeight> {\n  if (!def.weigh) {\n    return defaultNavLinkWeight;\n  }\n\n  return opts => {\n\n    const weight = def.weigh!(opts);\n\n    if (typeof weight === 'number') {\n      return afterThe(opts.node, weight);\n    }\n\n    let supplier: AfterEvent<NavLinkWeight> = afterSupplied(weight).do(translateAfter_(\n        (send, weight) => send(opts.node, weight),\n    ));\n\n    return afterEventBy<NavLinkWeight>(receiver => {\n      supplier({\n        supply: new Supply()\n            .needs(receiver.supply)\n            .whenOff(() => {\n              // Fall back to zero weight once the weight supply cut off\n              supplier = afterThe(opts.node, 0);\n              supplier(receiver);\n            }),\n        receive: receiver.receive.bind(receiver),\n      });\n    });\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkWeight(\n    {\n      node,\n      page,\n    }: NavLinkOpts,\n): AfterEvent<NavLinkWeight> {\n\n  const { element } = node as { element: Element };\n  const href = element.getAttribute('href');\n\n  if (href == null) {\n    return afterThe(node, -1);\n  }\n\n  const linkURL = new URL(href, element.ownerDocument.baseURI);\n\n  return afterThe(node, calcNavLinkWeight(linkURL, page.url));\n}\n\n/**\n * @internal\n */\nfunction calcNavLinkWeight(linkURL: URL, pageURL: URL): number {\n  if (linkURL.origin !== pageURL.origin) {\n    return -1;\n  }\n\n  const linkDir = navLinkPath2dir(linkURL);\n  const pageDir = navLinkPath2dir(pageURL);\n\n  if (linkURL.hash) {\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    // Require search parameters to be equal\n\n    const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n    if (searchParamWeight < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n      return -1;\n    }\n\n    return linkURL.pathname.length\n        + searchParamWeight\n        + calcNavLinkWeight(getHashURL(linkURL), getHashURL(pageURL));\n  }\n\n  const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n  if (searchParamWeight) {\n    if (searchParamWeight < 0) {\n      return -1;\n    }\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    return linkURL.pathname.length + searchParamWeight;\n  }\n\n  if (!pageDir.startsWith(linkDir)) {\n    return -1;\n  }\n\n  return linkURL.pathname.length;\n}\n\n/**\n * @internal\n */\nfunction navLinkPath2dir(url: URL): string {\n\n  const path = url.pathname;\n\n  return path.endsWith('/') ? path : path + '/';\n}\n\n/**\n * @internal\n */\nfunction navLinkSearchParamsWeight(\n    { searchParams: linkParams }: URL,\n    { searchParams: pageParams }: URL,\n): number {\n\n  let weight = 0;\n\n  linkParams.forEach((value, key) => {\n    if (!isIgnoredSearchParam(key)) {\n      if (weight >= 0) {\n        if (pageParams.getAll(key).includes(value)) {\n          weight += 1;\n        } else {\n          weight = -1;\n        }\n      }\n    }\n  });\n\n  return weight;\n}\n\n/**\n * @internal\n */\nfunction isIgnoredSearchParam(key: string): boolean {\n  return key.startsWith('__') && key.endsWith('__');\n}\n\n/**\n * @internal\n */\nconst NavLinkRenderSchedule__symbol = (/*#__PURE__*/ Symbol('nav-link-render-schedule'));\n\n/**\n * @internal\n */\nconst defaultActiveNavLinkClass: QualifiedName = ['active', Wesib__NS];\n\n/**\n * @internal\n */\ninterface RenderedElement extends Element {\n\n  [NavLinkRenderSchedule__symbol]?: RenderSchedule;\n\n}\n\n/**\n * @internal\n */\nfunction activateNavLink(\n    context: ComponentContext,\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => ActiveNavLink {\n\n  const scheduler = context.get(ElementRenderScheduler);\n  const { render, active = defaultActiveNavLinkClass } = def;\n  const activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n  const activate = def.activate ? def.activate.bind(def) : noop;\n  const assignClass = (active: boolean, { node }: { node: ElementNode }): void => {\n\n    const { element } = node as { element: Element };\n    const { classList } = element;\n\n    if (active) {\n      classList.add(activeClass);\n    } else {\n      classList.remove(activeClass);\n    }\n  };\n\n  return opts => {\n\n    const { element } = opts.node as { element: RenderedElement };\n    const schedule = element[NavLinkRenderSchedule__symbol]\n        || (element[NavLinkRenderSchedule__symbol] = scheduler(render));\n    const makeActive = (active: boolean): void => {\n      schedule(() => assignClass(active, opts));\n      activate(active, opts);\n    };\n\n    makeActive(true);\n\n    let lastSupply: Supply | undefined;\n\n    return {\n      supply(): Supply {\n\n        const supply = lastSupply = new Supply(() => {\n          if (lastSupply === supply) {\n            makeActive(false);\n          }\n        });\n\n        return supply;\n      },\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { onceAfter } from '@proc7ts/fun-events';\nimport { Class, setOfElements } from '@proc7ts/primitives';\nimport { Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Creates component decorator that handles events (e.g. clicks) on navigation links.\n *\n * Such events would lead to {@link Navigation navigation actions} instead of default ones.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Navigation links handler definition.\n *\n * @returns New component decorator.\n */\nexport function HandleNavLinks<T extends ComponentClass = Class>(\n    def: HandleNavLinksDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const handle = def.handle ? def.handle.bind(def) : defaultHandleNavLinks(def);\n  const events = setOfElements(def.event || 'click');\n\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n        context.whenConnected(() => {\n\n          const navigation = context.get(Navigation);\n\n          for (const eventType of events) {\n            context.on(eventType)(event => {\n              navigation.read.do(onceAfter)(\n                  page => handle({\n                    event,\n                    page,\n                    context,\n                    navigation,\n                  }),\n              );\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation links handler definition.\n *\n * @typeParam T - A type of component.\n */\nexport interface HandleNavLinksDef<T extends object = any> {\n\n  /**\n   * Type or types of events to handle.\n   *\n   * `click` by default.\n   */\n  readonly event?: string | readonly string[];\n\n  /**\n   * Handles event by performing navigation action.\n   *\n   * Every {@link event} sent by one of elements inside decorated component is passed to this function. In response\n   * it may perform a navigation event.\n   *\n   * By default handles events on anchor tags. When such tag contains an `href` attribute containing same-origin URL\n   * it {@link Navigation.open opens} a page at this URL instead of default action. It also prevents navigation\n   * if URL didn't change.\n   *\n   * @param event - A click event to handle.\n   * @param page - Current navigation page.\n   * @param navigation - Navigation service to use.\n   * @param context - Component context.\n   */\n  handle?(\n      {\n        event,\n        page,\n        navigation,\n        context,\n      }: {\n        event: Event;\n        page: Page;\n        navigation: Navigation;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n  /**\n   * Extracts hyper-reference of clicked element.\n   *\n   * Extracts hyper-reference from `href` attribute of event target.\n   *\n   * @param event - A click event to handle.\n   *\n   * @returns Extracted hyper-reference, or nothing if it can not be extracted. Event will be ignored in this case.\n   */\n  href?(event: Event): string | undefined | null;\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkHref(event: Event): string | null {\n\n  const target = event.target as Element;\n\n  return target.getAttribute('href');\n}\n\n/**\n * @internal\n */\nfunction defaultHandleNavLinks(\n    def: HandleNavLinksDef,\n): (\n    opts: {\n      event: Event;\n      page: Page;\n      navigation: Navigation;\n    },\n) => void {\n\n  const getHref = def.href ? def.href.bind(def) : defaultNavLinkHref;\n\n  return ({\n    event,\n    page,\n    navigation,\n  }) => {\n\n    const href = getHref(event);\n\n    if (href == null) {\n      return;\n    }\n\n    const target = event.target as Element;\n    const pageURL = page.url;\n    const url = new URL(href, target.ownerDocument.baseURI);\n\n    if (url.origin !== pageURL.origin) {\n      return; // External link\n    }\n\n    event.preventDefault();\n    if (pageURL.href !== url.href) {\n      navigation.open(href).catch(console.error);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { itsEach, overArray } from '@proc7ts/push-iterator';\nimport { isElement } from '@wesib/wesib';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @typeParam TNode - DOM node type.\n * @param from - The node to import.\n * @param to - The node to append imported node to.\n * @param importContent - A function that imports nodes nested in parent element. {@link importNodeContent} by default.\n *\n * @returns Imported node.\n */\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    importContent?: (this: void, from: TNode, to: TNode) => void,\n): TNode;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @typeParam TNode - DOM node type.\n * @param from - The node to import.\n * @param to - The node to append imported node to.\n * @param before - The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent - A function that imports nodes nested in parent element. {@link importNodeContent} by default.\n *\n * @returns Imported node.\n */\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: TNode, to: TNode) => void,\n): TNode;\n\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: TNode, to: TNode) => void),\n    importContent: (this: void, from: TNode, to: TNode) => void = importNodeContent,\n): TNode {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = to.ownerDocument!;\n\n  if (isElement(from)) {\n\n    const elementClone = doc.createElement(from.tagName.toLowerCase()) as Node as (Element & TNode);\n\n    from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)!));\n    importContent(from, elementClone);\n    to.insertBefore(elementClone, before);\n\n    return elementClone;\n  }\n\n  const nodeClone = doc.importNode(from, false);\n\n  to.insertBefore(nodeClone, before);\n\n  return nodeClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from - The node which contents to import.\n * @param to - The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  itsEach(\n      overArray(from.childNodes),\n      node => importNode(node, to),\n  );\n}\n","import { OnEvent, onEventBy, supplyOn, trackValue, valueOn_ } from '@proc7ts/fun-events';\nimport { asis, Supply } from '@proc7ts/primitives';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: Supply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = new Supply(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.cuts(trackSupply).cuts(tracker);\n\n        tracked = {\n          on: tracker.read.do(valueOn_(asis)),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on.do(supplyOn(supply))(receiver).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          }).catch(console.error);\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  mapOn_,\n  OnEvent,\n  onEventBy,\n  shareOn,\n  supplyOn,\n} from '@proc7ts/fun-events';\nimport { neverSupply, noop, Supply } from '@proc7ts/primitives';\nimport { flatMapIt, itsEach, itsEvery, overIterator, PushIterable } from '@proc7ts/push-iterator';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\nclass PageLoadRequestsParam$ extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam$();\n\n/**\n * @internal\n */\nexport class PageLoadRequests {\n\n  private readonly _map = new Map<Supply, PageLoadReq[]>();\n  private readonly _requests: PushIterable<PageLoadReq>;\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {\n    this._requests = flatMapIt(overIterator(() => this._map.values()));\n  }\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    if (!itsEvery(\n        this._requests,\n        request => {\n          if (!request.fragment) {\n            return false;\n          }\n          result.push(request.fragment);\n          return true;\n        },\n    )) {\n      return [];\n    }\n\n    return result;\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = new Supply();\n    let loadSupply = neverSupply();\n\n    return {\n      get() {/* void */},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page, when) {\n        if (when === 'pretend') {\n          return;\n        }\n\n        const transferred = self._transfer();\n\n        to.put(PageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = new Supply().needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page).do(supplyOn(loadSupply))(\n              response => emitter.send(response),\n          ).whenOff(error => {\n            if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n              // Report current page load error as failed load response\n              emitter.send({\n                ok: false as const,\n                page,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error,\n              });\n            }\n          });\n\n          return supply;\n        }).do(shareOn);\n\n        itsEach(\n            self._requests,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment)({\n              supply: new Supply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest): void {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, list.slice());\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.do(\n          mapOn_(\n              response => response.ok\n                  ? {\n                    ...response,\n                    fragment: (\n                        fragment.tag != null\n                            ? response.document.getElementsByTagName(fragment.tag)[0]\n                            : response.document.getElementById(fragment.id)\n                    ) || undefined,\n                  }\n                  : response,\n          ),\n      )\n      : onLoad;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/push-iterator\n */\nimport { itsIterated } from './its-iterated';\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to test elements of.\n * @param test - A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(\n    iterable: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): boolean {\n\n  let allMatch = true;\n\n  itsIterated(\n      iterable,\n      element => {\n        allMatch = !!test(element);\n        if (!allMatch) {\n          return false;\n        }\n        return;\n      },\n  );\n\n  return allMatch;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next - Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request - HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under {@link PageLoadAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request - HTTP request.\n   *\n   * @returns An `OnEvent` sender of page load response.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an {@link PageLoadAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { noop, valueProvider } from '@proc7ts/primitives';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url - An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> = (\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) })\n);\n","import { hthvParse, hthvQuote } from '@hatsy/http-header-value';\nimport { SingleContextKey } from '@proc7ts/context-values';\nimport { afterThe, digOn_, EventNotifier, mapOn_, OnEvent, onEventBy, resolveOnOrdered } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = (/*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n));\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser = new window.DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ Accept: 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request)(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      requestPageFragments(page, fetchRequest);\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const dispatcher = new EventNotifier<[PageLoadResponse]>();\n\n        dispatcher.on(receiver);\n        dispatcher.send({ page });\n\n        httpFetch(fetchRequest).do(\n            mapOn_(response => Promise.all([response, response.text()])),\n            resolveOnOrdered,\n            digOn_((...batch: [Response, string][]) => afterThe<[Response, string][]>(...batch)),\n            mapOn_(([response, text]): PageLoadResponse => {\n              if (!response.ok) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error: response.status,\n                };\n              }\n              try {\n                return {\n                  ok: true as const,\n                  page,\n                  response,\n                  document: parsePageDocument(parser, url, response, text),\n                };\n              } catch (error) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                  error,\n                };\n              }\n            }),\n        )(receiver);\n      });\n    }\n  };\n}\n\nfunction requestPageFragments(page: Page, request: Request): void {\n\n  const fragments = page.get(PageLoadRequestsParam)?.fragments;\n\n  if (fragments && fragments.length) {\n    request.headers.set(\n        'Accept-Fragment',\n        fragments.reduce(\n            (header, fragment) => (header ? header + ', ' : '') + (\n                fragment.tag != null\n                    ? 'tag=' + hthvQuote(fragment.tag)\n                    : 'id=' + hthvQuote(fragment.id)\n            ),\n            '',\n        ),\n    );\n  }\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as DOMParserSupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventSupplier } from '../base';\nimport { eventDig } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onSupplied } from '../senders';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that extracts event senders from incoming events.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event supplier from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New event processor.\n */\nexport function digOn<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventSupplier<TOutEvent> | void | undefined,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const processor = digOn_(extract);\n\n  return input => shareOn(processor(input));\n}\n\n/**\n * Creates an event processor that extracts event senders from incoming events, and does not share the outgoing events\n * supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event supplier from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New event processor.\n */\nexport function digOn_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventSupplier<TOutEvent> | void | undefined,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const extractSender = (...event: TInEvent): OnEvent<TOutEvent> | void => {\n\n    const extracted = extract(...event);\n\n    return extracted && onSupplied(extracted);\n  };\n\n  return input => onEventBy(eventDig(input, extractSender));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nclass PageLoadParam$ extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext): PageParam.Handle<void, PageLoadRequest> {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(PageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const PageLoadParam: PageParam<void, PageLoadRequest> = (/*#__PURE__*/ new PageLoadParam$());\n","import { ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { AfterEvent, afterThe, mapOn_ } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = (/*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<PageLoadURLModifier[]>;\n  readonly agent: AfterEvent<PageLoadAgent[]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe(\n          (next, request) => next(new Request(request.url, request)).do(\n              mapOn_(response => {\n                    if (response.ok) {\n\n                      const newRev = appRev(response.document);\n\n                      if (newRev && newRev !== rev) {\n\n                        const url = new URL(response.page.url.href);\n\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                      }\n                    }\n\n                    return response;\n                  }),\n          ),\n      );\n    }\n  }\n\n}\n\nfunction appRev(doc: Document): string | null | undefined {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { filterArray, filterIt, itsEach, mapIt, PushIterable } from '@proc7ts/push-iterator';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(\n      mapOn_(response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, doc.scripts),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, response.document.querySelectorAll('script')),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      }),\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: ArrayLike<HTMLScriptElement>,\n): PushIterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterArray(scripts, ({ src }) => !!src),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { itsEach, itsFirst, overArray } from '@proc7ts/push-iterator';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(\n      mapOn_(response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      }),\n  );\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(mapOn_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    });\n    setup.provide({\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    });\n    setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n    setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n    setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n  },\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { onceAfter } from '@proc7ts/fun-events';\nimport { Class, noop, Supply, valueProvider } from '@proc7ts/primitives';\nimport {\n  BootstrapWindow,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  ElementRenderScheduler,\n  RenderDef,\n} from '@wesib/wesib';\nimport { importNodeContent } from '../../util';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageLoadParam } from './page-load-param';\nimport { PageFragmentRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadSupport } from './page-load-support.feature';\n\n/**\n * Creates component decorator that includes page contents into decorated component's element.\n *\n * The page is loaded and included whenever it is {@link Navigation.onEnter entered}.\n *\n * Utilizes {@link PageLoadParam} navigation parameter.\n *\n * Enables {@link PageLoadSupport} feature.\n *\n * @typeParam T - A type of decorated component class.\n * @param def - Page inclusion definition.\n *\n * @returns New component decorator.\n */\nexport function IncludePage<T extends ComponentClass = Class>(\n    def: IncludePageDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const onResponse = def.onResponse ? def.onResponse.bind(def) : noop;\n  const contentKey: (page: Page) => string | undefined = def.contentKey\n      ? def.contentKey.bind(def)\n      : defaultPageContentKey;\n\n  return Component({\n    feature: {\n      needs: [PageLoadSupport],\n    },\n    define(context) {\n      context.whenComponent(context => {\n\n        const { fragment, render } = def;\n        const document = context.get(BootstrapWindow).document;\n        const schedule = context.get(ElementRenderScheduler)(render);\n        const navigation = context.get(Navigation);\n        let lastPageURL = contentKey(navigation.page);\n        let detectFragment: () => PageFragmentRequest;\n\n        if (fragment) {\n          detectFragment = valueProvider(fragment);\n        } else {\n          detectFragment = () => {\n\n            const { element: { id, tagName: tag } } = context as { element: Element };\n\n            return id ? { id } : { tag };\n          };\n        }\n\n        context.whenConnected(() => {\n\n          const range = document.createRange();\n\n          range.selectNodeContents(context.contentRoot);\n\n          navigation.read.do(onceAfter)(page => {\n            page.put(\n                PageLoadParam,\n                {\n                  fragment: detectFragment(),\n                  receiver: {\n                    supply: new Supply().needs(context),\n                    receive: (_ctx, response) => handleResponse(response),\n                  },\n                },\n            );\n          });\n\n          function handleResponse(response: PageLoadResponse): void {\n\n            const newPageURL = contentKey(response.page);\n\n            if (newPageURL === lastPageURL) {\n              return; // Only hash changed. Do not refresh the page.\n            }\n\n            if (!response.ok) {\n              schedule(() => onResponse({ context, range, response }));\n              return;\n            }\n\n            lastPageURL = newPageURL;\n            schedule(() => {\n              range.deleteContents();\n\n              const target = document.createDocumentFragment();\n              const { fragment } = response;\n\n              if (fragment) {\n                importNodeContent(fragment, target);\n                range.insertNode(target);\n              }\n\n              onResponse({ context, range, response });\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction defaultPageContentKey({ url }: Page): string {\n  return new URL('', url).href;\n}\n\n/**\n * Page inclusion definition.\n *\n * Configures {@link IncludePage @LoadPage} decorator.\n *\n * @typeParam T - A type of component.\n */\nexport interface IncludePageDef<T extends object = any> {\n\n  /**\n   * Page fragment to include.\n   *\n   * By default uses custom element identifier if present, or element tag name otherwise.\n   */\n  readonly fragment?: PageFragmentRequest;\n\n  /**\n   * Rendering options.\n   */\n  readonly render?: RenderDef.Options;\n\n  /**\n   * Builds content key for the given page.\n   *\n   * The loaded content will replace already included one only when their content key differ.\n   *\n   * By default uses page URL without hash part as a key. This prevents content refresh when only URL hash changes.\n   *\n   * @param page - Target page. Either loaded or not.\n   *\n   * @returns Content key.\n   */\n  contentKey?(page: Page): any;\n\n  /**\n   * Performs additional actions during page load.\n   *\n   * This method is called inside page contents render schedule for {@link PageLoadResponse each stage} of page\n   * load. At the final stage it is called after loaded page contents included.\n   *\n   * This method can be used e.g. to indicate the page load progress.\n   *\n   * @param context - Decorated component context.\n   * @param response - Page load response.\n   * @param range - Document range the loaded page contents going to replace.\n   */\n  onResponse?(\n      {\n        context,\n        response,\n        range,\n      }: {\n        context: ComponentContext<T>;\n        response: PageLoadResponse;\n        range: Range;\n      },\n  ): void;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InConverter, InNamespaceAliaser, InRenderScheduler, intoConvertedBy } from '@frontmeans/input-aspects';\nimport { ContextSupply, ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, EventKeeper, mapAfter, supplyAfter } from '@proc7ts/fun-events';\nimport { DefaultNamespaceAliaser, ElementRenderScheduler } from '@wesib/wesib';\n\n/**\n * Default input aspects.\n *\n * This is an `AfterEvent` keeper of aspect converter meant to be applied to controls.\n *\n * As a bare minimum it assigns the following aspects to converted controls:\n * - `InRenderScheduler` set to `ElementRenderScheduler`,\n * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n *\n * More input aspect converters may be registered in context. They may override the default ones.\n */\nexport type DefaultInAspects = AfterEvent<[InConverter.Aspect<any, any>]>;\n\n/**\n * @internal\n */\nclass DefaultInAspectsKey\n    extends ContextUpKey<AfterEvent<[InConverter.Aspect<any, any>]>, InConverter.Aspect<any, any>> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor() {\n    super('default-in-aspects');\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          AfterEvent<[InConverter.Aspect<any, any>]>,\n          EventKeeper<InConverter.Aspect<any, any>[]> | InConverter.Aspect<any, any>,\n          AfterEvent<InConverter.Aspect<any, any>[]>>,\n  ): void {\n\n    const nsAlias = slot.context.get(DefaultNamespaceAliaser);\n    const scheduler = slot.context.get(ElementRenderScheduler);\n\n    slot.insert(\n        slot.seed.do(\n            mapAfter((...fns) => intoConvertedBy(\n                ...fns,\n                InRenderScheduler.to(scheduler),\n                InNamespaceAliaser.to(nsAlias),\n            )),\n            supplyAfter(slot.context.get(ContextSupply)),\n        ),\n    );\n  }\n\n}\n\n/**\n * A key of component context containing default input aspects.\n */\nexport const DefaultInAspects: ContextUpRef<DefaultInAspects, InConverter.Aspect<any, any>> = (\n    /*#__PURE__*/ new DefaultInAspectsKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InControl } from '@frontmeans/input-aspects';\nimport { SingleContextUpKey, SingleContextUpRef } from '@proc7ts/context-values/updatable';\nimport { Supply } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\n\n/**\n * A user input originated from control.\n *\n * It is meant to be present in root {@link HierarchyContext hierarchy context}. Nested components may access it from\n * their hierarchy contexts to participate in user input.\n *\n * An {@link inputFromControl} function can be used to initiate user input.\n *\n * @typeParam TValue - Input value type.\n */\nexport interface InputFromControl<TValue = any> {\n\n  /**\n   * Root component context the input is initiated for.\n   */\n  readonly root: ComponentContext;\n\n  /**\n   * User input control.\n   */\n  readonly control: InControl<TValue>;\n\n}\n\n/**\n * No user input originated from control.\n */\nexport interface NoInputFromControl {\n  control?: undefined;\n}\n\n/**\n * A key of hierarchy context value containing a user input originated from control. Potentially\n * {@link NoInputFromControl absent}.\n */\nexport const InputFromControl: SingleContextUpRef<InputFromControl | NoInputFromControl> = (\n    /*#__PURE__*/ new SingleContextUpKey<InputFromControl | NoInputFromControl>(\n        'input-from-control',\n        {\n          byDefault: () => ({}),\n        },\n    )\n);\n\n/**\n * Initiates user input from the given control for the given root component.\n *\n * Constructs an {@link InputFromControl} instance and makes it available in `root` component's hierarchy.\n *\n * @typeParam TValue - Input value type.\n * @param root - Root component context to initiate user input for.\n * @param control - User input control.\n *\n * @returns User input supply. The user input would be stopped once this supply is cut off.\n */\nexport function inputFromControl<TValue>(\n    root: ComponentContext,\n    control: InControl<TValue>,\n): Supply {\n  return root.get(HierarchyContext)\n      .provide({\n        a: InputFromControl,\n        by: () => ({\n          root,\n          control,\n        }),\n      })\n      .needs(root)\n      .needs(control);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { produceBasicStyle, StypFormat, StypRules } from '@frontmeans/style-producer';\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { Supply } from '@proc7ts/primitives';\nimport { bootstrapDefault } from '@wesib/wesib';\n\n/**\n * Component style producer signature.\n */\nexport type ComponentStyleProducer =\n/**\n * @param rules - CSS rules to produce stylesheets for. This can be e.g. a `StypRule.rules` to render all rules,\n * or a result of `StypRuleList.grab()` method call to render only matching ones.\n * @param format - Style production format.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\n    (\n        rules: StypRules,\n        format: StypFormat,\n    ) => Supply;\n\n/**\n * A key of bootstrap, definition, or component context value containing a component style producer.\n *\n * Utilizes `produceBasicStyle()` by default. I.e. it does not enable default renderers. To enable them all a\n * {@link StyleProducerSupport} can be used.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n */\nexport const ComponentStyleProducer: SingleContextRef<ComponentStyleProducer> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentStyleProducer>(\n        'component-style-producer',\n        {\n          byDefault: bootstrapDefault(() => produceBasicStyle),\n        },\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { StypDomFormatConfig } from '@frontmeans/style-producer';\nimport {\n  BootstrapWindow,\n  ComponentContext,\n  DefaultNamespaceAliaser,\n  ElementRenderScheduler,\n  RenderDef,\n} from '@wesib/wesib';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * Builds configuration of DOM style production format.\n *\n * Schedules style rendering in `ElementRenderScheduler` by default.\n *\n * Utilizes `DefaultNamespaceAliaser` by default.\n *\n * @param format - Target component style production format.\n * @param config - Original component style production format configuration.\n * @param render - Element render definition to apply to style render schedule, unless render scheduler specified\n * explicitly in `config`.\n *\n * @returns Configuration of DOM style production format.\n */\nexport function componentStypDomFormatConfig(\n    format: ComponentStypFormat,\n    config: ComponentStypFormatConfig & StypDomFormatConfig = {},\n    render?: RenderDef,\n): StypDomFormatConfig {\n\n  const { context } = format;\n\n  return {\n    ...config,\n    document: config.document || context.get(BootstrapWindow).document,\n    parent: config.parent || context.contentRoot,\n    rootSelector: [],\n    scheduler: config.scheduler || defaultStypRenderScheduler(context, render),\n    nsAlias: config.nsAlias || context.get(DefaultNamespaceAliaser),\n    renderer: format.renderer(config),\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultStypRenderScheduler(\n    context: ComponentContext,\n    render: RenderDef = {},\n): ElementRenderScheduler {\n\n  const scheduler = context.get(ElementRenderScheduler);\n\n  return (opts = {}) => scheduler({ ...opts, ...render });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { StypRenderer } from '@frontmeans/style-producer';\nimport { MultiContextKey, MultiContextRef } from '@proc7ts/context-values';\n\n/**\n * A CSS renderer that will be enabled by default by {@link ComponentStypFormat component style production format}.\n */\nexport type ComponentStypRenderer = StypRenderer;\n\n/**\n * A key of component context value containing component CSS renderers.\n */\nexport const ComponentStypRenderer: MultiContextRef<ComponentStypRenderer> = (\n    /*#__PURE__*/ new MultiContextKey<ComponentStypRenderer>('component-styp-renderer')\n);\n","import { css__naming, html__naming, NamespaceDef, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { ContextValues, SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext, DefaultNamespaceAliaser, ElementDef } from '@wesib/wesib';\n\n/**\n * @internal\n */\nexport type ElementIdClass = QualifiedName;\n\n/**\n * @internal\n */\nexport const ElementIdClass__NS = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns/element-id-class',\n    'elic',\n    'element-id-class',\n));\n\n/**\n * @internal\n */\nexport const ElementIdClass: SingleContextRef<ElementIdClass> = (/*#__PURE__*/ new SingleContextKey(\n    'unique-element-class',\n    { byDefault: assignElementId },\n));\n\n/**\n * @internal\n */\nlet uniqueClassSeq = 0;\n\n/**\n * @internal\n */\nfunction assignElementId(contextValues: ContextValues): ElementIdClass {\n\n  const aliaser = contextValues.get(DefaultNamespaceAliaser);\n  const context = contextValues.get(ComponentContext);\n  const elementDef = context.get(ElementDef);\n  const name: string = elementDef.name ? html__naming.name(elementDef.name, aliaser) : 'component';\n  const local = `${name}#${++uniqueClassSeq}`;\n  const qualified = ElementIdClass__NS.name(aliaser(ElementIdClass__NS), local, css__naming);\n  const element = context.element as Element;\n\n  element.classList.add(qualified);\n\n  return qualified;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { RenderScheduler } from '@frontmeans/render-scheduler';\nimport {\n  lazyStypRules,\n  StypFormat,\n  StypFormatConfig,\n  stypObjectFormat,\n  StypObjectFormatConfig,\n  StypPureSelector,\n  StypRenderer,\n  StypRules,\n  StypSelector,\n  stypSelector,\n  StypSubSelector,\n} from '@frontmeans/style-producer';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { elementOrArray, extendSetOfElements, setOfElements, Supply, valueProvider } from '@proc7ts/primitives';\nimport { ComponentContext, ShadowContentRoot } from '@wesib/wesib';\nimport { ComponentStyleProducer } from './component-style-producer';\nimport { componentStypDomFormatConfig } from './component-styp-dom.format-config';\nimport { ComponentStypRenderer } from './component-styp-renderer';\nimport { ElementIdClass } from './element-id-class.impl';\n\n/**\n * Configuration of {@link ComponentStypFormat component style production format}.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n */\nexport interface ComponentStypFormatConfig extends StypFormatConfig {\n\n  /**\n   * Structured CSS selector to use for custom element's host.\n   *\n   * It modifies the selectors of produced CSS rules.\n   *\n   * For custom element with shadow root:\n   * - Replaces root CSS rule selector with `:host(<hostSelector>).\n   * - When `hostSelector` is omitted, then replaces root CSS rule selector with `:host`.\n   * - If CSS rule selector starts with `:host`, then replaces `:host` with `:host(<hostSelector>)`\n   * - If CSS rule selector starts with `:host(<selector>)`, then extends `<selector>` by `hostSelector`.\n   *   I.e. appends CSS classes and sub-selectors to it, and fulfills missing element and identifier selectors.\n   *\n   * For custom element without shadow root either uses provided `hostSelector`, or generates a unique one when omitted.\n   * And additionally:\n   * - Replaces root CSS rule selector it with `hostSelector`.\n   * - If CSS rule selector starts with `:host`, then replaces `:host` with `hostSelector`.\n   * - If CSS rule selector starts with `:host(<selector>), then replaces `:host(<selector>)` with `<selector>` extended\n   *   by `hostSelector`. I.e. appends CSS classes and sub-selectors to it, and fulfills missing element and identifier\n   *   selectors.\n   * - Otherwise prepends CSS rule selector with `hostSelector`.\n   *\n   * This selector should not contain a `:host` sub-selector.\n   */\n  readonly hostSelector?: StypPureSelector.Part | string;\n\n  /**\n   * Root CSS selector is never used for custom elements. A `hostSelector` is applied instead.\n   */\n  readonly rootSelector?: undefined;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * `ElementRenderScheduler` is used when omitted.\n   */\n  readonly scheduler?: RenderScheduler;\n\n  /**\n   * Namespace aliaser to use.\n   *\n   * `DefaultNamespaceAliaser` is used when omitted.\n   */\n  readonly nsAlias?: NamespaceAliaser;\n\n}\n\nconst ComponentStypFormat__symbol = (/*#__PURE__*/ new SingleContextKey<ComponentStypFormat>(\n    'component-styp-format',\n    {\n      byDefault(context) {\n        return new ComponentStypObjectFormat(context.get(ComponentContext));\n      },\n    },\n));\n\n/**\n * Component style production format.\n *\n * This format can be obtained from component context.\n *\n * The formats implemented:\n * - {@link ComponentStypObjectFormat} (the default) renders CSS using CSS object model.\n * - {@link ComponentStypDomFormat} renders CSS as text. May render CSS of disconnected element.\n */\nexport abstract class ComponentStypFormat {\n\n  /**\n   * A key of component context value containing its style production format.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentStypFormat> {\n    return ComponentStypFormat__symbol;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext;\n\n  /**\n   * Produces and dynamically updates component's CSS stylesheets based on the given CSS rules.\n   *\n   * Utilizes {@link newProducer component's producer function}.\n   *\n   * @param rules - A source of CSS rules to produce stylesheets for.\n   * @param config - Style production format configuration.\n   *\n   * @returns CSS rules supply. Once cut off the produced stylesheets are removed.\n   */\n  produce(\n      rules: StypRules.Source,\n      config?: ComponentStypFormatConfig,\n  ): Supply {\n\n    const producer = this.newProducer(rules, config);\n    const supply = new Supply();\n\n    this.context.whenSettled(() => {\n      producer().needs(supply).cuts(supply);\n    });\n\n    return supply;\n  }\n\n  /**\n   * Creates component's CSS stylesheets producer based on the given CSS rules.\n   *\n   * Utilizes {@link ComponentStyleProducer}.\n   *\n   * @param rules - A source of CSS rules to produce stylesheets for.\n   * @param config - Style production format configuration.\n   *\n   * @returns CSS rules producer function returning CSS rules supply. Once cut off the produced stylesheets are removed.\n   */\n  newProducer(\n      rules: StypRules.Source,\n      config?: ComponentStypFormatConfig,\n  ): (this: void) => Supply {\n\n    const css = lazyStypRules(rules);\n    let producer: () => Supply;\n    const componentSupply = this.context.supply;\n\n    producer = () => {\n\n      const produceStyle = this.context.get(ComponentStyleProducer);\n\n      return produceStyle(css, this.format(config)).needs(componentSupply);\n    };\n\n    // In case the component destroyed already, the producer will be reassigned here _before_ return.\n    componentSupply.whenOff(() => {\n      // Prevent style production once component destroyed.\n      producer = valueProvider(componentSupply);\n    });\n\n    return () => producer();\n  }\n\n  /**\n   * Builds CSS style production format to by its config.\n   *\n   * This method is called by {@link produce} one.\n   *\n   * @param config - Component style production format configuration.\n   *\n   * @returns Component style production format.\n   */\n  abstract format(config?: ComponentStypFormatConfig): StypFormat;\n\n  /**\n   * Builds component-specific style renderer.\n   *\n   * This renderer applies {@link ComponentStypFormatConfig.hostSelector host selector} to generated CSS rules.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config - Component style production format configuration.\n   *\n   * @returns Component style renderer(s).\n   */\n  renderer(\n      config: ComponentStypFormatConfig,\n  ): StypRenderer | readonly StypRenderer[] | undefined {\n\n    const shadowRoot = this.context.get(ShadowContentRoot, { or: null });\n    const { renderer } = config;\n    const renderers = extendSetOfElements(\n        setOfElements<StypRenderer>(renderer),\n        this.context.get(ComponentStypRenderer),\n    );\n\n    const hostSelector = config.hostSelector\n        ? stypSelector(config.hostSelector)[0] as StypPureSelector.NormalizedPart\n        : undefined;\n\n    renderers.add(shadowRoot\n        ? shadowRenderer(hostSelector)\n        : noShadowRenderer(hostSelector || { c: [this.context.get(ElementIdClass)] }));\n\n    return elementOrArray(renderers);\n  }\n\n}\n\n\n/**\n * @internal\n */\nfunction shadowRenderer(hostSelector: StypPureSelector.NormalizedPart | undefined): StypRenderer {\n  return {\n    order: -100,\n    render(producer, properties) {\n\n      let { selector } = producer;\n\n      if (!selector.length) {\n        selector = [hostSelector || { u: [[':', 'host']] }];\n      } else if (hostSelector) {\n\n        const [rest, host] = extractHostSelector(selector);\n\n        if (host) {\n          if (host.length) {\n            selector = [{ u: [[':', 'host', extendHostSelector(host, hostSelector)]] }, ...rest];\n          } else {\n            selector = [{ u: [[':', 'host', [hostSelector]]] }, ...rest];\n          }\n        }\n      }\n\n      producer.render(properties, { selector });\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction noShadowRenderer(hostSelector: StypPureSelector.NormalizedPart): StypRenderer {\n  return {\n    order: -100,\n    render(producer, properties) {\n\n      let { selector } = producer;\n\n      if (!selector.length) {\n        selector = [hostSelector];\n      } else {\n\n        const [rest, host] = extractHostSelector(selector);\n\n        if (host && host.length) {\n          selector = [...extendHostSelector(host, hostSelector), ...rest];\n        } else {\n          selector = [hostSelector, ...rest];\n        }\n      }\n\n      producer.render(properties, { selector });\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction extractHostSelector(\n    selector: StypSelector.Normalized,\n): [StypSelector.Normalized, StypSelector.Normalized?] {\n  if (typeof selector[0] !== 'string') {\n\n    const [{ ns, e, i, c, u, s, $ }, ...restParts] = selector;\n\n    if (!ns && !e && !i && !c && !s && u) {\n\n      const [[prefix, name, ...params]] = u;\n\n      if (prefix === ':' && name === 'host') {\n\n        let host: StypSelector.Mutable;\n\n        if (params.length) {\n          host = (params[0] as StypSubSelector.NormalizedParameter).slice();\n          (host[0] as { $?: string | readonly string[] }).$ = $;\n        } else {\n          host = $ ? [{ $ }] : [];\n        }\n\n        return [restParts, host];\n      }\n    }\n  }\n  return [selector];\n}\n\n/**\n * @internal\n */\nfunction extendHostSelector(\n    selector: StypSelector.Normalized,\n    {\n      ns,\n      e,\n      i,\n      c,\n      u,\n      s,\n    }: StypPureSelector.NormalizedPart,\n): StypSelector.Normalized {\n\n  const [first, ...rest] = selector as [StypSelector.NormalizedPart, ...StypSelector.Normalized];\n\n  return [\n    {\n      ns: first.e || first.ns ? first.ns : ns,\n      e: first.e || first.ns ? first.e : e,\n      i: first.i || i,\n      c: first.c ? (c ? [...first.c, ...c] : first.c) as typeof c : c,\n      u: first.u ? (u ? [...first.u, ...u] : first.u) as typeof u : u,\n      s: ((first.s || '') + (s || '')) || undefined,\n      $: first.$,\n    },\n    ...rest,\n  ];\n}\n\n/**\n * Component's CSS object model production format.\n *\n * Renders CSS when component's element connected to document.\n *\n * This format is used by default.\n */\nexport class ComponentStypObjectFormat extends ComponentStypFormat {\n\n  /**\n   * Constructs CSS object model production format.\n   *\n   * @param context - Target component context.\n   */\n  constructor(readonly context: ComponentContext) {\n    super();\n  }\n\n  format(config?: ComponentStypFormatConfig & StypObjectFormatConfig): StypFormat {\n    return stypObjectFormat(this.config(config));\n  }\n\n  /**\n   * Builds configuration of CSS object model production format.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config - Original component style production format configuration.\n   *\n   * @returns Configuration of CSS object model production format.\n   */\n  config(config?: ComponentStypFormatConfig & StypObjectFormatConfig): StypObjectFormatConfig {\n    return componentStypDomFormatConfig(this, config, { when: 'connected' });\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { stypDomFormat, StypDomFormatConfig, StypFormat } from '@frontmeans/style-producer';\nimport { ComponentContext } from '@wesib/wesib';\nimport { componentStypDomFormatConfig } from './component-styp-dom.format-config';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * Component's DOM style production format.\n *\n * Renders CSS styles as text.\n *\n * This format is generally slower than {@link ComponentStypObjectFormat}, but allows to render styles before element\n * is connected to document.\n */\nexport class ComponentStypDomFormat extends ComponentStypFormat {\n\n  /**\n   * When to start component style rendering.\n   *\n   * One of:\n   * `settled` (the default) - to start rendering when component is settled.\n   * `connected` - to start rendering when component's element is connected to document.\n   */\n  readonly when: 'settled' | 'connected';\n\n  /**\n   * Constructs DOM style production format.\n   *\n   * @param context - Target component context.\n   * @param when - When to start style rendering. `settled` by default.\n   */\n  constructor(\n      readonly context: ComponentContext,\n      {\n        when = 'settled',\n      }: {\n        readonly when?: 'settled' | 'connected';\n      } = {},\n  ) {\n    super();\n    this.when = when;\n  }\n\n  format(config?: ComponentStypFormatConfig & StypDomFormatConfig): StypFormat {\n    return stypDomFormat(this.config(config));\n  }\n\n  /**\n   * Builds configuration of DOM style production format.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config - Original component style production format configuration.\n   *\n   * @returns Configuration of DOM style production format.\n   */\n  config(\n      config?: ComponentStypFormatConfig & StypDomFormatConfig,\n  ): StypDomFormatConfig {\n    return componentStypDomFormatConfig(this, config, { when: this.when });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { StypRule, StypRules } from '@frontmeans/style-producer';\nimport { ComponentClass, ComponentProperty, ComponentPropertyDecorator } from '@wesib/wesib';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * A decorator of component property returning CSS rules to produce.\n *\n * Decorated property value should either contain a CSS rules source of type `StypRules.Source` or be a method\n * returning it.\n *\n * Produces CSS using {@link ComponentStypFormat component style production format}.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n *\n * @typeParam T - A type of decorated component class.\n * @param config - Non-mandatory component style production format config.\n *\n * @returns Component property decorator.\n */\nexport function ProduceStyle<T extends ComponentClass>(\n    config?: ComponentStypFormatConfig,\n): ComponentPropertyDecorator<\n    | StypRules.Source\n    | (() => StypRule | StypRules | Promise<StypRule | StypRules>),\n    T> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(({ component }) => {\n\n            const value = get(component);\n            const source: StypRules.Source = typeof value === 'function' ? value.bind(component) : value;\n            const format = context.get(ComponentStypFormat);\n\n            format.produce(source, config);\n          });\n        });\n      },\n    },\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { produceStyle } from '@frontmeans/style-producer';\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { ComponentStyleProducer } from './component-style-producer';\n\n/**\n * @internal\n */\nconst StyleProducerSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: ComponentStyleProducer, is: produceStyle });\n  },\n};\n\n/**\n * Style producer support feature.\n *\n * This feature enables default CSS renderers.\n *\n * It is _not_ enabled automatically by {@link ProduceStyle @ProduceStyle} decorator.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n */\nexport class StyleProducerSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StyleProducerSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { stypRules, StypRules } from '@frontmeans/style-producer';\nimport { ContextRef, ContextValueSlot, IterativeContextKey } from '@proc7ts/context-values';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { Theme } from './theme';\n\n/**\n * Theme style provides part of the theme styling information.\n *\n * Theme style(s) can be provided in bootstrap context. They are applied to the theme at most once, when requested\n * by calling {@link Theme.style} method.\n *\n * Theme style is either a function, or an extension of another theme style.\n */\nexport type ThemeStyle = ThemeStyle.Provider | ThemeStyle.Extension;\n\nexport namespace ThemeStyle {\n\n  /**\n   * Theme style provider function.\n   *\n   * This function is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n   *\n   * This function is used as an identifier of particular style and can be extended using {@link ThemeStyle.Extension}.\n   *\n   * It is not absolutely necessary to register style provider. It will be applied on request anyway.\n   *\n   * @param theme - A theme to apply styling to.\n   *\n   * @returns Dynamically updated CSS rule set containing the applied styling.\n   */\n  export type Provider = (this: void, theme: Theme) => StypRules;\n\n  /**\n   * Theme style extension.\n   *\n   * An extension should be registered in bootstrap context in order to be applied.\n   */\n  export interface Extension {\n\n    /**\n     * A theme style provider to extend.\n     */\n    readonly style: ThemeStyle.Provider;\n\n    /**\n     * Extends the theme style.\n     *\n     * This method is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n     *\n     * It will be called after the style provider it extends.\n     *\n     * @param theme - A theme to apply styling to.\n     *\n     * @returns Dynamically updated CSS rule set containing the applied styling.\n     */\n    provide(theme: Theme): StypRules;\n\n  }\n\n  /**\n   * A function obtaining combined style provider. I.e. the one that applies the style along with all extensions.\n   *\n   * @param A - provider of theme style to apply.\n   *\n   * @returns A combined theme style provider.\n   */\n  export type ById = (this: void, style: ThemeStyle.Provider) => ThemeStyle.Provider;\n\n}\n\n/**\n * @internal\n */\nclass ThemeStyleKey extends IterativeContextKey<ThemeStyle.ById, ThemeStyle> {\n\n  constructor() {\n    super('theme-style');\n  }\n\n  grow(\n      slot: ContextValueSlot<ThemeStyle.ById, ThemeStyle, Iterable<ThemeStyle>>,\n  ): void {\n\n    const providers = new Map<ThemeStyle.Provider, [ThemeStyle.Provider, boolean]>();\n\n    itsEach(\n        slot.seed,\n        style => {\n\n          let key: ThemeStyle.Provider;\n          let provider: ThemeStyle.Provider;\n          let isId: boolean;\n\n          if (typeof style === 'function') {\n            key = provider = style;\n            isId = true;\n          } else {\n            key = style.style;\n            provider = style.provide.bind(style);\n            isId = false;\n          }\n\n          const prev = providers.get(key);\n\n          if (!prev) {\n            providers.set(key, [provider, isId]);\n          } else {\n\n            const [prevProvider, hasId] = prev;\n\n            providers.set(\n                key,\n                [\n                  isId ? combineStyles(provider, prevProvider) : combineStyles(prevProvider, provider),\n                  isId || hasId,\n                ],\n            );\n          }\n        },\n    );\n\n    if (providers.size || !slot.hasFallback) {\n      slot.insert(byId);\n    }\n\n    function byId(id: ThemeStyle.Provider): ThemeStyle.Provider {\n\n      const existing = providers.get(id);\n\n      if (!existing) {\n        return id;\n      }\n\n      const [provider, hasId] = existing;\n\n      return hasId ? provider : combineStyles(id, provider);\n    }\n  }\n\n}\n\n/**\n * A key of bootstrap context value containing theme styles.\n */\nexport const ThemeStyle: ContextRef<ThemeStyle.ById, ThemeStyle> = (/*#__PURE__*/ new ThemeStyleKey());\n\n/**\n * @internal\n */\nfunction combineStyles(first: ThemeStyle.Provider, second: ThemeStyle.Provider): ThemeStyle.Provider {\n  return theme => stypRules(first(theme), second(theme));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport {\n  lazyStypRules,\n  RefStypRule,\n  StypProperties,\n  stypRoot,\n  StypRule,\n  StypRuleRef,\n  StypRules,\n} from '@frontmeans/style-producer';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { ThemeStyle } from './theme-style';\n\nexport interface ThemeFactory {\n\n  newTheme(): Theme;\n\n}\n\n/**\n * @internal\n */\nconst Theme__key = (/*#__PURE__*/ new SingleContextKey<Theme>(\n    'theme',\n    {\n      byDefault: bootstrapDefault(context => new Theme$(context.get(ThemeStyle))),\n    },\n));\n\n/**\n * A hierarchy of CSS rules within single root.\n *\n * A component may use it to extract styling information.\n *\n * Current theme is available in bootstrap, definition, or component context. By default, only one theme is declared\n * per bootstrap. But this can be overridden.\n */\nexport abstract class Theme {\n\n  /**\n   * A key of bootstrap, definition, or component context value containing current theme instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<Theme> {\n    return Theme__key;\n  }\n\n  /**\n   * Root CSS rule.\n   *\n   * All theme styling is represented as rules within this root.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * Obtains CSS rule reference by its `referrer`.\n   *\n   * This is a helper method that resolves the given `referrer` against the `root` CSS rule of this theme.\n   *\n   * @param referrer - Target CSS rule referrer.\n   *\n   * @returns CSS rule reference.\n   */\n  ref<T extends StypProperties<T>>(referrer: RefStypRule<T>): StypRuleRef<T> {\n    return referrer(this.root);\n  }\n\n  /**\n   * Obtains a styling for the given theme styles.\n   *\n   * This method requests the registered {@link ThemeStyle theme styles} for CSS rules they provide.\n   * If some of the styles are not registered then uses the given style as provider.\n   *\n   * @param styles - The styles to obtain styling information for.\n   *\n   * @returns Dynamically updated CSS rule set containing the requested styling.\n   */\n  abstract style(...styles: ThemeStyle.Provider[]): StypRules;\n\n}\n\n/**\n * @internal\n */\nclass Theme$ extends Theme {\n\n  readonly root: StypRule = stypRoot();\n  private readonly _rules = new Map<ThemeStyle.Provider, StypRules>();\n\n  constructor(private readonly _styles: ThemeStyle.ById) {\n    super();\n  }\n\n  style(...styles: ThemeStyle.Provider[]): StypRules {\n\n    const theme = this;\n\n    return lazyStypRules(...styles.reduce<StypRules[]>(addStyleRules, []));\n\n    function addStyleRules(target: StypRules[], style: ThemeStyle.Provider): StypRules[] {\n\n      const existing = theme._rules.get(style);\n\n      if (existing) {\n        target.push(existing);\n      } else {\n\n        const constructed = theme._styles(style)(theme);\n\n        theme._rules.set(style, constructed);\n        target.push(constructed);\n      }\n\n      return target;\n    }\n  }\n\n}\n","import { NamespaceDef } from '@frontmeans/namespace-aliaser';\n\nexport const Examples__NS = new NamespaceDef(\n    'https://wesib.github.io/examples',\n    'bex',\n    'wesib-examples',\n);\n","import { RefStypRule, StypColor, StypLength, StypLengthPt, StypProperties, StypRGB } from '@frontmeans/style-producer';\n\nexport interface ThemeSettings {\n  $color: StypColor;\n  $bgColor: StypColor;\n  $fontFace: string;\n  $fontSize: StypLengthPt;\n  $lineHeight: number;\n  $fontWeight: string;\n  $linkFontWeight: string;\n  $layoutBreakpoint: StypLength;\n}\n\nexport const ThemeSettings: RefStypRule<ThemeSettings> = RefStypRule.by(\n    { $: 'settings' },\n    {\n      $color: new StypRGB({ r: 161, g: 185, b: 142 }),\n      $bgColor: new StypRGB({ r: 40, g: 43, b: 36 }),\n      $fontFace: `'Exo 2', sans-serif`,\n      $fontSize: StypLengthPt.of(1, 'em'),\n      $lineHeight: 1.2,\n      $fontWeight: '400',\n      $linkFontWeight: '600',\n      $layoutBreakpoint: StypLength.of(576, 'px'),\n    },\n);\n\nexport function mediaStyle({ $layoutBreakpoint }: ThemeSettings): StypProperties {\n  return {\n    '@media:sm': `(max-width: ${$layoutBreakpoint})`,\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { Theme } from '@wesib/generic/styp';\nimport { ThemeSettings } from './theme-settings';\n\nexport function LinkStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read;\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add({ e: 'a' }, settings.do(mapAfter(linkStyle))),\n      rules.add({ e: 'a', s: ':visited' }, settings.do(mapAfter(linkStyle))),\n      rules.add({ e: 'a', s: ':hover' }, { textDecoration: 'underline' }),\n      rules.add({ e: 'a', s: ':active' }, { textDecoration: 'underline dotted' }),\n      rules.add({ e: 'a', s: ':focus' }, { textDecoration: 'underline dotted' }),\n  );\n}\n\nfunction linkStyle(\n    {\n      $color,\n      $linkFontWeight,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    fontWeight: $linkFontWeight,\n    textDecoration: 'none',\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { Theme } from '@wesib/generic/styp';\nimport { LinkStyle } from './link.style';\nimport { mediaStyle, ThemeSettings } from './theme-settings';\n\nexport function DefaultStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read;\n\n  return stypRules(\n      theme.root\n          .add(settings.do(mapAfter(defaultStyle)))\n          .add(settings.do(mapAfter(mediaStyle))),\n      theme.style(LinkStyle),\n  );\n}\n\nfunction defaultStyle(\n    {\n      $color,\n      $fontFace,\n      $fontSize,\n      $lineHeight,\n      $fontWeight,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    font: `normal ${$fontWeight} ${$fontSize}/${$lineHeight} ${$fontFace}`,\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { Theme } from '@wesib/generic/styp';\nimport { DefaultStyle } from './default.style';\nimport { ThemeSettings } from './theme-settings';\n\nexport function BodyStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read;\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add(\n          { e: 'html' },\n          {\n            height: '100%',\n            margin: 0,\n            padding: 0,\n          },\n      ),\n      rules.add(\n          { e: 'body' },\n          settings.do(mapAfter(bodyStyle)),\n      ),\n      theme.style(DefaultStyle),\n  );\n}\n\nfunction bodyStyle(\n    {\n      $bgColor,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    backgroundColor: $bgColor,\n    height: '100%',\n    margin: 0,\n    padding: 0,\n  };\n}\n","import { RefStypRule, StypColor, StypLength, StypLengthPt, StypMapper, StypRuleRefs } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { ThemeSettings } from '../theme';\n\nexport interface FormThemeSettings {\n  $color: StypColor;\n  $bgColor: StypColor;\n  $roBgColor: StypColor;\n  $fontFace: string;\n  $fontSize: StypLengthPt;\n  $errorFontSize: StypLengthPt;\n  $lineHeight: number;\n  $fontWeight: string;\n  $borderColor: StypColor;\n  $marginV: StypLengthPt;\n  $marginH: StypLengthPt;\n  $paddingV: StypLengthPt;\n  $paddingH: StypLengthPt;\n  $borderW: StypLength;\n}\n\nexport const FormThemeSettings: RefStypRule<FormThemeSettings> = RefStypRule.by(\n    { $: 'settings:form' },\n    root => StypRuleRefs.by<{ global: ThemeSettings }>(\n        {\n          global: ThemeSettings,\n        },\n        root,\n    ).read.do(mapAfter(formMappings)),\n);\n\nfunction formMappings(\n    {\n      global: {\n        $color,\n        $bgColor,\n        $fontFace,\n        $fontSize,\n        $lineHeight,\n        $fontWeight,\n      },\n    }: {\n      global: ThemeSettings;\n    },\n): StypMapper.Mappings<FormThemeSettings> {\n  return {\n    $color,\n    $bgColor: $bgColor.hsl.set(({ l }) => ({ l: l * 0.8 })),\n    $roBgColor: $bgColor.hsl.set(({ l }) => ({ l: l * 0.94 })),\n    $fontFace,\n    $fontSize,\n    $errorFontSize: $fontSize.mul(0.8),\n    $lineHeight,\n    $fontWeight,\n    $borderColor: $bgColor,\n    $marginV: $fontSize.div(4),\n    $marginH: $fontSize.div(4),\n    $paddingV: $fontSize.div(2),\n    $paddingH: $fontSize,\n    $borderW: StypLength.of(1, 'px'),\n  };\n}\n","import { InCssClasses, inCssError, inCssInfo, InputAspects__NS, InStyledElement } from '@frontmeans/input-aspects';\nimport { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { StypLengthPt, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { AfterEvent, mapAfter, mapAfter_ } from '@proc7ts/fun-events';\nimport { ConvertInput } from '@wesib/generic/input';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { Attributes, Component, ComponentContext, trackAttribute } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { FormThemeSettings } from './form.theme-settings';\n\n@Component(\n    ['in-error', Examples__NS],\n    Attributes('code'),\n    ConvertInput(\n        ({ control: { control }, aspects, context }) => {\n\n          const codes: AfterEvent<[string[]]> = trackAttribute(context, 'code')\n              .read\n              .do(\n                  mapAfter_(code => code ? code.trim().split(/\\s+/) : []),\n              );\n\n          return codes.do(\n              mapAfter(when => control.convert(\n                  InStyledElement.to(context.element),\n                  aspects,\n              ).setup(\n                  InCssClasses,\n                  cssClasses => {\n                    cssClasses.add(inCssInfo());\n                    cssClasses.add(inCssError({ when }));\n                  },\n              )),\n          );\n        },\n    ),\n)\nexport class InErrorComponent {\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  @ProduceStyle()\n  style(): StypRules {\n    return this._context.get(Theme).style(InErrorStyle);\n  }\n\n}\n\nconst InError__qualifier = 'bex:in-error';\nconst hasError__cssClass: QualifiedName = ['has-error', InputAspects__NS];\n\nfunction InErrorStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(FormThemeSettings).read;\n  const { root: { rules } } = theme;\n  const borderW = StypLengthPt.of(4, 'px');\n\n  return stypRules(\n      rules.add(\n          { u: [':', 'host'], $: InError__qualifier },\n          settings.do(mapAfter(({ $color, $errorFontSize }) => ({\n            display: 'none',\n            fontSize: $errorFontSize,\n            padding: $errorFontSize.div(2),\n            borderLeft: `${borderW} dotted ${$color}`,\n            paddingLeft: $errorFontSize.sub(borderW),\n          }))),\n      ),\n      rules.add(\n          {\n            u: [\n              ':',\n              'host',\n              {\n                c: [hasError__cssClass, ['touched', InputAspects__NS]],\n                u: [':', 'not', { c: ['has-focus', InputAspects__NS] }],\n              },\n            ],\n            $: InError__qualifier,\n          },\n          {\n            display: 'block',\n          },\n      ),\n      rules.add(\n          {\n            u: [\n              ':',\n              'host',\n              {\n                c: hasError__cssClass,\n                u: [\n                  [':', 'not', { u: ['code', '~=', 'missing'] }],\n                  [':', 'not', { u: ['code', '~=', 'incomplete'] }],\n                ],\n              },\n            ],\n            $: InError__qualifier,\n          },\n          {\n            display: 'block',\n          },\n      ),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { InControl, InConverter } from '@frontmeans/input-aspects';\nimport { afterAll, AfterEvent, afterThe, consumeEvents, digAfter_, EventKeeper } from '@proc7ts/fun-events';\nimport { Class, Supply } from '@proc7ts/primitives';\nimport { Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputFromControl, InputFromControl, NoInputFromControl } from './input-from-control';\n\n/**\n * Constructs component decorator that converts input control from {@link HierarchyContext.up enclosing component}\n * and uses it as an {@link InputFromControl origin of user input} in decorated component.\n *\n * @param convert - Input control converter definition.\n *\n * @returns New component decorator.\n */\nexport function ConvertInput<T extends ComponentClass = Class>(\n    convert: ConvertInputDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const { up } = context.get(HierarchyContext);\n\n        afterAll({\n          parent: up.do(\n              digAfter_((upper): AfterEvent<[InputFromControl | NoInputFromControl]> => upper\n                  ? upper.get(InputFromControl)\n                  : afterThe<[NoInputFromControl]>({})),\n          ),\n          aspects: context.get(DefaultInAspects),\n        }).do(\n            digAfter_(({\n              parent: [control],\n              aspects: [aspects],\n            }): EventKeeper<[InControl<any>?, Supply?]> => {\n              if (control.control) {\n\n                const converted = convert({ control, context, aspects });\n\n                if (converted) {\n                  return converted instanceof InControl ? afterThe(converted) : converted;\n                }\n              }\n\n              return afterThe();\n            }),\n            consumeEvents((control?: InControl<any> | null, supply?: Supply) => {\n              if (!control) {\n                return;\n              }\n\n              const usageSupply = inputFromControl(context, control);\n\n              (supply || control.supply).needs(usageSupply);\n\n              return usageSupply;\n            }),\n        );\n      });\n    },\n  });\n}\n\n/**\n * Converter definition of enclosing component's user input control.\n *\n * The returned converted control keeper may send an event supply as a second parameter. This supply will be cut off\n * once the input from converted control is no longer needed. Otherwise the control's input supply will be cut off\n * instead, and control would become unusable after that.\n *\n * Configures {@link ConvertInput @ConvertInput} component decorator.\n */\nexport type ConvertInputDef<T extends object = any> =\n/**\n * @param control - Enclosing component's user input to convert.\n * @param context - Decorated component context.\n * @param aspects - Default input aspect converter. This is a value of {@link DefaultInAspects}.\n *\n * @returns Either input control, its keeper, or nothing.\n */\n    (\n        this: void,\n        {\n          control,\n          context,\n          aspects,\n        }: {\n          control: InputFromControl;\n          context: ComponentContext<T>;\n          aspects: InConverter.Aspect<any, any>;\n        },\n    ) => InControl<any> | EventKeeper<[InControl<any>?, Supply?]> | null | undefined;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { StatePath } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { Component, ComponentDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeRegistry } from './attribute-registry';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\nimport { property2attributeName } from './property2attribute-name';\n\n/**\n * Creates a component decorator declaring supported custom element's attributes.\n *\n * @category Feature\n * @typeParam T - A type of decorated component class.\n * @param items - Attributes definition options.\n *\n * @return New component decorator.\n */\nexport function Attributes<T extends ComponentClass = Class>(\n    ...items: readonly Attributes.Item<InstanceType<T>>[]\n): ComponentDecorator<T> {\n  return Component({\n    define(defContext) {\n\n      const registry = defContext.get(AttributeRegistry);\n\n      for (const item of items) {\n        if (typeof item === 'string') {\n\n          const name = property2attributeName(item);\n\n          registry.declareAttribute({\n            name,\n            change: attributeStateUpdate(name),\n          });\n        } else {\n          for (const [key, updateState] of Object.entries(item)) {\n\n            const name = property2attributeName(key);\n\n            registry.declareAttribute({\n              name,\n              change: attributeStateUpdate(name, updateState),\n            });\n          }\n        }\n      }\n    },\n  });\n}\n\nexport namespace Attributes {\n\n  /**\n   * Attribute definition item.\n   *\n   * This is either an attribute name (_camelCase_ or _dash-style_), or a per-attribute options map.\n   *\n   * @typeParam T - A type of component.\n   */\n  export type Item<T extends object> = Map<T> | string;\n\n  /**\n   * Per-attribute definition options.\n   *\n   * This is a map with attribute names as keys (either _camelCase_ or _dash-style_), and their state update\n   * instructions as values.\n   *\n   * The state update instruction can be one of:\n   * - `false` to not update the component state,\n   * - `true` to update the component state with changed attribute key,\n   * - a state value key to update, or\n   * - an attribute update receiver function with custom state update logic.\n   *\n   * @typeParam T - A type of component.\n   */\n  export interface Map<T extends object> {\n    readonly [name: string]: boolean | StatePath | AttributeUpdateReceiver<T>;\n  }\n\n}\n","import { Feature } from '@wesib/wesib';\nimport { InErrorComponent } from './in-error.component';\n\n@Feature({\n  needs: [\n    InErrorComponent,\n  ],\n})\nexport class InputSupport {\n}\n","import { StypProperties } from '@frontmeans/style-producer';\nimport { IncludePage } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { ThemeSettings } from '../theme';\n\n@Component(\n    ['main', Examples__NS],\n    IncludePage({\n      onResponse({ response, range }) {\n        if (!response.ok) {\n          range.deleteContents();\n          if (response.ok == null) {\n            range.insertNode(document.createTextNode('Loading...'));\n          } else {\n            range.insertNode(document.createTextNode(`Error. ${response.error}`));\n          }\n        }\n      },\n    }),\n)\nexport class MainComponent {\n}\n\nexport function mainStyle(\n    {\n      $fontSize,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    flex: '1 1 auto',\n    padding: 0,\n    margin: `0 0 0 ${$fontSize.div(2)}`,\n  };\n}\n","import { StypColor, StypLengthPt, StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { ActivateNavLink, HandleNavLinks } from '@wesib/generic';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { Component, ComponentContext, Wesib__NS } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { ThemeSettings } from '../theme';\n\n@Component(\n    ['nav', Examples__NS],\n    HandleNavLinks(),\n    ActivateNavLink(),\n)\nexport class NavComponent {\n\n  private readonly _theme: Theme;\n\n  constructor(context: ComponentContext) {\n    this._theme = context.get(Theme);\n  }\n\n  @ProduceStyle()\n  style(): StypRules {\n    return this._theme.style(NavStyle);\n  }\n\n}\n\nconst Nav__qualifier = 'bex:nav';\n\nfunction NavStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read;\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add(\n          { u: [':', 'host'], $: Nav__qualifier },\n          settings.do(mapAfter(navStyle)),\n      ),\n      rules.add(\n          { u: [':', 'host'], $: Nav__qualifier },\n          settings.do(mapAfter(sts => ({\n            flex: '0 1 200px',\n            height: '100%',\n            background: navLinkBackground(sts),\n          }))),\n      ),\n      rules.add(\n          { u: [':', 'host'], $: [Nav__qualifier, '@media:sm'] },\n          {\n            flex: '0 1 100%',\n          },\n      ),\n      rules.add(\n          [{ u: [':', 'host'], $: Nav__qualifier }, { e: 'a', $: Nav__qualifier }],\n          settings.do(mapAfter(navLinkStyle)),\n      ),\n      rules.add(\n          [{ u: [':', 'host'], $: Nav__qualifier }, { e: 'a', c: ['active', Wesib__NS], $: Nav__qualifier }],\n          settings.do(mapAfter(activeNavLinkStyle)),\n      ),\n  );\n}\n\nfunction navStyle(\n    {\n      $fontSize,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    padding: 0,\n    margin: `0 ${$fontSize.div(2)} 0 0`,\n  };\n}\n\nexport function navLinkBackground({ $bgColor }: ThemeSettings): StypColor {\n  return $bgColor.hsl.set(({ l }) => ({ l: l * 0.8 }));\n}\n\nfunction navLinkStyle(\n    settings: ThemeSettings,\n): StypProperties {\n\n  const { $fontSize } = settings;\n\n  return {\n    display: 'block',\n    margin: 0,\n    padding: `${$fontSize.div(2)} ${$fontSize}`,\n    border: 0,\n    outline: 0,\n    background: navLinkBackground(settings),\n  };\n}\n\nfunction activeNavLinkStyle(\n    {\n      $fontSize,\n      $color,\n      $bgColor,\n    }: ThemeSettings,\n): StypProperties {\n\n  const borderW = StypLengthPt.of(4, 'px');\n\n  return {\n    background: $bgColor,\n    borderLeft: `${borderW} solid ${$color}`,\n    paddingLeft: $fontSize.sub(borderW),\n  };\n}\n","import { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { BootstrapContext, Component, ComponentContext } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { mediaStyle, ThemeSettings } from '../theme';\nimport { MainComponent, mainStyle } from './main.component';\nimport { NavComponent } from './nav.component';\n\n@Component({\n  name: ['container', Examples__NS],\n  feature: {\n    needs: [\n      MainComponent,\n      NavComponent,\n    ],\n  },\n})\nexport class ContainerComponent {\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  @ProduceStyle()\n  async style(): Promise<StypRules> {\n\n    const { elementDef: { name: mainName } } = await this._context.get(BootstrapContext).whenDefined(MainComponent);\n\n    return this._context.get(Theme).style(ContainerStyle(mainName!));\n  }\n\n}\n\nconst Container__qualifier = 'bex:container';\n\nfunction ContainerStyle(mainName: QualifiedName): (theme: Theme) => StypRules {\n  return theme => {\n\n    const settings = theme.ref(ThemeSettings).read;\n    const { root: { rules } } = theme;\n\n    return stypRules(\n        rules.add(\n            { u: [':', 'host'], $: Container__qualifier },\n            {\n              height: '100%',\n              display: 'flex',\n              flexFlow: 'row wrap',\n              alignItems: 'stretch',\n              alignContent: 'flex-start',\n            },\n        ).add(\n            settings.do(mapAfter(mediaStyle)),\n        ),\n        rules.add(\n            { u: [':', 'host'], $: [Container__qualifier, '@media:sm'] },\n            {\n              height: 'auto',\n            },\n        ),\n        rules.add(\n            [{ u: [':', 'host'], $: Container__qualifier }, { e: mainName, $: Container__qualifier }],\n            settings.do(mapAfter(mainStyle)),\n        ),\n    );\n  };\n}\n","import { PageLoadSupport } from '@wesib/generic';\nimport { StyleProducerSupport } from '@wesib/generic/styp';\nimport { Feature } from '@wesib/wesib';\nimport { ContainerComponent } from './container.component';\n\n@Feature({\n  needs: [\n    ContainerComponent,\n    PageLoadSupport,\n    StyleProducerSupport,\n  ],\n})\nexport class LayoutSupportFeature {\n}\n","import { produceBasicStyle, stypDomFormat } from '@frontmeans/style-producer';\nimport { ComponentStypDomFormat, ComponentStypFormat, Theme } from '@wesib/generic/styp';\nimport { Feature } from '@wesib/wesib';\nimport { BodyStyle } from './body.style';\n\n@Feature({\n  setup(setup) {\n    setup.perComponent({ a: ComponentStypFormat, as: ComponentStypDomFormat });\n  },\n  init(context) {\n    context.whenReady(() => {\n      produceBasicStyle(context.get(Theme).style(BodyStyle), stypDomFormat());\n    });\n  },\n})\nexport class BodyStyleSupport {}\n\n","import { Feature } from '@wesib/wesib';\nimport { InputSupport } from './input/input-support.feature';\nimport { LayoutSupportFeature } from './layout';\nimport { BodyStyleSupport } from './theme/body-style-support.feature';\n\n@Feature({\n  needs: [\n    BodyStyleSupport,\n    InputSupport,\n    LayoutSupportFeature,\n  ],\n})\nexport class AppFeature {}\n","import { InputAspects__NS } from '@frontmeans/input-aspects';\nimport { mixStypColors, StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { Theme } from '@wesib/generic/styp';\nimport { FormThemeSettings } from './form.theme-settings';\n\nexport function InputStyle(theme: Theme): StypRules {\n\n  const formSettings = theme.ref(FormThemeSettings).read;\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add({ e: 'input' }, formSettings.do(mapAfter(inStyle))),\n      rules.add({ e: 'input', s: '[readonly]' }, formSettings.do(mapAfter(readonlyInStyle))),\n      rules.add({ e: 'input', s: '[disabled]' }, formSettings.do(mapAfter(readonlyInStyle))),\n      rules.add({ e: 'input', s: ':focus' }, formSettings.do(mapAfter(focusedInStyle))),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['invalid', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          formSettings.do(mapAfter(invalidInStyle)),\n      ),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['missing', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          {\n            outlineStyle: 'dotted',\n          },\n      ),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['incomplete', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          {\n            outlineStyle: 'dotted',\n          },\n      ),\n  );\n}\n\nexport function inStyle(\n    {\n      $color,\n      $fontFace,\n      $fontSize,\n      $lineHeight,\n      $fontWeight,\n      $marginV,\n      $marginH,\n      $paddingV,\n      $paddingH,\n      $bgColor,\n      $borderColor,\n      $borderW,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    font: `normal ${$fontWeight} ${$fontSize}/${$lineHeight} ${$fontFace}`,\n    padding: `${$paddingV} ${$paddingH}`,\n    margin: `${$marginV} ${$marginH}`,\n    backgroundColor: $bgColor,\n    border: '0 none',\n    outline: `${$borderW} solid ${$borderColor}`,\n    boxShadow: 'inset 1px 1px 2px -2px black',\n    boxSizing: 'border-box',\n    width: '100%',\n  };\n}\n\nexport function readonlyInStyle(\n    {\n      $roBgColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    backgroundColor: $roBgColor,\n  };\n}\n\nfunction focusedInStyle(\n    {\n      $color,\n      $borderColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    outlineColor: mixStypColors($borderColor, $color, 0.5),\n  };\n}\n\nfunction invalidInStyle(\n    {\n      $color,\n      $borderW,\n      $borderColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    outline: `${$borderW.mul(2)} dashed ${mixStypColors($borderColor, $color, 0.25)}`,\n  };\n}\n","import { bootstrapComponents } from '@wesib/wesib';\nimport { AppFeature } from './app.feature';\n\nexport * from './app.feature';\nexport * from './examples.ns';\nexport * from './input';\nexport * from './theme';\n\nexport const examplesContext = bootstrapComponents(AppFeature);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport {\n  AfterEvent,\n  afterEventBy,\n  mapAfter,\n  onceOn,\n  OnEvent,\n  shareAfter,\n  supplyAfter,\n  trackValue,\n  valueOn,\n} from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { FeatureDef, FeatureRef, FeatureStatus } from '../../feature';\nimport { FeatureKey, FeatureLoader, FeatureRequester } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapContextRegistry } from '../impl';\nimport { whenDefined } from '../impl/when-defined.impl';\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features - Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapContextRegistry = BootstrapContextRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.get(FeatureRequester).request(feature);\n  bootstrapContext.get(FeatureKey.of(feature))(loader => {\n    loader!.init().then(complete).catch(console.error);\n  });\n\n  return bootstrapContext;\n}\n\n/**\n * @internal\n */\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\n/**\n * @internal\n */\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n\n/**\n * @internal\n */\nfunction initBootstrap(\n    bootstrapContextRegistry: BootstrapContextRegistry,\n): {\n  bootstrapContext: BootstrapContext;\n  complete(): void;\n} {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const values = bootstrapContextRegistry.values;\n\n  class BootstrapContext$ extends BootstrapContext {\n\n    readonly whenReady: OnEvent<[BootstrapContext]>;\n    readonly get = values.get;\n\n    constructor() {\n      super();\n      this.whenReady = stage.read.do(\n          valueOn(bsStage => !!bsStage && this),\n          onceOn,\n      );\n      bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]> {\n      return whenDefined(this, componentType);\n    }\n\n    load(feature: Class<any>): FeatureRef {\n\n      interface FeatureInfo {\n        status: FeatureStatus;\n        down?: Promise<void>;\n      }\n\n      const status = afterEventBy<[FeatureInfo]>(receiver => {\n\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const request = bootstrapContext.get(FeatureRequester).request(feature);\n        const info = trackValue<FeatureInfo>({\n          status: {\n            feature,\n            ready: false,\n          },\n        });\n\n        this.get(FeatureKey.of(feature))({\n          supply: receiver.supply,\n          receive(_ctx, ldr) {\n\n            // Present until `request` revoked\n            // But that happens only when supply is cut off.\n            const loader = ldr as FeatureLoader;\n\n            info.it = {\n              status: {\n                feature: loader.request.feature,\n                ready: loader.ready,\n              },\n              down: loader.down,\n            };\n            if (!loader.ready) {\n              loader.init().then(() => {\n                info.it = {\n                  status: {\n                    feature: loader.request.feature,\n                    ready: true,\n                  },\n                  down: loader.down,\n                };\n              }).catch(console.error);\n            }\n          },\n        }).whenOff(() => {\n          request.unuse(); // Apply this callback _after_ registration complete,\n                           // to prevent receiver call.\n        });\n\n        info.read(receiver);\n      }).do(shareAfter);\n\n      let whenDown: Promise<void>;\n      const supply = status(({ down }) => {\n        whenDown = down!;\n      });\n\n      class Ref extends FeatureRef {\n\n        readonly read: AfterEvent<[FeatureStatus]> = status.do(\n            supplyAfter(supply),\n            mapAfter(({ status }) => status),\n        );\n\n        get down(): Promise<void> {\n          return whenDown;\n        }\n\n        dismiss(reason?: any): Promise<void> {\n          supply.off(reason);\n          return whenDown;\n        }\n\n      }\n\n      return new Ref();\n    }\n\n  }\n\n  const bootstrapContext = new BootstrapContext$();\n\n  return {\n    bootstrapContext,\n    complete(): void {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n"],"names":["arrayOfElements","value","Array","isArray","elementOrArray","source","array","from","length","setOfElements","elements","Set","extendSetOfElements","set","forEach","element","add","superClassOf","type","satisfying","prototype","Object","getPrototypeOf","superType","constructor","asis","mergeFunctions","first","second","merge","_f","s","args","apply","this","noop","valueProvider","valuesProvider","values","lazyValue","provider","get","Supply","[object Object]","off","_off","reason","_whenOff","callback","prev","supply","isOff","Promise","resolve","reject","whenOff","undefined","another","needs","NeverSupply","_another","neverSupply$","neverSupply","isPresent","PushIterator__symbol","Symbol","isPushIterable","iterable","iteratorOf","iterator","makePushIterable","iterate","PushIterable$iterator","pushIterated","accept","isOver","makePushIterator","forNext","over","PushIterator$dontIterate","PushIterator$iterator","next","PushIterator$next","result","done","PushIterator$noNext","_accept","emptyPushIterator","pushHead","arrayElementOf","index","iterateOverArray","indexed","elementOf","i","goOn","overArray","itsIterated","it","status","itsEach","action","itsElements$defaultConverter","itsElements","convert","pushedElements","push","pushedEmpty","isEmpty","_element","itsFirst","pushedFirst","rawFirst","toPushIterator","res","rawIteratorPusher","itsHead","arrayHead","rawIterableHead","itsIterator","itsReduction","reducer","initialValue","reduced","overNone","overIterator","iterateOverRawIterator","overElementsOf","sources","src","srcTail","iterateOverSubElements","overOne","iterateOverOneValue","overKeys","Reflect","ownKeys","filterArray","test","iterateOverFilteredIndexed","filterIt","filterPusher","filterRawPusher","tail","flatMapArray","elementsOf","flatMapArray$defaultElementOf","subs","subsTail","flatMapIt","flatMapIt$defaultConverter","flatMapPusher","flatMapRawPusher","lastSrc","sourceTail","mapIt","mapPusher","mapRawPusher","valueIt","valueOf","valuePusher","valueRawPusher","overEntries","key","ContextKey__symbol","ContextKey","name","ContextSeedKey","super","seedKey","opts","seeder","seed","hasFallback","insert","ContextKeyError","Error","message","ContextSeeders","_initial","Map","found","_issuers","issuer","context","factory","withDeps","spec","ContextValues","ContextValueSlot$","registry","_opts","newSeed","or","_constructed","grow","setup","prevSetup","_setup","ContextRegistry","initial","_seeders","a","by","byProvider","with","deps","map","dep","isConstant","is","viaAlias","via","ctx","asInstance","selfInstance","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","contextValueSpec","provide","newValues","bind","seedRegistry","cached","constructed","_grow","newContextValues","other","otherSeeds","seeds","combine","SimpleContextSeeder","entry","_providers","unshift","splice","lastIndexOf","makeSeed","combineSimpleSeeds","SimpleSeedKey","SimpleContextKey","ContextSupplyKey","slot","ContextSupply","IterativeContextSeeder","delete","providers","iterativeSeed","itsEmpty","IterativeSeedKey","IterativeContextKey","MultiContextKey","byDefault","defaultSources","SingleContextKey","Naming","nsAlias","local","ns","DefaultNaming","alias","default__naming","html__naming","XmlNaming","id__naming","CssNaming","css__naming","NamespaceDef","url","aliases","naming","applyAlias","isQualifiedName","isNameAndNamespace","compareNames","compareStrings","firstName","firstUrl","newNamespaceAliaser","aliasesByNs","nsNumPerAlias","mostPreferred","nsNumRegistered","preferred","ids","generated","AfterEvent__symbol","isEventKeeper","eventReceiver","receiver","generic","_context","event","receive","receiveByEach","receivers","send","sendNonRecurrent","actualReceivers","received","recurrent","processEvent","shift","recurrentReceivers","idx","recurrentReceiver","recurrentEvent","EventNotifier","rcs","_rcs","clear","size","OnEvent__symbol","isEventSender","sendEventsTo","AfterEvent$noFallback","eventDig","input","extract","nestedSupply","prevSupply","extracted","OnEvent$do","processors","reduce","arg","OnEvent$supplier","onceEvent","supplier","OnEvent$then","onEvent","onCutOff","e","_ctx","shareEvents","shared","sharedSupply","initialEvents","on","dispatch","supplyEvents","required","dependentSupply","cuts","translateEvents","translate","neverReceive","afterEventBy","register","fallback","lastEvent","numReceivers","afterEvent","dest","reported","do","then","afterAll","keys","afterEach","afterSent","sender","afterSupplied","afterThe","onEventBy","consumeEvents","consume","consumerSupply","shareAfter","digAfter","processor","digAfter_","extractKeeper","events","EventEmitter","onNever","onSupplied","onAny","suppliers","remained","removeSupplier","onPromise","promise","alwaysReceiveValue","catch","shareOn","translateOn","mapper","translateOn_","mapAfter","mapAfter_","mapOn","mapOn_","onceAfter","onceOn","supplyOn","resolveOnOrdered","sourceSupply","numInProcess","numSent","numReceived","lastIndex","resolveOn","toSend","supplyAfter","translateAfter","translateAfter_","valueOn","valueOn_","statePath","path","PathEntry","_drop","emitter","newValue","oldValue","nested","_nested","slice","_dropIfEmpty","dontCreateMissing","created","_remove","Trackers","_entry","_root","nest","SubStateTracker","_trackers","_path","update","_tracker","onUpdate","StateTracker","subTracker","track","ValueTracker","valueReceiver","onRecurrent","recurrentValue","read","acceptValuesFrom","byNone","container","_by","TrackedValue","_it","_on","trackValue","ValueSync","old","third","syncWithTracker","tracker","syncTrackers","extractTracker","tracker1","tracker2","supply1","supply2","OnDomEvent$sample","OnDomEvent$context","DomEventDispatcher","target","_target","onDomEvent","listener","onDomEventBy","domListener","addEventListener","removeEventListener","dispatchEvent","contextDestroyed","flatUpSources","ContextUpSeeder","providersTracker","prov","toUpSrcKeeper","upSrcKeepers","isUpSrcKeeper","ContextSeedUpKey","upKey","ContextUpKeyUpKey","_key","fillBy","ContextUpKey","FnContextKey","createUpKey","fns","delegated","fn","SingleContextUpKey","backup","defaultValue","RenderScheduleConfig","options","win","node","window","ownerDocument","defaultView","messages","error","console","RenderQ__symbol","RenderQ","q","ref","schedule","doSchedule","queue","shot","config","postponed","execution","reset","suspend","exec","postpone","post","resume","pull","scheduled","customRenderScheduler","scheduleOptions","queueRef","newQueue","enqueued","lastQueue","executed","nextQueue","activeQueue","nextEnqueued","RenderQueue","replace","shots","animationRenderQueues","WeakMap","immediateRenderScheduler","execute","last","pop","defaultRenderScheduler","existing","task","requestAnimationFrame","replacement","newRenderSchedule","BootstrapContext__key","BootstrapContext","bootstrapDefault","bootstrapContext","decoratePropertyAccessor","propertyKey","desc","updateDescriptor","isField","updatedDesc","writable","isPropertyAccessorDescriptor","value__symbol","accessorDesc","toPropertyAccessorDescriptor","fieldKey","String","configurable","enumerable","fieldAccessorDescriptor","defineProperty","isElement","nodeType","Node","ELEMENT_NODE","MetaAccessor","symbol","hasOwnProperty","ownDef","own","superDef","of","prevMeta","updates","meta","newMeta","FeatureDef__symbol","FeatureMeta","defs","def","has","init","featureMeta","noFeatureDef","FeatureDef","featureType","for","all","define","Feature","FeatureContext__key","FeatureContext","componentType","whenDefined","feature","load","FeatureNeedsError","need","FeatureRef","ComponentDef__symbol","ComponentMeta","componentMeta","noComponentDef","ComponentDef","Component","decorator","ComponentContext__key","ComponentEventDispatcher__key","dispatcher","ContentRoot","StateUpdaterKey","combined","StateUpdater","ComponentContext__symbol","ComponentContext","updateState","contentRoot","ComponentEvent","Event","AnonymousComponentProperty__symbol","ComponentProperty","decorateWith","readable","component","componentDef","By","proto","descriptor","getValue","setValue","call","notReadableAccessor","notWritableAccessor","updated","With","access","As","Bind","binder","accessor__symbol","accessor","BootstrapContextRegistry__key","BootstrapContextRegistry","PerComponentRegistry","ComponentContextRegistry","PerDefinitionRegistry","bsContext","DefinitionContextRegistry","PostDefSetup__symbol","postDefSetup","superPostDefSetup","BootstrapWindow","BootstrapRoot","document","body","DefaultNamespaceAliaser","DefaultRenderSchedulerKey","toDefaultRenderScheduler","scheduler","DefaultRenderScheduler","ElementAdapterKey","adapters","adapter","defaultElementAdapter","ElementAdapter","ElementObserver","DefaultElementObserver","MutationObserver","mutations","mutation","removedNodes","mount","mountOf","checkConnected","addedNodes","observe","childList","DefinitionContext__symbol","definitionContextOf","CustomElements__key","customElements","CustomElements","componentTypeOrName","elementType","defContext","extend","elementDef","extends","componentResolver","ComponentResolver__symbol","resolvePromise","rejectPromise","buildPromise","settle","resolution","newPromiseResolver","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","mountTo","connect","ComponentContext$","_definitionContext","whenReady","_status","whenSettled","whenConnected","_newComponentRegistry","_component","settled","connected","componentDestroyed","parentNode","removeChild","removeElement","whenComponent","_whenComponent","lastRev","readNotifier","notifier","_","_elementBuilder","components","prevContext","newComponent","bubbles","ComponentMount$","_connect","el","doc","contains","destroy","MountComponentContext$","definitionContext","CustomComponentContext$","WhenComponent","currentRev","onCreated","receiverRev","eventContext","componentContext","notifiedRev","recurrentContext","rev","DefinitionContext$","_bsContext","_ready","_whenReady","ready","_def","definitionContextRegistry","parentPerComponentRegistry","append","_perComponentRegistry","definitionSetup","perDefinition","perComponent","_elementType","_createComponent","_created","definitions","CustomElement$","connectedCallback","disconnectedCallback","customElementType","ElementBuilder","_define","ComponentRegistry","_definitionQueue","definition","buildElement","FeatureContext$","_loader","st","state","bs","onDefinition","onComponent","_componentRegistry","request","onPostDefSetup","FeatureKey__symbol","FeatureKey","preferredFeatureClause","origin","stageId","clause","loadFeatureDeps","loader","to","stage","ownLoader","FeatureLoader","ownSource","rcv","unload","lastLoader","preventDuplicateLoader","clauses","presentFeatureDeps","filter","down","_down","_stage","SetupFeatureStage","after","lastStage","id","prevStage","stop","FeatureStage","_stop","perDep","InitFeatureStage","ActiveFeatureStage","FeatureRequest","_requester","featureDef","requester","isClause","unuse","_uses","FeatureRequester__key","FeatureRequester","_map","reuse","WhenDefined__symbol","AttributePath__root","attributePathTo","attributeStateUpdate","updateAttributeState","property2attributeName","c","substring","toLowerCase","AttributeRegistry","AttributeRegistry$","change","attrs","observedAttributes","attributeChangedCallback","attributeFilter","records","record","attributeName","getAttribute","attributes","attributeOldValue","alreadyObserved","newAttrs","attr","prevCallback","attrChanged","Attribute","parseAttributeDescriptor","declareAttribute","setAttribute","removeAttribute","ComponentStateKey","provided","ComponentState","ComponentState__key","AttributeTracker","_name","DomPropertyPath__root","RenderPath__root","RenderDef","recipe","valueByRecipe","base","defaults","trigger","ElementRenderCtl$","renderer","fulfill","when","scheduleRenderer","immediateSchedule","_renders","renderNow","renderElement","newRenderer","render","ElementRenderCtl","ElementRenderScheduler","renderCtl","recentShot","renderBy","Render","ShadowContentRoot","ShadowDomEvent","shadowRoot","ShadowRootBuilder","attachShadow","shadowRootOf","defaultShadowContentDef","mode","AttachShadow","Wesib__NS","DeltaSet","_added","_removed","remove","deltaSetDeltaReceiver","removed","added","InAspect__symbol","inAspectNull","instance","convertTo","inAspectSameOrBuild","control","aspectKey","build","attachTo","aspect","inAspectSameOrNull","inAspectValue","InputAspects__NS","InNamespaceAliaser__aspect","applyTo","InNamespaceAliaser","applyAspect","InRenderScheduler__aspect","InRenderScheduler","intoConvertedBy","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","aspectConverters","conversion","acf","cv","isInAspectConversion","intoConvertedAspects","aspects","noopInConversion","InControl","_aspect","aspectKeyOrSetup","aspectSetup","and","InConverted","_aspects","applied","_applyAspect","backward","convertAspect","prevValue","prevRev","InSameValueControl","_control","_supply","AbstractInControl","_aspectConversion","InContainer__aspect","InContainer","InContainerControls","InParents__aspect","InControlParents","InParents","allParents","existingSupply","parent","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","OwnModeTracker","initialInMode","DerivedInModes","_all","mergeInModes","derive","InParentsAspect","parentsInMode","derived","_derived","lastUpdate","applyInMode","parents","parentList","modes","ro","inModeValue","InData__aspect","InData","hasData","InGroup__aspect","InGroup","InGroupControls","inControlReplacedReason","InGroupSnapshot","_entriesIt","InGroupMap","_controls","replaced","newEntry","sendUpdate","modify","_shot","entries","k","InGroupControlControls","_group","_updates","controlEntryToGroupEntry","takeSnapshot","snapshot","model","withValues","keyOrControls","newControl","group","newModel","keyAndEntry","applyControlsToModel","InGroupControl","_model","controls","cs","readInGroupData","csData","controlsData","data","keyAndControlData","controlData","inGroup","RequireNothing$","requireNothing","dontRemove","InValidationMessages","validators","validatorMessages","validate","_messages","resultSupply","validator","validatorSupply","inValidator","InValidation__aspect","InValidation","validation","InControlValidation","noInValidationErrors","ok","hasBut","InValidationErrors","nonEmpty","code","codePresent","_byCode","codes","some","every","inValidationResult","results","nestedInValidationMessages","numValidators","requireAll","requirePresent","missing","AbstractInElement","self","_get","_set","_value","doUpdate","_update","correction","_input","listenForInput","onInput","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","activeElement","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","_flags","flags","updateInStatusFlags","elementInStatusFlags","_container","inControlStatuses","combineInStatusFlags","markEdited","markTouched","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","_sources","classes","mergeInCssClassesMap","classesSent","flag","delta","redelta","undelta","_schedule","controlSchedule","specs","names","inSupply","classesSupply","classList","updateClasses","inCssError","mark","hasError","errors","defaultInCssHasError","defaultInCssErrorMarks","marks","inCssErrorMarks","inCssInfo","cls","md","vl","valid","escapeCSS","text","len","charCodeAt","out","toString","escapeCSSVal","uppercasePattern","toHyphenLower","letters","offset","str","lowerCase","hyphenateCSSName$cache","hyphenateCSSName","hyphenated","hyphenateName","startsWith","isReadonlyArray","isNotEmptyArray","StypValueStruct","priority","prioritize","stypValuesEqual","StypColorStruct","StypRGB","coords","r","intCoord","g","b","coord","rgb","hsl","max","Math","min","l","round","StypHSL","h","d","StypColor","p","hueAsFraction","hueToRgb","t","newT","mixStypColors","color1","color2","weight","w","rgba1","rgba2","aDiff","w1","w2","StypNumericStruct","dim","toFormula","StypMapper","mappings","mapped","mappedValue","mapping","mappingBy","stypSplitPriority","endsWith","trim","StypDimension","val","unit","thisDim","pt","noPt","addendum","stypDimension","stypAddSub","subtrahend","multiplier","divisor","zero","StypCalcBase","left","op","right","usual","stypMul","stypDiv","StypAddSub","toDim","negate","StypMulDiv","Zero","_byPriority","important","ZeroByPriority","unitlessZeroDimensionKind","dimension","StypDimension_","isStypNumeric","StypLength","StypLengthPt","StypURL","noStypProperties","noStypPropertiesSpec","stypPropertiesBySpec","rule","preventDuplicates","propertiesKeeper","senderOrProperties","propertiesMap","properties","stored","propertyEntries","sentry","propertiesEqual","passNonDuplicate","$$css","mergeStypProperties","baseProperties","addendumProperties","v","priorityOf","addValue","addValues","isCombinator","item","normalizeStypSelector","selector","normalizeKey","normalized","combinator","prevCombinator","part","normalizeStypSelectorPart","sort","normalizeClasses","u","isSubSelectorsArray","normalizeSubSelector","normalizeSubSelectors","isPseudoSubSelector","$","normalizeQualifiers","sub","prefix","params","qualifiers","exposeQualifier","noQualifiers","qualifier","eqIdx","indexOf","exposed","lastExposed","split","noKeyAndTail","stypRuleKeyAndTail","rootSelector","classesMatch","query","qClass","find","mClass","namesEqual","stypSelector","ruleKeyTextOpts","qualify","stypRuleKeyText","formatStypSelector","defaultFormat","format","hasProperties","className","subFormat","attrName","attrOp","attrVal","attrFlag","formatSubSelector","xmlNs","qualifyElement","formatItem","AtRulesRenderer","_rule","outer","onlyAtProperties","producer","writer","isGroup","sheet","atSelectors","rest","extractPartAtSelectors","extractAtSelectors","restSelector","atSelector","buildAtSelector","addStyle","addGroup","customQuery","addQuery","namedQuery","stypRenderAtRules","order","create","isAtEntry","restQualifies","addAtSelector","colonIdx","prevQuery","stypRenderGlobals","FIRST_RENDER_ORDER","rootRule","importIndex","nsIndex","importDelta","renderImport","renderDefaultNamespace","renderNamespacePrefix","css","addGlobal","stypRenderProperties","style","notCustomProperty","stypRenderText","stypRenderXmlNs","xmlNsDefs","declareNs","rendererFactory","isRendererFactory","rendererSpec","compareRenderers","firstOrder","secondOrder","stypRenderScheduler","removeStyleElement","defaultPrettyPrint","indent","compactStypTextFormatter","nv","eol","pre","StypTextFormatter$","_config","StypStyleTextWriter","f","nf","substr","afterBody","AbstractStypGroupTextWriter","_add","StypGroupTextWriter","StypSheetTextWriter","stypDomFormat","head","textFormat","pretty","formatter","idSeq","onSheet","addSheet","stypTextFormat","textContent","createElement","appendChild","StypStyleObjectWriter","setProperty","cssText","StypGroupObjectWriter","ruleText","cssRules","insertRule","StypSheetObjectWriter","deleteRule","produceBasicStyle","rules","selectorFormat","factories","addRenderers","renderers","addRenderer","stypRenderFactories","renderSupply","renderRule","trackSupply","trackRules","styleProducer","production","_selector","stypSelectorText","reader","renderAt","nextIndex","nextRenderer","nextProducer","rendererForRule","ruleSelector","lastSheet","defaultStypRenderers","produceStyle","StypRule","StypRuleList","StypRuleHierarchy","Rules","_list","ruleMatches","_buildList","_ruleSet","returnSelf","grabRules","list","stypQuery","stypSelectorMatches","AllRules","Self","selfRuleList","iterateAllRules","extendRule","propertiesSupply","_spec","NestedRules","root","_byKey","StypRule$","builder","_outer","outerSelector","stypOuterSelector","empty","targetSelector","oldSpec","extendSpec","keyText","newNested","StypRuleRef","StypRuleRef$","ms","ps","watch","_mappings","_properties","RefStypRule","mappingsKeeper","StypRuleRefs","refs","fromAll","flattenProperties","referrers","noStypRules","stypRules","rulesByList","rulesFromSource","getRules","rulesByValue","evalRules","lazyStypRules","lazyRulesFromSource","ruleSet","reportExistingRules","lazyRules","asyncRules","hthvItem","n","x","pl","addParam","param","parseNone","datePattern","dateTimeParser","dateTime","parseDateTime","nextInItem","delimiterOf","itemParser","named","tagged","extra","parseAngleBrackets","angleBracketsParser","parseQuotedString","unquoted","quotedStringParser","parseExtra","tag","extraItem","nextInComment","spacesParser","start","paramParser","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter","FetchAgentKey","agents","fetch","agentIdx","agentRequest","agent","nextRequest","combineFetchAgents","defaultFetchAgent","HttpFetchAgent","HttpFetchAborted","HttpFetch","Request","responseEmitter","abortController","AbortController","signal","abort","response","customSignal","aborted","HierarchyRoot","HierarchyUpdates","issue","HierarchyUpdates__key","hierarchyRoot","findParentContext","immediate","HierarchyContext__key","HierarchyContext$","HierarchyContext","up","parentHierarchy","_parent","rootSupply","parentSupply","updateParent","parentCtx","newParent","_registry","isContextSeedUpKey","upper","enclosing","ElementNodeList","WATCH_DEEP","subtree","elementNodeList","selectorOrType","nodeOf","deep","cache","overNodes","overNodeSubtree","selected","refresh","ElementNodeList$","observer","firstReceiver","disconnect","initialEmitter","sel","querySelectorAll","children","matches","select","removeNode","addNode","nodes","childNodes","AttributesObserver","_bs","_observer","Observer","_emitter","_emitters","reconnect","takeRecords","observeSupply","NodeAttributes","_attrs","PropertyTracker","NodeProperties","_props","prop","ElementNode__symbol","ElementNode$","_bind","elementNodeOf","optional","selectNodes","ComponentNode","getHashURL","URL","hash","PageParam__symbol","PageParam","_page","NavigationAgentKey","navigate","agentTo","nextURL","title","nextTitle","nextData","baseURI","visited","current","put","defaultNavigationAgent","_when","_from","NavigationAgent","PageParamContext","NavHistory__key","NavHistory","extractNavData","_document","_location","location","_history","history","_uid","btoa","random","href","_entries","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","page","pushState","_enter","fromEntry","_forget","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","wesib:navigation:data","_params","handle","newHandle","_newContext","_init","transferred","at","stay","EnterPageEvent","cancelable","LeavePageEvent","StayOnPageEvent","Navigation__key","navHistory","nav","nextEntry","hashChange","Navigation","onEnter","onLeave","onStay","go","toURL","withParam","applyParams","open","targetOrCallback","navTarget","navTargetOf","applyAgent","whenLeave","doNavigate","prepared","leavePage","prepare","navigated","defaultNavLinkWeight","calcNavLinkWeight","linkURL","pageURL","linkDir","navLinkPath2dir","pageDir","searchParamWeight","navLinkSearchParamsWeight","pathname","searchParams","linkParams","pageParams","isIgnoredSearchParam","getAll","includes","NavLinkRenderSchedule__symbol","defaultActiveNavLinkClass","defaultNavLinkHref","importNode","beforeOrImport","importContent","importNodeContent","before","elementClone","tagName","getAttributeNames","insertBefore","nodeClone","cachingPageLoader","pageUrl","sup","tracked","onLoad","resp","num","requested","PageLoadAbortError","PageLoadRequestsParam","requests","PageLoadRequests","_navigation","_requests","fragments","allMatch","itsEvery","fragment","pageSupply","loadSupply","_transfer","responseReceiver","getElementsByTagName","getElementById","onFragment","req","PageLoadAgent","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","header","requestPageFragments","extractSender","digOn_","batch","parsePageDocument","parseFromString","querySelector","newBase","PageLoadParam$","PageLoadParam","PageCacheBuster__key","PageCacheBuster","appRev","navigation","urlModifier","newRev","reload","pageScriptsAgent","allScripts","externalScripts","scripts","script","pageStyleAgent","newStyles","oldStyles","oldStylesByHref","firstOldStyle","link","newStyle","oldStyle","nextSibling","pageTitleAgent","PageLoadSupport__feature","buster","PageLoadSupport","defaultPageContentKey","DefaultInAspectsKey","DefaultInAspects","InputFromControl","inputFromControl","ComponentStyleProducer","componentStypDomFormatConfig","defaultStypRenderScheduler","ComponentStypRenderer","ElementIdClass__NS","ElementIdClass","contextValues","aliaser","uniqueClassSeq","qualified","ComponentStypFormat__symbol","ComponentStypObjectFormat","ComponentStypFormat","newProducer","componentSupply","hostSelector","host","extractHostSelector","extendHostSelector","shadowRenderer","noShadowRenderer","restParts","createTextNode","stypObjectFormat","ComponentStypDomFormat","ProduceStyle","produce","StyleProducerSupport__feature","ThemeStyleKey","isId","prevProvider","hasId","combineStyles","ThemeStyle","theme","Theme__key","Theme$","Theme","referrer","_styles","styles","_rules","Examples__NS","ThemeSettings","$color","$bgColor","$fontFace","$fontSize","$lineHeight","$fontWeight","$linkFontWeight","$layoutBreakpoint","mediaStyle","@media:sm","LinkStyle","settings","linkStyle","textDecoration","color","fontWeight","DefaultStyle","defaultStyle","font","BodyStyle","height","margin","padding","bodyStyle","backgroundColor","FormThemeSettings","global","formMappings","$roBgColor","$errorFontSize","mul","$borderColor","$marginV","div","$marginH","$paddingV","$paddingH","$borderW","InErrorComponent","InErrorStyle","__decorate","items","Attributes","trackAttribute","cssClasses","converted","usageSupply","hasError__cssClass","borderW","display","fontSize","borderLeft","paddingLeft","InputSupport","MainComponent","mainStyle","flex","onResponse","contentKey","detectFragment","lastPageURL","range","createRange","selectNodeContents","newPageURL","deleteContents","createDocumentFragment","insertNode","handleResponse","IncludePage","NavComponent","_theme","NavStyle","getHref","preventDefault","defaultHandleNavLinks","eventType","HandleNavLinks","pick","activate","active","activeClass","assignClass","makeActive","lastSupply","activateNavLink","weigh","navLinkWeight","componentNode","weights","maxWeight","selectActiveNavLinks","newActive","activeLink","ActivateNavLink","navStyle","sts","background","navLinkBackground","navLinkStyle","activeNavLinkStyle","border","outline","ContainerComponent","mainName","flexFlow","alignItems","alignContent","ContainerStyle","LayoutSupportFeature","BodyStyleSupport","AppFeature","InputStyle","formSettings","inStyle","readonlyInStyle","focusedInStyle","invalidInStyle","outlineStyle","boxShadow","boxSizing","width","outlineColor","examplesContext","features","bootstrapContextRegistry","complete","BootstrapContext$","bsStage","info","ldr","whenDown","Ref","initBootstrap","bootstrapComponents"],"mappings":"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"}