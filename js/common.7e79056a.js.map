{"version":3,"file":"common.7e79056a.js","sources":["../../../../proc7ts/call-thru/src/misc/asis.ts","../../../../proc7ts/call-thru/src/misc/noop.ts","../../../../proc7ts/call-thru/src/misc/presence.ts","../../../../proc7ts/call-thru/src/misc/value-providers.ts","../../../../proc7ts/call-thru/src/next-call.ts","../../../../proc7ts/call-thru/src/passes/arg.ts","../../../../proc7ts/call-thru/src/passes/args.ts","../../../../proc7ts/call-thru/src/passes/skip.ts","../../../../proc7ts/a-iterable/src/util.ts","../../../../proc7ts/a-iterable/src/termination.ts","../../../../proc7ts/a-iterable/src/transform.ts","../../../../proc7ts/a-iterable/src/construction.ts","../../../../proc7ts/a-iterable/src/reverse.ts","../../../../proc7ts/a-iterable/src/objects.ts","../../../../proc7ts/context-values/src/context-key.ts","../../../../proc7ts/context-values/src/context-key-error.ts","../../../../proc7ts/context-values/src/context-value-spec.ts","../../../../proc7ts/context-values/src/context-values.ts","../../../../proc7ts/context-values/src/context-registry.ts","../../../../proc7ts/context-values/src/iterative-context-key.ts","../../../../proc7ts/context-values/src/multi-context-key.ts","../../../../proc7ts/context-values/src/simple-context-key.ts","../../../../proc7ts/context-values/src/single-context-key.ts","../../../../proc7ts/fun-events/src/base/event-keeper.ts","../../../../proc7ts/fun-events/src/base/event-supply.ts","../../../../proc7ts/fun-events/src/base/event-receiver.ts","../../../../proc7ts/fun-events/src/base/event-notifier.impl.ts","../../../../proc7ts/fun-events/src/base/event-notifier.ts","../../../../proc7ts/fun-events/src/base/event-sender.ts","../../../../proc7ts/fun-events/src/base/no-event-supply.ts","../../../../proc7ts/fun-events/src/base/send-events-to.ts","../../../../proc7ts/fun-events/src/impl/once.ts","../../../../proc7ts/fun-events/src/impl/share.ts","../../../../proc7ts/fun-events/src/impl/thru.ts","../../../../proc7ts/fun-events/src/impl/till-off.ts","../../../../proc7ts/fun-events/src/base/impl/never-receive.ts","../../../../proc7ts/fun-events/src/on-event.ts","../../../../proc7ts/fun-events/src/impl/then.ts","../../../../proc7ts/fun-events/src/after-event.ts","../../../../proc7ts/fun-events/src/keepers/after-sent.ts","../../../../proc7ts/fun-events/src/keepers/after-supplied.ts","../../../../proc7ts/fun-events/src/keepers/after-all.ts","../../../../proc7ts/fun-events/src/keepers/after-each.ts","../../../../proc7ts/fun-events/src/keepers/after-the.ts","../../../../proc7ts/fun-events/src/passes/next-after-event.ts","../../../../proc7ts/fun-events/src/senders/event-emitter.ts","../../../../proc7ts/fun-events/src/senders/on-never.ts","../../../../proc7ts/fun-events/src/senders/on-supplied.ts","../../../../proc7ts/fun-events/src/senders/on-any.ts","../../../../proc7ts/fun-events/src/senders/on-async.ts","../../../../proc7ts/fun-events/src/senders/on-any-async.ts","../../../../proc7ts/fun-events/src/senders/on-promise.ts","../../../../proc7ts/fun-events/src/base/impl/always-receive-value.ts","../../../../proc7ts/fun-events/src/state/state-path.ts","../../../../proc7ts/fun-events/src/state/state-tracker.ts","../../../../proc7ts/fun-events/src/value/value-tracker.ts","../../../../proc7ts/fun-events/src/value/track-value.ts","../../../../proc7ts/fun-events/src/value/value-sync.ts","../../../../proc7ts/namespace-aliaser/src/naming.ts","../../../../proc7ts/namespace-aliaser/src/namings.ts","../../../../proc7ts/namespace-aliaser/src/namespace.ts","../../../../proc7ts/namespace-aliaser/src/name.ts","../../../../proc7ts/namespace-aliaser/src/namespace-aliaser.ts","../../../../proc7ts/fun-events/src/dom/on-dom-event.ts","../../../../proc7ts/fun-events/src/dom/dom-event-dispatcher.ts","../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../proc7ts/context-values/src/updatable/context-supply.ts","../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../proc7ts/context-values/src/updatable/single-context-up-key.ts","../../../../proc7ts/render-scheduler/src/render-schedule.ts","../../../../proc7ts/render-scheduler/src/custom-render-scheduler.ts","../../../../proc7ts/render-scheduler/src/render-queue.ts","../../../../proc7ts/render-scheduler/src/animation-render-scheduler.ts","../../../../proc7ts/render-scheduler/src/immediate-render-scheduler.ts","../../../../proc7ts/render-scheduler/src/render-scheduler.ts","../../../wesib/src/boot/bootstrap-context.key.impl.ts","../../../wesib/src/boot/bootstrap-context.ts","../../../wesib/src/boot/bootstrap-default.ts","../../../wesib/src/common/types.impl.ts","../../../wesib/src/common/array-set.ts","../../../wesib/src/common/classes.ts","../../../wesib/src/common/decorators.ts","../../../wesib/src/common/reflect.ts","../../../wesib/src/common/functions.ts","../../../wesib/src/common/is-element.ts","../../../wesib/src/common/meta-accessor.ts","../../../wesib/src/common/promises.ts","../../../wesib/src/feature/feature-def.ts","../../../wesib/src/feature/feature.decorator.ts","../../../wesib/src/feature/feature-context.ts","../../../wesib/src/feature/feature-needs-error.ts","../../../wesib/src/feature/feature-ref.ts","../../../wesib/src/component/component-def.ts","../../../wesib/src/component/component.decorator.ts","../../../wesib/src/component/component-context.key.impl.ts","../../../wesib/src/component/component-event.key.impl.ts","../../../wesib/src/component/content-root.ts","../../../wesib/src/component/state-updater.ts","../../../wesib/src/component/component-context.ts","../../../wesib/src/component/component-event.ts","../../../wesib/src/component/component-property.decorator.ts","../../../wesib/src/boot/impl/bootstrap-context-registry.impl.ts","../../../wesib/src/boot/impl/component-context-registry.impl.ts","../../../wesib/src/boot/impl/definition-context-registry.impl.ts","../../../wesib/src/boot/impl/post-def-setup.impl.ts","../../../wesib/src/boot/globals/bootstrap-window.ts","../../../wesib/src/boot/globals/bootstrap-root.ts","../../../wesib/src/boot/globals/default-namespace-aliaser.ts","../../../wesib/src/boot/globals/default-render-scheduler.ts","../../../wesib/src/boot/globals/element-adapter.ts","../../../wesib/src/boot/globals/element-observer.ts","../../../wesib/src/boot/impl/definition-context.symbol.impl.ts","../../../wesib/src/component/definition/custom-elements.ts","../../../wesib/src/component/definition/definition.context.key.impl.ts","../../../wesib/src/component/definition/element-def.ts","../../../wesib/src/component/definition/definition-context.ts","../../../wesib/src/boot/impl/component-context.impl.ts","../../../wesib/src/boot/impl/component-mount.impl.ts","../../../wesib/src/component/component-mount.ts","../../../wesib/src/boot/impl/custom-element.impl.ts","../../../wesib/src/boot/impl/when-component.impl.ts","../../../wesib/src/boot/impl/definition-context.impl.ts","../../../wesib/src/boot/impl/element-builder.impl.ts","../../../wesib/src/boot/impl/unloader.impl.ts","../../../wesib/src/feature/loader/component-registry.impl.ts","../../../wesib/src/feature/loader/feature-context.impl.ts","../../../wesib/src/feature/loader/feature-loader.impl.ts","../../../wesib/src/feature/loader/feature-request.impl.ts","../../../wesib/src/feature/loader/feature-requester.impl.ts","../../../wesib/src/boot/impl/when-defined.impl.ts","../../../wesib/src/feature/attributes/attribute-descriptor.ts","../../../wesib/src/feature/attributes/attribute-path.ts","../../../wesib/src/feature/attributes/attribute-state-update.impl.ts","../../../wesib/src/feature/attributes/property2attribute-name.ts","../../../wesib/src/feature/attributes/attribute-registry.impl.ts","../../../wesib/src/feature/attributes/attributes-support.feature.ts","../../../wesib/src/feature/attributes/attribute.decorator.ts","../../../wesib/src/feature/attributes/attribute-descriptor.impl.ts","../../../wesib/src/feature/state/component-state.ts","../../../wesib/src/feature/state/state-support.feature.ts","../../../wesib/src/feature/attributes/track-attribute.ts","../../../wesib/src/feature/dom-properties/dom-property-path.ts","../../../wesib/src/feature/render/render-def.ts","../../../../proc7ts/call-thru/src/misc/value-recipe.ts","../../../wesib/src/feature/render/element-render-ctl.impl.ts","../../../wesib/src/feature/render/element-render-ctl.ts","../../../wesib/src/feature/render/element-render-scheduler.ts","../../../wesib/src/feature/render/render.decorator.ts","../../../wesib/src/feature/shadow-dom/shadow-content-root.ts","../../../wesib/src/feature/shadow-dom/shadow-dom-event.ts","../../../wesib/src/feature/shadow-dom/shadow-root-builder.ts","../../../wesib/src/feature/shadow-dom/shadow-dom-support.feature.ts","../../../wesib/src/feature/shadow-dom/attach-shadow.decorator.ts","../../../wesib/src/wesib.ns.ts","../../../../proc7ts/http-header-value/src/hthv-partial.impl.ts","../../../../proc7ts/http-header-value/src/parser/add-param.ts","../../../../proc7ts/http-header-value/src/parser/next-in-item.ts","../../../../proc7ts/http-header-value/src/parser/parse-date-time.ts","../../../../proc7ts/http-header-value/src/parser/parse-none.ts","../../../../proc7ts/http-header-value/src/parser/item-parser.ts","../../../../proc7ts/http-header-value/src/parser/quoted-string-parser.ts","../../../../proc7ts/http-header-value/src/parser/angle-brackets-parser.ts","../../../../proc7ts/http-header-value/src/parser/next-in-comment.ts","../../../../proc7ts/http-header-value/src/parser/spaces-parser.ts","../../../../proc7ts/http-header-value/src/parser/param-parser.ts","../../../../proc7ts/http-header-value/src/parser/parser-config.ts","../../../../proc7ts/http-header-value/src/hthv-parser.ts","../../../../proc7ts/http-header-value/src/parser/item-delimit-parser.ts","../../../../proc7ts/http-header-value/src/parser/comment-parser.ts","../../../../proc7ts/http-header-value/src/hthv-parse.ts","../../../../proc7ts/http-header-value/src/hthv-quote.ts","../../../generic/src/fetch/fetch-agent-key.impl.ts","../../../generic/src/fetch/http-fetch-agent.ts","../../../generic/src/fetch/http-fetch.impl.ts","../../../generic/src/fetch/http-fetch.ts","../../../generic/src/hierarchy/hierarchy-updates.impl.ts","../../../generic/src/hierarchy/hierarchy-context.ts","../../../generic/src/hierarchy/hierarchy-registry.impl.ts","../../../generic/src/tree/element-node.ts","../../../generic/src/tree/element-node-list.ts","../../../generic/src/tree/element-node-list.impl.ts","../../../generic/src/tree/node-attributes.impl.ts","../../../generic/src/tree/node-properties.impl.ts","../../../generic/src/tree/element-node.impl.ts","../../../generic/src/tree/component-tree-support.feature.ts","../../../generic/src/navigation/hash-url/hash-url.ts","../../../generic/src/navigation/page-param.ts","../../../generic/src/navigation/navigation-agent.ts","../../../generic/src/navigation/navigation.ts","../../../generic/src/navigation/page-param-context.ts","../../../generic/src/navigation/nav-history.impl.ts","../../../generic/src/navigation/navigation.event.ts","../../../generic/src/navigation/navigation.impl.ts","../../../generic/src/navigation/navigation-support.feature.ts","../../../generic/src/navigation/activate-nav-link.decorator.ts","../../../generic/src/navigation/handle-nav-links.decorator.ts","../../../generic/src/util/import-node.ts","../../../generic/src/navigation/page-load/caching-page-loader.impl.ts","../../../generic/src/navigation/page-load/page-load-requests.impl.ts","../../../generic/src/navigation/page-load/page-load-agent.ts","../../../generic/src/navigation/page-load/page-load-url-modifier.ts","../../../generic/src/navigation/page-load/page-loader.impl.ts","../../../../proc7ts/call-thru/src/passes/each.ts","../../../generic/src/navigation/page-load/page-load-param.ts","../../../generic/src/navigation/page-load/page-cache-buster.impl.ts","../../../generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../../generic/src/navigation/page-load/page-style-agent.impl.ts","../../../generic/src/navigation/page-load/page-title-agent.impl.ts","../../../generic/src/navigation/page-load/page-load-support.feature.ts","../../../generic/src/navigation/page-load/include-page.decorator.ts","../../../../proc7ts/style-producer/src/internal/css.ts","../../../../proc7ts/style-producer/src/internal/types.ts","../../../../proc7ts/style-producer/src/value/value.ts","../../../../proc7ts/style-producer/src/value/color/color.ts","../../../../proc7ts/style-producer/src/value/color/mix.ts","../../../../proc7ts/style-producer/src/value/numeric/numeric.ts","../../../../proc7ts/style-producer/src/value/mapper.ts","../../../../proc7ts/style-producer/src/value/priority.ts","../../../../proc7ts/style-producer/src/value/numeric/numeric.impl.ts","../../../../proc7ts/style-producer/src/value/numeric/zero.impl.ts","../../../../proc7ts/style-producer/src/value/numeric/dimension-kind.impl.ts","../../../../proc7ts/style-producer/src/value/unit/length.ts","../../../../proc7ts/style-producer/src/value/url.ts","../../../../proc7ts/style-producer/src/rule/properties.impl.ts","../../../../proc7ts/style-producer/src/selector/selector.impl.ts","../../../../proc7ts/style-producer/src/selector/query.ts","../../../../proc7ts/style-producer/src/selector/selector-constructor.ts","../../../../proc7ts/style-producer/src/selector/selector-text.impl.ts","../../../../proc7ts/style-producer/src/producer/renderers/at-rules.renderer.ts","../../../../proc7ts/style-producer/src/producer/renderers/renderer.impl.ts","../../../../proc7ts/style-producer/src/producer/renderers/globals.renderer.ts","../../../../proc7ts/style-producer/src/producer/renderers/properties.renderer.ts","../../../../proc7ts/style-producer/src/producer/renderers/text.renderer.ts","../../../../proc7ts/style-producer/src/producer/renderers/xml-ns.renderer.ts","../../../../proc7ts/style-producer/src/producer/formats/format.impl.ts","../../../../proc7ts/style-producer/src/producer/formats/text.format.ts","../../../../proc7ts/style-producer/src/producer/formats/dom.format.ts","../../../../proc7ts/style-producer/src/producer/formats/object.format.ts","../../../../proc7ts/style-producer/src/producer/produce-basic-style.ts","../../../../proc7ts/style-producer/src/selector/selector-text.ts","../../../../proc7ts/style-producer/src/producer/renderers/default-renderers.impl.ts","../../../../proc7ts/style-producer/src/producer/produce-style.ts","../../../../proc7ts/style-producer/src/rule/rule.ts","../../../../proc7ts/style-producer/src/rule/rules.impl.ts","../../../../proc7ts/style-producer/src/rule/rule.impl.ts","../../../../proc7ts/style-producer/src/rule/root.ts","../../../../proc7ts/style-producer/src/rule/rule-ref.ts","../../../../proc7ts/style-producer/src/rule/rule-refs.ts","../../../../proc7ts/style-producer/src/rule/rules.ts","../../../generic/src/styp/component-style-producer.ts","../../../generic/src/styp/component-styp-renderer.ts","../../../generic/src/styp/element-id-class.impl.ts","../../../generic/src/styp/component-styp-format.ts","../../../generic/src/styp/component-styp-dom.format.ts","../../../generic/src/styp/component-styp-object.format.ts","../../../generic/src/styp/basic-style-producer-support.feature.ts","../../../generic/src/styp/produce-style.decorator.ts","../../../generic/src/styp/style-producer-support.feature.ts","../../../generic/src/theme/theme.ts","../../../generic/src/theme/theme-factory.ts","../../../generic/src/theme/theme-style.ts","../../../generic/src/theme/theme.impl.ts","../../../generic/src/theme/theme-factory.impl.ts","../../../generic/src/theme/theme-support.feature.ts","../../../../proc7ts/delta-set/src/delta-set.ts","../../../../proc7ts/input-aspects/src/aspect.ts","../../../../proc7ts/input-aspects/src/aspect.impl.ts","../../../../proc7ts/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../../../proc7ts/input-aspects/src/aspects/render-scheduler.aspect.ts","../../../../proc7ts/input-aspects/src/converter.ts","../../../../proc7ts/input-aspects/src/control.ts","../../../../proc7ts/input-aspects/src/controls/value-of.control.ts","../../../../proc7ts/input-aspects/src/controls/abstract.control.ts","../../../../proc7ts/input-aspects/src/containers/container.control.ts","../../../../proc7ts/input-aspects/src/containers/parents.aspect.ts","../../../../proc7ts/input-aspects/src/element.control.ts","../../../../proc7ts/input-aspects/src/data/mode.aspect.ts","../../../../proc7ts/input-aspects/src/data/data.aspect.ts","../../../../proc7ts/input-aspects/src/containers/group.control.ts","../../../../proc7ts/input-aspects/src/validation/require-nothing.validator.ts","../../../../proc7ts/input-aspects/src/validation/validator.ts","../../../../proc7ts/input-aspects/src/validation/validator.impl.ts","../../../../proc7ts/input-aspects/src/validation/validation.aspect.ts","../../../../proc7ts/input-aspects/src/validation/require-all.validator.ts","../../../../proc7ts/input-aspects/src/validation/require-present.validator.ts","../../../../proc7ts/input-aspects/src/elements/abstract-element.control.ts","../../../../proc7ts/input-aspects/src/elements/text.control.ts","../../../../proc7ts/input-aspects/src/elements/focus/focus.aspect.ts","../../../../proc7ts/input-aspects/src/elements/focus/status.aspect.ts","../../../../proc7ts/input-aspects/src/elements/style/styled-element.aspect.ts","../../../../proc7ts/input-aspects/src/elements/style/css-classes.aspect.ts","../../../../proc7ts/input-aspects/src/elements/style/css-error.ts","../../../../proc7ts/input-aspects/src/elements/style/css-info.ts","../../../generic/src/input/default-in-aspects.ts","../../../generic/src/input/input-from-control.ts","../../src/common/examples.ns.ts","../../src/common/theme/theme-settings.ts","../../src/common/theme/link.style.ts","../../src/common/theme/default.style.ts","../../src/common/theme/body.style.ts","../../src/common/input/form.theme-settings.ts","../../src/common/input/in-error.component.ts","../../../generic/src/input/convert-input.decorator.ts","../../../wesib/src/feature/attributes/attributes.decorator.ts","../../src/common/input/input-support.feature.ts","../../src/common/layout/main.component.ts","../../src/common/layout/nav.component.ts","../../src/common/layout/container.component.ts","../../src/common/layout/layout-support.feature.ts","../../src/common/theme/body-style-support.feature.ts","../../src/common/app.feature.ts","../../src/common/input/input.style.ts","../../src/common/index.ts","../../../wesib/src/boot/bootstrap/bootstrap-components.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\n/**\n * A function that returns its argument as is.\n *\n * @param value  A value to return.\n *\n * @returns `value`.\n */\nexport function asis<T>(value: T): T {\n  return value;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\n/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nexport function noop(): undefined {\n  return;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\n/**\n * A function that checks whether the given value is present.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nexport function isPresent<T>(value: T | undefined | null): value is T {\n  return value != null;\n}\n\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nexport function isNotPresent<T>(value: T | undefined | null): value is T {\n  return value == null;\n}\n\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nexport function isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value  A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nexport function isUndefined<T>(value: T | undefined): value is T {\n  return value === undefined;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\n/**\n * Creates a provider of the only argument.\n *\n * @param value  A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return (): T => value;\n}\n\n/**\n * Creates a provider of lazily evaluated value.\n *\n * The returned function evaluates the value first time it is called. Then it just returns previously evaluated value.\n *\n * @param provider  A no-arg function evaluating the value.\n *\n * @returns A function that returns the value evaluated by `provider`.\n */\nexport function lazyValue<T>(provider: (this: void) => T): (this: void) => T {\n\n  let get = (): T => (get = valueProvider(provider()))();\n\n  return () => get();\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return (): T => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values  Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return (): T => Array.from(values) as T;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\nimport { CallChain } from './call-chain';\n\n/**\n * A key of a [[NextCall]] method responsible for calling the next pass in chain.\n */\nexport const NextCall__symbol = (/*#__PURE__*/ Symbol('next-call'));\n\n/**\n * A call of the next pass in chain.\n *\n * This is basically a function with additional method, which is treated specially by call chaining functions.\n * When previous pass in chain returns a [[NextCall]] instance, it will be used to call the next pass in chain.\n * Otherwise the next pass will be called with value returned as its {@link CallChain.pass single argument}.\n *\n * A [[NextCall]] is a function returning itself. So it can be chained like any other pass.\n *\n * A [[nextCall]] function can be used to construct a next call.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of arguments tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass. The same as `NextArgs` by default.\n */\nexport interface NextCall<Chain extends CallChain, NextArgs extends any[], NextArg = NextArgs> {\n\n  readonly $?: NextArg; // Silence the TypeScript compiler, as `NextArg` is never read.\n\n  /**\n   * Calls the given pass of the call chain.\n   *\n   * @param chain  Target call chain.\n   * @param pass  A pass in call chain to call.\n   */\n  [NextCall__symbol](\n      chain: Chain,\n      pass: (this: void, ...args: NextArgs) => void,\n  ): void;\n\n  /**\n   * Returns itself.\n   *\n   * Makes this call a valid no-arg pass of a call chain.\n   */\n  (): this; // eslint-disable-line @typescript-eslint/prefer-function-type\n\n}\n\n/**\n * Constructs a call of the next pass in chain.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of argument tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass. The same as `NextArgs` by default.\n * @param callNext  A next pass caller function.\n *\n * @returns Next pass call performed by the given function.\n */\nexport function nextCall<Chain extends CallChain, NextArgs extends any[], NextArg>(\n    callNext: (\n        this: void,\n        chain: Chain,\n        fn: (this: void, ...args: NextArgs) => void,\n    ) => void,\n): NextCall<Chain, NextArgs, NextArg> {\n\n  const result = (() => result) as NextCall<Chain, NextArgs, NextArg>;\n\n  result[NextCall__symbol] = (chain, fn) => callNext(chain, fn);\n\n  return result;\n}\n\n/**\n * Checks whether the `target` value is a {@link NextCall next call}.\n *\n * @typeparam Chain  A type of supported call chain.\n * @typeparam NextArgs  A type of arguments tuple of the next pass.\n * @typeparam NextArg  A type of single argument or arguments tuple of the next pass.\n * @param target  A value to check.\n *\n * @returns `true` if the `target` value is a function with [[NextCall__symbol]] property, or `false` otherwise.\n */\nexport function isNextCall<Chain extends CallChain, NextArgs extends any[], NextArg>(\n    target: any,\n): target is NextCall<Chain, NextArgs, NextArg> {\n  return typeof target === 'function' && NextCall__symbol in target;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Provides a single argument for the next call chain pass.\n *\n * The returned [[NextCall]] implementation does the same as if the `arg` returned from the call chain pass.\n *\n * @typeparam NextArg  A type of argument for the next pass.\n * @param arg  Argument for the next pass.\n *\n * @return A call of the next pass with the given argument.\n */\nexport function nextArg<NextArg>(arg: NextArg): NextCall<CallChain, [NextArg], NextArg> {\n  return nextCall((chain, pass) => chain.pass(pass, arg));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Provides arguments for the next call chain pass.\n *\n * @typeparam NextArgs  A type of arguments tuple for the next pass.\n * @param args  Arguments for the next pass.\n *\n * @return A call of the next pass with the given arguments.\n */\nexport function nextArgs<NextArgs extends any[]>(\n    ...args: NextArgs\n): NextCall<CallChain, NextArgs, NextArgs> {\n  return nextCall((chain, fn) => chain.call(fn, args));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * A special [[NextCall]] indicating the rest of the steps are skipped.\n *\n * @typeparam Result  Call chain result type.\n */\nexport type NextSkip<Result = undefined> = NextCall<CallChain, never, Result>;\n\n/**\n * Builds a next call that skips the rest of the chain.\n *\n * This has the same effect as {@link nextReturn `nextReturn(undefined)`}.\n */\nexport const nextSkip: NextSkip = (/*#__PURE__*/ nextCall(chain => chain.skip()));\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { RevertibleIterable } from './revertible-iterable';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * This is a shortcut for `iterable[Symbol.iterator]` to make it friendlier to minification.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n\n/**\n * Builds an iterable iterator over the given `iterable`.\n *\n * @param iterable  An iterable to iterate over.\n *\n * @return An iterator.\n */\nexport function itsIterable<T>(iterable: Iterable<T>): IterableIterator<T> {\n  return function *() { yield* iterable; }();\n}\n\n/**\n * Creates custom iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  When `undefined` or unspecified the created iterable won't be reversible.\n *\n * @returns New iterable.\n */\nexport function makeIt<T>(iterate: (this: Iterable<T>) => Iterator<T>, reverse?: undefined): Iterable<T>;\n\n/**\n * Creates custom revertible iterable.\n *\n * @param iterate  A no-arg function constructing an iterator.\n * @param reverse  A no-arg function constructing a reverse iterable.\n *\n * @returns New reversible iterable.\n */\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse: (this: RevertibleIterable<T>) => Iterable<T>,\n): RevertibleIterable<T>;\n\nexport function makeIt<T>(\n    iterate: (this: RevertibleIterable<T>) => Iterator<T>,\n    reverse?: (this: RevertibleIterable<T>) => Iterable<T>,\n): Iterable<T> {\n\n  const iterable: Iterable<T> = {\n    [Symbol.iterator]: iterate,\n  };\n\n  if (!reverse) {\n    return iterable;\n  }\n\n  const reversible = iterable as RevertibleIterable<T>;\n\n  reversible.reverse = reverse;\n\n  return reversible;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator } from './util';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable of elements to perform actions on.\n * @param action  An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  for (const element of iterable) {\n    action(element);\n  }\n}\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable  Iterable to check for elements.\n *\n * @return `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<any>): boolean {\n  return !!itsIterator(iterable).next().done;\n}\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (!test(element)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Tests whether at least one element of the given `iterable` passes the test implemented by the provided function.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  An iterable to test elements of.\n * @param test  A predicate function to test each element. Returns `false` to continue tests, or `true` to stop it\n * and return `true` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the callback function returned a truthy value for at least one element in the array, or `false`\n * otherwise. Returns `false` for empty iterable.\n */\nexport function itsSome<T>(iterable: Iterable<T>, test: (this: void, element: T) => boolean): boolean {\n  for (const element of iterable) {\n    if (test(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns the first element of the given `iterable`.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  return itsIterator(iterable).next().value;\n}\n\n/**\n * Returns the last element of the given `iterable`.\n *\n * If the given `iterable` is an array-like structure, then just returns its last element. If it is revertible,\n * then extracts the first element of reverted one. Otherwise iterates over elements to find the last one.\n *\n * @typeparam T  A type of `iterable` elements.\n * @param iterable  Iterable to extract element from.\n *\n * @return Either the last element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsLast<T>(iterable: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): T | undefined {\n  if (isArrayLike(iterable)) {\n    return iterable[iterable.length - 1];\n  }\n  if (itsRevertible(iterable)) {\n    return itsFirst(iterable.reverse());\n  }\n\n  let last: T | undefined;\n\n  for (const element of iterable) {\n    last = element;\n  }\n\n  return last;\n}\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeparam T  A type of `iterable` elements.\n * @typeparam R  A type of reduced value.\n * @param iterable  An iterable to reduce values of.\n * @param reducer  A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue  Initial value passed to the first `reducer` call.\n *\n * @return Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, R>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: R, element: T) => R,\n    initialValue: R,\n): R {\n\n  let reduced = initialValue;\n\n  for (const element of iterable) {\n    reduced = reducer(reduced, element);\n  }\n\n  return reduced;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { asis } from '@proc7ts/call-thru';\nimport { makeIt } from './util';\n\n/**\n * Creates an iterable with all `source` iterable elements that pass the test implemented by the provided function.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable.\n * @param test  A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): Iterable<T>;\n\n/**\n * Creates an iterable with all `source` iterable elements extending the given type.\n *\n * @typeparam T  A type of source elements\n * @typeparam R  Target type.\n * @param source  A source iterable.\n * @param test  A predicate function to test that element extends the type `R`. Returns `true` to keep the element, or\n * `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @return A new iterable with the elements that pass the test. If no elements passed the test, an empty iterable will\n * be returned.\n */\nexport function filterIt<T, R extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is R,\n): Iterable<R>;\n\nexport function filterIt<T>(source: Iterable<T>, test: (this: void, element: T) => boolean): Iterable<T> {\n  return makeIt(function *() {\n    for (const element of source) {\n      if (test(element)) {\n        yield element;\n      }\n    }\n  });\n}\n\n/**\n * Flattens the source iterable of iterables into a new iterable.\n *\n * Calling this function is the same as calling `flatMapIt(source, asis)`.\n *\n * @typeparam T  A type of source elements.\n * @param source  A source iterable of iterables.\n *\n * @returns A new iterable with each element of `source` being the flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): Iterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into a new\n * iterable.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces a new iterable, taking the source element as the only parameter.\n *\n * @returns A new iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => Iterable<R>): Iterable<R>;\n\nexport function flatMapIt<T, R>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => Iterable<R> = asis as (element: T) => Iterable<R>,\n): Iterable<R> {\n  return makeIt(function *() {\n    for (const element of source) {\n      yield* convert(element);\n    }\n  });\n}\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element of the `source` one.\n *\n * @typeparam T  A type of source elements.\n * @typeparam R  A type of converted elements.\n * @param source  A source iterable.\n * @param convert  A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n */\nexport function mapIt<T, R>(source: Iterable<T>, convert: (this: void, element: T) => R): Iterable<R> {\n  return makeIt(function *() {\n    for (const element of source) {\n      yield convert(element);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { reverseArray } from './reverse';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { makeIt } from './util';\n\n/**\n * Builds an iterable over elements of array-like structure.\n *\n * @param array  An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns A revertible iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): RevertibleIterable<T> {\n  return makeIt<T>(\n      function *() {\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < array.length; ++i) {\n          yield array[i];\n        }\n      },\n      () => reverseArray(array),\n  );\n}\n\n/**\n * @internal\n */\nconst noneIterable: RevertibleIterable<any> = {\n\n  *[Symbol.iterator](): Iterator<any> {/* do not iterate */},\n\n  reverse() { return this; },\n\n};\n\n/**\n * Returns an iterable without elements.\n *\n * @typeparam T  A type of constructed iterable elements.\n *\n * @returns An empty iterable instance revertible to itself.\n */\nexport function overNone<T>(): RevertibleIterable<T> {\n  return noneIterable;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { isArrayLike } from './api';\nimport { itsRevertible, RevertibleIterable } from './revertible-iterable';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Constructs a reversed iterable.\n *\n * If the `source` iterable is an array-like structure, then uses `reverseArray()` function to revert the constructed\n * iterable.\n * If the `source` iterable is revertible, then uses its `reverse()` method to revert the constructed one.\n * Otherwise stores elements to array and reverts them with `reverseArray()` function.\n *\n * @param source  A source iterable.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseIt<T>(source: Iterable<T> | RevertibleIterable<T> | ArrayLike<T>): Iterable<T> {\n  if (isArrayLike(source)) {\n    return reverseArray(source);\n  }\n  if (itsRevertible(source)) {\n\n    const reversed = source.reverse();\n\n    return makeIt(() => itsIterator(reversed));\n  }\n  return reverseArray(Array.from(source));\n}\n\n/**\n * Constructs an iterable of array-like structure elements in reverse order.\n *\n * @param array  Source array.\n *\n * @returns An iterable of the `source` elements in reverse order.\n */\nexport function reverseArray<T>(array: ArrayLike<T>): Iterable<T> {\n  return makeIt(\n      function *() {\n\n        const len = array.length;\n\n        for (let i = len - 1; i >= 0; --i) {\n          yield array[i];\n        }\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/a-iterable\n */\nimport { overArray } from './construction';\nimport { RevertibleIterable } from './revertible-iterable';\nimport { mapIt } from './transform';\nimport { itsIterator, makeIt } from './util';\n\n/**\n * Builds an iterable over the keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys from.\n */\nexport function overKeys<T extends object>(target: T): RevertibleIterable<keyof T> {\n  return overArray(Reflect.ownKeys(target) as (keyof T)[]);\n}\n\n/**\n * Object property entry. This is a tuple consisting of property key and value.\n */\nexport type ObjectEntry<T, K extends keyof T = keyof T> = [K, T[K]];\n\n/**\n * Builds an iterable over the key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @param target  An object to select keys and values from.\n */\nexport function overEntries<T extends object>(target: T): RevertibleIterable<ObjectEntry<T>> {\n\n  const keys = overKeys(target);\n\n  function mapToEntries(_keys: Iterable<keyof T>): Iterable<ObjectEntry<T>> {\n    return mapIt(_keys, key => [key, target[key]] as ObjectEntry<T>);\n  }\n\n  return makeIt(() => itsIterator(mapToEntries(keys)), () => mapToEntries(keys.reverse()));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRef } from './context-ref';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValues } from './context-values';\n\n/**\n * A symbol of the property containing a [[ContextKey]] instance.\n */\nexport const ContextKey__symbol = /*#__PURE__*/ Symbol('context-key');\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by [[ContextKey.grow]] method.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextKey<Value, Src = Value, Seed = unknown> implements ContextRef<Value, Src> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same [[seedKey]] to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<Src, Seed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name  Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @typeparam Ctx  Context type.\n   * @param opts  Context value growth options.\n   *\n   * @returns Single context value, or `undefined` if there is no default value.\n   */\n  abstract grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Value, Src, Seed>): Value | null | undefined;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n\n/**\n * Context value growth options.\n *\n * An instance of these options is passed to [[ContextKey.grow]] method to provide the necessary value growth context.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport interface ContextValueOpts<Ctx extends ContextValues, Value, Src, Seed> {\n\n  /**\n   * Target context.\n   */\n  readonly context: Ctx;\n\n  /**\n   * Context value seeder.\n   */\n  readonly seeder: ContextSeeder<Ctx, Src, Seed>;\n\n  /**\n   * Context value seed.\n   */\n  readonly seed: Seed;\n\n  /**\n   * A fallback value to use if there is no value associated with the given key.\n   *\n   * Can be `null` or `undefined`.\n   */\n  readonly or?: Value | null;\n\n  /**\n   * Handles missing context value.\n   *\n   * It can be called to prefer a fallback value over the default one specified in the value key.\n   *\n   * @param defaultProvider  Default value provider. It is called unless a fallback value is specified.\n   * If it returns a non-null/non-undefined value, then the returned value will be associated with the context key.\n   */\n  byDefault(defaultProvider: () => Value | null | undefined): Value | null | undefined;\n\n}\n\n/**\n * A provider of default value of context key.\n *\n * This is typically passed as `byDefault` option to context value key constructor.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Key  Context key type.\n */\nexport type ContextKeyDefault<Value, Key extends ContextKey<any, any, any>> =\n/**\n * @param context  Target context.\n * @param key  Context value key the default value is provided for.\n *\n * @return Either constructed value, or `null`/`undefined` if unknown.\n */\n    (this: void, context: ContextValues, key: Key) => Value | null | undefined;\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport abstract class ContextSeedKey<Src, Seed> extends ContextKey<Seed, Src, Seed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key  A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<any, Src>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeparam Ctx  Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src, Seed>;\n\n  grow<Ctx extends ContextValues>(opts: ContextValueOpts<Ctx, Seed, Src, Seed>): Seed | null | undefined {\n\n    const { seeder, seed } = opts;\n\n    return seeder.isEmpty(seed) ? opts.byDefault(() => seed) : seed;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextKey } from './context-key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key  Missing value key.\n   * @param message  Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valueProvider } from '@proc7ts/call-thru';\nimport { ContextRequest, ContextTarget } from './context-ref';\nimport { ContextValues } from './context-values';\n\n/**\n * Context value provider.\n *\n * It is responsible for constructing the values associated with particular key for the given context. Note that\n * provider generates source value, not the context values themselves.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Src  Source value type.\n */\nexport type ContextValueProvider<Ctx extends ContextValues, Src> =\n/**\n * @param context  Target context.\n *\n * @return Either constructed value source, or `null`/`undefined` if unknown.\n */\n    (this: void, context: Ctx) => Src | null | undefined;\n\n/**\n * Context value specifier.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @typeparam Seed  Value seed type.\n */\nexport type ContextValueSpec<\n    Ctx extends ContextValues,\n    Value,\n    Deps extends any[] = unknown[],\n    Src = Value,\n    Seed = unknown> =\n    | ContextValueSpec.IsConstant<Src, Seed>\n    | ContextValueSpec.ViaAlias<Src, Seed>\n    | ContextValueSpec.ByProvider<Ctx, Src, Seed>\n    | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.AsInstance<Ctx, Src, Seed>\n    | ContextValueSpec.SelfInstance<Ctx, Src, Seed>\n    | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>\n    | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface IsConstant<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Constant context value.\n     */\n    is: Src;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeparam Sec  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ViaAlias<Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<Src, Seed>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProvider<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<Ctx, Src>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface ByProviderWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: Deps) => Src | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: Ctx) => Src;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeparam Ctx  Context type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstance<Ctx extends ContextValues, Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (context: Ctx) => Src);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface AsInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<Src, Seed>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: Deps) => Src;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   */\n  export interface SelfInstanceWithDeps<Deps extends any[], Src, Seed = unknown> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<Src, Seed> & (new (...args: Deps) => Src);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<Deps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   */\n  export type DepsRequests<Deps extends any[]> = {\n    [K in keyof Deps]: ContextRequest<Deps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeparam Ctx  Context type.\n * @typeparam Value  Context value type.\n * @typeparam Deps  Dependencies tuple type.\n * @typeparam Src  Source value type.\n * @param spec  Context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<Ctx extends ContextValues, Value, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, Value, Deps, Src, Seed>,\n): ContextValueSpec.ByProvider<Ctx, Src, Seed> {\n  if (byProvider(spec)) {\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: Ctx) {\n        return by(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n  if (isConstant<Src, Seed>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (viaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: Ctx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (asInstance<Ctx, Deps, Src, Seed>(spec)) {\n    if (selfInstance<Ctx, Deps, Src, Seed>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!withDeps<Ctx, Deps, Src, Seed>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: Ctx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: Ctx) {\n        return new DepType(...deps.map(dep => context.get(dep)) as Deps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction byProvider<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction asInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction selfInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): spec is ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.SelfInstance<Ctx, Src, Seed> | ContextValueSpec.SelfInstanceWithDeps<Deps, Src, Seed>,\n): ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n}\n\n/**\n * @internal\n */\nfunction isConstant<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.IsConstant<Src, Seed> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction viaAlias<Src, Seed>(\n    spec: ContextValueSpec<any, any, any, Src, Seed>,\n): spec is ContextValueSpec.ViaAlias<Src, Seed> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.ByProvider<Ctx, Src, Seed> | ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.ByProviderWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec.AsInstance<Ctx, Src, Seed> | ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>,\n): spec is ContextValueSpec.AsInstanceWithDeps<Deps, Src, Seed>;\n\n/**\n * @internal\n */\nfunction withDeps<Ctx extends ContextValues, Deps extends any[], Src, Seed>(\n    spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>,\n): boolean {\n  return 'with' in spec;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { ContextRequest } from './context-ref';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrNull<Value>): Value | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts: ContextRequest.OrUndefined<Value>): Value | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeparam Value  A type of associated value.\n   * @param request  Context value request with target key.\n   * @param opts  Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<Value>(request: ContextRequest<Value>, opts?: ContextRequest.OrFallback<Value>): Value;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextKeyError } from './context-key-error';\nimport { ContextRef, ContextRequest } from './context-ref';\nimport { ContextSeeder, ContextSeeds } from './context-seeder';\nimport { contextValueSpec, ContextValueSpec } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\ntype SeedFactory<Ctx extends ContextValues, Seed> = (this: void, context: Ctx) => Seed;\n\n/**\n * @internal\n */\ntype Seeding<Ctx extends ContextValues, Src, Seed> = [ContextSeeder<Ctx, Src, Seed>, SeedFactory<Ctx, Seed>];\n\n/**\n * A registry of context value providers.\n *\n * @typeparam Ctx  Context type.\n */\nexport class ContextRegistry<Ctx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _initial: ContextSeeds<Ctx>;\n\n  /** @internal */\n  private readonly _seeds = new Map<ContextSeedKey<any, any>, Seeding<Ctx, any, any>>();\n\n  /** @internal */\n  private _nonCachedValues?: ContextValues;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial  An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<Ctx> | ContextValues) {\n    if (initial == null) {\n      this._initial = noop;\n    } else if (typeof initial === 'function') {\n      this._initial = initial;\n    } else {\n      this._initial = seedKey => initial.get(seedKey);\n    }\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  provide<Deps extends any[], Src, Seed>(spec: ContextValueSpec<Ctx, any, Deps, Src, Seed>): () => void {\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeding<Src, Seed>(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * @internal\n   */\n  private _seeding<Src, Seed>(seedKey: ContextSeedKey<Src, Seed>): Seeding<Ctx, Src, Seed> {\n\n    const found: Seeding<Ctx, Src, Seed> | undefined = this._seeds.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<Ctx, Src, Seed> = seedKey.seeder();\n    const factory: SeedFactory<Ctx, Seed> = context => seeder.seed(context, this._initial(seedKey, context));\n    const seeding: Seeding<Ctx, Src, Seed> = [seeder, factory];\n\n    this._seeds.set(seedKey, seeding);\n\n    return seeding;\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context  Target context.\n   * @param key  Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<Src, Seed>(context: Ctx, key: ContextSeedKey<Src, Seed>): Seed {\n\n    const [, factory] = this._seeding(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context  Target value context.\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: Ctx, cache?: boolean): <Src, Seed>(this: void, key: ContextSeedKey<Src, Seed>) => Seed | undefined {\n    return this.newValues(cache).get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @param cache  Whether to cache context values. When `false` the value providers may be called multiple times.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(cache = true): ContextValues & ThisType<Ctx> {\n    if (!cache && this._nonCachedValues) {\n      return this._nonCachedValues;\n    }\n\n    const values = new Map<ContextKey<any>, any>();\n    const registry = this;\n\n    class Values extends ContextValues {\n\n      get<Value, Src>(\n          this: Ctx,\n          { [ContextKey__symbol]: key }: ContextRef<Value, Src>,\n          opts?: ContextRequest.Opts<Value>,\n      ): Value | null | undefined {\n\n        const context = this;\n        const cached: Value | undefined = values.get(key);\n\n        if (cached != null) {\n          return cached;\n        }\n\n        const [constructed, defaultUsed] = growValue(context, key, opts);\n\n        if (cache && !defaultUsed) {\n          values.set(key, constructed);\n        }\n\n        return constructed;\n      }\n\n    }\n\n    if (!cache) {\n      return this._nonCachedValues = new Values();\n    }\n\n    return new Values();\n\n    function growValue<Value, Src, Seed>(\n        context: Ctx,\n        key: ContextKey<Value, Src, Seed>,\n        opts: ContextRequest.Opts<Value> | undefined,\n    ): [Value | null | undefined, boolean] {\n\n      const [seeder, seed] = findSeed<Src, Seed>(context, key);\n      let defaultUsed = false;\n\n      const valueOpts: {\n        -readonly [K in keyof ContextValueOpts<Ctx, Value, Src, Seed>]: ContextValueOpts<Ctx, Value, Src, Seed>[K];\n      } = {\n        context,\n        seeder,\n        seed,\n        byDefault: (opts && 'or' in opts)\n            ? () => {\n              defaultUsed = true;\n              return opts.or;\n            }\n            : defaultProvider => {\n\n              const defaultValue = defaultProvider();\n\n              if (defaultValue == null) {\n                throw new ContextKeyError(key);\n              }\n\n              return defaultValue;\n            },\n      };\n\n      if (opts && 'or' in opts) {\n        valueOpts.or = opts.or;\n      }\n\n      return [\n        key.grow(valueOpts),\n        defaultUsed,\n      ];\n    }\n\n    function findSeed<Src, Seed>(\n        context: Ctx,\n        key: ContextKey<any, Src, Seed>,\n    ): [ContextSeeder<Ctx, Src, Seed>, Seed] {\n\n      const { seedKey } = key;\n      const [seeder, factory] = registry._seeding(seedKey);\n\n      if (seedKey !== key as any) {\n        // This is not a seed key\n        // Retrieve the seed by seed key\n        return [seeder, context.get(seedKey)];\n      }\n\n      return [seeder, factory(context)];\n    }\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other  Another context value registry.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<Ctx>): ContextRegistry<Ctx> {\n    return new ContextRegistry(<Src, Seed>(key: ContextSeedKey<Src, Seed>, context: Ctx) => {\n\n      const [seeder, factory] = this._seeding(key);\n\n      return seeder.combine(factory(context), other.seed(context, key), context);\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { filterIt, flatMapIt, itsEmpty, mapIt, overNone } from '@proc7ts/a-iterable';\nimport { isPresent, lazyValue } from '@proc7ts/call-thru';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass IterativeContextSeeder<Ctx extends ContextValues, Src> implements ContextSeeder<Ctx, Src, Iterable<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.push(provider);\n    return () => {\n\n      const found = this._providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: Iterable<Src> = overNone()): Iterable<Src> {\n    return flatMapIt([\n      initial,\n      iterativeSeed(context, this._providers),\n    ]);\n  }\n\n  isEmpty(seed: Iterable<Src>): boolean {\n    return itsEmpty(seed);\n  }\n\n  combine(first: Iterable<Src>, second: Iterable<Src>): Iterable<Src> {\n    return flatMapIt([first, second]);\n  }\n\n}\n\n/**\n * @internal\n */\nclass IterativeSeedKey<Src> extends ContextSeedKey<Src, Iterable<Src>> {\n\n  seeder<Ctx extends ContextValues>(): IterativeContextSeeder<Ctx, Src> {\n    return new IterativeContextSeeder();\n  }\n\n}\n\n/**\n * Iterative context value key implementation.\n *\n * Collects value sources as iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class IterativeContextKey<Value, Src = Value> extends ContextKey<Value, Src, Iterable<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, Iterable<Src>>;\n\n  /**\n   * Constructs iterative context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src, Iterable<Src>>) {\n    super(name);\n    this.seedKey = seedKey || new IterativeSeedKey(this);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction iterativeSeed<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providers: readonly ContextValueProvider<Ctx, Src>[],\n): Iterable<Src> {\n  return filterIt<Src | null | undefined, Src>(\n      mapIt(\n          providers.map(provider => lazyValue(provider.bind(undefined, context))), // lazily evaluated providers\n          provider => provider(),\n      ),\n      isPresent,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { valuesProvider } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { ContextValues } from './context-values';\nimport { IterativeContextKey } from './iterative-context-key';\n\n/**\n * Multiple context value reference.\n *\n * Represents context value as read-only array of source values.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport type MultiContextRef<Src> = ContextRef<readonly Src[], Src>;\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeparam Src  Value source type and context value item type.\n */\nexport class MultiContextKey<Src>\n    extends IterativeContextKey<readonly Src[], Src>\n    implements MultiContextRef<Src> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n\n  /**\n   * Constructs multiple context values key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified then the default value is empty array.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = valuesProvider(),\n      }: {\n        seedKey?: ContextSeedKey<Src, Iterable<Src>>;\n        byDefault?: ContextKeyDefault<readonly Src[], ContextKey<readonly Src[], Src>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, readonly Src[], Src, Iterable<Src>>,\n  ): readonly Src[] | null | undefined {\n\n    const result = Array.from(opts.seed);\n\n    if (result.length) {\n      return result;\n    }\n\n    return opts.byDefault(() => {\n\n      const defaultSources = this.byDefault(opts.context, this);\n\n      if (defaultSources) {\n        return Array.from(defaultSources);\n      }\n\n      return;\n    });\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { lazyValue, noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextSeedKey } from './context-key';\nimport { ContextSeeder } from './context-seeder';\nimport { ContextValueProvider } from './context-value-spec';\nimport { ContextValues } from './context-values';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src, SimpleContextKey.Seed<Src>> {\n\n  private readonly _providers: ContextValueProvider<Ctx, Src>[] = [];\n\n  provide(provider: ContextValueProvider<Ctx, Src>): () => void {\n    this._providers.unshift(provider);\n    return () => {\n\n      const found = this._providers.lastIndexOf(provider);\n\n      if (found >= 0) {\n        this._providers.splice(found, 1);\n      }\n    };\n  }\n\n  seed(context: Ctx, initial?: SimpleContextKey.Seed<Src>): SimpleContextKey.Seed<Src> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (provider: ContextValueProvider<Ctx, Src>): SimpleContextKey.Seed<Src> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<Src>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<Src>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<Src>,\n      second: SimpleContextKey.Seed<Src>,\n  ): SimpleContextKey.Seed<Src> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<Src>(\n    seeds: readonly SimpleContextKey.Seed<Src>[],\n): SimpleContextKey.Seed<Src> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<Src> extends ContextSeedKey<Src, SimpleContextKey.Seed<Src>> {\n\n  seeder<Ctx extends ContextValues>(): SimpleContextSeeder<Ctx, Src> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class SimpleContextKey<Value, Src = Value> extends ContextKey<Value, Src, SimpleContextKey.Seed<Src>> {\n\n  readonly seedKey: ContextSeedKey<Src, SimpleContextKey.Seed<Src>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextSeedKey<Src, SimpleContextKey.Seed<Src>>) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeparam Src  Source vale type.\n   */\n  export type Seed<Src> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when when absent.\n   */\n      (this: void) => Src | null | undefined;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueOpts } from './context-key';\nimport { ContextRef } from './context-ref';\nimport { ContextValues } from './context-values';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextRef<Value> = ContextRef<Value, Value>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextKey<Value>\n    extends SimpleContextKey<Value>\n    implements SingleContextRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextKey<Value>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<Value, SimpleContextKey.Seed<Value>>;\n        byDefault?: ContextKeyDefault<Value, ContextKey<Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, Value, Value, SimpleContextKey.Seed<Value>>,\n  ): Value | null | undefined {\n\n    const value = opts.seed();\n\n    if (value != null) {\n      return value;\n    }\n\n    return opts.byDefault(() => this.byDefault(opts.context, this));\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent } from '../after-event';\n\n/**\n * A key of [[EventKeeper]] method returning its [[AfterEvent]] instance..\n *\n * @category Core\n */\nexport const AfterEvent__symbol = (/*#__PURE__*/ Symbol('after-event'));\n\n/**\n * An event supplier that keeps the last event sent.\n *\n * The registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport interface EventKeeper<E extends any[]> {\n\n  /**\n   * Returns an [[AfterEvent]] instance of this event keeper.\n   *\n   * @returns [[AfterEvent]] instance registering event receivers sent by this keeper.\n   */\n  [AfterEvent__symbol](): AfterEvent<E>;\n\n}\n\nexport namespace EventKeeper {\n\n  /**\n   * A type of events sent by the given event keeper.\n   *\n   * @typeparam T  Target event keeper.\n   */\n  export type Event<T extends EventKeeper<any>> = T extends EventKeeper<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventKeeper]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains an [[AfterEvent__symbol]] property, or `false` otherwise.\n */\nexport function isEventKeeper<E extends any[]>(value: object): value is EventKeeper<E> {\n  return AfterEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/call-thru';\n\n/**\n * A key of [[EventSupplyPeer]] property containing [[EventSupply]] instance.\n *\n * @category Core\n */\nexport const EventSupply__symbol = (/*#__PURE__*/ Symbol('events-supply'));\n\n/**\n * A supply of events from {@link EventSupplier event supplier} to {@link EventReceiver event receiver}.\n *\n * When no longer needed the supply may be {@link off cut off}.\n *\n * May be constructed using [[eventSupply]] function.\n *\n * @category Core\n */\nexport class EventSupply implements EventSupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _off: (reason?: any) => void;\n\n  /**\n   * @internal\n   */\n  private _whenOff: (callback: (reason?: any) => void) => void;\n\n  constructor(off: (this: void, reason?: any) => void = noop) {\n    this._off = reason => {\n      this._whenOff = callback => callback(reason);\n      this._off = noop;\n      off(reason);\n    };\n    this._whenOff = callback => {\n\n      const prev = this._off;\n\n      this._off = reason => {\n        prev(reason);\n        callback(reason);\n      };\n    };\n  }\n\n  /**\n   * Whether this supply is {@link off cut off} already.\n   *\n   * `true` means the events will no longer be supplied.\n   */\n  get isOff(): boolean {\n    return this._off === noop;\n  }\n\n  /**\n   * `this` event supply.\n   */\n  get [EventSupply__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Cuts off the supply of events.\n   *\n   * After this method call the receiver will no longer receive events.\n   *\n   * Calling this method for the second time has no effect.\n   *\n   * @param reason  An optional reason why supply is cut off. It will be reported to [[whenOff]] callbacks.\n   * @returns A cut off event supply instance.\n   */\n  off(reason?: any): EventSupply {\n    this._off(reason);\n    return this;\n  }\n\n  /**\n   * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n   * will be called immediately if [[isOff]] is `true`.\n   *\n   * @param callback  A callback function accepting optional cut off reason as its only parameter.\n   * By convenience an `undefined` reason means normal completion.\n   *\n   * @returns `this` instance.\n   */\n  whenOff(callback: (this: void, reason?: any) => void): this {\n    this._whenOff(callback);\n    return this;\n  }\n\n  /**\n   * Makes another event supply depend on this one.\n   *\n   * Once this supply is {@link off cut off}, `another` one is cut off with the same reason.\n   *\n   * Calling this method has the same effect as calling {@link needs eventSupplyOf(another).need(this)}.\n   *\n   * @param another  A peer of event supply to make depend on this one.\n   *\n   * @returns `this` instance.\n   */\n  cuts(another: EventSupplyPeer): this {\n    eventSupplyOf(another).needs(this);\n    return this;\n  }\n\n  /**\n   * Declares this event supply depends on another one.\n   *\n   * Once `another` supply is {@link off cut off}, this one is will be cut off with the same reason.\n   *\n   * @param another  A peer of event supply this one depends on.\n   *\n   * @returns `this` instance.\n   */\n  needs(another: EventSupplyPeer): this {\n    eventSupplyOf(another).whenOff(reason => this._off(reason));\n    return this;\n  }\n\n}\n\n/**\n * A peer of event supply.\n *\n * Contains an [[EventSupply]] that can be extracted by [[eventSupplyOf]] function.\n *\n * To be implemented by objects that controls event supply. An [[EventSupply]] is a peer of itself.\n *\n * @category Core\n */\nexport interface EventSupplyPeer {\n\n  /**\n   * An event supply of this peer.\n   */\n  readonly [EventSupply__symbol]: EventSupply;\n\n}\n\n/**\n * Extracts an event supply from its peer.\n *\n * @category Core\n * @param peer  A peer of event supply.\n *\n * @returns Extracted event supply contained in [[EventSupply__symbol]] property.\n */\nexport function eventSupplyOf(peer: EventSupplyPeer): EventSupply {\n  return peer[EventSupply__symbol];\n}\n\n/**\n * Constructs new {@link EventSupply event supply}.\n *\n * @category Core\n * @param off  A function to call when supply will supply is {@link EventSupply.off cut off}. Accepts optional\n * cut off reason as its only parameter. No-op by default.\n */\nexport function eventSupply(off?: (this: void, reason?: any) => void): EventSupply {\n  return new EventSupply(off);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { eventSupply, EventSupply } from './event-supply';\n\n/**\n * Event receiver is called on each event sent by [[EventSender]] when registered.\n *\n * A receiver may be represented either by {@link EventReceiver.Function function}, or by\n * {@link EventReceiver.Object object}. The former is a simplest form. The latter allows control all aspects of event\n * processing.\n *\n * To register an event receiver just call the event sender's `[OnEvent__symbol]` or event keeper's\n * `[AfterEvent__symbol]` method with this event receiver as argument.\n *\n * A _recurrent event_ is an event sent from inside event receiver and targeted the same receiver. Recurrent event\n * processing is scheduled until after the current event processing finishes. To handle recurrent events in a specific\n * way the event receiver may utilize an {@link EventReceiver.Context event processing context} available as\n * a first parameter of [[EventReceiver.Object.receive]] method.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport type EventReceiver<E extends any[]> = EventReceiver.Function<E> | EventReceiver.Object<E>;\n\nexport namespace EventReceiver {\n\n  /**\n   * Event receiver function signature.\n   *\n   * It never receives event processing context.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export type Function<E extends any[]> =\n  /**\n   * @param event  An event represented by function call arguments.\n   */\n      (this: void, ...event: E) => void;\n\n  /**\n   * Event receiver object.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Object<E extends any[]> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link EventSupply.off cut off}.\n     *\n     * When omitted a new supply will be created per receiver registration within event supplier.\n     */\n    readonly supply?: EventSupply;\n\n    /**\n     * Receives an event.\n     *\n     * @param context  An event processing context.\n     * @param event  An event represented as the rest of arguments.\n     */\n    receive(context: Context<E>, ...event: E): void;\n\n  }\n\n  /**\n   * The most generic event receiver form.\n   *\n   * Any event receiver may be converted to generic form by [[eventReceiver]] function.\n   *\n   * In contrast to [[Object]] this one always has a supply.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Generic<E extends any[]> extends Object<E> {\n\n    readonly supply: EventSupply;\n\n  }\n\n  /**\n   * Event processing context.\n   *\n   * It is passed to [[Object]] receivers.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Context<E extends any[]> {\n\n    /**\n     * Schedules the given event receiver to be called to process recurrent event(s).\n     *\n     * If called during event processing the recurrent events will be sent to the given `receiver` after current event\n     * processed instead of original one.\n     *\n     * If called multiple times the latest `receiver` will be used.\n     *\n     * If not called the recurrent events will be sent to original event receiver.\n     *\n     * > This method should be called __before__ the recurrent event issued. Otherwise it may happen that recurrent\n     * > event will be ignored in some situations. E.g. when it is issued during receiver registration.\n     *\n     * @param receiver  Recurrent events receiver function.\n     */\n    onRecurrent(receiver: Function<E>): void;\n\n  }\n\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n * @param receiver  An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nexport function eventReceiver<E extends any[]>(receiver: EventReceiver<E>): EventReceiver.Generic<E> {\n\n  let generic: {\n    readonly supply: EventSupply;\n    receive: (context: EventReceiver.Context<E>, ...event: E) => void;\n  };\n\n  if (typeof receiver === 'function') {\n    generic = {\n      supply: eventSupply(),\n      receive(_context, ...event) {\n        receiver(...event);\n      },\n    };\n  } else {\n    generic = {\n      supply: receiver.supply || eventSupply(),\n      receive(context, ...event) {\n        if (!this.supply.isOff) {\n          // Supply cut off callback may be called before the receiver disabled.\n          // Such callback may send an event that should not be received.\n          receiver.receive(context, ...event);\n        }\n      },\n    };\n  }\n\n  // Disable receiver when event supply is cut off. But see the comment above.\n  // For function receiver this callback is always the first one.\n  generic.supply.whenOff(() => generic.receive = noop);\n\n  return generic;\n}\n","import { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @internal\n * @param receivers  An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nexport function receiveByEach<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n): (this: void, ...event: E) => void {\n\n  let send: (this: void, event: E) => void = sendNonRecurrent;\n\n  return (...event) => send(event);\n\n  function sendNonRecurrent(event: E): void {\n\n    let actualReceivers = receivers;\n    const received: E[] = [];\n\n    send = (recurrent: E) => received.push(recurrent);\n\n    try {\n      for (; ;) {\n        actualReceivers = processEvent(actualReceivers, event);\n\n        const recurrent = received.shift();\n\n        if (!recurrent) {\n          break;\n        }\n\n        event = recurrent;\n      }\n    } finally {\n      send = sendNonRecurrent;\n    }\n  }\n}\n\nfunction processEvent<E extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<E>>,\n    event: E,\n): EventReceiver.Generic<E>[] {\n\n  const recurrentReceivers: EventReceiver.Generic<E>[] = [];\n\n  for (const receiver of receivers) {\n\n    const idx = recurrentReceivers.length;\n\n    recurrentReceivers.push(receiver);\n\n    const context: EventReceiver.Context<E> = {\n      onRecurrent(recurrentReceiver) {\n        recurrentReceivers[idx] = eventReceiver({\n          supply: receiver.supply,\n          receive(_context, ...recurrentEvent) {\n            recurrentReceiver(...recurrentEvent);\n          },\n        });\n      },\n    };\n\n    receiver.receive(context, ...event);\n  }\n\n  return recurrentReceivers;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\nimport { eventSupply, EventSupply, EventSupply__symbol, eventSupplyOf, EventSupplyPeer } from './event-supply';\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an [[EventSender]] interface though. Use an [[EventEmitter]] if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link EventSupply.off cut off}.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventNotifier<E extends any[]> implements EventSupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _rcs?: Set<EventReceiver.Generic<E>>;\n\n  readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * Sends the given `event` to all registered receivers.\n   *\n   * @param event  An event to send represented by function call arguments.\n   */\n  readonly send: (this: this, ...event: E) => void;\n\n  constructor() {\n\n    const rcs = this._rcs = new Set<EventReceiver.Generic<E>>();\n\n    this.send = receiveByEach(rcs);\n    this[EventSupply__symbol] = eventSupply(() => {\n      rcs.clear();\n      delete this._rcs;\n    });\n  }\n\n  /**\n   * The number of currently registered event receivers.\n   */\n  get size(): number {\n    return this._rcs ? this._rcs.size : 0;\n  }\n\n  /**\n   * Registers an event receiver.\n   *\n   * Receivers registered with this method will receive the {@link send emitted} events.\n   *\n   * The `[OnEvent__symbol]` method is an alias of this one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of events to the given `receiver`.\n   */\n  on(receiver: EventReceiver<E>): EventSupply {\n\n    const generic = eventReceiver(receiver);\n    const supply = generic.supply.needs(this);\n    const { _rcs } = this;\n\n    if (_rcs && !supply.isOff) {\n      _rcs.add(generic);\n      supply.whenOff(() => _rcs.delete(generic));\n    }\n\n    return supply;\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive any events. While new receivers would be cut off immediately upon\n   * registration.\n   *\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { OnEvent } from '../on-event';\n\n/**\n * A key of [[EventSender]] method returning its [[OnEvent]] instance.\n *\n * @category Core\n */\nexport const OnEvent__symbol = (/*#__PURE__*/ Symbol('on-event'));\n\n/**\n * A sender of events.\n *\n * Contains an [[OnEvent]] instance registering event receivers.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n */\nexport interface EventSender<E extends any[]> {\n\n  /**\n   * Returns an [[OnEvent]] instance of this event sender.\n   *\n   * @returns [[OnEvent]] instance registering event receivers sent by this sender.\n   */\n  [OnEvent__symbol](): OnEvent<E>;\n\n}\n\nexport namespace EventSender {\n\n  /**\n   * A type of events sent by the given event sender.\n   *\n   * @typeparam T  Target event sender.\n   */\n  export type Event<T extends EventSender<any>> = T extends EventSender<infer E> ? E : never;\n\n}\n\n/**\n * Checks whether the given object implements an [[EventSender]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param value  An object to check.\n *\n * @returns `true` if `value` contains [[OnEvent__symbol]] property, or `false` otherwise.\n */\nexport function isEventSender<E extends any[]>(value: object): value is EventSender<E> {\n  return OnEvent__symbol in value;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventSupply, eventSupplyOf, EventSupplyPeer } from './event-supply';\n\n/**\n * @internal\n */\nclass NoSupply extends EventSupply {\n\n  get isOff(): true {\n    return true;\n  }\n\n  off(): this {\n    return this;\n  }\n\n  whenOff(callback: (reason?: any) => void): this {\n    callback();\n    return this;\n  }\n\n  cuts(another: EventSupplyPeer): this {\n    eventSupplyOf(another).off();\n    return this;\n  }\n\n  needs(): this {\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst noSupply = (/*#__PURE__*/ new NoSupply());\n\n/**\n * Returns a no-event supply.\n *\n * @category Core\n *\n * @returns An event supply that is already cut off without any particular reason.\n */\nexport function noEventSupply(): EventSupply {\n  return noSupply;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event sender targeted specific receiver.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n *\n * @param receiver  Target event receiver.\n *\n * @returns A function accepting events and sending them to target `receiver`.\n */\nexport function sendEventsTo<E extends any[]>(receiver: EventReceiver<E>): (this: void, ...event: E) => void {\n\n  const generic = eventReceiver(receiver);\n  let send: (...event: E) => void = receiveByEach([generic]);\n\n  generic.supply.whenOff(() => send = noop);\n\n  return (...event) => send(...event);\n}\n","import { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function once<E extends any[]>(\n    onSource: OnEvent<E>,\n): (receiver: EventReceiver.Generic<E>) => void {\n  return receiver => onSource.to({\n    supply: receiver.supply,\n    receive: (context, ...event) => {\n      receiver.receive(context, ...event);\n      receiver.supply.off();\n    },\n  });\n}\n","import { EventNotifier, EventReceiver, eventSupply, EventSupply, sendEventsTo } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function share<E extends any[]>(\n    onSource: OnEvent<E>,\n): (receiver: EventReceiver.Generic<E>) => void {\n\n  const shared = new EventNotifier<E>();\n  let sharedSupply: EventSupply;\n  let initialEvents: E[] | undefined;\n\n  return receiver => {\n    if (!shared.size) {\n      initialEvents = [];\n      sharedSupply = eventSupply(() => initialEvents = undefined);\n\n      onSource.to({\n        supply: sharedSupply,\n        receive(_ctx, ...event) {\n          if (initialEvents) {\n            if (shared.size) {\n              // More events received\n              // Stop sending initial ones\n              initialEvents = undefined;\n            } else {\n              // Record events received during first receiver registration\n              // to send them to all receivers until more event received\n              initialEvents.push(event);\n            }\n          }\n          shared.send(...event);\n        },\n      });\n    }\n\n    receiver.supply.needs(sharedSupply);\n    shared.on(receiver).whenOff((reason?: any) => {\n      if (!shared.size) {\n        sharedSupply.off(reason);\n      }\n    });\n\n    if (initialEvents) {\n      // Send initial events to just registered receiver\n\n      const dispatch = sendEventsTo(receiver);\n\n      initialEvents.forEach(event => dispatch(...event));\n    }\n  };\n}\n","import { isNextCall, NextCall__symbol, noop } from '@proc7ts/call-thru';\nimport { EventReceiver, EventSender, eventSupply, EventSupply, noEventSupply, OnEvent__symbol } from '../base';\nimport { OnEvent } from '../on-event';\nimport { OnEventCallChain } from '../passes';\n\n/**\n * @internal\n */\nexport function thru<E extends any[]>(\n    onSource: OnEvent<E>,\n    passes: ((...args: any[]) => any)[],\n): (receiver: EventReceiver.Generic<E>) => void {\n\n  interface ChainEntry {\n    readonly chain: OnEventCallChain;\n    supply: EventSupply;\n  }\n\n  return (receiver: EventReceiver.Generic<any>) => {\n\n    const chains: ChainEntry[] = [];\n\n    onSource.to({\n      supply: receiver.supply,\n      receive(context, ...event) {\n\n        const chain = (index: number, chainSupply: EventSupply): [OnEventCallChain, EventSupply] => {\n\n          const lastPass = index >= passes.length;\n\n          ++index;\n\n          const existing = chains[index];\n\n          if (existing) {\n\n            const prevSupply = existing.supply;\n\n            existing.supply = chainSupply;\n\n            return [existing.chain, prevSupply];\n          }\n\n          const pass = index < passes.length ? passes[index] : noop;\n\n          const entry: ChainEntry = {\n            chain: {\n              call<A extends any[]>(fn: (...args: A) => any, args: A): void {\n                handleResult(fn(...args), args);\n              },\n              pass<A>(fn: (arg: A) => any, arg: A): void {\n                handleResult(fn(arg), [arg]);\n              },\n              skip(): void {\n                entry.supply.off();\n              },\n              onEvent<E extends any[]>(\n                  pass: (this: void, ...event: E) => void,\n                  sender: EventSender<E>,\n              ): void {\n\n                const supply = eventSupply().needs(entry.supply);\n\n                sender[OnEvent__symbol]().to({\n                  supply,\n                  receive(_context, ...event): void {\n                    handleResult(pass(...event), event, supply);\n                  },\n                });\n              },\n            },\n            supply: chainSupply,\n          };\n\n          chains[index] = entry;\n\n          return [entry.chain, noEventSupply()];\n\n          function handleResult(\n              callResult: any,\n              args: any[],\n              parentSupply = entry.supply,\n          ): void {\n\n            const [nextChain, prevSupply] = chain(index, eventSupply().needs(parentSupply));\n\n            try {\n              if (isNextCall(callResult)) {\n                callResult[NextCall__symbol](nextChain, pass);\n              } else if (lastPass) {\n                receiver.receive(context, ...args);\n              } else {\n                nextChain.pass(pass, callResult);\n              }\n            } finally {\n              prevSupply.off();\n            }\n          }\n        };\n\n        const [firstChain, prevSupply] = chain(0, eventSupply().needs(receiver.supply));\n\n        try {\n          firstChain.call(passes[0], event);\n        } finally {\n          prevSupply.off();\n        }\n      },\n    });\n  };\n}\n","import { EventReceiver, eventSupply, EventSupply, EventSupplyPeer } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function tillOff<E extends any[]>(\n    onSource: OnEvent<E>,\n    required: EventSupplyPeer,\n    dependentSupply?: EventSupply,\n): (receiver: EventReceiver.Generic<E>) => void {\n  return receiver => {\n    if (dependentSupply) {\n      onSource.to({\n        supply: eventSupply().needs(required).cuts(dependentSupply),\n        receive: (receiver.receive as Function).bind(receiver),\n      });\n    } else {\n      receiver.supply.needs(required);\n      onSource.to(receiver);\n    }\n  };\n}\n","import { EventReceiver } from '../index';\n\n/**\n * @internal\n */\nexport function neverReceiveBecause(reason?: any): (receiver: EventReceiver.Generic<any>) => void {\n  return ({ supply }) => supply.off(reason);\n}\n\n/**\n * @internal\n */\nexport function neverReceive({ supply }: EventReceiver.Generic<any>): void {\n  supply.off();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport {\n  eventReceiver,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  EventSupplyPeer,\n  noEventSupply,\n  OnEvent__symbol,\n} from './base';\nimport { once, share, then, thru, tillOff } from './impl';\nimport { OnEventCallChain } from './passes';\nimport Args = OnEventCallChain.Args;\nimport Out = OnEventCallChain.Out;\n\n/**\n * An [[EventSender]] implementation able to register event receivers.\n *\n * The registered event receiver starts receiving upcoming events until the returned event supply is\n * {@link EventSupply.off cut off}.\n *\n * Contains additional event processing methods.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class OnEvent<E extends any[]> implements EventSender<E> {\n\n  /**\n   * Generic event receiver registration function. It will be called on each receiver registration,\n   * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n   */\n  protected readonly _on: (receiver: EventReceiver.Generic<E>) => void;\n\n  /**\n   * Constructs [[OnEvent]] instance.\n   *\n   * @param on  Generic event receiver registration function. It will be called on each receiver registration,\n   * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n   */\n  constructor(on: (receiver: EventReceiver.Generic<E>) => void) {\n    this._on = on;\n  }\n\n  /**\n   * Event receiver registration function of this sender.\n   *\n   * Delegates to [[OnEvent.to]] method.\n   */\n  get F(): OnEvent.Fn<E> {\n    return this.to.bind(this);\n  }\n\n  [OnEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Returns a reference to itself.\n   *\n   * @returns `this` instance.\n   */\n  to(): this;\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver  Target receiver of events.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  to(receiver: EventReceiver<E>): EventSupply;\n\n  /**\n   * Either starts sending events to the given `receiver`, or returns a reference to itself.\n   *\n   * @param receiver  Target receiver of events.\n   *\n   * @returns Either a supply of events from this sender to the given `receiver`, or `this` instance when `receiver`\n   * is omitted.\n   */\n  to(receiver?: EventReceiver<E>): this | EventSupply;\n\n  to(receiver?: EventReceiver<E>): this | EventSupply {\n    if (!receiver) {\n      return this;\n    }\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (!supply.isOff) {\n      this._on(generic);\n    }\n\n    return supply;\n  }\n\n  /**\n   * Attaches callbacks to the next event and/or supply cut off reason.\n   *\n   * This method makes event sender act as promise-like for the first parameter of the next event. Thus it is possible\n   * e.g. to use it in `await` expression.\n   *\n   * @param onEvent  The callback to execute when next event received.\n   * @param onCutOff  The callback to execute when supply is cut off before the next event received.\n   *\n   * @returns A Promise for the next event.\n   */\n  then<TResult1 = E extends [infer F, ...any[]] ? F : undefined, TResult2 = never>(\n      onEvent?: ((...event: E) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n      onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return then(this, onEvent, onCutOff);\n  }\n\n  /**\n   * Builds an [[OnEvent]] sender of events originated from this one that stops sending them to registered receiver\n   * after the first one.\n   *\n   * @returns Event sender.\n   */\n  once(): OnEvent<E>;\n\n  /**\n   * Registers a receiver of events originated from this sender that stops receiving them after the first one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of event.\n   */\n  once(receiver: EventReceiver<E>): EventSupply;\n\n  once(receiver?: EventReceiver<E>): OnEvent<E> | EventSupply {\n    return (this.once = onEventBy(once(this)).F)(receiver);\n  }\n\n  /**\n   * Builds an [[OnEvent]] sender that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New event sender.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): OnEvent<E> {\n    return onEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * Consumes events.\n   *\n   * @param consume  A function consuming events. This function may return a {@link EventSupplyPeer peer of event\n   * supply} when registers a nested event receiver. This supply will be cut off on new event, unless returned again.\n   *\n   * @returns An event supply that will stop consuming events once {@link EventSupply.off cut off}.\n   */\n  consume(consume: (...event: E) => EventSupplyPeer | void | undefined): EventSupply {\n\n    let consumerSupply = noEventSupply();\n\n    // Do not use `.cuts()` here as `consumerSupply` is mutable\n    const supply = eventSupply(reason => consumerSupply.off(reason));\n\n    this.to({\n      supply,\n      receive(_ctx, ...event: E) {\n\n        const prevSupply = consumerSupply;\n\n        try {\n          consumerSupply = eventSupplyOf(consume(...event) || noEventSupply());\n        } finally {\n          if (consumerSupply !== prevSupply) {\n            prevSupply.off();\n          }\n        }\n      },\n    });\n\n    return supply;\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender that shares events supply among all registered receivers.\n   *\n   * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * supplies do.\n   *\n   * @returns An [[OnEvent]] sender sharing a common supply of events originated from this sender.\n   */\n  share(): OnEvent<E> {\n    return onEventBy(share(this));\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations.\n   *\n   * The passes are preformed by `@proc7ts/call-thru` library. The event receivers registered by resulting event sender\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes. The returned sender shares the supply\n   * of transformed events among receivers.\n   */\n  thru<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): OnEvent<Out<Return1>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): OnEvent<Out<Return2>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): OnEvent<Out<Return3>>;\n\n  thru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): OnEvent<Out<Return3>>;\n\n  thru(...passes: any[]): OnEvent<any[]> {\n    return (this as any).thru_(...passes).share();\n  }\n\n  /**\n   * Constructs an [[OnEvent]] sender of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[OnEvent.thru]] one, except it does not share the supply of transformed events\n   * among receivers. This may be useful e.g. when the result will be further transformed anyway. It is wise to\n   * {@link share share} the supply of events from final result in this case.\n   *\n   * @returns An [[OnEvent]] sender of events transformed with provided passes.\n   */\n  thru_<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): OnEvent<Out<Return1>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): OnEvent<Out<Return2>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): OnEvent<Out<Return3>>;\n\n  thru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): OnEvent<Out<Return3>>;\n\n  thru_(...passes: any[]): OnEvent<any[]> {\n    return onEventBy(thru(this, passes));\n  }\n\n}\n\nexport namespace OnEvent {\n\n  /**\n   * A signature of function registering receivers of events sent by event sender.\n   *\n   * When called without parameters it returns an [[OnEvent]] sender. When called with event receiver as parameter\n   * it returns a supply of events from that sender.\n   *\n   * Available as [[OnEvent.F]] property value.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Fn<E extends any[]> {\n\n    /**\n     * Returns the event sender.\n     *\n     * @returns [[OnEvent]] sender the events originated from.\n     */\n    (\n        this: void,\n    ): OnEvent<E>;\n\n    /**\n     * Registers a receiver of events sent by the sender.\n     *\n     * @param receiver  A receiver of events to register.\n     *\n     * @returns A supply of events from the sender to the given `receiver`.\n     */\n    (\n        this: void,\n        receiver: EventReceiver<E>,\n    ): EventSupply;\n\n    /**\n     * Either registers a receiver of events sent by the sender, or returns the sender itself.\n     *\n     * @param receiver  A receiver of events to register.\n     *\n     * @returns Either a supply of events from the sender to the given `receiver`, or [[OnEvent]] sender the events\n     * originated from when `receiver` is omitted.\n     */\n    (\n        this: void,\n        receiver?: EventReceiver<E>,\n    ): EventSupply | OnEvent<E>;\n\n  }\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[OnEvent]] sender.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An [[OnEvent]] sender registering event receivers with the given `register` function.\n */\nexport function onEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n): OnEvent<E> {\n  return new OnEvent(register);\n}\n","import { EventReceiver, eventSupply } from '../base';\nimport { OnEvent } from '../on-event';\nimport { once } from './once';\n\nexport function then<E extends any[], TResult1 = E[0], TResult2 = never>(\n    onSource: OnEvent<E>,\n    onEvent?: ((...value: E) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n): Promise<TResult1 | TResult2> {\n  return new Promise((resolve, reject) => {\n    once(onSource)({\n      supply: onCutOff\n          ? eventSupply(reason => {\n            try {\n              resolve(onCutOff(reason));\n            } catch (e) {\n              reject(e);\n            }\n          })\n          : eventSupply(reject),\n      receive: onEvent\n          ? (_ctx, ...event) => {\n            try {\n              resolve(onEvent(...event));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          : ((_ctx: EventReceiver.Context<E>, event: E[0]) => resolve(event)) as any,\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/call-thru';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  eventReceiver,\n  EventReceiver,\n  EventSupply,\n  eventSupply,\n  EventSupplyPeer,\n} from './base';\nimport { once, share, thru, tillOff } from './impl';\nimport { OnEvent } from './on-event';\nimport { OnEventCallChain } from './passes';\nimport Args = OnEventCallChain.Args;\nimport Out = OnEventCallChain.Out;\n\nfunction noEvent(): never {\n  throw new Error('No events to send');\n}\n\n/**\n * An [[EventKeeper]] implementation able to register the receivers of kept and upcoming events.\n *\n * The registered event receiver receives the kept event immediately upon registration, and all upcoming events\n * after that until the returned event supply is cut off.\n *\n * To convert a plain event receiver registration function to [[AfterEvent]] an [[afterEventBy]] function can be used.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class AfterEvent<E extends any[]> extends OnEvent<E> implements EventKeeper<E> {\n\n  /**\n   * @internal\n   */\n  private _last?: E;\n\n  /**\n   * @internal\n   */\n  private _rcn = 0;\n\n  /**\n   * @internal\n   */\n  private readonly _or: (this: void) => E;\n\n  /**\n   * Constructs [[AfterEvent]] instance.\n   *\n   * The event constructed by `or` will be sent to the registered first receiver, unless `register` function sends one.\n   *\n   * @param on  Generic event receiver registration function. It will be called on each receiver registration,\n   * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n   * @param or  A function creating fallback event. When omitted, the initial event is expected to be sent by\n   * `register` function. A receiver registration would lead to an error otherwise.\n   */\n  constructor(\n      on: (this: void, receiver: EventReceiver.Generic<E>) => void,\n      or: (this: void) => E = noEvent,\n  ) {\n    super(on);\n    this._or = or;\n  }\n\n  /**\n   * Event receiver registration function of this event keeper.\n   *\n   * Delegates to [[AfterEvent.to]] method.\n   */\n  get F(): AfterEvent.Fn<E> {\n    return this.to.bind(this);\n  }\n\n  [AfterEvent__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Returns a reference to itself.\n   *\n   * @returns `this` instance.\n   */\n  to(): this;\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver  Target receiver of events.\n   *\n   * @returns A supply of events from this keeper to the given `receiver`.\n   */\n  to(receiver: EventReceiver<E>): EventSupply;\n\n  /**\n   * Either starts sending events to the given `receiver`, or returns a reference to itself.\n   *\n   * @param receiver  Target receiver of events.\n   *\n   * @returns Either a supply of events from this keeper to the given `receiver`, or `this` instance when `receiver`\n   * is omitted.\n   */\n  to(receiver?: EventReceiver<E>): this | EventSupply;\n\n  to(receiver?: EventReceiver<E>): this | EventSupply {\n    if (!receiver) {\n      return this;\n    }\n\n    let dest: (context: EventReceiver.Context<E>, ...event: E) => void = noop;\n    const generic = eventReceiver(receiver);\n\n    if (generic.supply.isOff) {\n      return generic.supply;\n    }\n\n    const supply = eventSupply().needs(generic.supply);\n    let reported = false;\n\n    this._on({\n      supply,\n      receive: (context, ...event: E) => {\n        reported = true;\n        this._last = event;\n        dest(context, ...event);\n      },\n    });\n    ++this._rcn;\n\n    if (!supply.isOff || reported) {\n      generic.receive(\n          {\n            onRecurrent(recurrent) {\n              dest = (_context, ...event) => recurrent(...event);\n            },\n          },\n          ...(this._last || (this._last = this._or())),\n      );\n      dest = (context, ...event) => generic.receive(context, ...event);\n    }\n\n    supply.whenOff(reason => {\n      if (!--this._rcn) {\n        this._last = undefined;\n      }\n      generic.supply.off(reason);\n    });\n\n    return supply;\n  }\n\n  /**\n   * Builds an [[AfterEvent]] keeper of events originated from this one that stops sending them to registered receiver\n   * after the first one.\n   *\n   * @returns Event keeper.\n   */\n  once(): AfterEvent<E>;\n\n  /**\n   * Registers a receiver of events originated from this keeper that stops receiving them after the first one.\n   *\n   * @param receiver  A receiver of events to register.\n   *\n   * @returns A supply of event.\n   */\n  once(receiver: EventReceiver<E>): EventSupply;\n\n  once(receiver?: EventReceiver<E>): AfterEvent<E> | EventSupply {\n    return (this.once = afterEventBy(once(this)).F)(receiver);\n  }\n\n  /**\n   * Builds an [[AfterEvent]] keeper that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New event keeper.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): AfterEvent<E> {\n    return afterEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper that shares events supply among all registered receivers.\n   *\n   * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n   * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n   * event supplies do.\n   *\n   * @returns An [[AfterEvent]] keeper sharing a common supply of events originating from this keeper.\n   */\n  share(): AfterEvent<E> {\n    return afterEventBy(share(this));\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations.\n   *\n   * This does the same as [[thru]] method, but return [[AfterEvent]] keeper instead of [[OnEvent]] sender. This can\n   * not be done automatically, as not every transformation results to [[EventKeeper]]. E.g. when some events\n   * are filtered out.\n   *\n   * The passes are preformed by `@proc7ts/call-thru` library. The event receivers registered by resulting event keeper\n   * are called by the last pass in chain. Thus they can be e.g. filtered out or called multiple times.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes. The returned keeper shares the supply\n   * of transformed events among receivers.\n   */\n  keepThru<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): AfterEvent<Out<Return1>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AfterEvent<Out<Return2>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru(...passes: any[]): AfterEvent<any[]> {\n    return (this as any).keepThru_(...passes).share();\n  }\n\n  /**\n   * Constructs an [[AfterEvent]] keeper of original events passed trough the chain of transformations without sharing\n   * the transformed events supply.\n   *\n   * This method does the same as [[AfterEvent.keepThru]] one, except it does not share the supply of transformed\n   * events among receivers. This may be useful e.g. when the result will be further transformed anyway.\n   * It is wise to {@link AfterEvent.share share} the supply of events from final result in this case.\n   *\n   * @returns An [[AfterEvent]] keeper of events transformed with provided passes.\n   */\n  keepThru_<\n      Return1,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n  ): AfterEvent<Out<Return1>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n  ): AfterEvent<Out<Return2>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_<\n      Return1,\n      Args2 extends Args<Return1>, Return2,\n      Args3 extends Args<Return2>, Return3,\n      Args4 extends Args<Return3>, Return4,\n      Args5 extends Args<Return4>, Return5,\n      Args6 extends Args<Return5>, Return6,\n      Args7 extends Args<Return6>, Return7,\n      Args8 extends Args<Return7>, Return8,\n      Args9 extends Args<Return8>, Return9,\n      Args10 extends Args<Return9>, Return10,\n      Args11 extends Args<Return10>, Return11,\n      Args12 extends Args<Return11>, Return12,\n      Args13 extends Args<Return12>, Return13,\n      >(\n      pass1: (this: void, ...args: E) => Return1,\n      pass2: (this: void, ...args: Args2) => Return2,\n      pass3: (this: void, ...args: Args3) => Return3,\n      pass4: (this: void, ...args: Args4) => Return4,\n      pass5: (this: void, ...args: Args5) => Return5,\n      pass6: (this: void, ...args: Args6) => Return6,\n      pass7: (this: void, ...args: Args7) => Return7,\n      pass8: (this: void, ...args: Args8) => Return8,\n      pass9: (this: void, ...args: Args9) => Return9,\n      pass10: (this: void, ...args: Args10) => Return10,\n      pass11: (this: void, ...args: Args11) => Return11,\n      pass12: (this: void, ...args: Args12) => Return12,\n      pass13: (this: void, ...args: Args13) => Return13,\n  ): AfterEvent<Out<Return3>>;\n\n  keepThru_(...passes: any[]): AfterEvent<any[]> {\n    return afterEventBy(thru(this, passes as any));\n  }\n\n}\n\nexport namespace AfterEvent {\n\n  /**\n   * A signature of function registering receivers of events sent by event keeper.\n   *\n   * When called without parameters it returns an [[AfterEvent]] keeper. When called with event receiver as parameter\n   * it returns a supply of events from that keeper.\n   *\n   * Available as [[AfterEvent.F]] property value.\n   *\n   * @typeparam E  An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Fn<E extends any[]> {\n\n    /**\n     * Returns the event keeper.\n     *\n     * @returns [[AfterEvent]] keeper the events originated from.\n     */\n    (\n        this: void,\n    ): AfterEvent<E>;\n\n    /**\n     * Registers a receiver of events sent by the keeper.\n     *\n     * @param receiver  A receiver of events to register.\n     *\n     * @returns A supply of events from the keeper to the given `receiver`.\n     */\n    (\n        this: void,\n        receiver: EventReceiver<E>,\n    ): EventSupply;\n\n    /**\n     * Either registers a receiver of events sent by the keeper, or returns the keeper itself.\n     *\n     * @param receiver  A receiver of events to register.\n     *\n     * @returns Either a supply of events from the keeper to the given `receiver`, or [[AfterEvent]] keeper the events\n     * originated from when `receiver` is omitted.\n     */\n    (\n        this: void,\n        receiver?: EventReceiver<E>,\n    ): EventSupply | AfterEvent<E>;\n  }\n\n}\n\n/**\n * Converts a plain event receiver registration function to [[AfterEvent]] keeper with a fallback.\n *\n * The event constructed by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param register  Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper registering event receivers with the given `register` function.\n */\nexport function afterEventBy<E extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<E>) => void,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return new AfterEvent(register, fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { EventSender, OnEvent__symbol } from '../base';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param sender  An event sender.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSent<E extends any[]>(\n    sender: EventSender<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return afterEventBy(receiver => sender[OnEvent__symbol]().to(receiver), fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventSupplier, isEventKeeper } from '../base';\nimport { afterSent } from './after-sent';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `keeper`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param keeper  A keeper of events.\n *\n * @returns An [[AfterEvent]] keeper of events originated from the given `keeper`.\n */\nexport function afterSupplied<E extends any[]>(keeper: EventKeeper<E>): AfterEvent<E>;\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by the given `supplier`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `supplier` sends one.\n *\n * This is a synonym of [[afterSent]], unless `supplier` is an [[EventKeeper]].\n *\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param supplier  An event supplier.\n * @param fallback  A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `supplier`. A receiver registration would lead to an error otherwise.\n *\n * @returns An [[AfterEvent]] keeper of events either originated from the given `supplier`, or `initial` one.\n */\nexport function afterSupplied<E extends any[]>(\n    supplier: EventSupplier<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E>;\n\nexport function afterSupplied<E extends any[]>(\n    supplier: EventSupplier<E>,\n    fallback?: (this: void) => E,\n): AfterEvent<E> {\n  return isEventKeeper(supplier) ? supplier[AfterEvent__symbol]() : afterSent(supplier, fallback);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { afterSupplied } from './after-supplied';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeparam S  A type of `sources` map.\n * @param sources  A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each source keeper. Each event in this map has the\n * same key as its source keeper in `sources`.\n */\nexport function afterAll<S extends { readonly [key: string]: EventKeeper<any> }>(\n    sources: S,\n): AfterEvent<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]> {\n\n  const keys = Object.keys(sources);\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(\n      receiver: EventReceiver.Generic<[{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }]>,\n  ): void {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach((key: keyof S) => {\n      supply.needs(sources[key][AfterEvent__symbol]().to((...event) => {\n        result[key] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(result);\n    }\n  }\n\n  function latestEvent(): [{ readonly [K in keyof S]: EventKeeper.Event<S[K]> }] {\n\n    const result: { [K in keyof S]: EventKeeper.Event<S[K]> } = {} as any;\n\n    keys.forEach(\n        key => afterSupplied(sources[key]).once(\n            (...event) => result[key as keyof S] = event,\n        ),\n    );\n\n    return [result];\n  }\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { afterSupplied } from './after-supplied';\n\n/**\n * Builds an [[AfterEvent]] keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeparam E  A type of events sent by each source.\n * @param sources  An array of source event keepers.\n *\n * @returns An event keeper sending events received from each source keeper. Each event item is an event tuple\n * originated from source keeper under its index in `sources` array.\n */\nexport function afterEach<E extends any[]>(...sources: EventKeeper<E>[]): AfterEvent<E[]> {\n\n  return afterEventBy(registerReceiver, latestEvent).share();\n\n  function registerReceiver(receiver: EventReceiver.Generic<E[]>): void {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result: E[] = [];\n\n    sources.forEach((source, index) => {\n      supply.needs(source[AfterEvent__symbol]().to((...event) => {\n        result[index] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(...result);\n    }\n  }\n\n  function latestEvent(): E[] {\n\n    const result: E[] = [];\n\n    sources.forEach(\n        source => afterSupplied(source).once(\n            (...event) => result.push(event),\n        ),\n    );\n\n    return result;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop, valueProvider } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy } from '../after-event';\n\n/**\n * Builds an [[AfterEvent]] keeper of the given `event`.\n *\n * @category Core\n * @param event  An event that will be sent to all receivers upon registration.\n *\n * @returns An [[AfterEvent]] keeper that always sends the given `event`.\n */\nexport function afterThe<E extends any[]>(...event: E): AfterEvent<E> {\n  return afterEventBy(noop, valueProvider(event));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { NextCall, nextCall } from '@proc7ts/call-thru';\nimport { EventKeeper } from '../base';\nimport { afterSupplied } from '../keepers';\nimport { OnEventCallChain } from './on-event-call-chain';\n\n/**\n * Builds a next chained call of {@link OnEventCallChain} that calls the next pass with every event supplied by\n * the given keeper.\n *\n * The event supply from the given keeper will be cut off each time the call is applied.\n *\n * This differs from [[nextOnEvent]] when passing supplier implementing both [[EventSender]] and [[EventKeeper]]\n * interfaces such as [[ValueTracker]]. [[nextOnEvent]] would prefer the former, while this one would prefer the latter.\n *\n * @category Core\n * @typeparam E  An event type. This is a tuple of argument types of the next pass.\n * @param keeper  A keeper of events to pass down the chain.\n *\n * @returns Next call passing events from the given `keeper`.\n */\nexport function nextAfterEvent<E extends any[]>(\n    keeper: EventKeeper<E>,\n): NextCall<OnEventCallChain, E> {\n  return nextCall((chain, pass) => chain.onEvent(pass, afterSupplied(keeper)));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventNotifier, EventReceiver, EventSender, EventSupply, OnEvent__symbol } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Event emitter is a handy implementation of [[OnEvent]] sender.\n *\n * Extends [[EventNotifier]] by making its [[EventNotifier.on]] method implement an [[OnEvent]] interface.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n */\nexport class EventEmitter<E extends any[]> extends EventNotifier<E> implements EventSender<E> {\n\n  /**\n   * Returns an [[OnEvent]] sender.\n   */\n  on(): OnEvent<E>;\n  on(receiver: EventReceiver<E>): EventSupply;\n  on(receiver?: EventReceiver<E>): OnEvent<E> | EventSupply {\n    return (this.on = onEventBy<E>(receiver => super.on(receiver)).F)(receiver);\n  }\n\n  [OnEvent__symbol](): OnEvent<E> {\n    return this.on();\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { neverReceive } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * An [[OnEvent]] sender that never sends any events.\n *\n * @category Core\n */\nexport const onNever: OnEvent<any> = (/*#__PURE__*/ onEventBy(neverReceive));\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent__symbol, EventSupplier, isEventSender, OnEvent__symbol } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * Builds an [[OnEvent]] sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param supplier  An event supplier.\n *\n * @returns An [[OnEvent]] sender of events originated from the given `supplier`.\n */\nexport function onSupplied<E extends any[]>(supplier: EventSupplier<E>): OnEvent<E> {\n  return isEventSender(supplier) ? supplier[OnEvent__symbol]() : supplier[AfterEvent__symbol]();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventReceiver, EventSupplier, eventSupply } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onNever } from './on-never';\nimport { onSupplied } from './on-supplied';\n\n/**\n * Builds an [[OnEvent]] sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeparam E  An event type. This is a list of event receiver parameter types.\n * @param suppliers  Original event suppliers.\n *\n * @returns An [[OnEvent]] sender of all supplied events.\n */\nexport function onAny<E extends any[]>(...suppliers: EventSupplier<E>[]): OnEvent<E> {\n  if (!suppliers.length) {\n    return onNever;\n  }\n\n  return onEventBy<E>(receiver => {\n\n    const { supply } = receiver;\n    let remained = suppliers.length;\n    const removeSupplier = (reason?: any): void => {\n      if (!--remained) {\n        supply.off(reason);\n      }\n    };\n    const receive = (context: EventReceiver.Context<E>, ...event: E): void => {\n      receiver.receive(context, ...event);\n    };\n\n    suppliers.forEach(\n        supplier => onSupplied(supplier).to({\n          supply: eventSupply(removeSupplier).needs(supply),\n          receive,\n        }),\n    );\n  }).share();\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { nextArg } from '@proc7ts/call-thru';\nimport { EventSender, eventSupply, sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onAnyAsync } from './on-any-async';\nimport { onSupplied } from './on-supplied';\n\n/**\n * Builds an [[OnEvent]] sender of asynchronously resolved events originated from the given sender of unresolved events.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved in the same\n * order as they have been received. Possibly in batches, e.g. when events resolved out of order.\n *\n * The resulting events supply is cut if some of incoming event promises rejected. In this case the rejection reason\n * is used as a reason to cut off. If incoming events supply is cut off, then the resulting event supply will be cut off\n * too, but only after all incoming events resolved and sent.\n *\n * @category Core\n * @typeparam E  Resolved event type.\n * @param from  Unresolved events sender containing either events or their promises.\n *\n * @returns New `OnEvent` sender of resolved events.\n */\nexport function onAsync<E>(from: EventSender<[PromiseLike<E> | E]>): OnEvent<[E, ...E[]]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    const sourceSupply = eventSupply();\n    let numInProcess = 0;\n    const source = onSupplied(from)\n        .tillOff(supply, sourceSupply)\n        .thru_(event => {\n          ++numInProcess;\n          return nextArg(event);\n        });\n    let received: E[] = [];\n    let numSent = 1;\n    let numReceived = 0;\n\n    sourceSupply.whenOff(reason => {\n      if (!numInProcess) {\n        supply.off(reason);\n      }\n    });\n\n    onAnyAsync(source).to({\n      supply,\n      receive(_ctx, event, index) {\n\n        const i = index - numSent;\n\n        received[i] = event;\n        ++numReceived;\n        if (numReceived > i) {\n\n          let toSend: E[];\n\n          if (numReceived === received.length) {\n            // Can send all received events\n            toSend = received;\n            received = [];\n          } else {\n            // Can send events up to `i`\n            toSend = received.splice(0, i + 1);\n          }\n          numSent += toSend.length;\n          numReceived -= toSend.length;\n          numInProcess -= toSend.length;\n\n          dispatch(...(toSend as [E, ...E[]]));\n          if (!numInProcess && sourceSupply.isOff) {\n            receiver.supply.needs(sourceSupply);\n          }\n        }\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventSender, OnEvent__symbol, sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Builds an [[OnEvent]] sender of any of asynchronously resolved events originated from the given sender of\n * unresolved events.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved. The original\n * order of events is not preserved. Instead each resolved event is sent along with its index in original order.\n *\n * The resulting events supply is cut off immediately once unresolved events supply is cut off, or some of incoming\n * event promises rejected. In the latter case the rejection reason is used as a reason to cut off.\n *\n * @category Core\n * @typeparam E  Resolved event type.\n * @param from  Unresolved events sender containing either events or their promises.\n *\n * @returns New `OnEvent` sender of resolved events and their indices in original order starting from `1`.\n */\nexport function onAnyAsync<E>(from: EventSender<[PromiseLike<E> | E]>): OnEvent<[E, number]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    let lastIndex = 0;\n\n    from[OnEvent__symbol]().to({\n      supply,\n      receive(_ctx, promise) {\n\n        const index = ++lastIndex;\n\n        Promise.resolve()\n            .then(() => promise)\n            .then(\n                event => dispatch(event, index),\n                reason => supply.off(reason),\n            );\n      },\n    });\n  });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventReceiver } from '../base';\nimport { alwaysReceiveValue, neverReceiveBecause } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Represents a promise as event sender.\n *\n * When the `promise` resolves successfully the resolved value is sent to registered event receivers. The events\n * supply is {@link EventSupply.off cut off} immediately after that without any reason specified.\n *\n * When the `promise` is rejected the events supply is {@link EventSupply.off cut off} with promise rejection reason.\n *\n * @category Core\n * @param promise  The promise to represent as event sender.\n *\n * @returns An [[OnEvent]] sender of the given `promise` settlement event.\n */\nexport function onPromise<T>(promise: Promise<T>): OnEvent<[T]> {\n\n  let receive = (receiver: EventReceiver.Generic<[T]>): void => {\n    promise.then(() => receive(receiver), () => receive(receiver));\n  };\n\n  promise.then(value => {\n    receive = alwaysReceiveValue(value);\n  }).catch(e => {\n    receive = neverReceiveBecause(e);\n  });\n\n  return onEventBy(receiver => receive(receiver));\n}\n","import { EventReceiver } from '../event-receiver';\nimport { sendEventsTo } from '../send-events-to';\n\n/**\n * @internal\n */\nexport function alwaysReceiveValue<T>(value: T): (receiver: EventReceiver.Generic<[T]>) => void {\n  return receiver => {\n    try {\n      sendEventsTo(receiver)(value);\n      receiver.supply.off();\n    } catch (e) {\n      receiver.supply.off(e);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\n/**\n * A path to state or its part. E.g. property value.\n *\n * May consist of one or more property keys.\n *\n * An array consisting of the only one property key is the same as this property key.\n *\n * An empty array is a path to the state itself.\n *\n * @category State Tracking\n */\nexport type StatePath = PropertyKey | StatePath.Normalized;\n\nexport namespace StatePath {\n\n  /**\n   * Normalized state path.\n   *\n   * This is always an array of property keys.\n   */\n  export type Normalized = readonly PropertyKey[];\n\n}\n\n/**\n * Normalizes a state path consisting of single key.\n *\n * @category State Tracking\n * @param key  A path key.\n *\n * @return Normalized state path.\n */\nexport function statePath<K extends PropertyKey>(key: K): [K];\n\n/**\n * Normalizes arbitrary state path. I.e. converts it to array.\n *\n * @param path  Arbitrary state path.\n *\n * @return Normalized state path.\n */\nexport function statePath(path: StatePath): StatePath.Normalized;\n\nexport function statePath(path: StatePath): StatePath.Normalized {\n  return Array.isArray(path) ? path : [path];\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { EventSender, eventSupply, EventSupply, OnEvent__symbol } from '../base';\nimport { onEventBy } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { OnStateUpdate } from './on-state-update';\nimport { statePath, StatePath } from './state-path';\nimport { StateUpdateReceiver } from './state-update-receiver';\n\nclass PathEntry {\n\n  readonly emitter = new EventEmitter<[StatePath.Normalized, any, any]>();\n  private readonly _nested = new Map<PropertyKey, PathEntry>();\n\n  constructor(private readonly _drop: () => void) {\n    this.emitter.on((path, newValue, oldValue) => {\n\n      const key = path[0];\n      const nested = this._nested.get(key);\n\n      if (nested) {\n        nested.emitter.send(path.slice(1), newValue, oldValue);\n      }\n    });\n  }\n\n  on(receiver: StateUpdateReceiver): EventSupply {\n\n    const supply = this.emitter.on(receiver);\n\n    return eventSupply(reason => {\n      supply.off(reason);\n      this._dropIfEmpty();\n    }).needs(supply);\n  }\n\n  nest(key: PropertyKey): PathEntry;\n\n  nest(key: PropertyKey, dontCreateMissing: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined {\n\n    const found = this._nested.get(key);\n\n    if (found || dontCreateMissing) {\n      return found;\n    }\n\n    const created = new PathEntry(() => this._remove(key));\n\n    this._nested.set(key, created);\n\n    return created;\n  }\n\n  done(reason?: any): void {\n    for (const nested of this._nested.values()) {\n      nested.done(reason);\n    }\n    this.emitter.done(reason);\n  }\n\n  private _remove(key: PropertyKey): void {\n    this._nested.delete(key);\n    this._dropIfEmpty();\n  }\n\n  private _dropIfEmpty(): void {\n    if (!this._nested.size && this.emitter.size <= 1) {\n      this._drop();\n    }\n  }\n\n}\n\nclass Trackers {\n\n  private readonly _root = new PathEntry(noop);\n\n  on(path: StatePath.Normalized, receiver: StateUpdateReceiver): EventSupply {\n    return this._entry(path).on(receiver);\n  }\n\n  send<V>(path: StatePath.Normalized, newValue: V, oldValue: V): void {\n    this._root.emitter.send(path, newValue, oldValue);\n  }\n\n  done(path: StatePath.Normalized, reason?: any): void {\n\n    const entry = this._entry(path, true);\n\n    if (entry) {\n      entry.done(reason);\n    }\n  }\n\n  private _entry(path: StatePath.Normalized): PathEntry;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing: true): PathEntry | undefined;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing?: true): PathEntry | undefined {\n\n    let entry = this._root;\n\n    for (const key of path) {\n\n      const nested = entry.nest(key, dontCreateMissing);\n\n      if (!nested) {\n        return;\n      }\n\n      entry = nested;\n    }\n\n    return entry;\n  }\n\n}\n\nclass SubStateTracker implements StateTracker {\n\n  readonly update: <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void;\n\n  constructor(private readonly _trackers: Trackers, private readonly _path: StatePath.Normalized) {\n    this.update = <V>(path: StatePath, newValue: V, oldValue: V) => {\n      this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n    };\n  }\n\n  get _tracker(): this {\n    return this;\n  }\n\n  onUpdate(): OnStateUpdate;\n  onUpdate(receiver: StateUpdateReceiver): EventSupply;\n  onUpdate(receiver?: StateUpdateReceiver): OnStateUpdate | EventSupply {\n    return (this.onUpdate = onEventBy<[StatePath, any, any]>(\n        receiver => this._trackers.on(this._path, receiver),\n    ).F as OnStateUpdate.Fn)(receiver);\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate();\n  }\n\n  track(path: StatePath): SubStateTracker {\n    path = statePath(path);\n    if (!path.length) {\n      return this; // Path to itself.\n    }\n    return new SubStateTracker(this._trackers, [...this._path, ...path]);\n  }\n\n  done(reason?: any): void {\n    this._trackers.done(this._path, reason);\n  }\n\n}\n\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under [[StatePath]].\n *\n * When node modified a [[StateTracker.update]] should be called. Then all state update receivers registered by\n * [[StateTracker.onUpdate]] will receive this update.\n *\n * @category State Tracking\n */\nexport class StateTracker implements EventSender<[StatePath.Normalized, any, any]> {\n\n  /**\n   * @internal\n   */\n  readonly _tracker: SubStateTracker = new SubStateTracker(new Trackers(), []);\n\n  /**\n   * Builds a {@link OnStateUpdate state updates sender}.\n   *\n   * A state update will be sent to it whenever an `update()` function is called.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns State updates sender.\n   */\n  onUpdate(): OnStateUpdate;\n\n  /**\n   * Registers a receiver of state updates.\n   *\n   * @param receiver State updates receiver to register.\n   *\n   * @returns A supply of state updates.\n   */\n  onUpdate(receiver: StateUpdateReceiver): EventSupply;\n\n  onUpdate(receiver?: StateUpdateReceiver): OnStateUpdate | EventSupply {\n    return (this.onUpdate = this._tracker.onUpdate().F)(receiver);\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate();\n  }\n\n  // noinspection JSCommentMatchesSignature\n  /**\n   * Updates the component state.\n   *\n   * All receivers registered with [[onUpdate]] will receive this update.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  get update(): <V>(\n      this: void,\n      path: StatePath,\n      newValue: V,\n      oldValue: V,\n  ) => void {\n    return this._tracker.update;\n  }\n\n  /**\n   * Starts tracking of partial state under the given path.\n   *\n   * @param path  A path to state part.\n   *\n   * @return New partial state tracker.\n   */\n  track(path: StatePath): StateTracker {\n\n    const subTracker = this._tracker.track(path);\n\n    return subTracker === this._tracker ? this : subTracker;\n  }\n\n  /**\n   * Unregisters updates receivers and cuts off their supplies.\n   *\n   * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n   *\n   * @param reason  An optional reason to stop tracking.\n   */\n  done(reason?: any): void {\n    this._tracker.done(reason);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  EventSupplyPeer,\n  isEventKeeper,\n  noEventSupply,\n  OnEvent__symbol,\n} from '../base';\nimport { OnEvent } from '../on-event';\nimport { onSupplied } from '../senders';\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an [[EventSender]] interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an [[EventKeeper]] interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeparam T  Tracked value type.\n */\nexport abstract class ValueTracker<T = any> implements EventSender<[T, T]>, EventKeeper<[T]>, EventSupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _by = noEventSupply();\n\n  /**\n   * Returns [[OnEvent]] sender of value changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Value changes sender.\n   */\n  abstract on(): OnEvent<[T, T]>;\n\n  /**\n   * Registers a receiver of value changes.\n   *\n   * The new value is sent as first argument, and the old value as a second one.\n   *\n   * @param receiver  A receiver to register.\n   *\n   * @returns A supply of value changes.\n   */\n  abstract on(receiver: EventReceiver<[T, T]>): EventSupply;\n\n  /**\n   * Builds an [[AfterEvent]] keeper of current value.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Current value keeper.\n   */\n  read(): AfterEvent<[T]>;\n\n  /**\n   * Registers a receiver of current values.\n   *\n   * @param receiver  A receiver to register.\n   *\n   * @returns A supply of current value.\n   */\n  read(receiver: EventReceiver<[T]>): EventSupply;\n\n  read(receiver?: EventReceiver<[T]>): AfterEvent<[T]> | EventSupply {\n    return (this.read = afterEventBy<[T]>(\n        receiver => this.on(receiveNewValue(receiver)),\n        () => [this.it],\n    ).F)(receiver);\n  }\n\n  [OnEvent__symbol](): OnEvent<[T, T]> {\n    return this.on();\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read();\n  }\n\n  /**\n   * An event supply of this value tracker.\n   */\n  abstract readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * The tracked value.\n   */\n  abstract it: T;\n\n  /**\n   * Updates the tracked value by the given value `supplier`.\n   *\n   * If the value is already updated by another supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @param supplier  The source value sender or keeper.\n   *\n   * @returns `this` instance.\n   */\n  by(supplier: EventSupplier<[T]>): this;\n\n  /**\n   * Updates the tracked value by value suppliers extracted from events sent by the given `supplier`.\n   *\n   * If the value is already updated by another value supplier, then unbinds from the old one first.\n   *\n   * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @typeparam S  Source value type.\n   * @param supplier  The event supplier to extract value suppliers from.\n   * @param extract  A function extracting value supplier from event received from `supplier`.\n   * May return `undefined` to suspend receiving values.\n   *\n   * @returns `this` instance.\n   */\n  by<S extends any[]>(\n      supplier: EventSupplier<S>,\n      extract: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this;\n\n  by<S extends any[]>(\n      supplier: EventSupplier<S> | EventSupplier<[T]>,\n      extract?: (this: void, ...event: S) => EventSupplier<[T]> | undefined,\n  ): this {\n\n    const acceptValuesFrom = (sender: EventSupplier<[T]>): EventSupply => {\n\n      const onValue = isEventKeeper(sender) ? sender[AfterEvent__symbol]() : sender[OnEvent__symbol]();\n\n      return onValue.to(value => this.it = value);\n    };\n\n    this.byNone();\n    if (!extract) {\n\n      const sender = supplier as EventSupplier<[T]>;\n\n      this._by = acceptValuesFrom(sender);\n    } else {\n\n      const container = supplier as EventSupplier<S>;\n\n      this._by = onSupplied(container).consume((...event: S) => {\n\n        const sender = extract(...event);\n\n        if (sender) {\n          return acceptValuesFrom(sender);\n        }\n\n        return;\n      });\n    }\n\n    this._by.whenOff(() => this._by = noEventSupply());\n\n    return this;\n  }\n\n  /**\n   * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n   *\n   * If the tracker is not bound then does nothing.\n   *\n   * @param reason  Arbitrary reason of unbinding the value.\n   *\n   * @returns `this` instance.\n   */\n  byNone(reason?: any): this {\n    this._by.off(reason);\n    return this;\n  }\n\n  /**\n   * Removes all registered event receivers and cuts off corresponding event supplies.\n   *\n   * After this method call they won't receive events.\n\n   * @param reason  A reason to stop sending events.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction receiveNewValue<T, N extends T>(\n    valueReceiver: EventReceiver.Generic<[T]>,\n): EventReceiver.Generic<[N, T]> {\n  return {\n    supply: valueReceiver.supply,\n    receive(context, newValue) {\n      valueReceiver.receive(\n          {\n            onRecurrent(recurrentReceiver) {\n              context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n            },\n          },\n          newValue,\n      );\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport { EventKeeper, EventReceiver, EventSupply, EventSupply__symbol, eventSupplyOf } from '../base';\nimport { OnEvent } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * @internal\n */\nclass TrackedValue<T> extends ValueTracker<T> {\n\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  constructor(private _it: T) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._on);\n  }\n\n  on(): OnEvent<[T, T]>;\n  on(receiver: EventReceiver<[T, T]>): EventSupply;\n  on(receiver?: EventReceiver<[T, T]>): OnEvent<[T, T]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const oldValue = this._it;\n\n    if (oldValue !== value) {\n      this._it = value;\n      this._on.send(value, oldValue);\n    }\n  }\n\n}\n\n/**\n * Constructs a value which changes can be tracked.\n *\n * @category Value Tracking\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial: T): ValueTracker<T>;\n\n/**\n * Constructs an optional value which changes can be tracked.\n *\n * @param initial  Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial?: T): ValueTracker<T | undefined>;\n\nexport function trackValue<T>(initial: T): ValueTracker<T> {\n  return new TrackedValue<T>(initial);\n}\n\n/**\n * Constructs a tracked value updated by the given value `supplier`.\n *\n * If the value is already updated by another supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @category Value Tracking\n * @param supplier  The source value keeper.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T>(supplier: EventKeeper<[T]>): ValueTracker<T>;\n\n/**\n * Constructs a tracked value updated by value keepers extracted from events sent by the given `supplier`.\n *\n * If the value is already updated by another value supplier, then unbinds from the old one first.\n *\n * Call the [[ValueTracker.byNone]] method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @typeparam S  Source value type.\n * @param supplier  The event keeper to extract value keepers from.\n * @param extract  A function extracting value keeper from event received from `supplier`.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventKeeper<S>,\n    extract: (this: void, ...event: S) => EventKeeper<[T]>,\n): ValueTracker<T>;\n\nexport function trackValueBy<T, S extends any[]>(\n    supplier: EventKeeper<S> | EventKeeper<[T]>,\n    extract?: (this: void, ...event: S) => EventKeeper<[T]>,\n): ValueTracker<T> {\n  return (trackValue() as any).by(supplier, extract);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events\n */\nimport {\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  isEventKeeper,\n} from '../base';\nimport { afterSupplied } from '../keepers';\nimport { OnEvent } from '../on-event';\nimport { EventEmitter, onSupplied } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * Synchronizes tracked values with each other.\n *\n * Any change to any of the added tracked values would update all the others.\n *\n * @category Value Tracking\n */\nexport class ValueSync<T> extends ValueTracker<T> {\n\n  /**\n   * @internal\n   */\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  /**\n   * @internal\n   */\n  private _it: T;\n\n  constructor(initial: T) {\n    super();\n    this._it = initial;\n  }\n\n  on(): OnEvent<[T, T]>;\n  on(receiver: EventReceiver<[T, T]>): EventSupply;\n  on(receiver?: EventReceiver<[T, T]>): OnEvent<[T, T]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._on);\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const old = this.it;\n\n    if (old !== value) {\n      this._it = value;\n      this._on.send(value, old);\n    }\n  }\n\n  /**\n   * Synchronizes the tracked value with the others.\n   *\n   * Applies the value from this sync to the given tracker first.\n   *\n   * @param tracker  A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync(tracker: ValueTracker<T>): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the others in the given direction.\n   *\n   * @param direction  If set to `\"in\"` the value from the given tracker takes precedence over the one in [[ValueSync]].\n   * Otherwise the value from the sync is applied to the given tracker first.\n   * @param tracker  A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync(direction: 'in' | 'out', tracker: ValueTracker<T>): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * Applies the value from this sync to extracted trackers.\n   *\n   * @param supplier  The event supplier to extract value trackers from.\n   * @param extract  A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync<U extends any[]>(\n      supplier: EventSupplier<U>,\n      extract: (this: void, ...event: U) => ValueTracker<T> | undefined,\n  ): EventSupply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`\n   * in the given direction.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * @param direction  If set to `\"in\"` the value from extracted tracker takes precedence over the one in\n   * [[ValueSync]]. Otherwise the value from the sync is applied to extracted trackers first.\n   * @param supplier  The event supplier to extract value trackers from.\n   * @param extract  A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link EventSupply.off Cut it off} to break synchronization.\n   */\n  sync<U extends any[]>(\n      direction: 'in' | 'out',\n      supplier: EventSupplier<U>,\n      extract: (this: void, ...event: U) => ValueTracker<T> | undefined,\n  ): EventSupply;\n\n  sync<U extends any[]>(\n      first: 'in' | 'out' | ValueTracker<T> | EventSupplier<U>,\n      second?: ValueTracker<T>\n          | EventSender<U>\n          | EventKeeper<U>\n          | ((this: void, ...event: U) => ValueTracker<T> | undefined),\n      third?: (this: void, ...event: U) => ValueTracker<T> | undefined,\n  ): EventSupply {\n\n    let syncWithTracker = (tracker: ValueTracker<T>): EventSupply => syncTrackers(this, tracker);\n    let source: ValueTracker<T> | EventSupplier<U>;\n    let extract: ((this: void, ...event: U) => ValueTracker<T> | undefined) | undefined;\n\n    if (typeof first === 'string') {\n      if (first === 'in') {\n        syncWithTracker = tracker => syncTrackers(tracker, this);\n      }\n      source = second as ValueTracker<T> | EventSender<U> | EventKeeper<U>;\n      extract = third;\n    } else {\n      source = first;\n      extract = second as (this: void, ...event: U) => ValueTracker<T> | undefined;\n    }\n\n    const extractTracker = extract;\n\n    if (!extractTracker) {\n      return syncWithTracker(source as ValueTracker<T>);\n    }\n\n    const supplier = source as EventSupplier<U>;\n\n    return (isEventKeeper(supplier) ? afterSupplied(supplier) : onSupplied(supplier)).consume((...event) => {\n\n      const tracker = extractTracker(...event);\n\n      return tracker && syncWithTracker(tracker);\n    });\n\n    function syncTrackers(tracker1: ValueTracker<T>, tracker2: ValueTracker<T>): EventSupply {\n\n      const supply1 = tracker1.read(value => {\n        tracker2.it = value;\n      });\n      const supply2 = tracker2.on(value => {\n        tracker1.it = value;\n      });\n\n      return eventSupply(reason => {\n        supply2.off(reason);\n        supply1.off(reason);\n      }).needs(supply1).needs(supply2);\n    }\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/namespace-aliaser\n */\nimport { QualifiedName } from './name';\nimport { NamespaceDef } from './namespace';\nimport { NamespaceAliaser } from './namespace-aliaser';\n\n/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nexport abstract class Naming {\n\n  /**\n   * Applies the given namespace `alias` to the given local `name`.\n   *\n   * @param name Local name to apply namespace alias to.\n   * @param alias Namespace alias to apply.\n   * @param namespace Aliased namespace definition.\n   *\n   * @returns A string containing the `name` with `alias` applied to it.\n   */\n  abstract applyAlias(name: string, alias: string, namespace: NamespaceDef): string;\n\n  /**\n   * Converts the given qualified `name` into simple one accordingly to this naming schema.\n   *\n   * @param name Qualified name to convert.\n   * @param nsAlias Namespace aliaser to use.\n   */\n  name(name: QualifiedName, nsAlias: NamespaceAliaser): string {\n    if (typeof name === 'string') {\n      return name;\n    }\n\n    const [local, ns] = name;\n\n    return ns.name(nsAlias(ns), local, this);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/namespace-aliaser\n */\nimport { Naming } from './naming';\n\n/**\n * @internal\n */\nclass DefaultNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}-${name}`;\n  }\n\n}\n\n/**\n * Default naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const default__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * HTML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const html__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * @internal\n */\nclass XmlNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}:${name}`;\n  }\n\n}\n\n/**\n * XML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const xml__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * Element identifiers naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const id__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * @internal\n */\nclass CssNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${name}@${alias}`;\n  }\n\n}\n\n/**\n * CSS classes naming scheme.\n *\n * Appends namespace alias as a name suffix separated by `@` sign.\n *\n * The result looks like `<name>@<alias>`.\n */\nexport const css__naming: Naming = (/*#__PURE__*/ new CssNaming());\n","/**\n * @packageDocumentation\n * @module @proc7ts/namespace-aliaser\n */\nimport { Naming } from './naming';\nimport { default__naming } from './namings';\n\n/**\n * Namespace definition.\n *\n * Namespaces are identified by their URLs.\n */\nexport class NamespaceDef {\n\n  /**\n   * Unique namespace URL.\n   */\n  readonly url: string;\n\n  /**\n   * Preferred namespace aliases.\n   */\n  readonly aliases: readonly string[];\n\n  /**\n   * The most preferred namespace alias.\n   *\n   * By default this is the first preferred alias, or `ns` if there is no preferred aliases.\n   */\n  get alias(): string {\n    return this.aliases[0] || 'ns';\n  }\n\n  /**\n   * Constructs new namespace definition.\n   *\n   * @param url  Unique namespace URL.\n   * @param aliases  Preferred namespace aliases. It is expected that each alias is an ASCII letter followed by\n   * any number of ASCII letters, digits, `-`, or `_` signs. Aliases starting with `xml` are reserved. Empty alias\n   * is reserved for [default namespace][[DEFAULT__NS]].\n   */\n  constructor(url: string, ...aliases: string[]) {\n    this.url = url;\n    this.aliases = aliases;\n  }\n\n  /**\n   * Converts a local `name` belonging to this namespace to simple one according to the given `naming` schema.\n   *\n   * Calls [[Naming.applyAlias]] by default.\n   *\n   * @param alias  Namespace alias to apply to the name.\n   * @param name  A name to convert.\n   * @param naming  Naming schema to use. {@link default__naming default naming schema} is used when omitted.\n   *\n   * @returns A simple name with this namespace alias applied.\n   */\n  name(alias: string, name: string, naming: Naming = default__naming): string {\n    return naming.applyAlias(name, alias, this);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/namespace-aliaser\n */\nimport { DEFAULT__NS } from './default.ns';\nimport { NamespaceDef } from './namespace';\n\n/**\n * A name qualified with namespace.\n *\n * This can be either:\n * - a simple name string, which means a name in default namespace, or\n * - a name+namespace tuple.\n */\nexport type QualifiedName = string | NameAndNamespace;\n\n/**\n * A local name and namespace tuple.\n *\n * Consists of a local name string and namespace definition this name belongs to.\n */\nexport type NameAndNamespace = readonly [string, NamespaceDef];\n\n/**\n * Checks whether the given `value` is a name+namespace tuple.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is an array consisting of exactly two elements, where the first element is a\n * non-empty string, and the second element is an instance of [[NamespaceDef]]. Or `false` otherwise.\n */\nexport function isNameAndNamespace(value: any): value is NameAndNamespace {\n  return Array.isArray(value)\n      && value.length === 2\n      && typeof value[0] === 'string'\n      && value[1] instanceof NamespaceDef;\n}\n\n/**\n * Checks whether the given `value` is a qualified name.\n *\n * @param value  A value to check.\n *\n * @returns `true` if the given `value` is a non-empty string or an array consisting of exactly two elements,\n * where the first element is a non-empty string, and the second element is an instance of [[NamespaceDef]].\n * Or `false` otherwise.\n */\nexport function isQualifiedName(value: any): value is QualifiedName {\n  return typeof value === 'string' || isNameAndNamespace(value);\n}\n\n/**\n * Detects a namespace of the given qualified `name`\n *\n * @param name  Qualified name to detect a namespace of.\n *\n * @returns A namespace if the given `name` has it, or {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function namespaceOf(name: QualifiedName): NamespaceDef {\n  return typeof name !== 'string' ? name[1] : DEFAULT__NS;\n}\n\n/**\n * Converts the given qualified `name` to local name and namespace tuple.\n *\n * @param name  Qualified name to convert.\n *\n * @returns The `name` itself if it has a namespace, or a tuple consisting of `name` and\n * {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function nameAndNamespace(name: QualifiedName): NameAndNamespace {\n  return typeof name !== 'string' ? name : [name, DEFAULT__NS];\n}\n\n/**\n * Checks whether two qualified names are equal to each other.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `true` if both names are equal, or `false` otherwise.\n */\nexport function namesEqual(first: QualifiedName, second: QualifiedName): boolean {\n  if (typeof first === 'string') {\n    return typeof second === 'string' ? first === second : !second[1].url && second[0] === first;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    return !firstUrl && firstName === second;\n  }\n\n  return firstName === second[0] && firstUrl === second[1].url;\n}\n\n/**\n * Compares two qualified names.\n *\n * Names in default namespace considered less than other names. Namespaces are compared by their URLs.\n *\n * @param first  First qualified name to compare.\n * @param second  Second qualified name to compare.\n *\n * @returns `-1` if the `first` name is less than the `second` one, `0` if they are equal, or `1` if the `first` name\n * is greater than the `second` one.\n */\nexport function compareNames(first: QualifiedName, second: QualifiedName): -1 | 0 | 1 {\n  if (typeof first === 'string') {\n    if (typeof second === 'string') {\n      return compareStrings(first, second);\n    }\n    if (!second[1].url) {\n      return compareStrings(first, second[0]);\n    }\n    return -1;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    if (!firstUrl) {\n      return compareStrings(firstName, second);\n    }\n    return 1;\n  }\n\n  return compareStrings(firstUrl, second[1].url) || compareStrings(firstName, second[0]);\n}\n\n/**\n * @internal\n */\nfunction compareStrings(first: string, second: string): -1 | 0 | 1 {\n  return first < second ? -1 : first > second ? 1 : 0;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/namespace-aliaser\n */\nimport { NamespaceDef } from './namespace';\n\n/**\n * Namespace aliaser function interface.\n *\n * Maps namespaces to their unique aliases.\n */\nexport type NamespaceAliaser =\n/**\n * @param ns  A definition of namespace to find alias for.\n *\n * @returns Namespace alias.\n */\n    (ns: NamespaceDef) => string;\n\n/**\n * Creates a namespace aliaser.\n *\n * The returned function tries to find a registered alias for the given namespace. If not found then tries to use one\n * of its preferred aliases. If all of them are reserved already for another namespaces, generates a new unique alias.\n *\n * @returns New instance of namespace aliaser.\n */\nexport function newNamespaceAliaser(): NamespaceAliaser {\n\n  const aliasesByNs = new Map<string, string>();\n  const nsNumPerAlias = new Map<string, number>();\n\n  return function nsAlias(ns: NamespaceDef): string {\n\n    const found = aliasesByNs.get(ns.url);\n\n    if (found) {\n      return found;\n    }\n\n    const mostPreferred = ns.alias;\n    let nsNumRegistered = 0;\n\n    for (const preferred of [mostPreferred, ...ns.aliases]) {\n\n      const ids = nsNumPerAlias.get(preferred);\n\n      if (!ids) {\n        aliasesByNs.set(ns.url, preferred);\n        nsNumPerAlias.set(preferred, 1);\n        return preferred;\n      }\n      if (!nsNumRegistered) {\n        // Use the first one\n        nsNumRegistered = ids;\n      }\n    }\n\n    const generated = mostPreferred + (++nsNumRegistered);\n\n    aliasesByNs.set(ns.url, generated);\n    nsNumPerAlias.set(mostPreferred, nsNumRegistered);\n\n    return generated;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events/dom\n */\nimport { eventReceiver, EventReceiver, EventSupply, EventSupplyPeer } from '../base';\nimport { once, tillOff } from '../impl';\nimport { OnEvent } from '../on-event';\n\n/**\n * DOM event listener.\n *\n * DOM events are never recurrent.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport type DomEventListener<E extends Event> = EventReceiver<[E]>;\n\n/**\n * An [[EventSender]] implementation able to register DOM event listeners.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n */\nexport class OnDomEvent<E extends Event> extends OnEvent<[E]> {\n\n  /**\n   * DOM event listener registration function of this event sender.\n   *\n   * Delegates to [[OnDomEvent.to]] method.\n   */\n  get F(): OnDomEvent.Fn<E> {\n    return this.to.bind(this);\n  }\n\n  /**\n   * Returns a reference to itself.\n   *\n   * @returns `this` instance.\n   */\n  to(): this;\n\n  /**\n   * Starts sending DOM events to the given `listener`.\n   *\n   * @param listener  Target listener of DOM events.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events from this sender to the given `listener`.\n   */\n  to(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  /**\n   * Either starts sending DOM events to the given `listener`, or returns a reference to itself.\n   *\n   * @param listener  Target listener of DOM events.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns Either a supply of DOM events from this sender to the given `listener`, or `this` instance when `listener`\n   * is omitted.\n   */\n  to(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): this | EventSupply;\n\n  to(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): this | EventSupply {\n    if (!listener) {\n      return this;\n    }\n\n    const receiver = eventReceiver(listener);\n    const { supply } = receiver;\n\n    if (!supply.isOff) {\n      (this._on as (\n          this: void,\n          listener: EventReceiver.Generic<[E]>,\n          opts?: AddEventListenerOptions | boolean,\n      ) => void)(receiver, opts);\n    }\n\n    return supply;\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this one that stops sending them to registered receiver\n   * after the first one.\n   *\n   * @returns DOM event sender.\n   */\n  once(): OnDomEvent<E>;\n\n  /**\n   * Registers a listener of DOM events originated from this sender that stops receiving them after the first one.\n   *\n   * @param listener  A DOM event listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM event.\n   */\n  once(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  once(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.once = onDomEventBy(once(this)).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender that sends events from this one until the required `supply` is cut off.\n   *\n   * The outgoing events supply will be cut off once incoming event supply does. Unless a second supply passed in.\n   * In the latter case that supply will be cut off instead.\n   *\n   * @param required  A peer of required event supply.\n   * @param dependentSupply  The supply to cut off on cutting off the incoming events supply.\n   *\n   * @returns New DOM event sender.\n   */\n  tillOff(required: EventSupplyPeer, dependentSupply?: EventSupply): OnDomEvent<E> {\n    return onDomEventBy(tillOff(this, required, dependentSupply));\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this sender that enables event capturing by default.\n   *\n   * This corresponds to specifying `true` or `{ capture: true }` as a second argument to\n   * `EventTarget.addEventListener()`.\n   *\n   * @returns DOM events sender.\n   */\n  capture(): OnDomEvent<E>;\n\n  /**\n   * Registers a capturing listener of DOM events.\n   *\n   * This corresponds to specifying `true` or `{ capture: true }` as a second argument to\n   * `EventTarget.addEventListener()`.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  capture(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  capture(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.capture = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this.to(listener, true);\n      }\n      if (typeof opts === 'object' && opts.capture == null) {\n        return this.to(listener, { ...opts, capture: true });\n      }\n      return this.to(listener, opts);\n    }).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this sender that registers listeners to invoke instead\n   * of the default action.\n   *\n   * It invokes an `Event.preventDefault()` method prior to calling the registered listener.\n   *\n   * @returns DOM events sender.\n   */\n  instead(): OnDomEvent<E>;\n\n  /**\n   * Registers a listener of DOM events to invoke instead of default action.\n   *\n   * This listener invokes an `Event.preventDefault()` method prior to event handling.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  instead(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  instead(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.instead = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this.to(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.preventDefault();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    }).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originate from this sender that registers listeners preventing further\n   * propagation of current event in the capturing and bubbling phases.\n   *\n   * It invokes an `Event.stopPropagation()` method prior to calling the registered listener.\n   *\n   * @returns DOM events sender.\n   */\n  just(): OnDomEvent<E>;\n\n  /**\n   * Registers a listener of DOM events preventing further propagation of current event in the capturing and bubbling\n   * phases.\n   *\n   * This listener invokes an `Event.stopPropagation()` method prior to event handling.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  just(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  just(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.just = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this.to(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopPropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    }).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this sender that registers the last event listener.\n   *\n   * It invokes an `Event.stopImmediatePropagation()` method prior to calling the registered listener.\n   *\n   * @returns DOM event sender.\n   */\n  last(): OnDomEvent<E>;\n\n  /**\n   * Registers the last DOM event listener.\n   *\n   * This listener invokes an `Event.stopImmediatePropagation()` method prior to event handling.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  last(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  last(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.last = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n\n      const receiver = eventReceiver(listener);\n\n      return this.to(\n          {\n            supply: receiver.supply,\n            receive(context, event) {\n              event.stopImmediatePropagation();\n              receiver.receive(context, event);\n            },\n          },\n          opts,\n      );\n    }).F)(listener, opts);\n  }\n\n  /**\n   * Builds an [[OnDomEvent]] sender of events originated from this sender that accepts listeners never calling\n   * `Event.preventDefault()`.\n   *\n   * This corresponds to specifying `{ passive: true }` as a second argument to `EventTarget.addEventListener()`.\n   *\n   * @returns DOM event listener.\n   */\n  passive(): OnDomEvent<E>;\n\n  /**\n   * Registers a DOM event listener that never calls `Event.preventDefault()`.\n   *\n   * This corresponds to specifying `{ passive: true }` as a second argument to `EventTarget.addEventListener()`.\n   *\n   * @param listener  A DOM events listener to register.\n   * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events.\n   */\n  passive(listener: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): EventSupply;\n\n  passive(listener?: DomEventListener<E>, opts?: AddEventListenerOptions | boolean): OnDomEvent<E> | EventSupply {\n    return (this.passive = onDomEventBy((\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => {\n      if (opts == null) {\n        return this.to(listener, { passive: true });\n      }\n      if (typeof opts === 'boolean') {\n        return this.to(listener, { capture: opts, passive: true });\n      }\n      if (opts.passive == null) {\n        return this.to(listener, { ...opts, passive: true });\n      }\n      return this.to(listener, opts);\n    }).F)(listener, opts);\n  }\n\n}\n\nexport namespace OnDomEvent {\n\n  /**\n   * A signature of function registering listeners of DOM events sent by event sender.\n   *\n   * When called without parameters it returns an [[OnDomEvent]] sender. When called with DOM event listener\n   * as parameter it returns a supply of DOM events from that sender.\n   *\n   * Available as [[OnDomEvent.F]] property value.\n   *\n   * @typeparam E  Supported DOM event type.\n   */\n  export interface Fn<E extends Event> {\n\n    /**\n     * Returns the DOM events sender.\n     *\n     * @returns [[OnDomEvent]] sender the events originated from.\n     */\n    (\n        this: void,\n    ): OnDomEvent<E>;\n\n    /**\n     * Registers a listener of DOM events sent by the sender.\n     *\n     * @param listener  A listener of DOM events to register.\n     * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n     *\n     * @returns A supply of DOM events from the sender to the given `listener`.\n     */\n    (\n        this: void,\n        listener: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ): EventSupply;\n\n    /**\n     * Either registers a listener of DOM events sent by the sender, or returns the sender itself.\n     *\n     * @param listener  A listener of DOM events to register.\n     * @param opts  DOM event listener options to pass to `EventTarget.addEventListener()`.\n     *\n     * @returns Either a supply of DOM events from the sender to the given `listener`, or [[OnDomEvent]] sender\n     * the events originated from when `listener` is omitted.\n     */\n    (\n        this: void,\n        listener?: DomEventListener<E>,\n        opts?: AddEventListenerOptions | boolean,\n    ): EventSupply | OnDomEvent<E>;\n\n  }\n\n}\n\n/**\n * Converts a plain DOM event listener registration function to [[OnDomEvent]] sender.\n *\n * @category DOM\n * @typeparam E  Supported DOM event type.\n * @param register  A generic DOM event listener registration function.\n *\n * @returns An [[OnDomEvent]] sender registering event listeners with the given `register` function.\n */\nexport function onDomEventBy<E extends Event>(\n    register: (\n        this: void,\n        listener: EventReceiver.Generic<[E]>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => void,\n): OnDomEvent<E> {\n  return new OnDomEvent(register);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/fun-events/dom\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { EventReceiver, eventSupply, EventSupply, EventSupply__symbol, eventSupplyOf, EventSupplyPeer } from '../base';\nimport { OnDomEvent, onDomEventBy } from './on-dom-event';\n\nconst domEventContext: EventReceiver.Context<any> = {\n  onRecurrent: noop,\n};\n\n/**\n * DOM event dispatcher can be used to register event listeners of particular event types and dispatch events.\n *\n * @category DOM\n */\nexport class DomEventDispatcher implements EventSupplyPeer {\n\n  readonly [EventSupply__symbol]: EventSupply = eventSupply();\n\n  /**\n   * @internal\n   */\n  private readonly _target: EventTarget;\n\n  /**\n   * Constructs DOM event dispatcher for the given event target.\n   *\n   * @param target  Event target to construct event dispatcher for.\n   */\n  constructor(target: EventTarget) {\n    this._target = target;\n  }\n\n  /**\n   * Returns a sender of DOM events of the given `type`.\n   *\n   * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n   * But, in contrast, it allows to register the same listener many times.\n   *\n   * The {@link EventSupply event supply} returned upon event listener registration unregisters it with\n   * `EventTarget.removeEventListener()` once {@link EventSupply.off cut off}.\n   *\n   * @typeparam E  Supported DOM event type.\n   * @param type  DOM event type name.\n   *\n   * @returns [[OnDomEvent]] sender of DOM events of the given `type`.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return onDomEventBy<E>((listener, opts) => {\n\n      const { supply } = listener;\n\n      supply.needs(eventSupplyOf(this));\n\n      if (!supply.isOff) {\n\n        // Create unique DOM listener instance\n        const domListener: EventListener = event => listener.receive(domEventContext, event as E);\n\n        this._target.addEventListener(type, domListener, opts);\n        listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n      }\n    });\n  }\n\n  /**\n   * Dispatches the given DOM event to event target.\n   *\n   * Calls `EventTarget.dispatchEvent()` method.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise. Also returns `false` after [[done]] method called.\n   */\n  dispatch(event: Event): boolean {\n    return !eventSupplyOf(this).isOff && this._target.dispatchEvent(event);\n  }\n\n  /**\n   * Removes all registered event listeners and rejects new listeners registration and event dispatching.\n   *\n   * @param reason  A reason to unregister event listeners.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    eventSupplyOf(this).off(reason);\n    return this;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\n/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason  Context destruction reason.\n */\nexport function contextDestroyed(reason?: any): () => never {\n  return () => {\n    throw reason ?? new TypeError('Context destroyed');\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { EventSupply, EventSupply__symbol, EventSupplyPeer } from '@proc7ts/fun-events';\nimport { ContextValueOpts } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { ContextValues } from '../context-values';\nimport { SimpleContextKey } from '../simple-context-key';\n\n/**\n * Context values supply.\n *\n * When available as context value, it is used to indicate the context is no longer used (e.g. destroyed).\n *\n * A context value provider can destroy the value it provides when this supply is cut off.\n */\nexport type ContextSupply = EventSupply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): ContextSupply | null | undefined {\n    return opts.seed()\n        || opts.or\n        || (opts.context as Partial<EventSupplyPeer>)[EventSupply__symbol]\n        || opts.byDefault(noop);\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is not guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `EventSupplyPeer` interface.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { flatMapIt, mapIt, overArray } from '@proc7ts/a-iterable';\nimport { CallChain, nextArgs, NextCall } from '@proc7ts/call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey, ContextValueOpts } from '../context-key';\nimport { ContextRef } from '../context-ref';\nimport { ContextSeeder } from '../context-seeder';\nimport { ContextValueProvider } from '../context-value-spec';\nimport { ContextValues } from '../context-values';\nimport { ContextSupply } from './context-supply';\n\n/**\n * @internal\n */\nclass ContextUpSeeder<Ctx extends ContextValues, Src>\n    implements ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  private readonly _providers: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]> = trackValue([]);\n\n  provide(provider: ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>): () => void {\n    this._providers.it = [...this._providers.it, provider];\n    return () => {\n\n      const providers = this._providers.it;\n      const found = providers.indexOf(provider);\n\n      if (found >= 0) {\n        this._providers.it = providers.slice(0, found).concat(providers.slice(found + 1));\n      }\n    };\n  }\n\n  seed(context: Ctx, initial: AfterEvent<Src[]> = afterThe<Src[]>()): AfterEvent<Src[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<Src[]>, second: AfterEvent<Src[]>): AfterEvent<Src[]> {\n    return afterEach(\n        first,\n        second,\n    ).keepThru(\n        flatUpSources,\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<Ctx extends ContextValues, Src>(\n    context: Ctx,\n    providersTracker: ValueTracker<ContextValueProvider<Ctx, Src | EventKeeper<Src[]>>[]>,\n): AfterEvent<Src[]> {\n  return providersTracker.read().keepThru(\n      providers => !providers.length\n          ? nextArgs()\n          : nextAfterEvent(\n              afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overArray(providers),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n          ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<Src>(src: null | undefined | Src | EventKeeper<Src[]>): AfterEvent<Src[]> {\n  return src == null ? afterThe() : isUpSrcKeeper(src) ? afterSupplied(src) : afterThe(src);\n}\n\n/**\n * @internal\n */\nfunction isUpSrcKeeper<Src>(src: Src | EventKeeper<Src[]>): src is EventKeeper<Src[]> {\n  return (typeof src === 'object' || typeof src === 'function') && isEventKeeper(src as (object | Function));\n}\n\n/**\n * @internal\n */\nfunction flatUpSources<Src>(...sources: Src[][]): NextCall<CallChain, Src[]> {\n  return nextArgs<Src[]>(...flatMapIt<Src>(sources));\n}\n\n/**\n * @internal\n */\nclass ContextSeedUpKey<Src>\n    extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpKey.SeedKey<Src> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<Ctx extends ContextValues>(): ContextSeeder<Ctx, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport interface ContextUpRef<Value, Src> extends ContextRef<Value, Src | EventKeeper<Src[]>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<Value, Src>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKeyUpKey<Value, Src>\n    extends ContextKey<ContextUpKey.Up<Value>, Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n  readonly grow: <Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n  ) => ContextUpKey.Up<Value>;\n\n  get seedKey(): ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n    return this._key.seedKey;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<Value, Src>,\n      grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ) {\n    super(_key.name + ':up');\n    this.grow = opts => {\n\n      const value = grow(opts);\n      const supply = opts.context.get(ContextSupply, { or: null });\n\n      return supply ? value.tillOff(supply) as ContextUpKey.Up<Value> : value;\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts single value sources and `EventKeeper`s of value source arrays.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeparam Value  Context value type.\n * @typeparam Src  Source value type.\n */\nexport abstract class ContextUpKey<Value, Src>\n    extends ContextKey<Value, Src | EventKeeper<Src[]>, AfterEvent<Src[]>>\n    implements ContextUpRef<Value, Src> {\n\n  readonly seedKey: ContextUpKey.SeedKey<Src>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by [[grow]] function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<Value, Src>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(name: string, seedKey?: ContextUpKey.SeedKey<Src>) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeedUpKey<Src>(this);\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of the value of this key.\n   *\n   * @param grow  A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey(\n      grow: <Ctx extends ContextValues>(\n          opts: ContextValueOpts<Ctx, ContextUpKey.Up<Value>, EventKeeper<Src[]> | Src, AfterEvent<Src[]>>,\n      ) => ContextUpKey.Up<Value>,\n  ): ContextUpKey.UpKey<Value, Src> {\n    return new ContextUpKeyUpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A type of updates keeper of context value.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeparam Value  Original context value type.\n   */\n  export type Up<Value> = Value extends AfterEvent<any>\n      ? Value\n      : (Value extends EventKeeper<infer E>\n          ? AfterEvent<E>\n          : AfterEvent<[Value]>);\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * @typeparam Value  Context value type.\n   * @typeparam Src  Source value type.\n   */\n  export type UpKey<Value, Src> = ContextKey<ContextUpKey.Up<Value>, Src>;\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeparam Src  Source value type.\n   */\n  export interface SeedKey<Src> extends ContextSeedKey<Src | EventKeeper<Src[]>, AfterEvent<Src[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { ContextKeyDefault, ContextValueOpts } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport type FnContextRef<Args extends any[], Ret = void> =\n    ContextUpRef<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an [[ContextKeyError]].\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Args  Function arguments tuple type.\n * @typeparam Ret  Function return value type.\n */\nexport class FnContextKey<Args extends any[], Ret = void>\n    extends ContextUpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>\n    implements FnContextRef<Args, Ret> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<Args, Ret>) =>\n      (this: void, ...args: Args) => Ret;\n\n  readonly upKey: ContextUpKey.UpKey<(this: void, ...args: Args) => Ret, (this: void, ...args: Args) => Ret>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: Args) => Ret)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: Args) => Ret, FnContextKey<Args, Ret>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key) || (() => { throw new ContextKeyError(this); });\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru(\n            (...fns) => {\n              if (fns.length) {\n                return fns[fns.length - 1];\n              }\n\n              const defaultProvider = (): AfterEvent<[(this: void, ...args: Args) => Ret]> => afterThe(this.byDefault(\n                  opts.context,\n                  this,\n              ));\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          (this: void, ...args: Args) => Ret,\n          EventKeeper<((this: void, ...args: Args) => Ret)[]> | ((this: void, ...args: Args) => Ret),\n          AfterEvent<((this: void, ...args: Args) => Ret)[]>>,\n  ): (this: void, ...args: Args) => Ret {\n\n    let delegated: (this: void, ...args: Args) => Ret;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    return (...args) => delegated(...args);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/context-values/updatable\n */\nimport { nextArg, noop } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { ContextKeyDefault, ContextValueOpts } from '../context-key';\nimport { ContextKeyError } from '../context-key-error';\nimport { ContextValues } from '../context-values';\nimport { ContextSupply } from './context-supply';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * Single updatable context value reference.\n *\n * @typeparam Value  Context value type.\n */\nexport type SingleContextUpRef<Value> = ContextUpRef<AfterEvent<[Value]>, Value>;\n\n/**\n * Single updatable context value key.\n *\n * The associated value is an `AfterEvent` keeper of the last source value. It is always present,\n * but signals an [[ContextKeyError]] error on attempt to receive an absent value.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeparam Value  Context value type.\n */\nexport class SingleContextUpKey<Value>\n    extends ContextUpKey<AfterEvent<[Value]>, Value>\n    implements SingleContextUpRef<Value> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n\n  get upKey(): this {\n    return this;\n  }\n\n  /**\n   * Constructs single updatable context value key.\n   *\n   * @param name  Human-readable key name.\n   * @param seedKey  Value seed key. A new one will be constructed when omitted.\n   * @param byDefault  Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<Value>;\n        byDefault?: ContextKeyDefault<Value, ContextUpKey<AfterEvent<[Value]>, Value>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, AfterEvent<[Value]>, EventKeeper<Value[]> | Value, AfterEvent<Value[]>>,\n  ): AfterEvent<[Value]> {\n\n    const value = opts.seed.keepThru((...sources: Value[]) => {\n      if (sources.length) {\n        // Sources present. Take the last one.\n        return nextArg(sources[sources.length - 1]);\n      }\n\n      // Sources absent. Attempt to detect the backup value.\n      const backup = opts.byDefault(() => {\n\n        const defaultValue = this.byDefault(opts.context, this);\n\n        return defaultValue && afterThe(defaultValue);\n      });\n\n      if (backup != null) {\n        return nextAfterEvent(backup); // Backup value found.\n      }\n\n      // Backup value is absent. Construct an error response.\n      return nextAfterEvent(afterEventBy<[Value]>(() => {\n        throw new ContextKeyError(this);\n      }));\n    });\n\n    const supply = opts.context.get(ContextSupply, { or: null });\n\n    return supply ? value.tillOff(supply) : value;\n  }\n\n}\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { RenderShot } from './render-shot';\n\n/**\n * Render schedule signature.\n *\n * This function accepts a {@link RenderShot render shot} to schedule. All scheduled render shots are meant to update\n * the same rendering target. If multiple render shots scheduled before execution starts, only the last one will be\n * executed to limit rendering rate.\n *\n * The render shot execution may fail. This should not prevent other scheduled or postponed render shots from being\n * executed. The render shot execution failure reason is expected to be reported with [[RenderScheduleConfig.error]]\n * method.\n *\n * Render schedules are constructed by {@link RenderScheduler render schedulers}, or by [[newRenderSchedule]] function\n * that uses the {@link setRenderScheduler default scheduler} for that.\n */\nexport type RenderSchedule =\n/**\n * @param shot  A render shot to schedule.\n */\n    (this: void, shot: RenderShot) => void;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link RenderScheduler render scheduler} when constructing new {@link RenderSchedule schedule}.\n *\n * A {@link RenderScheduleConfig render configuration} can be constructed based on the options with\n * [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleOptions {\n\n  /**\n   * A window for constructed schedule.\n   *\n   * Detected by [[nodeWindow]] by default, if [[node]] is specified. Falls back to current `window`.\n   *\n   * The schedulers that don't need a window never access this option value.\n   */\n  window?: Window;\n\n  /**\n   * A DOM node for constructed schedule.\n   *\n   * Used to detect missing [[window]] option.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * Reports errors with `console.error()` by default.\n   *\n   * @param messages  Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * Render schedule configuration.\n *\n * This is based on {@link RenderScheduleOptions render options}, but has all properties present.\n *\n * The configuration ought to be constructed out of render options by [[RenderScheduleConfig.by]] function.\n */\nexport interface RenderScheduleConfig {\n\n  /**\n   * A window the schedule is constructed for.\n   *\n   * The schedulers that don't need a window should never access this option value.\n   */\n  window: Window;\n\n  /**\n   * A DOM node the schedule is constructed for.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * @param messages  Error messages to report.\n   */\n  error(...messages: any[]): void;\n\n}\n\nexport const RenderScheduleConfig = {\n\n  /**\n   * Constructs a configuration of render scheduler by its options.\n   *\n   * @param options  Render scheduler options the configuration should be base on.\n   */\n  by(this: void, options: RenderScheduleOptions = {}): RenderScheduleConfig {\n\n    let win: Window | undefined;\n\n    return {\n      get node() {\n        return options.node;\n      },\n      get window() {\n        return win || (win = options.window || (options.node && nodeWindow(options.node)) || window);\n      },\n      error(...messages) {\n        if (options && options.error) {\n          options.error(...messages);\n        } else {\n          console.error(...messages);\n        }\n      },\n    };\n  },\n\n};\n\n/**\n * Detects a window the given DOM node is attached to.\n *\n * @param node  Target DOM node.\n *\n * @returns A window of the owner document, or `null` if absent.\n */\nexport function nodeWindow(node: Node): Window | null {\n\n  const document = node.ownerDocument || node as Document;\n\n  return document.defaultView;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { RenderQueue } from './render-queue';\nimport { RenderScheduleConfig } from './render-schedule';\nimport { RenderScheduler } from './render-scheduler';\nimport { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Custom render scheduler options.\n *\n * This is passed to [[customRenderScheduler]] function to construct new custom scheduler.\n */\nexport interface CustomRenderSchedulerOptions {\n\n  /**\n   * Obtains a queue for render schedule.\n   *\n   * This is called once per render schedule.\n   *\n   * Render schedules may share the queue.\n   *\n   * @param config  Render schedule configuration.\n   *\n   * @returns  A queue of scheduled render shots.\n   */\n  newQueue(config: RenderScheduleConfig): RenderQueue;\n\n}\n\n/**\n * @internal\n */\nconst RenderQ__symbol = Symbol('render-q');\n\n/**\n * @internal\n */\nclass RenderQ {\n\n  readonly ref: [RenderQ, RenderQ];\n  schedule: (this: RenderQ, config: RenderScheduleConfig) => void;\n  private scheduled?: RenderScheduleConfig;\n\n  static by(queue: RenderQueue, ref?: [RenderQ, RenderQ]): RenderQ {\n    return (queue as any)[RenderQ__symbol]\n        || ((queue as any)[RenderQ__symbol] = new RenderQ(queue, ref));\n  }\n\n  private constructor(private readonly q: RenderQueue, ref?: [RenderQ, RenderQ]) {\n    this.schedule = this.doSchedule;\n    this.ref = ref || [this, this];\n  }\n\n  add(shot: RenderShot): void {\n    this.q.add(shot);\n  }\n\n  private doSchedule(config: RenderScheduleConfig): void {\n    this.schedule = () => {/* do not schedule */};\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.unshift(shot);\n      },\n    };\n\n    this.q.schedule(() => {\n\n      const next = this.reset();\n\n      next.suspend();\n      this.exec(execution);\n      // Activate next queue\n      this.ref[1] = this.ref[0];\n      // Schedule postponed shots (in reverse order)\n      postponed.forEach(shot => this.q.add(shot));\n      // Recurrently postponed shots are executed immediately after their initiators\n      execution.postpone = shot => this.q.post(shot);\n      this.exec(execution);\n      next.resume();\n    });\n  }\n\n  private exec(execution: RenderExecution): void {\n    for (; ;) {\n\n      const shot = this.q.pull();\n\n      if (!shot) {\n        break;\n      }\n      shot(execution);\n    }\n  }\n\n  private reset(): RenderQ {\n    // Update next queue. Current queue remains active\n    return this.ref[0] = RenderQ.by(this.q.reset(), this.ref);\n  }\n\n  private suspend(): void {\n    this.schedule = config => {\n      this.scheduled = config;\n      this.schedule = () => {/* do not schedule */};\n    };\n  }\n\n  private resume(): void {\n    if (this.scheduled) {\n      this.doSchedule(this.scheduled);\n    } else {\n      this.schedule = this.doSchedule;\n    }\n  }\n\n}\n\n/**\n * Builds custom render scheduler.\n *\n * @param options  Render scheduler options.\n *\n * @returns New render scheduler.\n */\nexport function customRenderScheduler(\n    options: CustomRenderSchedulerOptions,\n): RenderScheduler {\n  return scheduleOptions => {\n\n    const config = RenderScheduleConfig.by(scheduleOptions);\n    const queueRef: readonly [RenderQ, RenderQ] = RenderQ.by(options.newQueue(config)).ref;\n    let enqueued: [RenderQ, RenderShot, true?] | [] = [];\n\n    return shot => {\n\n      const [lastQueue,, executed] = enqueued;\n      const [nextQueue, activeQueue] = queueRef;\n      let queue = lastQueue || activeQueue;\n\n      if (lastQueue === activeQueue && !executed || lastQueue === nextQueue) {\n        enqueued[1] = shot;\n      } else {\n\n        // Add to active queue initially, unless a shot executed in it already.\n        // Add to the next queue otherwise.\n        const nextEnqueued: [RenderQ, RenderShot, true?] = enqueued = [\n          queue = executed ? nextQueue : activeQueue,\n          shot,\n        ];\n\n        queue.add((execution: RenderExecution) => {\n          nextEnqueued[2] = true; // Switch to next queue\n          try {\n            nextEnqueued[1]({\n              get config() {\n                return config;\n              },\n              postpone(postponed) {\n                execution.postpone(postponed);\n              },\n            });\n          } catch (e) {\n            config.error(e);\n          }\n        });\n      }\n\n      queue.schedule(config);\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { RenderShot } from './render-shot';\n\n/**\n * A queue of scheduled render shots.\n *\n * Utilized by render scheduler in order to collect render shots and schedule their execution.\n *\n * The default implementation may be constructed using [[RenderQueue.by]] function.\n */\nexport interface RenderQueue {\n\n  /**\n   * Adds a render shot to this queue.\n   *\n   * @param shot  Scheduled render shot to add.\n   */\n  add(shot: RenderShot): void;\n\n  /**\n   * Adds a render shot to the head of this queue.\n   *\n   * @param shot  Scheduled render shot to add.\n   */\n  post(shot: RenderShot): void;\n\n  /**\n   * Retrieves the first added render shot and removes it from the queue.\n   *\n   * @returns  Either pulled out render shot, or `undefined` when there is no more render shots.\n   */\n  pull(): RenderShot | undefined;\n\n  /**\n   * Schedules queued render shots execution.\n   *\n   * @param task  A function that performs render shots execution task.\n   */\n  schedule(task: (this: void) => void): void;\n\n  /**\n   * Resets the queue for the next execution.\n   *\n   * @returns  Another (empty) queue that will collect scheduled render shots from now on.\n   */\n  reset(): RenderQueue;\n\n}\n\nexport const RenderQueue = {\n\n  /**\n   * Builds the default implementation of render queue.\n   *\n   * @param schedule  Schedules queued render shots execution. This is an implementation of [[RenderQueue.schedule]]\n   * method.\n   * @param replace  Called right after [[RenderQueue.reset]] method in order to inform on the queue that will collect\n   * scheduled render shots from now.\n   *\n   * @returns New render queue.\n   */\n  by(\n      this: void,\n      {\n        schedule,\n        replace = () => {/* do not replace */},\n      }: {\n        schedule(this: RenderQueue, task: (this: void) => void): void;\n        replace?(this: void, replacement: RenderQueue): void;\n      },\n  ): RenderQueue {\n\n    const shots: RenderShot[] = [];\n\n    return {\n      schedule,\n      add(shot) {\n        shots.push(shot);\n      },\n      post(shot) {\n        shots.unshift(shot);\n      },\n      pull() {\n        return shots.shift();\n      },\n      reset() {\n\n        const next = RenderQueue.by({ schedule, replace });\n\n        replace(next);\n\n        return next;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { customRenderScheduler } from './custom-render-scheduler';\nimport { RenderQueue } from './render-queue';\nimport { RenderScheduler } from './render-scheduler';\n\n/**\n * @internal\n */\nconst animationRenderQueues = (/*#__PURE__*/ new WeakMap<Window, RenderQueue>());\n\n/**\n * A render scheduler that executes scheduled render shots within animation frame.\n *\n * Utilizes [requestAnimationFrame()] function for that.\n *\n * The render shots scheduled by different schedules created for the same window are all executed in the same animation\n * frame. The {@link RenderExecution.postpone postponed} render shots are executed only after all scheduled ones\n * complete.\n *\n * [requestAnimationFrame()]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n */\nexport const animationRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue({ window }) {\n\n    const existing = animationRenderQueues.get(window);\n\n    if (existing) {\n      return existing;\n    }\n\n    const newQueue = RenderQueue.by({\n      schedule: task => window.requestAnimationFrame(task),\n      replace: replacement => animationRenderQueues.set(window, replacement),\n    });\n\n    animationRenderQueues.set(window, newQueue);\n\n    return newQueue;\n  },\n}));\n","import { RenderSchedule, RenderScheduleConfig, RenderScheduleOptions } from './render-schedule';\nimport { RenderScheduler } from './render-scheduler';\nimport { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Render scheduler that executes render shots immediately.\n *\n * @param options\n */\nexport const immediateRenderScheduler: RenderScheduler = (options?: RenderScheduleOptions): RenderSchedule => {\n\n  const config = RenderScheduleConfig.by(options);\n\n  return (shot: RenderShot) => {\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.push(shot);\n      },\n    };\n\n    execute(shot);\n    for (; ;) {\n\n      const last = postponed.pop();\n\n      if (!last) {\n        break;\n      }\n\n      execute(last);\n    }\n\n    function execute(shot: RenderShot): void {\n      try {\n        shot(execution);\n      } catch (e) {\n        config.error(e);\n      }\n    }\n  };\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/render-scheduler\n */\nimport { animationRenderScheduler } from './animation-render-scheduler';\nimport { RenderSchedule, RenderScheduleOptions } from './render-schedule';\n\n/**\n * Render scheduler signature.\n *\n * This function constructs a {@link RenderSchedule render schedule} according to the given options.\n *\n * The default render scheduler is always available as [[newRenderSchedule]] function.\n *\n * There are several scheduler implementations exist:\n * - [[animationRenderScheduler]] (used by default),\n * - [[asyncRenderScheduler]],\n * - [[immediateRenderScheduler]],\n * - [[ManualRenderScheduler]],\n * - [[noopRenderScheduler]].\n *\n * Custom scheduler implementations could be created using [[customRenderScheduler]] function.\n */\nexport type RenderScheduler =\n/**\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: RenderScheduleOptions) => RenderSchedule;\n\n/**\n * @internal\n */\nlet defaultRenderScheduler = animationRenderScheduler;\n\n/**\n * Assigns or resets the default render scheduler.\n *\n * An {@link animationRenderScheduler animation frame render scheduler} is used bu default.\n *\n * @param scheduler  New default render scheduler. {@link animationRenderScheduler animation frame render scheduler}\n * will be used if `null`, `undefined`, or omitted.\n *\n * @returns New default render scheduler.\n */\nexport function setRenderScheduler(\n    scheduler?: RenderScheduler | null,\n): RenderScheduler {\n  return defaultRenderScheduler = scheduler || animationRenderScheduler;\n}\n\n/**\n * Constructs {@link RenderSchedule render schedule} using {@link setRenderScheduler default render scheduler}.\n *\n * @param options  Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\nexport function newRenderSchedule(options?: RenderScheduleOptions): RenderSchedule {\n  return defaultRenderScheduler(options);\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = (/*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport { EventReceiver, EventSupply, OnEvent } from '@proc7ts/fun-events';\nimport { Class } from '../common';\nimport { ComponentClass, DefinitionContext } from '../component/definition';\nimport { FeatureRef } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to [[FeatureDef.Options.init]] method so that the feature can configure itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of ready bootstrap context.\n   */\n  abstract whenReady(): OnEvent<[BootstrapContext]>;\n\n  /**\n   * Registers a `receiver` of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of reay bootstrap context.\n   *\n   * @returns Bootstrap readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[BootstrapContext]>): EventSupply;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentType  Component class constructor.\n   *\n   * @return An `OnEvent` sender of definition context sent when the given `componentType` is registered.\n   */\n  abstract whenDefined<C extends object>(componentType: ComponentClass<C>): OnEvent<[DefinitionContext<C>]>;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * @param feature  The feature to load.\n   *\n   * @returns  Loaded feature reference.\n   */\n  abstract load(feature: Class): FeatureRef;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKeyDefault } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @param provide  A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<Value, Key extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: Key) => Value | null | undefined,\n): ContextKeyDefault<Value, Key> {\n  return (context, key) => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext ? provide(bootstrapContext, key) : bootstrapContext.get(key);\n  };\n}\n","/**\n * @internal\n */\nexport function isArray<T>(value: T | T[] | null | undefined): value is T[];\n\n/**\n * @internal\n */\nexport function isArray<T>(value: T | readonly T[] | null | undefined): value is readonly T[];\n\nexport function isArray<T>(value: T | readonly T[]): value is T[] {\n  return Array.isArray(value);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsEach, itsFirst } from '@proc7ts/a-iterable';\nimport { isArray } from './types.impl';\n\n/**\n * @category Utility\n */\nexport class ArraySet<T> implements Iterable<T> {\n\n  readonly items: Set<T>;\n\n  constructor(value?: T | readonly T[]) {\n    this.items = value == null ? new Set() : isArray(value) ? new Set(value) : new Set([value]);\n  }\n\n  get value(): T | T[] | undefined {\n    return this.items.size < 2 ? itsFirst(this.items) : Array.from(this.items);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.items[Symbol.iterator]();\n  }\n\n  add(...items: readonly T[]): this {\n    return this.addAll(items);\n  }\n\n  addAll(items: Iterable<T>): this {\n    itsEach(items, item => this.items.add(item));\n    return this;\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  merge(items: readonly T[] | T | undefined): this {\n    if (isArray(items)) {\n      this.addAll(items);\n    } else if (items != null) {\n      this.items.add(items);\n    }\n    return this;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Arbitrary class constructor.\n *\n * @category Utility\n * @typeparam T  A type of object.\n */\nexport interface Class<T extends object = any> extends Function {\n  new(...args: any[]): T;\n  prototype: T;\n}\n\n/**\n * Detects super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @category Utility\n * @param type  The class constructor to find super class of.\n * @param satisfying  The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(type: Class, satisfying: (type: Class) => boolean = () => true): Class | undefined {\n\n  const prototype = Object.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as Class;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from './classes';\nimport { fieldAccessorDescriptor, PropertyAccessorDescriptor, toPropertyAccessorDescriptor } from './reflect';\n\n/**\n * Typed class decorator.\n *\n * @category Utility\n * @typeparam T  A type of class to decorate.\n */\nexport type TypedClassDecorator<T extends Class> = (type: T) => T | void;\n\n/**\n * Typed property decorator.\n *\n * @category Utility\n * @typeparam T  A type of class the decorated property belongs to.\n */\nexport type TypedPropertyDecorator<T extends Class> =\n    <V>(target: InstanceType<T>, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<V>) => any | void;\n\n/**\n * Property decorator helper converting a field or property to the one with accessor (`get` and optionally `set`).\n *\n * @category Utility\n * @typeparam T  A type of target object.\n * @typeparam V  A property value type.\n * @param target  Target object containing the property.\n * @param propertyKey  Target property key.\n * @param desc  Target property descriptor, or `undefined` for object fields.\n * @param updateDescriptor  Descriptor updater. Accepts the accessor descriptor as the only argument. If returns\n * a descriptor, then it is applied to the property. Otherwise the target property descriptor is never updated.\n *\n * @returns Updated property descriptor to return from decorator to apply to the property, or `undefined` if there is\n * nothing to update.\n */\nexport function decoratePropertyAccessor<T, V>(\n    target: T,\n    propertyKey: string | symbol,\n    desc: TypedPropertyDescriptor<V> | undefined,\n    updateDescriptor: (desc: PropertyAccessorDescriptor<V>) => PropertyAccessorDescriptor<V>,\n): PropertyAccessorDescriptor<V> | undefined {\n\n  const isField = !desc;\n  const accessorDesc: PropertyAccessorDescriptor<V> = desc\n      ? toPropertyAccessorDescriptor(desc)\n      : fieldAccessorDescriptor(target, propertyKey as keyof T) as any;\n  const updatedDesc = updateDescriptor(accessorDesc);\n\n  if (isField && updatedDesc) {\n    Object.defineProperty(target, propertyKey, updatedDesc);\n    return;\n  }\n\n  return updatedDesc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Converts an object field to property accessor.\n *\n * Defines a new property with the given name in the target object and returns its descriptor.\n *\n * The converted descriptor is always configurable, enumerable, and writable.\n *\n * @category Utility\n * @typeparam T  The type of target object.\n * @typeparam K  Target object property keys type.\n * @param target  The object containing target field.\n * @param fieldKey  Target field key.\n *\n * @return New property accessor descriptor.\n */\nexport function field2accessor<T, K extends keyof T>(\n    target: T,\n    fieldKey: K,\n): PropertyAccessorDescriptor<T[K]> {\n\n  const desc = fieldAccessorDescriptor(target, fieldKey);\n\n  Object.defineProperty(target, fieldKey, desc);\n\n  return desc;\n}\n\n/**\n * Creates an property accessor descriptor for the given field.\n *\n * @category Utility\n * @typeparam T  The type of target object.\n * @typeparam K  Target object property keys type.\n * @param target  The object containing target field.\n * @param fieldKey  Target field key.\n */\nexport function fieldAccessorDescriptor<T, K extends keyof T>(\n    target: T,\n    fieldKey: K,\n): PropertyAccessorDescriptor<T[K]> {\n\n  const value__symbol = Symbol(`${String(fieldKey)}:value`);\n  const initial: T[K] = target[fieldKey];\n\n  return {\n    configurable: true,\n    enumerable: true,\n    get(this: any) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n    set(this: any, newValue) {\n      this[value__symbol] = newValue;\n    },\n  };\n}\n\n/**\n * Property accessor descriptor. I.e. the one with `get` and `set` functions.\n *\n * @category Utility\n * @typeparam V  Property value type.\n */\nexport interface PropertyAccessorDescriptor<V> extends TypedPropertyDescriptor<V> {\n  enumerable?: boolean;\n  configurable?: boolean;\n  writable?: undefined;\n  value?: undefined;\n  get?: () => V;\n  set?: (value: V) => void;\n}\n\n/**\n * Detects whether the given property descriptor is the one of property accessor.\n *\n * @category Utility\n * @typeparam V  Property value type.\n * @param desc  Target property descriptor.\n *\n * @return `true` if the descriptor has no `value` or `writable` attributes set.\n */\nexport function isPropertyAccessorDescriptor<V>(\n    desc: TypedPropertyDescriptor<V>,\n): desc is PropertyAccessorDescriptor<V> {\n  return desc.value === undefined && desc.writable === undefined;\n}\n\n/**\n * Converts a property descriptor to property accessor descriptor.\n *\n * @category Utility\n * @typeparam V  Property value type.\n * @param desc  Target property descriptor.\n *\n * @return Either an accessor descriptor constructed from data descriptor, or `desc` if it is an accessor descriptor\n * already.\n */\nexport function toPropertyAccessorDescriptor<V>(\n    desc: TypedPropertyDescriptor<V>,\n): PropertyAccessorDescriptor<V> {\n  if (isPropertyAccessorDescriptor(desc)) {\n    return desc;\n  }\n\n  const value__symbol = Symbol('value');\n  const initial = desc.value as V;\n\n  const accessorDesc: PropertyAccessorDescriptor<V> = {\n    ...desc,\n    writable: undefined,\n    value: undefined,\n    get(this: any) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n  };\n\n  if (desc.writable) {\n    accessorDesc.set = function (this: any, newValue: V) {\n      this[value__symbol] = newValue;\n    };\n  }\n\n  delete accessorDesc.writable;\n  delete accessorDesc.value;\n\n  return accessorDesc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @category Utility\n * @typeparam P  Function parameter types as tuple.\n * @typeparam R  A type of function result.\n * @typeparam T  A type if `this` object expected by function.\n * @param first  The first function to call.\n * @param second  The second function to call.\n * @param merge  Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<P extends any[], R, T>(\n    first: (this: T, ...args: P) => R,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: (this: T, ...args: P) => R,\n    merge?: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge?: (first: R, second: R) => R,\n): ((this: T, ...args: P) => R) | undefined;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R = (_f, s) => s,\n): ((this: T, ...args: P) => R) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function (this: T, ...args: P): R {\n    return merge(\n        first.apply(this, args),\n        second.apply(this, args),\n    );\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Checks whether the given DOM node is element.\n *\n * @category Utility\n * @param node  A DOM node to check.\n *\n * @returns `true` is `node` is element, or `false` otherwise.\n */\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { flatMapIt, mapIt } from '@proc7ts/a-iterable';\nimport { Class, superClassOf } from './classes';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<M, S = M> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  own(type: Class): M | undefined {\n    // eslint-disable-next-line no-prototype-builtins\n    return type.hasOwnProperty(this.symbol) ? (type as any)[this.symbol] : undefined;\n  }\n\n  of(type: Class): M | undefined {\n\n    const ownDef: M | undefined = this.own(type);\n    const superType = superClassOf(type);\n    const superDef = superType && this.of(superType);\n\n    return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n  }\n\n  define<C extends Class>(type: C, sources: Iterable<S>): C {\n\n    const prevMeta = this.own(type);\n    const updates = mapIt(sources, source => this.meta(source, type));\n    const newMeta: M = this.merge(prevMeta ? flatMapIt([[prevMeta], updates]) : updates);\n\n    Object.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: newMeta,\n        },\n    );\n\n    return type;\n  }\n\n  abstract merge(metas: Iterable<M>): M;\n\n  protected abstract meta(source: S, type: Class): M;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * @category Utility\n */\nexport class PromiseResolver<T = void> {\n\n  readonly promise: Promise<T>;\n  private _resolve!: (value: T) => void;\n  private _reject!: (error: any) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  resolve(value: T): void {\n    this._resolve(value);\n  }\n\n  reject(error: any): void {\n    this._reject(error);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from '@proc7ts/a-iterable';\nimport { BootstrapSetup } from '../boot';\nimport { ArraySet, Class, mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureContext } from './feature-context';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = (/*#__PURE__*/ Symbol('feature-def'));\n\n/**\n * Feature definition.\n *\n * This can be one of:\n * - feature definition options object,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n */\nexport type FeatureDef =\n    | FeatureDef.Options\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace FeatureDef {\n\n  /**\n   * Feature definition options.\n   */\n  export interface Options {\n\n    readonly [FeatureDef__symbol]?: undefined;\n\n    /**\n     * Features this one requires.\n     */\n    readonly needs?: Class | readonly Class[];\n\n    /**\n     * Features this one provides.\n     *\n     * The feature always provides itself.\n     */\n    readonly has?: Class | readonly Class[];\n\n    /**\n     * Sets up bootstrap.\n     *\n     * This method is called before bootstrap context created.\n     *\n     * @param setup  Bootstrap setup.\n     */\n    setup?(setup: BootstrapSetup): void;\n\n    /**\n     * Bootstraps this feature by calling the given bootstrap context constructed.\n     *\n     * @param context  Feature initialization context.\n     */\n    init?(context: FeatureContext): void;\n\n  }\n\n  /**\n   * Feature definition holder.\n   */\n  export interface Holder {\n\n    /**\n     * The feature definition this holder contains.\n     */\n    readonly [FeatureDef__symbol]: FeatureDef;\n\n  }\n\n  /**\n   * Feature definition factory.\n   */\n  export interface Factory {\n\n    /**\n     * Builds feature definition.\n     *\n     * @param featureType  A feature class constructor to build definition for.\n     *\n     * @returns Built feature definition.\n     */\n    [FeatureDef__symbol](featureType: Class): FeatureDef;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor<FeatureDef.Options, FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(defs: Iterable<FeatureDef.Options>): FeatureDef.Options {\n    return itsReduction<FeatureDef.Options, FeatureDef.Options>(\n        defs,\n        (prev, def) => ({\n          needs: new ArraySet(prev.needs).merge(def.needs).value,\n          has: new ArraySet(prev.has).merge(def.has).value,\n          setup: mergeFunctions<[BootstrapSetup], void, Class>(prev.setup, def.setup),\n          init: mergeFunctions<[FeatureContext], void, Class>(prev.init, def.init),\n        }),\n        {},\n    );\n  }\n\n  meta(source: FeatureDef, type: Class): FeatureDef.Options {\n\n    const def = source[FeatureDef__symbol];\n\n    return def == null\n        ? source as FeatureDef.Options\n        : this.meta(\n            typeof def === 'function' ? (source as FeatureDef.Factory)[FeatureDef__symbol](type) : def,\n            type,\n        );\n  }\n\n}\n\n/**\n * @internal\n */\nconst featureMeta = (/*#__PURE__*/ new FeatureMeta());\n\n/**\n * @internal\n */\nconst noFeatureDef: FeatureDef.Factory = {\n  [FeatureDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts feature definition options from its type.\n   *\n   * @param featureType  Target feature class constructor.\n   *\n   * @returns Feature definition options. May be empty when there is no feature definition found in the given\n   * `featureType`.\n   */\n  of(this: void, featureType: Class): FeatureDef.Options {\n    return featureMeta.of(featureType) || {};\n  },\n\n  /**\n   * Builds feature definition options for the given feature class.\n   *\n   * @param featureType  Target feature class constructor.\n   * @param def  A feature definition.\n   *\n   * @returns Feature definition options.\n   */\n  for(this: void, featureType: Class, def: FeatureDef): FeatureDef.Options {\n    return featureMeta.meta(def, featureType);\n  },\n\n  /**\n   * Merges multiple feature definition options.\n   *\n   * @param defs  Feature definition options to merge.\n   *\n   * @returns Merged feature definition options.\n   */\n  merge(this: void, ...defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return featureMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple feature definitions.\n   *\n   * @param defs  Feature definitions to merge.\n   *\n   * @returns Merged feature definition.\n   */\n  all(this: void, ...defs: readonly FeatureDef[]): FeatureDef {\n    return itsReduction<FeatureDef, FeatureDef.Factory>(\n        defs,\n        (prev, def) => ({\n          [FeatureDef__symbol](featureType: Class) {\n            return FeatureDef.merge(\n                FeatureDef.for(featureType, prev),\n                FeatureDef.for(featureType, def),\n            );\n          },\n        }),\n        noFeatureDef,\n    );\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeparam T  Feature type.\n   * @param featureType  Feature class constructor.\n   * @param defs  Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends Class>(this: void, featureType: T, ...defs: readonly FeatureDef[]): T {\n    return featureMeta.define(featureType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class, TypedClassDecorator } from '../common';\nimport { FeatureDef } from './feature-def';\n\n/**\n * Feature class decorator.\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to [[bootstrapComponents]] function or referenced by other features.\n *\n * This is an alternative to direct call to [[FeatureDef.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated feature class.\n * @param defs  Feature definitions.\n *\n * @returns A feature class decorator.\n */\nexport function Feature<T extends Class = any>(...defs: FeatureDef[]): TypedClassDecorator<T> {\n  return (type: T) => FeatureDef.define(type, ...defs);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from '@proc7ts/context-values';\nimport { EventReceiver, EventSupply, OnEvent } from '@proc7ts/fun-events';\nimport { BootstrapContext, BootstrapSetup } from '../boot';\nimport { Class } from '../common';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../component/definition';\nimport { FeatureRef } from './feature-ref';\n\n/**\n * @internal\n */\nconst FeatureContext__key = (/*#__PURE__*/ new SingleContextKey<FeatureContext>('feature-context'));\n\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nexport abstract class FeatureContext extends BootstrapContext implements BootstrapSetup {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext__key;\n  }\n\n  /**\n   * Feature class this context is created for.\n   */\n  abstract readonly feature: Class;\n\n  /**\n   * Builds an `OnEvent` sender of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of ready feature context.\n   */\n  abstract whenReady(): OnEvent<[FeatureContext]>;\n\n  /**\n   * Registers a receiver of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of ready feature context.\n   *\n   * @returns Feature readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[FeatureContext]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component definition events.\n   *\n   * The registered receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   *\n   * @returns `OnEvent` sender of component definition contexts.\n   */\n  abstract onDefinition(): OnEvent<[DefinitionContext]>;\n\n  /**\n   * Starts sending component definition events to the given `receiver`.\n   *\n   * The receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   *\n   * @param receiver  Target receiver of component definition contexts.\n   *\n   * @returns Component definition events supply.\n   */\n  abstract onDefinition(receiver: EventReceiver<[DefinitionContext]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component construction events.\n   *\n   * The registered receiver will be notified right before component is constructed.\n   *\n   * @returns `OnEvent` sender of constructed component contexts.\n   */\n  abstract onComponent(): OnEvent<[ComponentContext]>;\n\n  /**\n   * Starts sending component construction events to the given `receiver`.\n   *\n   * @param receiver  Target receiver of constructed component contexts.\n   *\n   * @returns Component construction events supply.\n   */\n  abstract onComponent(receiver: EventReceiver<[ComponentContext]>): EventSupply;\n\n  /**\n   * Provides bootstrap context value.\n   *\n   * Note that this happens when bootstrap context already exists. To provide a value before bootstrap context created\n   * a [[BootstrapSetup.provide]] method can be used.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perDefinition<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]>;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  whenDefined<C extends object>(componentType: ComponentClass<C>): OnEvent<[DefinitionContext<C>]> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  load(feature: Class): FeatureRef {\n    return this.get(BootstrapContext).load(feature);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\n\n/**\n * Feature need.\n *\n * Indicates why one feature needs another one. The reason can be one of:\n *\n * - `needs` when feature {@link FeatureDef.Options.needs depends} on another one, or\n * - `has` when feature {@link FeatureDef.Options.has provides} another one.\n *\n * @category Core\n */\nexport type FeatureNeed = [Class, 'needs' | 'has', Class];\n\n/**\n * An error in feature needs. I.e. circular dependency.\n *\n * @category Core\n */\nexport class FeatureNeedsError extends Error {\n\n  /**\n   * Feature needs causing this error.\n   */\n  readonly needs: readonly FeatureNeed[];\n\n  /**\n   * Constructs feature needs error.\n   *\n   * @param needs  Feature needs causing the error.\n   */\n  constructor(needs: readonly FeatureNeed[]) {\n    super(\n        'Circular feature needs: ' + needs.reduce(\n        (\n            prev,\n            [feature, reason, need],\n        ) => (prev ? prev : feature.name) + ` ${reason} ${need.name}`,\n        '',\n        ),\n    );\n    this.needs = needs;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventReceiver, EventSupply } from '@proc7ts/fun-events';\nimport { FeatureStatus } from './feature-status';\n\n/**\n * Dynamically loaded feature reference.\n *\n * It is returned from [[BootstrapContext.load]] and can be used to read feature load status and unload it.\n *\n * Implements an `EventKeeper` interface by sending a feature load status updates.\n *\n * @category Core\n */\nexport abstract class FeatureRef implements EventKeeper<[FeatureStatus]> {\n\n  /**\n   * A promise resolved when feature is unloaded.\n   *\n   * This happens after all feature references dismissed.\n   */\n  abstract readonly down: Promise<void>;\n\n  /**\n   * Builds an `AfterEvent` keeper of feature load status.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` sender of feature load status.\n   */\n  abstract read(): AfterEvent<[FeatureStatus]>;\n\n  /**\n   * Starts sending feature load status and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of feature load status.\n   *\n   * @returns Feature load status supply.\n   */\n  abstract read(receiver: EventReceiver<[FeatureStatus]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[FeatureStatus]> {\n    return this.read();\n  }\n\n  /**\n   * Dismisses feature reference.\n   *\n   * When all feature references dismissed, then unloads the feature. This removes everything set up by the\n   * feature via [[BootstrapSetup]] and [[DefinitionSetup]].\n   *\n   * @param reason  Arbitrary reason of feature reference dismiss. This will be reported by load status supplies\n   * as their cut off reason.\n   *\n   * @returns A promise resolved when feature is unloaded. This happens only after all feature references dismissed.\n   */\n  abstract dismiss(reason?: any): Promise<void>;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from '@proc7ts/a-iterable';\nimport { isQualifiedName, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureDef, FeatureDef__symbol } from '../feature';\nimport { ComponentClass, DefinitionContext, DefinitionSetup, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = (/*#__PURE__*/ Symbol('component-def'));\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * This can be one of:\n * - custom element name (possibly qualified),\n * - component definition options,\n * - component definition holder,\n * - component definition factory,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport type ComponentDef<T extends object = any> =\n    | QualifiedName\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace ComponentDef {\n\n  /**\n   * Component definition options.\n   */\n  export interface Options<T extends object = any> {\n\n    readonly [ComponentDef__symbol]?: undefined;\n\n    /**\n     * Custom element name.\n     *\n     * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n     * name/namespace tuple.\n     *\n     * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n     * still can be mounted.\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Existing element to extend by custom one.\n     */\n    readonly extend?: ElementDef.Extend;\n\n    /**\n     * Additional feature definition options.\n     */\n    readonly feature?: FeatureDef.Options;\n\n    /**\n     * Sets up component definition.\n     *\n     * This method is called before component definition context constructed.\n     *\n     * @param setup  Component definition setup.\n     */\n    setup?(setup: DefinitionSetup<T>): void;\n\n    /**\n     * Defines this component by calling the given component definition context methods.\n     *\n     * This function is called before the custom element is defined.\n     *\n     * @param context  Component definition context.\n     */\n    define?(context: DefinitionContext<T>): void;\n\n  }\n\n  /**\n   * Component definition holder.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Holder<T extends object = any> {\n\n    /**\n     * The component definition this holder contains.\n     */\n    readonly [ComponentDef__symbol]: ComponentDef<T>;\n\n  }\n\n  /**\n   * Component definition factory.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Factory<T extends object = any> {\n\n    /**\n     * Builds component definition.\n     *\n     * @param componentType  A component class constructor to build definition for.\n     *\n     * @returns Built component definition.\n     */\n    [ComponentDef__symbol](componentType: ComponentClass<T>): ComponentDef<T>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor<ComponentDef.Options, ComponentDef> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(defs: Iterable<ComponentDef.Options<T>>): ComponentDef.Options<T> {\n    return itsReduction<ComponentDef.Options<T>, ComponentDef.Options<T>>(\n        defs,\n        (prev, def) => ({\n          ...prev,\n          ...def,\n          setup: mergeFunctions(prev.setup, def.setup),\n          define: mergeFunctions(prev.define, def.define),\n          feature: prev.feature\n              ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n              : def.feature,\n        }),\n        {},\n    );\n  }\n\n  meta<T extends object>(source: ComponentDef<T>, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n\n    const def = (source as any)[ComponentDef__symbol];\n\n    if (def != null) {\n      return this.meta(\n          typeof def === 'function' ? (source as ComponentDef.Factory<T>)[ComponentDef__symbol](componentType) : def,\n          componentType,\n      );\n    }\n    if ((source as any)[FeatureDef__symbol] != null) {\n      return {\n        feature: FeatureDef.for(componentType, source as FeatureDef),\n      };\n    }\n    if (isQualifiedName(source)) {\n      return { name: source };\n    }\n\n    return source as ComponentDef.Options;\n  }\n\n}\n\n/**\n * @internal\n */\nconst componentMeta = (/*#__PURE__*/ new ComponentMeta());\n\n/**\n * @internal\n */\nconst noComponentDef: ComponentDef.Factory = {\n  [ComponentDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts component definition options from its type.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Target component class constructor.\n   *\n   * @returns Component definition options. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(this: void, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n    return componentMeta.of(componentType) as ComponentDef.Options<T> || {};\n  },\n\n  /**\n   * Builds component definition options for the given component class.\n   *\n   * @param componentType  Target component class constructor.\n   * @param source  A source of component definition.\n   *\n   * @returns Component definition.\n   */\n  for<T extends object>(\n      this: void,\n      componentType: ComponentClass<T>,\n      source: ComponentDef<T>,\n  ): ComponentDef.Options<T> {\n    return componentMeta.meta(source, componentType);\n  },\n\n  /**\n   * Merges multiple component definition options.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definition options to merge.\n   *\n   * @returns Merged component definition options.\n   */\n  merge<T extends object>(this: void, ...defs: ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return componentMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple component definitions.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definitions to merge.\n   *\n   * @returns Merged component definition.\n   */\n  all<T extends object>(this: void, ...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return itsReduction<ComponentDef<T>, ComponentDef.Factory<T>>(\n        defs,\n        (prev, def) => ({\n          [ComponentDef__symbol](componentType: ComponentClass<T>) {\n            return ComponentDef.merge(\n                ComponentDef.for(componentType, prev),\n                ComponentDef.for(componentType, def),\n            );\n          },\n        }),\n        noComponentDef,\n    );\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends existing component definition and stores it under [[ComponentDef__symbol]] key.\n   *\n   * Each component can be passed directly to [[bootstrapComponents]] function or added as a requirement\n   * of another feature.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   * @param defs  Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends ComponentClass>(\n      this: void,\n      componentType: T,\n      ...defs: ComponentDef<InstanceType<T>>[]\n  ): T {\n    return componentMeta.define(componentType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * Component decorator interface.\n *\n * In addition to being a decorator for component class, it may also serve as {@link ComponentDef component definition}.\n * Thus it can be added as parameter to {@link Component @Component} decorator, or used as class decorator by itself.\n *\n * Constructed by [[Component]] function.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n */\nexport type ComponentDecorator<T extends ComponentClass = Class> =\n    & ((this: void, type: T) => T | void)\n    & ComponentDef<InstanceType<T>>;\n\n/**\n * Decorator of component class.\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with [[FeatureContext.define]] method or used as a feature, e.g. passed to\n * [[bootstrapComponents]] function, or added to [[FeatureDef.Options.needs]] property of another feature.\n *\n * This is an alternative to direct call to [[ComponentDef.Options.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n * @param defs  Component definitions.\n *\n * @returns A component class decorator.\n */\nexport function Component<T extends ComponentClass = Class>(\n    ...defs: ComponentDef<InstanceType<T>>[]\n): ComponentDecorator<T> {\n\n  const decorator = ((type: T) => ComponentDef.define(type, ...defs)) as ComponentDecorator<T>;\n  const def = decorator as ComponentDef.Factory<InstanceType<T>>;\n\n  def[ComponentDef__symbol] = () => ComponentDef.all(...defs);\n\n  return decorator;\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = (/*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context'));\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { eventSupplyOf } from '@proc7ts/fun-events';\nimport { DomEventDispatcher, OnDomEvent } from '@proc7ts/fun-events/dom';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher } from './component-event';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = (/*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault(values) {\n\n        const context = values.get(ComponentContext__key);\n        const dispatcher = new DomEventDispatcher(context.element);\n\n        eventSupplyOf(dispatcher).needs(context);\n\n        return {\n          dispatch(event: Event): boolean {\n            return dispatcher.dispatch(event);\n          },\n          on<E extends Event>(type: string): OnDomEvent<E> {\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * @category Core\n */\nexport type ContentRoot = any;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = (/*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(ComponentContext__key).element;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop, valueProvider } from '@proc7ts/call-thru';\nimport { ContextValueOpts, ContextValues } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent, statePath, StatePath } from '@proc7ts/fun-events';\nimport { mergeFunctions } from '../common';\n\n/**\n * Component state updater signature.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeparam V  Updated value type\n * @param path  Updated state node path.\n * @param newValue  New value.\n * @param oldValue  Replaced value.\n */\n    <V>(this: void, path: StatePath, newValue: V, oldValue: V) => void;\n\nexport namespace StateUpdater {\n\n  /**\n   * Normalized component state updater signature.\n   *\n   * Accepts normalized state path.\n   */\n  export type Normalized =\n  /**\n   * @typeparam V  Updated value type\n   * @param path  Normalized path of updated state node.\n   * @param newValue  New value.\n   * @param oldValue  Replaced value.\n   */\n      <V>(this: void, path: StatePath.Normalized, newValue: V, oldValue: V) => void;\n\n}\n\n/**\n * @internal\n */\nclass StateUpdaterKey extends ContextUpKey<StateUpdater, StateUpdater.Normalized> {\n\n  readonly upKey: ContextUpKey.UpKey<StateUpdater, StateUpdater.Normalized>;\n\n  constructor() {\n    super('state-updater');\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru(\n            (...fns) => {\n              if (fns.length) {\n\n                const combined: StateUpdater.Normalized = fns.reduce(\n                    (prev, fn) => mergeFunctions(fn, prev),\n                    noop,\n                );\n\n                return (path, newValue, oldValue) => combined(statePath(path), newValue, oldValue);\n              }\n\n              const defaultProvider = valueProvider(afterThe(noop));\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          StateUpdater,\n          EventKeeper<StateUpdater.Normalized[]> | StateUpdater.Normalized,\n          AfterEvent<StateUpdater.Normalized[]>>,\n      ): StateUpdater {\n\n    let delegated: StateUpdater;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(\n        fn => delegated = fn,\n    ).whenOff(\n        () => delegated = noop,\n    );\n\n    return (path, newValue, oldValue) => delegated(path, newValue, oldValue);\n  }\n\n}\n\n/**\n * A key of component context value containing a component {@link StateUpdater state updater} function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Note that this value is not provided, unless a {@link StateSupport state support} enabled.\n *\n * When multiple state updaters provided, they all will be called on each state update, in reverse order.\n *\n * Does nothing after component destruction.\n *\n * @category Core\n */\nexport const StateUpdater: ContextUpRef<StateUpdater, StateUpdater.Normalized> = (/*#__PURE__*/ new StateUpdaterKey());\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport {\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  EventSupplyPeer,\n  OnEvent,\n  StatePath,\n} from '@proc7ts/fun-events';\nimport { OnDomEvent } from '@proc7ts/fun-events/dom';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentMount } from './component-mount';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of a custom element and component properties containing a reference to component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = (/*#__PURE__*/ Symbol('component-context'));\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perComponent]] and [[DefinitionSetup.perComponent]] methods.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues implements EventSupplyPeer {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.whenComponent component instantiation event} receiver. A [[whenReady]] callback could\n   * be utilized to work this around.\n   */\n  abstract readonly component: T;\n\n  /**\n   * Component mount.\n   *\n   * This is defined when component is mounted to arbitrary element by [[DefinitionContext.mountTo]]. Ot is `undefined`\n   * for components created in standard way.\n   */\n  abstract readonly mount: ComponentMount<T> | undefined;\n\n  /**\n   * Whether the component is settled.\n   *\n   * Component settlement happens:\n   * - when [[settle]] method is called,\n   * - when component is {@link DefinitionContext.mountTo mounted} to element, or\n   * - when component's element is [[connected]].\n   *\n   * It is guaranteed that component settlement won't happen inside custom element's constructor. So the settlement\n   * event may be used e.g. to start DOM manipulations, as the latter is prohibited inside custom element constructor.\n   *\n   * This becomes `true` right before [[whenSettled]] event is sent.\n   */\n  abstract readonly settled: boolean;\n\n  /**\n   * Whether the component's element is connected.\n   *\n   * This becomes `true` right before [[whenConnected]] event is sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An event supply that {@link destroy destroys} component when cut off.\n   */\n  abstract readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * Note that state update has no effect unless [[StateSupport]] feature is enabled or [[StateUpdater]] context value\n   * is provided by other means.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  readonly updateState: StateUpdater;\n\n  /**\n   * Extracts component context from its custom element or from component itself.\n   *\n   * @param element  Custom element instance created for the component or the component itself.\n   *\n   * @return Component context reference stored under [[ComponentContext__symbol]] key.\n   *\n   * @throws TypeError  When the given `element` does not contain component context reference.\n   */\n  static of<T extends object>(element: any): ComponentContext<T> {\n\n    const context = element[ComponentContext__symbol];\n\n    if (!context) {\n      throw TypeError(`No component context found in ${element}`);\n    }\n\n    return context;\n  }\n\n  constructor() {\n    super();\n    this.updateState = <V>(key: StatePath, newValue: V, oldValue: V): void => {\n      this.get(StateUpdater)(key, newValue, oldValue);\n    };\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): any {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Builds an `OnEvent` sender of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   *\n   * @returns An `OnEvent` sender of this context upon component readiness.\n   */\n  abstract whenReady(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * @param receiver  Target receiver of this component upon component readiness.\n   *\n   * @returns Component readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Settles component.\n   *\n   * Calling this method has no effect if component is [[settled]] already, when component is not\n   * {@link whenReady ready} yet, or custom element's constructor is not exited.\n   *\n   * Calling this method may trigger DOM manipulations (the latter is prohibited inside custom element's constructor).\n   * This may be desired for rendering optimizations. E.g. to render element's content _before_ adding it to document.\n   *\n   * This method is called automatically when {@link DefinitionContext.mountTo mounting} component to element.\n   */\n  abstract settle(): void;\n\n  /**\n   * Builds an `OnEvent` sender of component settlement event.\n   *\n   * The registered receiver is called when component is [[settled]]. If settled already the receiver is called\n   * immediately.\n   *\n   * @returns An `OnEvent` sender of this component context when settled.\n   */\n  abstract whenSettled(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component settlement event.\n   *\n   * The registered receiver is called when component is [[settled]]. If settled already the receiver is called\n   * immediately.\n   *\n   * @param receiver  Target receiver of this component context when connected.\n   *\n   * @returns Component settlement event supply.\n   */\n  abstract whenSettled(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. I.e. when custom element's\n   * `connectedCallback()` method is called, or when the element this component is {@link mount mounted to} is\n   * {@link ComponentMount.connect connected}.\n   *\n   * If connected already the receiver is called immediately.\n   *\n   * @returns An `OnEvent` sender of this component context when connected.\n   */\n  abstract whenConnected(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. I.e. when custom element's\n   * `connectedCallback()` method is called, or when the element this component is {@link mount mounted to} is\n   * {@link ComponentMount.connect connected}.\n   *\n   * If connected already the receiver is called immediately.\n   *\n   * @param receiver  Target receiver of this component context when connected.\n   *\n   * @returns Component's element connection event supply.\n   */\n  abstract whenConnected(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Returns a DOM event producer for the given event type.\n   *\n   * This is a shorthand for invoking a component event producer function available under\n   * `[ComponentEventProducer.key]` key.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return this.get(ComponentEventDispatcher__key).on(type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * This is a shorthand for invoking a component {@link ComponentEventDispatcher event dispatcher}.\n   *\n   * @param event  An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(ComponentEventDispatcher__key).dispatch(event);\n  }\n\n  /**\n   * Destroys the component.\n   *\n   * Removes element from the DOM tree. I.e. disconnects custom element first.\n   *\n   * After this method call the component should no longer be used.\n   *\n   * Note that component destruction is virtual. It is up to developer to decide when component is no longer needed.\n   * However the component is destroyed automatically once disconnected, i.e. when custom element's\n   * `disconnectedCallback()` method is called.\n   *\n   * @param reason  Optional reason of destruction.\n   */\n  abstract destroy(reason?: any): void;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextRef } from '@proc7ts/context-values';\nimport { OnDomEvent } from '@proc7ts/fun-events/dom';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\n\n/**\n * Component event.\n *\n * Events of this type are thrown by various services to inform on component status changes.\n *\n * It is illegal to dispatch such events for elements not bound to components. It is reasonable to dispatch events\n * using [[ComponentEventDispatcher]] available in component context.\n *\n * The following event types supported:\n * - `wesib:component` is dispatched when component is bound to element. I.e. when HTML element is upgraded to custom\n *   one defined by component, or component is mounted to element. The event is dispatched when component is connected\n *   for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Core\n * @event ComponentEvent#wesib:component\n */\nexport class ComponentEvent extends Event {\n\n  /**\n   * Target component context.\n   */\n  get context(): ComponentContext {\n    return ComponentContext.of(this.target);\n  }\n\n}\n\n/**\n * Component event dispatcher is used to listen for and dispatch component events.\n *\n * It is available in bootstrap context context.\n *\n * By default treats a component element as event target.\n *\n * @category Core\n */\nexport interface ComponentEventDispatcher {\n\n  /**\n   * Dispatches the DOM event for the given component.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(event: Event): boolean;\n\n  /**\n   * Returns an `OnDomEvent` sender of DOM events of the given type.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E>;\n\n}\n\n/**\n * A key of component context value containing component event dispatcher.\n *\n * @category Core\n */\nexport const ComponentEventDispatcher: SingleContextRef<ComponentEventDispatcher> = ComponentEventDispatcher__key;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { valueProvider } from '@proc7ts/call-thru';\nimport { Class, decoratePropertyAccessor, PropertyAccessorDescriptor } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { Component, ComponentDecorator } from './component.decorator';\nimport { ComponentClass } from './definition';\n\n/**\n * Component property decorator interface.\n *\n * Allows to construct a {@link ComponentDecorator component decorator} by declaring a virtual property to use instead\n * of decorated one.\n *\n * Constructed by [[ComponentProperty]] function.\n *\n * @category Core\n * @typeparam V  Property value type.\n * @typeparam T  A type of decorated component class.\n */\nexport interface ComponentPropertyDecorator<V, T extends ComponentClass = Class> {\n\n  /**\n   * Decorates component method.\n   *\n   * @typeparam P  Property value type.\n   * @param proto  Decorated class prototype.\n   * @param propertyKey  Decorated property key.\n   * @param descriptor  Decorated property descriptor.\n   *\n   * @returns  Either updated property descriptor, or nothing.\n   */\n  // eslint-disable-next-line\n  <P extends V>(\n      this: void,\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<P>,\n  ): any | void;\n\n  /**\n   * Builds component decorator assuming the virtual property has the given value.\n   *\n   * @param value  Virtual property value.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  As(\n      this: void,\n      value: V,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the virtual property value is provided by the given `provider`.\n   *\n   * @param provider  Virtual property read-only value provider.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  By(\n      this: void,\n      provider: ComponentProperty.Provider<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is available via the given `accessor`.\n   *\n   * @param accessor  Virtual property accessor.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  With(\n      this: void,\n      accessor: ComponentProperty.Accessor<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is bound to component with by the given `binder`.\n   *\n   * @param binder  A binder of virtual property accessor\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]]..\n   *\n   * @returns New component decorator.\n   */\n  Bind(\n      this: void,\n      binder: ComponentProperty.Binder<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n}\n\nexport namespace ComponentProperty {\n\n  /**\n   * Component property value provider signature.\n   *\n   * This function will be called each time the property value is requested.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export type Provider<V, T extends object = any> =\n  /**\n   * @param component  Component instance.\n   * @param key  Target property key.\n   *\n   * @returns Property value.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => V;\n\n  /**\n   * Component property accessor.\n   *\n   * Allows to read and write property value.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export interface Accessor<V, T extends object = any> {\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component  Target component instance.\n     * @param key  Property key.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: T, key: string | symbol): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     * @param key  Property key.\n     */\n    set(this: void, component: T, value: V, key: string | symbol): void;\n\n  }\n\n  /**\n   * Property accessor binder signature.\n   *\n   * This is a function that binds a {@link BoundAccessor property accessor} to target component.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export type Binder<V, T extends object = any> =\n  /**\n   * @param component  Target component to bind property accessor to.\n   * @param key  Property key.\n   *\n   * @returns Property accessor bound to `component`.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => BoundAccessor<V>;\n\n  export interface BoundAccessor<V> {\n\n    /**\n     * Reads bound component's property value.\n     *\n     * An attempt to read the value would throw when omitted.\n     *\n     * @returns Property value.\n     */\n    get?(): V;\n\n    /**\n     * Assigns bound component's new property value.\n     *\n     * An attempt to assign the value would throw when omitted.\n     *\n     * @param value  New property value.\n     */\n    set?(value: V): void;\n\n  }\n\n  /**\n   * Component property descriptor.\n   *\n   * Passed to {@link Definer property definer} by [[ComponentProperty]] function to construct a {@link Definition\n   * property definition}.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export interface Descriptor<V, T extends ComponentClass = Class> {\n\n    /**\n     * Component class constructor.\n     */\n    readonly type: T;\n\n    /**\n     * Component property key.\n     */\n    readonly key: string | symbol;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.get property read definition}.\n     */\n    readonly readable: boolean;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.set property assignment definition}.\n     */\n    readonly writable: boolean;\n\n    /**\n     * Whether the property is initially enumerable.\n     *\n     * This can be changed by {@link Definition.enumerable property definition}.\n     */\n    readonly enumerable: boolean;\n\n    /**\n     * Whether the property is initially configurable.\n     *\n     * This can be changed by {@link Definition.configurable property definition}.\n     */\n    readonly configurable: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component  Target component instance.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: InstanceType<T>): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     */\n    set(this: void, component: InstanceType<T>, value: V): void;\n\n  }\n\n  /**\n   * Component property definition builder signature.\n   *\n   * This is a function called by [[ComponentProperty]] to define the property.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export type Definer<V, T extends ComponentClass = Class> =\n  /**\n   * @param descriptor  Component property descriptor.\n   *\n   * @returns Component property definition. Or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<V, T>,\n      ) => Definition<V, T> | void;\n\n  /**\n   * Property definition to apply to existing property.\n   *\n   * When applying to decorated property, this definition updates its definition.\n   *\n   * When applying to virtual property assumed by one of [[ComponentPropertyDecorator]] methods, most of returned\n   * values ignored. Except for {@link Definition.componentDef component definition}, {@link Definition.get value\n   * reader}, and {@link Definition.set value setter}.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export interface Definition<V, T extends ComponentClass = Class> {\n\n    /**\n     * Component definition to apply to component.\n     *\n     * When specified, it is used to enable certain functionality for decorated (or virtual) property.\n     */\n    readonly componentDef?: ComponentDef<InstanceType<T>>;\n\n    /**\n     * Whether to make the property enumerable.\n     *\n     * When specified, it is used as `enumerable` attribute value of decorated property descriptor.\n     */\n    readonly enumerable?: boolean;\n\n    /**\n     * Whether to make the property configurable.\n     *\n     * When specified, it is used as `configurable` attribute value of decorated property descriptor.\n     */\n    readonly configurable?: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * When specified it changes how the property value is read.\n     *\n     * When neither [[get]], nor [[set]] specified, the property access does not change.\n     *\n     * @param component  Target component instance.\n     * @param key  Property key.\n     *\n     * @returns Property value.\n     */\n    get?(this: void, component: InstanceType<T>, key: string | symbol): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * When specified it changes how the property value is assigned.\n     *\n     * When neither [[get]], nor [[set]] specified, the property access does not change.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     * @param key  Property key.\n     */\n    set?(this: void, component: InstanceType<T>, value: V, key: string | symbol): void;\n\n  }\n\n}\n\n/**\n * Anonymous component property key.\n *\n * Used as a default virtual property key.\n *\n * @category Core\n */\nexport const AnonymousComponentProperty__symbol = (/*#__PURE__*/ Symbol('anonymous-component-property'));\n\n/**\n * Decorator of component property.\n *\n * Updates decorated property and component definition. Can be converted to {@link ComponentDecorator component\n * decorator} by calling appropriate method of returned decorator instance.\n *\n * @category Core\n * @typeparam V  Decorated property value type.\n * @typeparam T  A type of decorated component class.\n * @param define  Component property definition builder.\n *\n * @returns Component property decorator.\n */\nexport function ComponentProperty<V, T extends ComponentClass = Class>(\n    define: ComponentProperty.Definer<V, T>,\n): ComponentPropertyDecorator<V, T> {\n\n  const decorator = (\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<V>,\n  ): any | void => decoratePropertyAccessor(\n      proto,\n      propertyKey,\n      descriptor,\n      desc => {\n\n        const { get: getValue, set: setValue } = desc;\n        const type = proto.constructor;\n        const { get, set, configurable, enumerable, componentDef = {} } = define({\n          type,\n          key: propertyKey,\n          readable: !!desc.get,\n          writable: !!desc.set,\n          enumerable: !!desc.enumerable,\n          configurable: !!desc.configurable,\n          get: getValue\n              ? ((component: InstanceType<T>) => getValue.call(component))\n              : notReadableAccessor(propertyKey),\n          set: setValue\n              ? ((component, value) => setValue.call(component, value))\n              : notWritableAccessor(propertyKey),\n        }) || {};\n\n        ComponentDef.define(type, componentDef);\n\n        const updated: PropertyAccessorDescriptor<V> = {\n          ...desc,\n          configurable: configurable ?? desc.configurable,\n          enumerable: enumerable ?? desc.enumerable,\n        };\n\n        if (get || set) {\n          updated.get = get && function (this: InstanceType<T>) {\n            return get(this, propertyKey);\n          };\n          updated.set = set && function (this: InstanceType<T>, value: V) {\n            set(this, value, propertyKey);\n          };\n        }\n\n        return updated;\n      },\n  );\n  const decorateWith = (\n      { get, set }: ComponentProperty.Accessor<V, InstanceType<T>>,\n      key: string | symbol = AnonymousComponentProperty__symbol,\n      writable: boolean,\n  ): ComponentDecorator<T> => Component({\n    [ComponentDef__symbol](type: InstanceType<T>) {\n\n      const def = define({\n        type,\n        key,\n        readable: true,\n        writable,\n        enumerable: false,\n        configurable: false,\n        get: component => get(component, key),\n        set: (component, value) => set(component, value, key),\n      });\n\n      return (def && def.componentDef) || {};\n    },\n  });\n  const By = (\n      provider: ComponentProperty.Provider<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T> => decorateWith(\n      {\n        get(component, key) {\n          return provider(component, key);\n        },\n      } as ComponentProperty.Accessor<V>,\n      key,\n      false,\n  );\n\n  const result = decorator as ComponentPropertyDecorator<V, T>;\n\n  result.With = (access, key) => decorateWith(access, key, true);\n  result.By = By;\n  result.As = (value, key?) => By(valueProvider(value), key);\n  result.Bind = (binder, key = AnonymousComponentProperty__symbol) => {\n\n    const accessor__symbol = Symbol(`${String(key)}:accessor`);\n    const accessor = (component: any): {\n      get(): V;\n      set(value: V): void;\n    } => {\n\n      const existing = component[accessor__symbol];\n\n      if (existing) {\n        return existing;\n      }\n\n      const accessor = binder(component, key);\n\n      return component[accessor__symbol] = {\n        get: accessor.get ? accessor.get.bind(accessor) : notReadableAccessor(key),\n        set: accessor.set ? accessor.set.bind(accessor) : notWritableAccessor(key),\n      };\n    };\n\n    return decorateWith(\n        {\n          get(component) {\n            return accessor(component).get();\n          },\n          set(component, value) {\n            return accessor(component).set(value);\n          },\n        },\n        key,\n        true,\n    );\n  };\n\n  return result;\n}\n\n/**\n * @internal\n */\nfunction notReadableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not readable`); };\n}\n\n/**\n * @internal\n */\nfunction notWritableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not writable`); };\n}\n","import {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  SingleContextKey,\n} from '@proc7ts/context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapContextRegistry__key = (\n    /*#__PURE__*/ new SingleContextKey<BootstrapContextRegistry>('bootstrap-context-registry')\n);\n\n/**\n * @internal\n */\nexport class BootstrapContextRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapContextRegistry> {\n    return BootstrapContextRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapContextRegistry {\n    return new BootstrapContextRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapContextRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst ComponentContextRegistry__key = (/*#__PURE__*/ new SingleContextKey<ComponentContextRegistry>(\n    'component-context-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n    },\n));\n\n/**\n * @internal\n */\nexport class ComponentContextRegistry extends ContextRegistry<ComponentContext> {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentContextRegistry> {\n    return ComponentContextRegistry__key;\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst DefinitionContextRegistry__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContextRegistry>(\n    'definition-context-registry',\n    {\n      byDefault: bootstrapDefault(context => new DefinitionContextRegistry(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class DefinitionContextRegistry extends ContextRegistry<DefinitionContext> {\n\n  static get [ContextKey__symbol](): ContextKey<DefinitionContextRegistry> {\n    return DefinitionContextRegistry__key;\n  }\n\n}\n","import { nextArgs, nextSkip } from '@proc7ts/call-thru';\nimport { EventEmitter, onAny, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { superClassOf } from '../../common';\nimport { ComponentDef__symbol } from '../../component';\nimport { ComponentClass, DefinitionSetup } from '../../component/definition';\nimport { Unloader } from './unloader.impl';\n\n/**\n * @internal\n */\nexport function onPostDefSetup(\n    componentType: ComponentClass,\n    unloader: Unloader,\n): OnEvent<[DefinitionSetup]> {\n\n  const { on } = postDefSetup(componentType);\n\n  return onEventBy(receiver => {\n    on.to({\n      supply: receiver.supply.needs(unloader.supply),\n      receive(ctx, setup) {\n\n        const whenReady = setup.whenReady().tillOff(unloader.supply).F;\n        const whenComponent = setup.whenComponent().tillOff(unloader.supply).F;\n\n        receiver.receive(ctx, {\n          get componentType() {\n            return setup.componentType;\n          },\n          get whenReady() {\n            return whenReady;\n          },\n          get whenComponent() {\n            return whenComponent;\n          },\n          perDefinition(spec) {\n            return unloader.add(() => setup.perDefinition(spec));\n          },\n          perComponent(spec) {\n            return unloader.add(() => setup.perComponent(spec));\n          },\n        });\n      },\n    });\n  });\n}\n\n/**\n * @internal\n */\nexport interface PostDefSetup<T extends object = any> {\n  readonly on: OnEvent<[DefinitionSetup<T>]>;\n  send(setup: DefinitionSetup): void;\n  setup(setup: DefinitionSetup<T>): void;\n}\n\nconst PostDefSetup__symbol = (/*#__PURE__*/ Symbol('post-def-setup'));\n\n/**\n * @internal\n */\nexport function postDefSetup<T extends object>(componentType: ComponentClass<T>): PostDefSetup<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(PostDefSetup__symbol)) {\n    return (componentType as any)[PostDefSetup__symbol];\n  }\n\n  const tracker = trackValue<DefinitionSetup<T>>();\n  const emitter = new EventEmitter<[DefinitionSetup]>();\n  const onSetup: OnEvent<[DefinitionSetup<T>]> = tracker.read().thru(setup => setup ? nextArgs(setup) : nextSkip());\n  const on = onAny(onSetup, emitter);\n  const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n\n  if (superType) {\n\n    const superPostDefSetup = postDefSetup(superType);\n\n    on.to(setup => superPostDefSetup.send(setup));\n  }\n\n  const result: PostDefSetup<T> = {\n    on,\n    send(setup) {\n      emitter.send(setup);\n    },\n    setup(setup) {\n      tracker.it = setup;\n    },\n  };\n\n  Object.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window & typeof globalThis;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = (/*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * A window (e.g. DOM) element all bootstrapped components belong to.\n *\n * @category Core\n */\nexport type BootstrapRoot = any;\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of [[BootstrapWindow]].\n *\n * @category Core\n */\nexport const BootstrapRoot: SingleContextRef<BootstrapRoot> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { NamespaceAliaser } from '@proc7ts/namespace-aliaser';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> = (\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueOpts, ContextValues } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { newRenderSchedule, RenderScheduler } from '@proc7ts/render-scheduler';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * Default rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultRenderScheduler = RenderScheduler;\n\nclass DefaultRenderSchedulerKey extends ContextUpKey<DefaultRenderScheduler, RenderScheduler> {\n\n  readonly upKey: ContextUpKey.UpKey<DefaultRenderScheduler, RenderScheduler>;\n\n  constructor() {\n    super('default-render-scheduler');\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru(\n            (...fns) => {\n              if (fns.length) {\n                return toDefaultRenderScheduler(opts.context, fns[fns.length - 1]);\n              }\n\n              const defaultProvider = (): AfterEvent<[DefaultRenderScheduler]> => afterThe(\n                  toDefaultRenderScheduler(opts.context, newRenderSchedule),\n              );\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          DefaultRenderScheduler,\n          EventKeeper<RenderScheduler[]> | RenderScheduler,\n          AfterEvent<RenderScheduler[]>>,\n      ): DefaultRenderScheduler {\n\n    let delegated: DefaultRenderScheduler;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(\n        scheduler => delegated = toDefaultRenderScheduler(opts.context, scheduler),\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    return (...args) => delegated(...args);\n  }\n\n}\n\nfunction toDefaultRenderScheduler(\n    context: ContextValues,\n    scheduler: RenderScheduler,\n): DefaultRenderScheduler {\n  return (options = {}) => scheduler({\n    ...options,\n    window: options.window || context.get(BootstrapWindow),\n  });\n}\n\n/**\n * A key of bootstrap, definition, or component context value containing [[DefaultRenderScheduler]] instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window}.\n *\n * @category Core\n */\nexport const DefaultRenderScheduler: ContextUpRef<DefaultRenderScheduler, RenderScheduler> = (\n    /*#__PURE__*/ new DefaultRenderSchedulerKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueOpts, ContextValues } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\n\n/**\n * Element adapter is a function able to convert a raw element to component. E.g. mount a component to it.\n *\n * Features may use it internally. E.g. an `AutoConnectSupport` applies it to each added DOM element.\n *\n * Multiple element adapters can be registered in bootstrap context.\n *\n * @category Core\n */\nexport type ElementAdapter =\n/**\n * @param element  Target raw element to adapt.\n *\n * @returns An adapted component's context, or `undefined` if element can not be adapted.\n */\n    (this: void, element: any) => ComponentContext | undefined;\n\n/**\n * @internal\n */\nclass ElementAdapterKey extends ContextUpKey<ElementAdapter, ElementAdapter> {\n\n  readonly upKey: ContextUpKey.UpKey<ElementAdapter, ElementAdapter>;\n\n  constructor() {\n    super('element-adapter');\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru((...adapters) => {\n\n          const combined: ElementAdapter = adapters.reduce(\n              (prev, adapter) => element => prev(element) || adapter(element),\n              defaultElementAdapter,\n          );\n\n          const defaultProvider = (): AfterEvent<[ElementAdapter]> => afterThe(defaultElementAdapter);\n\n          return combined !== defaultElementAdapter\n              ? combined\n              : nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n        }),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          ElementAdapter,\n          EventKeeper<ElementAdapter[]> | ElementAdapter,\n          AfterEvent<ElementAdapter[]>>,\n  ): ElementAdapter {\n\n    let delegated: ElementAdapter;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(\n        adapter => delegated = adapter,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    return element => delegated(element);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultElementAdapter(element: any): ComponentContext {\n  return element[ComponentContext__symbol];\n}\n\n/**\n * A key of bootstrap context value containing combined [[ElementAdapter]] instance.\n *\n * @category Core\n */\nexport const ElementAdapter: ContextUpRef<ElementAdapter, ElementAdapter> = (/*#__PURE__*/ new ElementAdapterKey());\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { filterIt, itsEach, overArray } from '@proc7ts/a-iterable';\nimport { FnContextKey } from '@proc7ts/context-values/updatable';\nimport { isElement } from '../../common';\nimport { ComponentContext__symbol, ComponentMount } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ElementAdapter } from './element-adapter';\n\n/**\n * Element mutations observer.\n *\n * It is a `MutationObserver` implementation that:\n * - always observes target's children,\n * - applies {@link ElementAdapter element adapter} to added elements,\n * - tracks mounted components {@link ComponentMount.connected connection state}.\n *\n * A function constructing element observer instance could be obtained from bootstrap context.\n *\n * @category Core\n */\nexport interface ElementObserver extends MutationObserver {\n\n  /**\n   * Configures the observer callback to begin receiving notifications of changes to the DOM that match the given\n   * options.\n   * To stop the MutationObserver (so that none of its callbacks will be triggered any longer), call\n   * [[disconnect]].\n   *\n   * @param target  A DOM node within the DOM tree to watch for changes, and to be the root of a subtree of nodes\n   * to be watched.\n   * @param options  An options that describe what DOM mutations should be reported to the observer's callback.\n   */\n  observe(target: Node, options?: ElementObserverInit): void;\n\n}\n\n/**\n * A key of bootstrap context value containing a function constructing a new [[ElementObserver]] instance.\n *\n * @category Core\n */\nexport const ElementObserver: FnContextKey<[MutationCallback], ElementObserver> = (/*#__PURE__*/ new FnContextKey(\n    'element-observer',\n    {\n      byDefault: bootstrapDefault(bsContext => {\n\n        const adapter = bsContext.get(ElementAdapter);\n        class DefaultElementObserver extends MutationObserver implements ElementObserver {\n\n          constructor(callback: MutationCallback) {\n            super(mutations => {\n              mutations.forEach(mutation => {\n                itsEach(\n                    overArray(mutation.removedNodes),\n                    node => mountOf(node)?.checkConnected(),\n                );\n                itsEach(\n                    filterIt(\n                        overArray(mutation.addedNodes),\n                        isElement,\n                    ),\n                    element => adapter(element)?.mount?.checkConnected(),\n                );\n              });\n              callback(mutations, this);\n            });\n          }\n\n          observe(target: Node, options?: ElementObserverInit): void {\n            super.observe(target, { ...options, childList: true });\n          }\n\n        }\n\n        return callback => new DefaultElementObserver(callback);\n      }),\n    },\n));\n\n/**\n * Element observer initialization options.\n *\n * @category Core\n */\nexport interface ElementObserverInit extends MutationObserverInit {\n\n  /**\n   * Whether mutations to target's children are to be observed.\n   *\n   * Always `true`.\n   */\n  childList?: true;\n\n}\n\n/**\n * @internal\n */\nfunction mountOf(node: any): ComponentMount | undefined {\n  return node[ComponentContext__symbol]?.mount;\n}\n","import { ComponentClass, DefinitionContext } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const DefinitionContext__symbol = (/*#__PURE__*/ Symbol('definition-context'));\n\n/**\n * @internal\n */\nexport function definitionContextOf<T extends object>(componentType: ComponentClass<T>): DefinitionContext<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (!componentType.hasOwnProperty(DefinitionContext__symbol)) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n  return (componentType as any)[DefinitionContext__symbol];\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { html__naming, isQualifiedName, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { definitionContextOf } from '../../boot/impl/definition-context.symbol.impl';\nimport { Class, PromiseResolver } from '../../common';\nimport { ComponentClass } from './component-class';\n\n/**\n * @internal\n */\nconst CustomElements__key = (/*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: bootstrapDefault(createCustomElements),\n    },\n));\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName  A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType  A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName  Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\n/**\n * @internal\n */\nfunction createCustomElements(bsContext: BootstrapContext): CustomElements {\n\n  const customElements: CustomElementRegistry = bsContext.get(BootstrapWindow).customElements;\n  const nsAlias = bsContext.get(DefaultNamespaceAliaser);\n\n  class CustomElements$ extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | string, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name, extend } = defContext.elementDef;\n\n      if (!name) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            html__naming.name(name, nsAlias),\n            elementType,\n            {\n              extends: extend.name,\n            },\n        );\n      } else {\n        customElements.define(html__naming.name(name, nsAlias), elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name } = defContext.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise;\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new CustomElements$();\n}\n\n/**\n * @internal\n */\nconst ComponentResolver__symbol = (/*#__PURE__*/ Symbol('component-resolver'));\n\n/**\n * @internal\n */\nfunction componentResolver(componentType: any): PromiseResolver {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(ComponentResolver__symbol)) {\n    return componentType[ComponentResolver__symbol];\n  }\n  return componentType[ComponentResolver__symbol] = new PromiseResolver();\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class } from '../../common';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n */\nexport const ElementDef: SingleContextRef<ElementDef> = (/*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || values.get(BootstrapWindow).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n));\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { EventReceiver, EventSupply, OnEvent } from '@proc7ts/fun-events';\nimport { Class } from '../../common';\nimport { ComponentContext } from '../component-context';\nimport { ComponentMount } from '../component-mount';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perDefinition]] and [[DefinitionSetup.perDefinition]] methods. All [[BootstrapContext]] values\n * are available too.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * Builds an `OnEvent` sender of component definition context upon its readiness.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of this component definition context upon its readiness.\n   */\n  abstract whenReady(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component definition readiness event.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of this component definition context upon its readiness.\n   *\n   * @returns Component definition readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a `ComponentContext.mount` property to check\n   * whether the component is mounted or is constructed in standard way.\n   *\n   * The constructed component will be in disconnected state. To update its connection state either update a\n   * `ComponentMount.connected` property, or use a `connectTo()` method.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: any): ComponentMount<T>;\n\n  /**\n   * Connects a component to arbitrary element.\n   *\n   * This method does the same as `mountTo()`, but also marks the mounted component as connected.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  connectTo(element: any): ComponentMount<T> {\n\n    const mount = this.mountTo(element);\n\n    mount.connect();\n\n    return mount;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of component context upon its instantiation.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenConnected connected}. This is to prevent resource\n   * leaks on destroyed components.\n   *\n   * @returns `OnEvent` sender of instantiated component context.\n   */\n  abstract whenComponent(): OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Starts sending component instantiation events to the given `receiver`.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenConnected connected}. This is to prevent resource\n   * leaks on destroyed components.\n   *\n   * @param receiver  Target receiver of instantiate component contexts.\n   *\n   * @returns Component instantiation events supply.\n   */\n  abstract whenComponent(receiver: EventReceiver<[ComponentContext<T>]>): EventSupply;\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeparam Deps  A type of dependencies.\n   * @typeparam Src  The type of context value sources.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Component context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, Deps, Src, Seed>,\n  ): () => void;\n\n}\n","import { nextArg, nextArgs, nextSkip, valueProvider } from '@proc7ts/call-thru';\nimport {\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { ComponentContext, ComponentContext__symbol, ComponentEvent } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nconst enum ComponentStatus {\n  Building,\n  Ready,\n  Built,\n  Settled,\n  Connected,\n}\n\n/**\n * @internal\n */\nexport abstract class ComponentContext$<T extends object> extends ComponentContext<T> {\n\n  readonly get: ComponentContext<T>['get'];\n  private _status = trackValue<ComponentStatus>(ComponentStatus.Building);\n\n  constructor(\n      readonly _definitionContext: DefinitionContext$<T>,\n      readonly element: any,\n  ) {\n    super();\n\n    const registry = _definitionContext._newComponentRegistry();\n\n    registry.provide({ a: ComponentContext, is: this });\n    this.get = registry.newValues().get;\n  }\n\n  get componentType(): ComponentClass<T> {\n    return this._definitionContext.componentType;\n  }\n\n  get component(): T {\n    return this._component();\n  }\n\n  get settled(): boolean {\n    return this._status.it >= ComponentStatus.Settled && !eventSupplyOf(this).isOff;\n  }\n\n  get connected(): boolean {\n    return this._status.it >= ComponentStatus.Connected && !eventSupplyOf(this).isOff;\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._status);\n  }\n\n  _component(): T {\n    throw new TypeError('Component is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  whenReady(): OnEvent<[this]>;\n  whenReady(receiver: EventReceiver<[this]>): EventSupply;\n  whenReady(receiver?: EventReceiver<[this]>): OnEvent<[this]> | EventSupply {\n    return (this.whenReady = this._status.read().thru_(\n        status => status ? nextArgs(this) : nextSkip(),\n    ).once().F)(receiver);\n  }\n\n  settle(): void {\n    if (this._status.it === ComponentStatus.Built) {\n      // Prevent settling until exiting custom element constructor\n      this._status.it = ComponentStatus.Settled;\n    }\n  }\n\n  whenSettled(): OnEvent<[this]>;\n  whenSettled(receiver: EventReceiver<[this]>): EventSupply;\n  whenSettled(receiver?: EventReceiver<[this]>): OnEvent<[this]> | EventSupply {\n    return (this.whenSettled = this._status.read().thru_(\n        status => status >= ComponentStatus.Settled ? nextArg(this) : nextSkip(),\n    ).once().F)(receiver);\n  }\n\n  whenConnected(): OnEvent<[this]>;\n  whenConnected(receiver: EventReceiver<[this]>): EventSupply;\n  whenConnected(receiver?: EventReceiver<[this]>): OnEvent<[this]> | EventSupply {\n    return (this.whenConnected = this._status.read().thru_(\n        status => status >= ComponentStatus.Connected ? nextArg(this) : nextSkip(),\n    ).once().F)(receiver);\n  }\n\n  destroy(reason?: any): void {\n    try {\n      this._status.done(reason);\n    } finally {\n      delete (this.component as any)[ComponentContext__symbol];\n      delete this.element[ComponentContext__symbol];\n      this._component = componentDestroyed;\n      removeElement(this.element);\n    }\n  }\n\n  _createComponent(): this {\n\n    const whenComponent = this._definitionContext._whenComponent;\n\n    let lastRev = 0;\n\n    this.element[ComponentContext__symbol] = this;\n    whenComponent.readNotifier.once(notifier => lastRev = notifier(this, lastRev));\n    this.whenConnected(() => {\n      whenComponent.readNotifier.to({\n        supply: eventSupply().needs(this),\n        receive: (_, notifier) => {\n          lastRev = notifier(this, lastRev);\n        },\n      });\n    });\n    this._definitionContext._elementBuilder.components.send(this);\n\n    const component = newComponent(this);\n\n    this._component = valueProvider(component);\n    this._status.it = ComponentStatus.Ready; // Issue `whenReady` event\n\n    return this;\n  }\n\n  _connect(): void {\n    this._status.it = ComponentStatus.Connected;\n  }\n\n  _created(): void {\n    if (this._status.it < ComponentStatus.Built) { // Mounted component can be connected already\n      this._status.it = ComponentStatus.Built; // Can settle now\n    }\n    this.whenConnected(\n        () => this.dispatchEvent(new ComponentEvent('wesib:component', { bubbles: true })),\n    );\n  }\n\n}\n\nfunction newComponent<T extends object>(context: ComponentContext<T>): T {\n\n  const type = context.componentType;\n  const proto = type.prototype as any;\n  const prevContext = proto[ComponentContext__symbol];\n\n  proto[ComponentContext__symbol] = context;\n  try {\n\n    const component = new type(context);\n\n    (component as any)[ComponentContext__symbol] = context;\n\n    return component;\n  } finally {\n    proto[ComponentContext__symbol] = prevContext;\n  }\n}\n\nfunction removeElement(element: Element): void {\n\n  const { parentNode } = element;\n\n  if (parentNode) {\n    parentNode.removeChild(element);\n  }\n}\n\nfunction componentDestroyed(): never {\n  throw new TypeError('Component destroyed already');\n}\n","import { ComponentMount } from '../../component';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass ComponentMount$<T extends object> extends ComponentMount<T> {\n\n  constructor(readonly context: ComponentContext$<T>) {\n    super();\n  }\n\n  get connected(): boolean {\n    return this.context.connected;\n  }\n\n  connect(): void {\n    this.context._connect();\n  }\n\n  checkConnected(): boolean {\n\n    const el: Element = this.context.element;\n    const doc = el.ownerDocument;\n    const connected = doc != null && doc.contains(el);\n\n    if (connected !== this.connected) {\n      if (connected) {\n        this.connect();\n      } else {\n        this.context.destroy();\n      }\n    }\n\n    return connected;\n  }\n\n}\n\n/**\n * @internal\n */\nexport class MountComponentContext$<T extends object> extends ComponentContext$<T> {\n\n  readonly mount: ComponentMount<T>;\n\n  constructor(definitionContext: DefinitionContext$<T>, element: any) {\n    super(definitionContext, element);\n    this.mount = this.mount = new ComponentMount$<T>(this);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext } from './component-context';\n\n/**\n * A mount of the component to an element.\n *\n * This is constructed when a component is mounted to arbitrary element by [[DefinitionContext.mountTo]] method.\n *\n * Mounted components do not maintain their connection state automatically. It is a calling code responsibility to set\n * their connection state by updating [[ComponentMount.connected]] property. E.g. by calling a\n * [[ComponentMount.checkConnected]] method. An [[ElementObserver]] and [[AutoConnectSupport]] feature could be used to\n * do it automatically.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentMount<T extends object = any> {\n\n  /**\n   * Mounted component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Component connection state.\n   *\n   * The initial state is set by [[checkConnected]] method.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * Mounted component.\n   */\n  get component(): T {\n    return this.context.component;\n  }\n\n  /**\n   * An element the component is mounted to.\n   */\n  get element(): any {\n    return this.context.element;\n  }\n\n  /**\n   * Forcibly connects mounted component element to the document.\n   */\n  abstract connect(): void;\n\n  /**\n   * Checks whether the mounted component element is actually connected to its owning document.\n   *\n   * Updates the `connected` property and returns its value.\n   *\n   * When component is disconnected after it has been connected, the component is {@link ComponentContext.destroy\n   * destroyed}.\n   *\n   * @returns `true` if the component element is connected, or `false` otherwise.\n   */\n  abstract checkConnected(): boolean;\n\n}\n","import { Class } from '../../common';\nimport { ComponentContext__symbol } from '../../component';\nimport { ElementDef } from '../../component/definition';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass CustomComponentContext$<T extends object> extends ComponentContext$<T> {\n\n  get mount(): undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nexport function customElementType<T extends object>(\n    definitionContext: DefinitionContext$<T>,\n): Class {\n\n  const elementDef = definitionContext.get(ElementDef);\n\n  class CustomElement$ extends elementDef.extend.type {\n\n    // Component context reference\n    [ComponentContext__symbol]: CustomComponentContext$<T>;\n\n    constructor() {\n      super();\n\n      const context = new CustomComponentContext$(definitionContext, this);\n\n      context._createComponent();\n      context._created();\n    }\n\n    connectedCallback(): void {\n      super.connectedCallback?.();\n      this[ComponentContext__symbol]._connect();\n    }\n\n    disconnectedCallback(): void {\n      this[ComponentContext__symbol].destroy();\n      super.disconnectedCallback?.();\n    }\n\n  }\n\n  return CustomElement$;\n}\n","import { AfterEvent, EventEmitter, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\n\nexport class WhenComponent<T extends object> {\n\n  readonly onCreated: OnEvent<[ComponentContext<T>]>;\n  readonly readNotifier: AfterEvent<[ComponentNotifier<T>]>;\n\n  constructor() {\n\n    const currentRev = trackValue(0);\n    const created = new EventEmitter<[ComponentContext<T>, number]>();\n\n    this.onCreated = onEventBy(receiver => {\n\n      const receiverRev = currentRev.it + 1;\n\n      created.on({\n        supply: receiver.supply,\n        receive: (eventContext, componentContext, notifiedRev) => {\n          if (notifiedRev < receiverRev) {\n            // Notify only receivers added after the last notification\n            receiver.receive(\n                {\n                  onRecurrent(recurrentReceiver) {\n                    eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                  },\n                },\n                componentContext,\n            );\n          }\n        },\n      });\n\n      ++currentRev.it;\n    });\n    this.readNotifier = currentRev.read().keepThru_(\n        rev => (context, notifiedRev) => {\n          created.send(context, notifiedRev);\n          return rev;\n        },\n    );\n  }\n\n}\n\nexport type ComponentNotifier<T extends object> = (\n    this: void,\n    context: ComponentContext<T>,\n    notifiedRev: number,\n) => number;\n","import { nextArgs, nextSkip, valueProvider } from '@proc7ts/call-thru';\nimport { ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { EventReceiver, EventSupply, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { Class } from '../../common';\nimport { ComponentContext, ComponentContext__symbol, ComponentDef, ComponentMount } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { ComponentContextRegistry } from './component-context-registry.impl';\nimport { MountComponentContext$ } from './component-mount.impl';\nimport { customElementType } from './custom-element.impl';\nimport { DefinitionContextRegistry } from './definition-context-registry.impl';\nimport { DefinitionContext__symbol } from './definition-context.symbol.impl';\nimport { ElementBuilder } from './element-builder.impl';\nimport { postDefSetup } from './post-def-setup.impl';\nimport { WhenComponent } from './when-component.impl';\n\n/**\n * @internal\n */\nexport class DefinitionContext$<T extends object> extends DefinitionContext<T> {\n\n  readonly get: ContextValues['get'];\n  private readonly _def: ComponentDef.Options<T>;\n  readonly _whenComponent = new WhenComponent<T>();\n  private readonly _ready: ValueTracker<boolean>;\n  private readonly _whenReady: OnEvent<[]>;\n  private readonly _perTypeRegistry: ComponentContextRegistry;\n\n  constructor(\n      readonly _bsContext: BootstrapContext,\n      readonly _elementBuilder: ElementBuilder,\n      readonly componentType: ComponentClass<T>,\n  ) {\n    super();\n    this._ready = trackValue(false);\n    this._whenReady = this._ready.read().thru(ready => ready ? nextArgs() : nextSkip());\n    this._def = ComponentDef.of(componentType);\n\n    const definitionContextRegistry = new DefinitionContextRegistry(\n        _bsContext.get(DefinitionContextRegistry).seedIn(this),\n    );\n\n    definitionContextRegistry.provide({ a: DefinitionContext, is: this });\n    this.get = definitionContextRegistry.newValues().get;\n    this._perTypeRegistry = new ComponentContextRegistry(definitionContextRegistry.seedIn(this));\n\n    const whenReady$ = this.whenReady().F;\n    const whenComponent$ = this.whenComponent().F;\n\n    const definitionSetup: DefinitionSetup<T> = {\n      get componentType() {\n        return componentType;\n      },\n      get whenReady() {\n        return whenReady$;\n      },\n      get whenComponent() {\n        return whenComponent$;\n      },\n      perDefinition: spec => definitionContextRegistry.provide(spec),\n      perComponent: spec => this._perTypeRegistry.provide(spec),\n    };\n\n    this._def.setup?.(definitionSetup);\n    postDefSetup(componentType).setup(definitionSetup);\n  }\n\n  get elementType(): Class {\n    return this._elementType();\n  }\n\n  whenReady(): OnEvent<[this]>;\n  whenReady(receiver: EventReceiver<[this]>): EventSupply;\n  whenReady(receiver?: EventReceiver<[this]>): EventSupply | OnEvent<[this]> {\n    return (this.whenReady = (this._whenReady.thru_(valueProvider(this)).once() as OnEvent<[this]>).F)(receiver);\n  }\n\n  mountTo(element: any): ComponentMount<T> {\n    if (element[ComponentContext__symbol]) {\n      throw new Error(`Element ${element} already bound to component`);\n    }\n\n    const context = new MountComponentContext$(this, element);\n\n    context._createComponent();\n\n    const { mount } = context;\n\n    mount.checkConnected();\n    context._created();\n    context.settle();\n\n    return mount;\n  }\n\n  whenComponent(): OnEvent<[ComponentContext<T>]>;\n  whenComponent(receiver: EventReceiver<[ComponentContext<T>]>): EventSupply;\n  whenComponent(receiver?: EventReceiver<[ComponentContext<T>]>): OnEvent<[ComponentContext<T>]> | EventSupply {\n    return (this.whenComponent = this._whenComponent.onCreated.F)(receiver);\n  }\n\n  perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, Deps, Src, Seed>,\n  ): () => void {\n    return this._perTypeRegistry.provide(spec);\n  }\n\n  _newComponentRegistry(): ComponentContextRegistry {\n    return this._bsContext.get(ComponentContextRegistry).append(this._perTypeRegistry);\n  }\n\n  _elementType(): Class {\n    throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  _define(): void {\n    this._def.define?.(this);\n    this._elementBuilder.definitions.send(this);\n    this._elementType = valueProvider(customElementType(this));\n    (this.componentType as any)[DefinitionContext__symbol] = this;\n    this._ready.it = true;\n  }\n\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { EventEmitter } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { DefinitionContext$ } from './definition-context.impl';\n\n/**\n * @internal\n */\nexport interface ElementBuilder {\n  readonly definitions: EventEmitter<[DefinitionContext]>;\n  readonly components: EventEmitter<[ComponentContext]>;\n  buildElement<T extends object>(this: void, componentType: ComponentClass<T>): DefinitionContext<T>;\n}\n\n/**\n * @internal\n */\nexport const ElementBuilder: SingleContextRef<ElementBuilder> = (/*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(newElementBuilder),\n    },\n));\n\nfunction newElementBuilder(bsContext: BootstrapContext): ElementBuilder {\n  return {\n    definitions: new EventEmitter<[DefinitionContext]>(),\n    components: new EventEmitter<[ComponentContext]>(),\n    buildElement<T extends object>(componentType: ComponentClass<T>) {\n\n      const definitionContext = new DefinitionContext$(bsContext, this, componentType);\n\n      definitionContext._define();\n\n      return definitionContext;\n    },\n  };\n\n}\n","import { itsEach, overArray } from '@proc7ts/a-iterable';\nimport { noop, valueProvider } from '@proc7ts/call-thru';\nimport { EventSupply, eventSupply } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nexport interface Unloader {\n  readonly supply: EventSupply;\n  add(adder: () => () => void): () => void;\n}\n\nconst doNotAdd = valueProvider(noop);\n\n/**\n * @internal\n */\nexport function newUnloader(): Unloader {\n\n  const unloads: (() => void)[] = [];\n  let add = (adder: () => () => void): () => void => {\n\n    const unload = adder();\n\n    unloads.push(unload);\n\n    return unload;\n  };\n  const supply = eventSupply(() => {\n    add = doNotAdd;\n    itsEach(\n        overArray(unloads).reverse(),\n        unload => unload(),\n    );\n    unloads.length = 0;\n  });\n\n  return {\n    supply,\n    add(adder) {\n      return add(adder);\n    },\n  };\n}\n","import { ElementBuilder } from '../../boot/impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _definitionQueue: (() => void)[] = [];\n\n  constructor(private readonly _context: FeatureContext) {\n    _context.whenReady(() => {\n      this._definitionQueue.forEach(definition => definition());\n      delete this._definitionQueue;\n    });\n  }\n\n  get customElements(): CustomElements {\n    return this._context.get(CustomElements);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._definitionQueue.push(() => {\n\n      const elementBuilder = this._context.get(ElementBuilder);\n      const defContext = elementBuilder.buildElement(componentType);\n\n      this.customElements.define(componentType, defContext.elementType);\n    });\n  }\n\n}\n","import { nextArg, nextSkip } from '@proc7ts/call-thru';\nimport { ContextRegistry, ContextValueSpec } from '@proc7ts/context-values';\nimport { afterAll, EventReceiver, EventSupply, OnEvent, trackValue } from '@proc7ts/fun-events';\nimport { BootstrapContext } from '../../boot';\nimport {\n  BootstrapContextRegistry,\n  ComponentContextRegistry,\n  DefinitionContextRegistry,\n  ElementBuilder,\n  newUnloader,\n  onPostDefSetup,\n} from '../../boot/impl';\nimport { Class } from '../../common';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\nimport { FeatureLoader } from './feature-loader.impl';\n\n/**\n * @internal\n */\nexport class FeatureContext$ extends FeatureContext {\n\n  readonly _unloader = newUnloader();\n  readonly get: FeatureContext['get'];\n  private readonly _componentRegistry: ComponentRegistry;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      private readonly _loader: FeatureLoader,\n  ) {\n    super();\n\n    const registry = new ContextRegistry<FeatureContext>(_bsContext);\n\n    registry.provide({ a: FeatureContext, is: this });\n    this.get = registry.newValues().get;\n    this._componentRegistry = new ComponentRegistry(this);\n  }\n\n  get feature(): Class {\n    return this._loader.request.feature;\n  }\n\n  whenReady(): OnEvent<[FeatureContext]>;\n  whenReady(receiver: EventReceiver<[FeatureContext]>): EventSupply;\n  whenReady(receiver?: EventReceiver<[FeatureContext]>): OnEvent<[FeatureContext]> | EventSupply {\n    return (this.whenReady = afterAll({\n      st: this._loader.state,\n      bs: trackValue<BootstrapContext>().by(this._bsContext.whenReady()),\n    }).thru(\n        ({\n          st: [ready],\n          bs: [bs],\n        }) => bs && ready ? nextArg(this) : nextSkip(),\n    ).once().F)(receiver);\n  }\n\n  onDefinition(): OnEvent<[DefinitionContext]>;\n  onDefinition(receiver: EventReceiver<[DefinitionContext]>): EventSupply;\n  onDefinition(receiver?: EventReceiver<[DefinitionContext]>): OnEvent<[DefinitionContext]> | EventSupply {\n    return (this.onDefinition = this._bsContext.get(ElementBuilder).definitions.on()\n        .tillOff(this._unloader.supply).F)(receiver);\n  }\n\n  onComponent(): OnEvent<[ComponentContext]>;\n  onComponent(receiver: EventReceiver<[ComponentContext]>): EventSupply;\n  onComponent(receiver?: EventReceiver<[ComponentContext]>): EventSupply | OnEvent<[ComponentContext]> {\n    return (this.onComponent = this._bsContext.get(ElementBuilder).components.on()\n        .tillOff(this._unloader.supply).F)(receiver);\n  }\n\n  provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n  ): () => void {\n    return this._unloader.add(() => this._bsContext.get(BootstrapContextRegistry).provide(spec));\n  }\n\n  perDefinition<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n  ): () => void {\n    return this._unloader.add(() => this._bsContext.get(DefinitionContextRegistry).provide(spec));\n  }\n\n  perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n  ): () => void {\n    return this._unloader.add(() => this._bsContext.get(ComponentContextRegistry).provide(spec));\n  }\n\n  setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]> {\n    return onPostDefSetup(componentType, this._unloader);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._componentRegistry.define(componentType);\n  }\n\n}\n","import { filterIt, mapIt } from '@proc7ts/a-iterable';\nimport { isPresent, nextArgs, NextCall, NextSkip, nextSkip } from '@proc7ts/call-thru';\nimport { ContextValueOpts, ContextValues } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterThe,\n  EventKeeper,\n  nextAfterEvent,\n  OnEventCallChain,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { BootstrapContext } from '../../boot';\nimport { ArraySet, Class } from '../../common';\nimport { FeatureContext } from '../feature-context';\nimport { FeatureContext$ } from './feature-context.impl';\nimport { FeatureClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureKey__symbol = (/*#__PURE__*/ Symbol('feature-key'));\n\n/**\n * @internal\n */\nexport class FeatureKey extends ContextUpKey<AfterEvent<[FeatureLoader?]>, FeatureClause> {\n\n  static of(feature: Class): FeatureKey {\n    // eslint-disable-next-line no-prototype-builtins\n    return feature.hasOwnProperty(FeatureKey__symbol)\n        ? (feature as any)[FeatureKey__symbol]\n        : ((feature as any)[FeatureKey__symbol] = new FeatureKey(feature));\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  private constructor(feature: Class) {\n    super(`feature:${feature.name}`);\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[FeatureLoader?]>,\n          EventKeeper<FeatureClause[]> | FeatureClause,\n          AfterEvent<FeatureClause[]>>,\n  ): AfterEvent<[FeatureLoader?]> | null | undefined {\n    return loadFeature(\n        opts.context.get(BootstrapContext),\n        opts.seed.keepThru(preferredFeatureClause),\n    );\n  }\n\n}\n\nfunction preferredFeatureClause(...clauses: FeatureClause[]): FeatureClause | undefined {\n\n  let required = false;\n  let preferred: FeatureClause | undefined;\n\n  for (const clause of clauses) {\n    switch (clause[1]) {\n    case 'is':\n      required = true;\n      if (!preferred) {\n        preferred = clause;\n      }\n      break;\n    case 'has':\n      preferred = clause;\n      break;\n    case 'needs':\n      required = true;\n    }\n  }\n\n  return required ? preferred : undefined;\n}\n\nfunction loadFeature(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<[FeatureLoader?]> {\n  return afterEventBy<[FeatureLoader?]>(receiver => {\n\n    let origin: Class | undefined;\n    let source: AfterEvent<[FeatureLoader?]> = afterThe();\n    let stageId: Promise<FeatureStageId> = Promise.resolve('idle');\n\n    return afterAll({\n      clause: from,\n      deps: loadFeatureDeps(bsContext, from),\n    }).keepThru_(({ clause: [clause], deps }): NextCall<OnEventCallChain, [FeatureLoader?]> => {\n      if (!clause) {\n        return nextArgs();\n      }\n\n      const [request, , target] = clause;\n\n      if (request.feature === origin) {\n        return nextAfterEvent(source); // Origin didn't change. Reuse the source.\n      }\n\n      origin = request.feature;\n\n      if (target !== origin) {\n        // Originated from replacement feature provider. Reuse its loader.\n        return nextAfterEvent(source = bsContext.get(FeatureKey.of(origin)).keepThru_(\n            loader => {\n              loader!.to(stageId);\n              stageId = loader!.stage;\n              return loader;\n            },\n        ));\n      }\n\n      // Create feature's own loader\n      const ownLoader = new FeatureLoader(bsContext, request, deps).to(stageId);\n      const ownSource = afterThe(ownLoader);\n\n      return nextAfterEvent(source = afterEventBy<[FeatureLoader]>(\n          rcv => ownSource.to(rcv).whenOff(() => {\n            stageId = ownLoader.unload();\n          }),\n      ).share()); // Can be accessed again when reused\n    }).to(receiver);\n  }).keepThru(\n      preventDuplicateLoader(),\n  );\n}\n\nfunction preventDuplicateLoader():\n    (\n        loader?: FeatureLoader,\n    ) => NextCall<OnEventCallChain, [FeatureLoader?]> | NextSkip {\n\n  let lastLoader: FeatureLoader | null | undefined = null; // Initially `null` to differ from `undefined`\n\n  return (loader?: FeatureLoader) => {\n    if (lastLoader === loader) {\n      return nextSkip();\n    }\n    lastLoader = loader;\n\n    if (!loader) {\n      return nextArgs<[FeatureLoader?]>();\n    }\n\n    return nextArgs<[FeatureLoader?]>(loader);\n  };\n}\n\nfunction loadFeatureDeps(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<FeatureLoader[]> {\n  return from.keepThru_(clause => {\n    if (!clause) {\n      return nextArgs();\n    }\n\n    const [{ def }] = clause;\n    const needs = new ArraySet(def.needs);\n\n    if (!needs.size) {\n      return nextArgs();\n    }\n\n    return nextAfterEvent(\n        afterEach(\n            ...mapIt(\n                needs,\n                dep => bsContext.get(FeatureKey.of(dep)),\n            ),\n        ).keepThru_(presentFeatureDeps),\n    );\n  });\n}\n\nfunction presentFeatureDeps(...deps: [FeatureLoader?][]): NextCall<OnEventCallChain, FeatureLoader[]> {\n  return nextArgs<FeatureLoader[]>(\n      ...filterIt<FeatureLoader | undefined, FeatureLoader>(\n          mapIt(deps, dep => dep[0]),\n          isPresent,\n      ),\n  );\n}\n\n/**\n * @internal\n */\nexport class FeatureLoader {\n\n  readonly down: Promise<void>;\n  private _stage: Promise<FeatureStage>;\n  private _down!: () => void;\n  readonly state = trackValue(false);\n\n  constructor(\n      readonly bsContext: BootstrapContext,\n      readonly request: FeatureRequest,\n      readonly deps: FeatureLoader[],\n  ) {\n    this.down = new Promise(resolve => this._down = resolve);\n    this._stage = Promise.resolve(new SetupFeatureStage(this));\n  }\n\n  get stage(): Promise<FeatureStageId> {\n    return this._stage.then(stage => stage.after);\n  }\n\n  get ready(): boolean {\n    return this.state.it;\n  }\n\n  to(stageId: Promise<FeatureStageId>): this {\n\n    const lastStage = this._stage;\n\n    this._stage = stageId.then(id => lastStage.then(stage => stage[id]()));\n\n    return this;\n  }\n\n  async setup(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.setup()));\n  }\n\n  async init(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.init()));\n  }\n\n  async unload(): Promise<FeatureStageId> {\n\n    const prevStage = this._stage;\n\n    delete this._stage; // Unloaded feature should never be accessed again.\n\n    const stage = await prevStage;\n    const stageId = await stage.stop();\n\n    this._down();\n\n    return stageId;\n  }\n\n}\n\ntype FeatureStageId = 'idle' | 'setup' | 'init';\ntype FeatureStageStop = (this: void) => Promise<any>;\n\nabstract class FeatureStage {\n\n  abstract readonly after: FeatureStageId;\n\n  constructor(\n      readonly loader: FeatureLoader,\n      private readonly _stop: FeatureStageStop = () => Promise.resolve(),\n  ) {}\n\n  idle(): Promise<this> {\n    return Promise.resolve(this);\n  }\n\n  abstract setup(): Promise<FeatureStage>;\n\n  abstract init(): Promise<FeatureStage>;\n\n  stop(): Promise<FeatureStageId> {\n    return this._stop().then(() => this.after);\n  }\n\n  protected perDep(action: (dep: FeatureLoader) => Promise<void>): Promise<any> {\n\n    const { deps } = this.loader;\n\n    return Promise.all(deps.map(dep => action(dep)));\n  }\n\n}\n\nclass SetupFeatureStage extends FeatureStage {\n\n  get after(): 'idle' {\n    return 'idle';\n  }\n\n  async setup(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.setup());\n\n    const { bsContext, request: { def } } = this.loader;\n    const context = new FeatureContext$(bsContext, this.loader);\n    const supply = context._unloader.supply;\n\n    def.setup?.(context);\n\n    return new InitFeatureStage(\n        this.loader,\n        context,\n        () => Promise.resolve(supply.off()),\n    );\n  }\n\n  init(): Promise<FeatureStage> {\n    return this.setup().then(stage => stage.init());\n  }\n\n}\n\nclass InitFeatureStage extends FeatureStage {\n\n  get after(): 'setup' {\n    return 'setup';\n  }\n\n  constructor(\n      state: FeatureLoader,\n      private readonly _context: FeatureContext,\n      stop: FeatureStageStop,\n  ) {\n    super(state, stop);\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  async init(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.init());\n\n    const { request: { def } } = this.loader;\n\n    def.init?.(this._context);\n\n    return new ActiveFeatureStage(this);\n  }\n\n}\n\nclass ActiveFeatureStage extends FeatureStage {\n\n  get after(): 'init' {\n    return 'init';\n  }\n\n  constructor(prev: InitFeatureStage) {\n    super(prev.loader, () => prev.stop());\n    prev.loader.state.it = true;\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  init(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n}\n","import { ArraySet, Class, mergeFunctions } from '../../common';\nimport { ComponentDef, ComponentDef__symbol } from '../../component';\nimport { FeatureDef } from '../feature-def';\nimport { FeatureNeedsError } from '../feature-needs-error';\nimport { FeatureKey } from './feature-loader.impl';\nimport { FeatureRequester } from './feature-requester.impl';\n\n/**\n * @internal\n */\nexport type FeatureClause = [FeatureRequest, 'is' | 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport type FeatureNeedClause = [FeatureRequest, 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport class FeatureRequest {\n\n  readonly def: FeatureDef.Options;\n  private _uses = 0;\n\n  constructor(\n      private readonly _requester: FeatureRequester,\n      readonly feature: Class,\n      private _revoke: () => void,\n  ) {\n    this.def = featureDef(feature);\n  }\n\n  request(clauses: readonly FeatureNeedClause[]): this {\n\n    const requester = this._requester;\n    const { registry } = requester;\n    const isClause: FeatureClause = [this, 'is', this.feature];\n\n    this._revokeBy(registry.provide({\n      a: FeatureKey.of(this.feature),\n      is: isClause,\n    }));\n\n    for (const feature of new ArraySet(this.def.has)) {\n\n      const clause: FeatureNeedClause = [this, 'has', feature];\n\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n\n      // Request the provided feature _after_ provider\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n    }\n\n    for (const feature of new ArraySet(this.def.needs)) {\n\n      const clause: FeatureNeedClause = [this, 'needs', feature];\n\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n    }\n\n    this._uses = 1;\n\n    return this;\n  }\n\n  reuse(clauses: readonly FeatureNeedClause[]): this {\n    if (!this._uses) {\n      throw new FeatureNeedsError(clauses.map(([{ feature }, reason, need]) => [feature, reason, need]));\n    }\n\n    ++this._uses;\n\n    return this;\n  }\n\n  unuse(): void {\n    if (!--this._uses) {\n      this._revoke();\n    }\n  }\n\n  private _revokeBy(revoke: () => void): void {\n    this._revoke = mergeFunctions(revoke, this._revoke);\n  }\n\n}\n\nfunction featureDef(featureType: Class): FeatureDef.Options {\n\n  let def = FeatureDef.of(featureType);\n\n  if (ComponentDef__symbol in featureType) {\n    def = FeatureDef.merge(\n        def,\n        {\n          init(context) {\n            context.define(featureType);\n          },\n        },\n    );\n\n    const { feature } = ComponentDef.of(featureType);\n\n    if (feature) {\n      def = FeatureDef.merge(def, feature);\n    }\n\n  }\n\n  return def;\n}\n\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapContextRegistry } from '../../boot/impl';\nimport { Class } from '../../common';\nimport { FeatureNeedClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureRequester__key = (/*#__PURE__*/ new SingleContextKey<FeatureRequester>(\n    'feature-requester',\n    {\n      byDefault: bootstrapDefault(context => new FeatureRequester(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class FeatureRequester {\n\n  static get [ContextKey__symbol](): ContextKey<FeatureRequester> {\n    return FeatureRequester__key;\n  }\n\n  readonly registry: BootstrapContextRegistry;\n  private readonly _map = new Map<Class, FeatureRequest>();\n\n  constructor(context: BootstrapContext) {\n    this.registry = context.get(BootstrapContextRegistry);\n  }\n\n  request(feature: Class, clauses: readonly FeatureNeedClause[] = []): FeatureRequest {\n\n    const existing = this._map.get(feature);\n\n    if (existing) {\n      return existing.reuse(clauses);\n    }\n\n    const request = new FeatureRequest(this, feature, () => this._map.delete(feature));\n\n    this._map.set(feature, request);\n\n    return request.request(clauses);\n  }\n\n}\n","import { OnEvent, onPromise } from '@proc7ts/fun-events';\nimport { ComponentClass, CustomElements, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { definitionContextOf } from './definition-context.symbol.impl';\n\n/**\n * @internal\n */\nexport const WhenDefined__symbol = (/*#__PURE__*/ Symbol('when-defined'));\n\n/**\n * @internal\n */\nexport function whenDefined<T extends object>(\n    bsContext: BootstrapContext,\n    componentType: ComponentClass<T>,\n): OnEvent<[DefinitionContext<T>]> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(WhenDefined__symbol)) {\n    return (componentType as any)[WhenDefined__symbol];\n  }\n\n  const result: OnEvent<[DefinitionContext<T>]> = onPromise(\n      Promise.resolve(bsContext.whenReady())\n          .then(() => bsContext.get(CustomElements).whenDefined(componentType))\n          .then(() => definitionContextOf(componentType)),\n  );\n\n  return (componentType as any)[WhenDefined__symbol] = result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { MultiContextKey, MultiContextRef } from '@proc7ts/context-values';\n\n/**\n * Custom element attribute change callback signature.\n *\n * This function is called whenever a new attribute value assigned.\n *\n * @category Feature\n * @typeparam T  A type of component.\n */\nexport type AttributeChangedCallback<T extends object> =\n/**\n * @param component  Component instance.\n * @param newValue  New attribute value, or `null` when attribute removed.\n * @param oldValue  Previous attribute value, or `null` if attribute did not exist.\n */\n    (this: void, component: T, newValue: string | null, oldValue: string | null) => void;\n\n/**\n * Custom element attribute descriptor.\n *\n * Descriptors are to be registered in component's definition context in order to make them available to component.\n * The {@link Attribute @Attribute}, {@link Attributes @Attributes}, and {@link AttributeChanged @AttributeChanged}\n * decorators are doing so.\n *\n * @category Feature\n */\nexport interface AttributeDescriptor<T extends object = any> {\n\n  /**\n   * Attribute name.\n   */\n  readonly name: string;\n\n  /**\n   * Attribute change callback that will be called each time attribute value changes.\n   */\n  readonly change: AttributeChangedCallback<T>;\n\n}\n\n/**\n * A key of component definition context value containing attribute descriptors.\n *\n * @category Feature\n */\nexport const AttributeDescriptor: MultiContextRef<AttributeDescriptor> = (\n    /*#__PURE__*/ new MultiContextKey<AttributeDescriptor>('attribute-descriptor')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nexport const AttributePath__root = (/*#__PURE__*/ Symbol('attribute'));\n\n/**\n * A path to the named attribute state.\n *\n * @category Feature\n */\nexport type AttributePath = readonly [keyof AttributePath__rootKeys, string];\n\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name  Target attribute name.\n *\n * @return Attribute state path.\n */\nexport function attributePathTo(name: string): AttributePath {\n  return [AttributePath__root, name];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface AttributePath__rootKeys {\n  [AttributePath__root]: true;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { StatePath } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeChangedCallback } from './attribute-descriptor';\nimport { attributePathTo } from './attribute-path';\n\n/**\n * @internal\n */\nexport function attributeStateUpdate<T extends object>(\n    name: string,\n    updateState: boolean | AttributeUpdateReceiver<T> | StatePath = true,\n): AttributeChangedCallback<T> {\n  if (updateState === false) {\n    return noop;\n  }\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = attributePathTo(name);\n    const update: AttributeUpdateReceiver<T> = updateState === true ? updateAttributeState : updateState;\n\n    return (component: T, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component: T, newValue, oldValue) => updateAttributeState(component, updateState, newValue, oldValue);\n}\n\nfunction updateAttributeState<T extends object>(\n    component: T,\n    path: StatePath,\n    newValue: string | null,\n    oldValue: string | null,\n): void {\n  ComponentContext.of(component).updateState(path, newValue, oldValue);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Converts property name to _dash-style_ attribute name.\n *\n * - Any ASCII uppercase letter A to Z is transformed into a dash followed by its lowercase counterpart;\n * - other characters are left unchanged.\n *\n * @category Feature\n * @param name  Property name to convert.\n *\n * @returns  _dash-style_ attribute name.\n */\nexport function property2attributeName(name: string): string {\n\n  let result: string | undefined;\n\n  for (let i = 0; i < name.length; ++i) {\n\n    const c = name[i];\n\n    if (c <= 'Z' && c >= 'A') {\n      if (!result) {\n        // Allocate result on first conversion\n        result = name.substring(0, i);\n      }\n      result += '-' + c.toLowerCase();\n    } else if (result) {\n      result += c;\n    }\n  }\n\n  return result || name;\n}\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { ArraySet, Class, mergeFunctions } from '../../common';\nimport { isArray } from '../../common/types.impl';\nimport { ComponentContext, ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\n\nconst AttributeRegistry__key = (/*#__PURE__*/ new SingleContextKey<AttributeRegistry>('attribute-registry'));\n\n/**\n * @internal\n */\nexport class AttributeRegistry<T extends object = any> {\n\n  static get [ContextKey__symbol](): ContextKey<AttributeRegistry> {\n    return AttributeRegistry__key;\n  }\n\n  private _attrs?: Map<string, AttributeChangedCallback<T>>;\n\n  constructor(private readonly _context: DefinitionContext) {\n  }\n\n  get attrs(): Map<string, AttributeChangedCallback<T>> {\n    if (this._attrs) {\n      return this._attrs;\n    }\n\n    const attrs = new Map<string, AttributeChangedCallback<T>>();\n\n    this._context.get(AttributeDescriptor).forEach(desc => {\n\n      const { name, change } = desc;\n\n      attrs.set(name, mergeFunctions(attrs.get(name), change));\n    });\n\n    return this._attrs = attrs;\n  }\n\n  define(elementType: Class): void {\n\n    const attrs = this.attrs;\n\n    if (!attrs.size) {\n      return; // No attributes defined\n    }\n\n    Object.defineProperty(elementType, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      value: observedAttributes(elementType, attrs.keys()),\n    });\n    Object.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n      configurable: true,\n      enumerable: true,\n      value: attributeChangedCallback(elementType, attrs),\n    });\n  }\n\n  mount(mount: ComponentMount<T>): void {\n\n    const element = mount.element;\n    const attrs = this.attrs;\n    const attributeFilter = Array.from(attrs.keys());\n\n    if (!attributeFilter.length) {\n      return; // No attributes defined\n    }\n\n    const MutationObserver = this._context.get(BootstrapWindow).MutationObserver;\n    const observer = new MutationObserver(\n        records => records.forEach(\n            record => {\n\n              const attributeName = record.attributeName as string;\n\n              return attrs.get(attributeName)!(\n                  ComponentContext.of<T>(element).component,\n                  element.getAttribute(attributeName),\n                  record.oldValue,\n              );\n            },\n        ),\n    );\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter,\n      attributeOldValue: true,\n    });\n  }\n\n}\n\n/**\n * @internal\n */\ntype ElementAttributeChanged = (\n    this: any,\n    name: string,\n    oldValue: string | null,\n    newValue: string | null,\n) => void;\n\n/**\n * @internal\n */\nfunction observedAttributes(\n    elementType: Class,\n    attrs: Iterable<string>,\n): readonly string[] {\n\n  const alreadyObserved: readonly string[] | undefined = (elementType as any).observedAttributes;\n\n  return Array.from(\n      isArray<string>(alreadyObserved)\n          ? new ArraySet(alreadyObserved).addAll(attrs).items\n          : attrs,\n  );\n}\n\n/**\n * @internal\n */\nfunction attributeChangedCallback<T extends object>(\n    elementType: Class,\n    attrs: Map<string, AttributeChangedCallback<T>>,\n): ElementAttributeChanged {\n\n  const prevCallback: ElementAttributeChanged | undefined = elementType.prototype.attributeChangedCallback;\n\n  if (!prevCallback) {\n    return function (this: any, name, oldValue, newValue) {\n      attrs.get(name)!(ComponentContext.of<T>(this).component, newValue, oldValue);\n    };\n  }\n\n  return function (this: any, name, oldValue, newValue) {\n\n    const attrChanged = attrs.get(name);\n\n    if (attrChanged) {\n      attrChanged(ComponentContext.of<T>(this).component, newValue, oldValue);\n    } else {\n      prevCallback.call(this, name, oldValue, newValue);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { AttributeRegistry } from './attribute-registry.impl';\n\n/**\n * @internal\n */\nconst AttributesSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perDefinition({ as: AttributeRegistry });\n    setup.onDefinition(definitionContext => {\n      // Define element prototype attributes\n      definitionContext.whenReady(\n          ({ elementType }) => definitionContext.get(AttributeRegistry).define(elementType),\n      );\n    });\n    setup.onComponent(componentContext => {\n\n      const mount = componentContext.mount;\n\n      if (mount) {\n        // Mount element attributes\n        componentContext.get(AttributeRegistry).mount(mount);\n      }\n    });\n  },\n};\n\n/**\n * A feature adding attributes to custom elements.\n *\n * This feature is enabled automatically whenever an `@Attribute`, `@Attributes`, or `@AttributeChanged` decorator\n * applied to component.\n *\n * @category Feature\n */\nexport class AttributesSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return AttributesSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeDescriptor } from './attribute-descriptor';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributesSupport } from './attributes-support.feature';\n\n/**\n * Creates a decorator for component's property that accesses custom element's attribute.\n *\n * The decorated property accesses corresponding attribute on read, and updates it on setting. `null` value corresponds\n * to absent attribute. Setting to `null` removes corresponding attribute.\n *\n * This decorator automatically enables [[AttributesSupport]] feature.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Attribute definition or just an attribute name (either _camelCase_ or _dash-style_).\n *\n * @return Component property decorator.\n */\nexport function Attribute<T extends ComponentClass>(\n    def?: AttributeDef<InstanceType<T>> | string,\n): ComponentPropertyDecorator<string | null, T> {\n  return ComponentProperty(({ type, key }) => {\n\n    const descriptor = parseAttributeDescriptor(type.prototype, key, def);\n    const { name } = descriptor;\n\n    return {\n      componentDef: {\n        feature: {\n          needs: AttributesSupport,\n        },\n        setup(setup) {\n          setup.perDefinition({ a: AttributeDescriptor, is: descriptor });\n        },\n      },\n      get(component: InstanceType<T>): string | null {\n        return ComponentContext.of(component).element.getAttribute(name);\n      },\n      set(component: InstanceType<T>, newValue: string | null) {\n\n        const { element }: { element: Element } = ComponentContext.of(component);\n\n        if (newValue != null) {\n          element.setAttribute(name, newValue);\n        } else {\n          element.removeAttribute(name);\n        }\n      },\n    };\n  });\n}\n","import { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\nimport { property2attributeName } from './property2attribute-name';\n\n/**\n * @internal\n */\nexport function parseAttributeDescriptor<T extends ComponentClass>(\n    target: InstanceType<T>,\n    propertyKey: string | symbol,\n    opts?: AttributeDef<InstanceType<T>> | string,\n): AttributeDescriptor<InstanceType<T>> {\n\n  let name: string;\n  let change: AttributeChangedCallback<InstanceType<T>>;\n\n  if (typeof opts === 'string') {\n    name = property2attributeName(opts);\n    change = attributeStateUpdate(name);\n  } else {\n    if (opts && opts.name) {\n      name = property2attributeName(opts.name);\n    } else if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n          'Attribute name is required as property key is not a string: '\n          + `${target.constructor.name}.prototype.${String(propertyKey)}`,\n      );\n    } else {\n      name = property2attributeName(propertyKey);\n    }\n\n    change = attributeStateUpdate(name, opts && opts.updateState);\n  }\n\n  return { name, change };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { StateTracker } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nconst ComponentState__key = (/*#__PURE__*/ new SingleContextKey<ComponentState>('component-state'));\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { eventSupplyOf } from '@proc7ts/fun-events';\nimport { ComponentContext, StateUpdater } from '../../component';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { ComponentState } from './component-state';\n\n/**\n * @internal\n */\nconst StateSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentState,\n      by(context: ComponentContext) {\n\n        const state = new ComponentState();\n\n        eventSupplyOf(context).whenOff(reason => state.done(reason));\n\n        return state;\n      },\n    });\n    setup.perComponent({\n      a: StateUpdater,\n      by(state: ComponentState) {\n        return state.update;\n      },\n      with: [ComponentState],\n    });\n  },\n};\n\n/**\n * Component state support feature.\n *\n * When enabled, it registers the following component context values:\n *\n * - [[StateUpdater]] that allows to update the component state, and\n * - [[ComponentState]] that allows to track component state changes.\n *\n * Other features would use this to notify when the state changes. E.g. [[DomPropertiesSupport]]\n * and [[AttributesSupport]] features issue state updates when needed.\n *\n * @category Feature\n */\nexport class StateSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StateSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport {\n  EventReceiver,\n  EventSupply,\n  eventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  StatePath,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { attributePathTo } from './attribute-path';\n\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly [EventSupply__symbol] = eventSupply();\n\n  constructor(\n      private readonly _context: ComponentContext,\n      private readonly _name: string,\n      private readonly _path: StatePath,\n  ) {\n    super();\n  }\n\n  get it(): string | null {\n    return this._context.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (!eventSupplyOf(this).isOff) {\n      if (value == null) {\n        this._context.element.removeAttribute(this._name);\n      } else {\n        this._context.element.setAttribute(this._name, value);\n      }\n    }\n  }\n\n  on(): OnEvent<[string | null, string | null]>;\n  on(receiver: EventReceiver<[string | null, string | null]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[string | null, string | null]>,\n  ): OnEvent<[string | null, string | null]> | EventSupply {\n    return (this.on = this._context.get(ComponentState).track(this._path).onUpdate().thru(\n        (_path, newValue, oldValue) => nextArgs(newValue, oldValue),\n    ).tillOff(this).F)(receiver);\n  }\n\n}\n\n/**\n * Creates a tracker of custom element's attribute value.\n *\n * Requires [[AttributesSupport]] feature to be enabled and attribute to be defined. E.g. with {@link Attribute\n * @Attribute}, {@link AttributeChanged @AttributeChanged}, or {@link Attributes @Attributes} decorator.\n *\n * @category Feature\n * @param context  Target component context.\n * @param name  Attribute name.\n * @param path  Custom attribute state path.\n *\n * @returns New attribute value tracker.\n */\nexport function trackAttribute(\n    context: ComponentContext,\n    name: string,\n    path: StatePath = attributePathTo(name),\n): ValueTracker<string | null> {\n  return new AttributeTracker(context, name, path);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const DomPropertyPath__root = (/*#__PURE__*/ Symbol('dom-property'));\n\n/**\n * A path to the named DOM property state.\n *\n * @category Feature\n */\nexport type DomPropertyPath<K extends PropertyKey = PropertyKey> = readonly [keyof DomPropertyPath__rootKeys, K];\n\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @param key  Target property key.\n *\n * @return DOM property state path.\n */\nexport function domPropertyPathTo<K extends PropertyKey = PropertyKey>(key: K): DomPropertyPath<K> {\n  return [DomPropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface DomPropertyPath__rootKeys {\n  [DomPropertyPath__root]: true;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs, nextSkip, valueByRecipe } from '@proc7ts/call-thru';\nimport { EventSender, isEventSender, OnEvent, onSupplied, StatePath } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\n\n/**\n * Element rendering definition.\n *\n * This is either a {@link RenderDef.Spec rendering specifier}, or its {@link RenderDef.Provider provider function}.\n *\n * @category Feature\n */\nexport type RenderDef =\n    | RenderDef.Spec\n    | RenderDef.Provider;\n\nexport namespace RenderDef {\n\n  /**\n   * Rendering options.\n   */\n  export interface Options {\n\n    /**\n     * When to start the rendering.\n     *\n     * One of:\n     * - `settled` (the default) - start rendering when component is {@link ComponentContext.settled settled}.\n     * - `connected` - start rendering when component's element is {@link ComponentContext.connected connected}\n     *   to document.\n     */\n    readonly when?: 'settled' | 'connected';\n\n    /**\n     * Reports rendering error. E.g. a render shot execution failure.\n     *\n     * @param messages  Error messages to report.\n     */\n    error?(...messages: any[]): void;\n\n  }\n\n  /**\n   * Rendering specifier.\n   */\n  export interface Spec extends Options {\n\n    /**\n     * A trigger that issues rendering.\n     *\n     * This can be useful e.g. when component has multiple independent sub-views.\n     *\n     * This can be one of the following:\n     * - A path to component state part the renderer should track. The rendering would trigger only when the target\n     *   state part is updated. This requires {@link StateSupport component state support} to be enabled.\n     * - Arbitrary event sender. The rendering would be triggered on any event from this sender.\n     *\n     * A root state path is tracked when omitted.\n     *\n     * When trigger is a root path (the default value), then the rendering will be triggered by any state update.\n     * Except for updates of sub-states inside {@link RenderPath__root}.\n     */\n    readonly on?: StatePath | EventSender<[]>;\n\n  }\n\n  /**\n   * Rendering specifier provider signature.\n   */\n  export type Provider =\n  /**\n   * @param context  A context of component to render.\n   *\n   * @returns Rendering specifier.\n   */\n      (\n          this: void,\n          context: ComponentContext,\n      ) => RenderDef.Spec;\n\n}\n\n/**\n * A root path to sub-states updates to which will be ignored by default.\n *\n * This can be used to create sub-states that won't trigger rendering occasionally, but only when requested explicitly.\n *\n * @category Feature\n */\nexport const RenderPath__root = (/*#__PURE__*/ Symbol('render'));\n\n/**\n * @category Feature\n */\nexport const RenderDef = {\n\n  /**\n   * Builds a rendering specifier for component by its definition.\n   *\n   * @param context  A context of component to render.\n   * @param def  Arbitrary rendering definition.\n   *\n   * @returns Rendering specifier.\n   */\n  spec(\n      this: void,\n      context: ComponentContext,\n      def: RenderDef,\n  ): RenderDef.Spec {\n    return valueByRecipe(def, context);\n  },\n\n  /**\n   * Fulfills rendering specifier with the given defaults.\n   *\n   * @param base  Base rendering specifier to fulfill.\n   * @param defaults  Defaults that will be applied unless defined in `base` specifier.\n   *\n   * @return `base` rendering specifier fulfilled by `defaults`.\n   */\n  fulfill(this: void, base: RenderDef.Spec, defaults: RenderDef.Spec = {}): RenderDef.Spec {\n\n    const { on = defaults.on, error } = base;\n\n    return {\n      on,\n      error: error ? error.bind(base) : defaults.error && defaults.error.bind(defaults),\n    };\n  },\n\n  /**\n   * Builds a trigger issuing rendering updates.\n   *\n   * @param context  Rendered component context.\n   * @param spec  Rendering specifier.\n   *\n   * @returns `OnEvent` sender that sends an event each time the rendering required.\n   */\n  trigger(\n      this: void,\n      context: ComponentContext,\n      spec: RenderDef.Spec = {},\n  ): OnEvent<[]> {\n\n    const { on = [] } = spec;\n\n    if (typeof on === 'object' && isEventSender(on)) {\n      return onSupplied(on).tillOff(context);\n    }\n\n    const trigger = context\n        .get(ComponentState)\n        .track(on)\n        .onUpdate()\n        .tillOff(context);\n\n    if (Array.isArray(on) && !on.length) {\n      return trigger.thru_(\n          (path: StatePath.Normalized) => path[0] === RenderPath__root ? nextSkip : nextArgs(),\n      );\n    }\n\n    return trigger;\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\n\nimport { valueProvider } from './value-providers';\n\n/**\n * A recipe of value evaluation.\n *\n * This is either a value as-is, or its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeparam T  Evaluated value type. This can not be a function.\n * @typeparam P  A type of parameters tuple required for value evaluation.\n */\nexport type ValueRecipe<T, P extends any[] = []> =\n    | T\n    | ValueRecipe.Evaluator<T, P>;\n\nexport namespace ValueRecipe {\n\n  /**\n   * Value evaluator signature.\n   *\n   * @typeparam T  Evaluated value type. This can not be a function.\n   * @typeparam P  A type of parameters tuple required for value evaluation.\n   */\n  export type Evaluator<T, P extends any[] = []> =\n  /**\n   * @param args  Parameters required for value evaluation.\n   *\n   * @returns Evaluated value.\n   */\n      (this: void, ...args: P) => T;\n\n}\n\n/**\n * @internal\n */\nfunction isValueEvaluator<T, P extends any[]>(\n    value: ValueRecipe<T, P>,\n): value is ValueRecipe.Evaluator<T, P> {\n  return typeof value === 'function';\n}\n\n/**\n * Evaluates a value by its recipe.\n *\n * @typeparam T  Evaluated value type. This can not be a function.\n * @typeparam P  A type of parameters tuple required for value evaluation.\n * @param recipe  Value evaluation recipe.\n * @param args  Parameters required for value evaluation.\n *\n * @returns Either value itself, or the one evaluated by the given evaluator recipe.\n */\nexport function valueByRecipe<T, P extends any[]>(\n    recipe: ValueRecipe<T, P>,\n    ...args: P\n): T {\n  return (/*#__INLINE__*/ isValueEvaluator(recipe)) ? recipe(...args) : recipe;\n}\n\n/**\n * Converts a value recipe to its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeparam T  Evaluated value type. This can not be a function.\n * @typeparam P  A type of parameters tuple required for value evaluation.\n * @param recipe  Value recipe to convert.\n *\n * @returns Either evaluator itself, or the one evaluating to the given value.\n */\nexport function valueRecipe<T, P extends any[]>(recipe: ValueRecipe<T, P>): ValueRecipe.Evaluator<T, P> {\n  return (/*#__INLINE__*/ isValueEvaluator(recipe)) ? recipe : valueProvider(recipe);\n}\n","import { noop } from '@proc7ts/call-thru';\nimport { EventSupply } from '@proc7ts/fun-events';\nimport { immediateRenderScheduler, RenderExecution } from '@proc7ts/render-scheduler';\nimport { DefaultRenderScheduler } from '../../boot/globals';\nimport { ComponentContext } from '../../component';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * @internal\n */\nconst enum RenderStatus {\n  Cancelled = -1,\n  Complete = 0,\n  Pending = 1,\n  Scheduled = 2,\n}\n\n/**\n * @internal\n */\nexport class ElementRenderCtl$ implements ElementRenderCtl {\n\n  private readonly _renders = new Set<() => void>();\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  renderBy(\n      renderer: ElementRenderer,\n      def: RenderDef = {},\n  ): EventSupply {\n\n    const spec = RenderDef.spec(this._context, def);\n    const trigger = RenderDef.trigger(this._context, spec);\n    const schedule = this._context.get(DefaultRenderScheduler)({\n      ...RenderDef.fulfill(spec),\n      node: this._context.element,\n    });\n    const whenConnected = spec.when === 'connected';\n    let status = RenderStatus.Pending;\n    const startRendering = (): 0 | void => status /* there is an update to render */ && scheduleRenderer();\n    const onUpdate = whenConnected\n        ? () => this._context.connected && scheduleRenderer()\n        : () => this._context.settled && scheduleRenderer();\n    const supply = trigger\n        .to(onUpdate)\n        .needs(this._context)\n        .whenOff(cancelRenderer);\n\n    (whenConnected ? this._context.whenConnected() : this._context.whenSettled()).to(startRendering);\n\n    const immediateSchedule = immediateRenderScheduler();\n\n    this._renders.add(renderNow);\n\n    return supply.whenOff(() => this._renders.delete(renderNow));\n\n    function scheduleRenderer(): void {\n      status = RenderStatus.Scheduled;\n      schedule(renderElement);\n    }\n\n    function renderNow(): void {\n      immediateSchedule(renderElement);\n    }\n\n    function cancelRenderer(): void {\n      if (status === RenderStatus.Scheduled) { // Scheduled, but not rendered yet\n        schedule(noop);\n      }\n      status = RenderStatus.Cancelled;\n    }\n\n    function renderElement(execution: RenderExecution): void {\n      if (status > RenderStatus.Complete) { // Prevent excessive rendering\n        status = RenderStatus.Complete;\n        for (; ;) {\n\n          const newRenderer = renderer(execution);\n\n          if (newRenderer === renderer || typeof newRenderer !== 'function') {\n            break;\n          }\n\n          renderer = newRenderer;\n        }\n      }\n    }\n  }\n\n  renderNow(): void {\n    this._renders.forEach(render => render());\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { EventSupply } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ElementRenderCtl$ } from './element-render-ctl.impl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A render control of component's element.\n *\n * Controls rendering by {@link ElementRenderer element renderers}.\n *\n * Available in component context. Requires {@link StateSupport state support} to be enabled.\n *\n * @category Feature\n */\nexport interface ElementRenderCtl {\n\n  /**\n   * Enables component element rendering by the given `renderer`.\n   *\n   * A `renderer` call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n   *\n   * @param renderer  Element renderer function.\n   * @param def  Optional element rendering definition.\n   *\n   * @returns Render shots supply. Element `renderer` will stop rendering once this supply is cut off.\n   */\n  renderBy(\n      renderer: ElementRenderer,\n      def?: RenderDef,\n  ): EventSupply;\n\n  /**\n   * Executes scheduled element render shots immediately.\n   *\n   * Uses `immediateRenderScheduler` for that.\n   *\n   * Does not execute element renderers that are not scheduled. I.e. if no corresponding state updates happened.\n   */\n  renderNow(): void;\n\n}\n\n/**\n * A key of component context value containing {@link ElementRenderCtl element render control}.\n *\n * @category Feature\n */\nexport const ElementRenderCtl: ContextRef<ElementRenderCtl> = (\n    /*#__PURE__*/ new SingleContextKey<ElementRenderCtl>(\n        'element-render-ctl',\n        {\n          byDefault(values) {\n            return new ElementRenderCtl$(values.get(ComponentContext));\n          },\n        },\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextRef, ContextValues, SingleContextKey } from '@proc7ts/context-values';\nimport { trackValue } from '@proc7ts/fun-events';\nimport { RenderSchedule, RenderScheduleOptions, RenderShot } from '@proc7ts/render-scheduler';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A signature of element render scheduler.\n *\n * Schedules render shots to be executed by {@link ElementRenderCtl element render control}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport type ElementRenderScheduler =\n/**\n * @param options  Options of constructed element render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: ElementRenderScheduleOptions) => RenderSchedule;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link ElementRenderScheduler element render scheduler} when constructing new render schedule.\n *\n * Generic `RenderSchedule` options are ignored.\n *\n * @category Feature\n */\nexport interface ElementRenderScheduleOptions extends RenderScheduleOptions, RenderDef.Options {\n\n  /**\n   * When to start the rendering.\n   *\n   * One of:\n   * - `settled` - start rendering when component is {@link ComponentContext.settled settled}.\n   * - `connected` (the default) - start rendering when component's element is {@link ComponentContext.connected\n   *   connected} to document.\n   */\n  readonly when?: 'settled' | 'connected';\n\n  /**\n   * Reports rendering error. E.g. a render shot execution failure.\n   *\n   * @param messages  Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * @internal\n */\nfunction newElementRenderScheduler(context: ContextValues): ElementRenderScheduler {\n\n  const renderCtl = context.get(ElementRenderCtl);\n\n  return (opts = {}): RenderSchedule => {\n\n    const recentShot = trackValue<RenderShot>(noop);\n    const renderer: ElementRenderer = execution => {\n      recentShot.it(execution);\n    };\n\n    renderCtl.renderBy(renderer, RenderDef.fulfill({ on: recentShot.on() }, opts));\n\n    return (shot: RenderShot): void => {\n      recentShot.it = execution => shot(execution); // Ensure render shot always updated\n    };\n  };\n}\n\n/**\n * A key of component context value containing {@link ElementRenderScheduler element render scheduler}.\n *\n * @category Feature\n */\nexport const ElementRenderScheduler: ContextRef<ElementRenderScheduler> = (\n    /*#__PURE__*/ new SingleContextKey<ElementRenderScheduler>(\n        'element-render-scheduler',\n        {\n          byDefault: newElementRenderScheduler,\n        },\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { RenderExecution } from '@proc7ts/render-scheduler';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { StateSupport } from '../state';\nimport { ElementRenderCtl } from './element-render-ctl';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * Component property decorator that declares a rendering method for the component.\n *\n * The decorated method call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n *\n * The decorated method should have no arguments. It may return either nothing, or a function. In the latter case the\n * returned function will be called immediately to render the element. It may, in turn, return a renderer function,\n * and so on.\n *\n * This decorator automatically enables [[StateSupport]] feature.\n *\n * Enables rendering with {@link ElementRenderCtl.renderBy element render control}.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Non-mandatory render definition.\n *\n * @returns Component method decorator.\n */\nexport function Render<T extends ComponentClass>(\n    def?: RenderDef,\n): ComponentPropertyDecorator<(execution: RenderExecution) => ElementRenderer | void, T> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      feature: {\n        needs: StateSupport,\n      },\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(() => {\n\n            const { component } = context;\n            const renderer = get(component).bind(component);\n\n            context.get(ElementRenderCtl).renderBy(renderer, def);\n          });\n        });\n      },\n    },\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * Component shadow content root.\n *\n * @category Feature\n */\nexport type ShadowContentRoot = ShadowRoot;\n\n/**\n * A key of component context value containing a shadow content root instance.\n *\n * This is only available when the component is decorated with {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Feature\n */\nexport const ShadowContentRoot: SingleContextRef<ShadowContentRoot> = (\n    /*#__PURE__*/ new SingleContextKey<ShadowContentRoot>('shadow-content-root')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * An event related to element's shadow DOM.\n *\n * The following event types supported:\n * - `wesib:shadowAttached` is dispatched when a shadow root is attached to element.\n *   In particular, it is dispatched for components decorated with {@link AttachShadow @AttachShadow}.\n *   The event is dispatched when component is connected for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Feature\n */\nexport class ShadowDomEvent extends Event {\n\n  /**\n   * Shadow root this event relates to.\n   */\n  get shadowRoot(): ShadowRoot {\n    return (this.target as Element).shadowRoot as ShadowRoot;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { ComponentContext } from '../../component';\nimport { ShadowContentDef } from './attach-shadow.decorator';\n\n/**\n * Shadow root builder function type.\n *\n * An instance of this function is available in component context and is used by {@link AttachShadow @AttachShadow}\n * decorator to attach shadow root to decorated component's custom element.\n *\n * By default, if shadow root already exists for the component's element, it uses it.\n *\n * Dispatches a `wesib:shadowAttached` event for the found or attached shadow root.\n *\n * @category Feature\n */\nexport type ShadowRootBuilder =\n/**\n * @param context  Target component context.\n * @param init  Shadow root initialization options.\n *\n * @returns A shadow root instance for target component, or `null`/`undefined` if one can not be attached.\n */\n    (context: ComponentContext, init: ShadowContentDef) => ShadowRoot | null | undefined;\n\n/**\n * A key of component context value containing a shadow root builder instance.\n *\n * @category Feature\n */\nexport const ShadowRootBuilder: FnContextRef<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>>(\n        'shadow-root-builder',\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { ShadowDomEvent } from './shadow-dom-event';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * @internal\n */\nconst ShadowDomSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: ShadowRootBuilder, is: attachShadow });\n  },\n};\n\n/**\n * Shadow root support feature.\n *\n * This feature is automatically enabled when {@link AttachShadow @AttachShadow} decorator is used.\n *\n * @category Feature\n */\nexport class ShadowDomSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ShadowDomSupport__feature;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction attachShadow(context: ComponentContext, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const element = context.element;\n  const shadowRoot = shadowRootOf(element, init);\n\n  if (shadowRoot) {\n    (shadowRoot as any)[ComponentContext__symbol] = context;\n    context.whenConnected(() => context.dispatchEvent(new ShadowDomEvent(\n        'wesib:shadowAttached',\n        { bubbles: true },\n    )));\n  }\n\n  return shadowRoot;\n}\n\n/**\n * @internal\n */\nfunction shadowRootOf(element: Element, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const existing = element.shadowRoot;\n\n  if (existing) {\n    // Shadow root already attached. Using it.\n    return existing;\n  }\n  if ('attachShadow' in element) {\n    return element.attachShadow(init);\n  }\n\n  return; // Unable to attach shadow root.\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../../common';\nimport { Component, ComponentContext, ComponentDecorator, ContentRoot } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ShadowContentRoot } from './shadow-content-root';\nimport { ShadowDomSupport } from './shadow-dom-support.feature';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * @internal\n */\nconst defaultShadowContentDef: ShadowContentDef = { mode: 'open' };\n\n/**\n * Shadow content root definition.\n *\n * This is a readonly component shadow root initialization options.\n *\n * @category Feature\n */\nexport type ShadowContentDef = Readonly<ShadowRootInit>;\n\n/**\n * Creates a component decorator that attaches shadow root to decorated component instance.\n *\n * The returned component decorator enables [[ShadowDomSupport]] feature and attaches shadow content root to the\n * component.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Shadow content root definition. Uses `mode: 'open'` by default.\n *\n * @returns New component decorator.\n */\nexport function AttachShadow<T extends ComponentClass = Class>(\n    def: ShadowContentDef = defaultShadowContentDef,\n): ComponentDecorator<T> {\n  return Component({\n    setup(setup) {\n      setup.perComponent(\n          {\n            a: ShadowContentRoot,\n            by(ctx: ComponentContext<InstanceType<T>>) {\n              return ctx.get(ShadowRootBuilder)(ctx, def);\n            },\n          },\n      );\n      setup.perComponent({ // Content root is an alias of shadow root when present.\n        a: ContentRoot,\n        by(context: ComponentContext<InstanceType<T>>) {\n          return context.get(ShadowContentRoot, { or: null });\n        },\n      });\n    },\n    feature: { needs: ShadowDomSupport },\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { NamespaceDef } from '@proc7ts/namespace-aliaser';\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nexport const Wesib__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns',\n    'b',\n    'wesib',\n));\n","import { HthvItem } from './hthv-item';\n\n/**\n * @internal\n */\nexport interface HthvPartial<I extends HthvItem<any, any, any> = HthvItem> {\n  $: I['$'];\n  n?: I['n'];\n  t?: I['t'];\n  v: I['v'];\n  x?: I['x'];\n  p?: I['p'];\n  pl?: I['pl'];\n}\n\n/**\n * @internal\n */\nexport function hthvItem<I extends HthvItem<any, any, any>>(\n    {\n      $,\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<I>,\n): I {\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as I;\n}\n","import { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam(\n    {\n      p,\n      pl,\n    }: HthvItem,\n    param: HthvParamItem,\n): void {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","import { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = config.delimiterOf(c);\n\n    return c;\n  };\n}\n","import { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (datePattern.test(input.s)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","/**\n * @internal\n */\nexport const parseNone = (): false => false;\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseDateTime } from './parse-date-time';\nimport { parseNone } from './parse-none';\nimport { quotedStringParser } from './quoted-string-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport interface ItemParserOpts {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseQuotedString = quotedStringParser(config);\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem))); // eslint-disable-line curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (config.delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    config: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (config.delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment(config: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = config.delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = config.delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser(config: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(config.delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserOpts = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport { HthvDelimitConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  delimiterOf(char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n    }: {\n      delimit?: HthvDelimitConfig;\n    } = {},\n): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = (/*#__PURE__*/ buildParserConfig());\n\n/**\n * @internal\n */\nexport const commentParserConfig = (/*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n}));\n","/**\n * @packageDocumentation\n * @module @proc7ts/http-header-value\n */\nimport { HthvDelimiterChar } from './hthv-delimiter';\nimport { HthvItem } from './hthv-item';\nimport { hthvItem } from './hthv-partial.impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeparam N  Whether parsed items have {@link HthvItem.n names}.\n * @typeparam T  Whether parsed items have {@link HthvItem.t tags}.\n * @typeparam P  Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    N extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    T extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    P extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value  HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<N, T, P>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse comments.\n   *\n   * `false` by default.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config  New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // eslint-disable-line curly\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (config.delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../hthv-partial.impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserOpts } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport { spacesParser } from './spaces-parser';\nimport { ParserConfig } from './parser-config';\nimport { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const skipSpaces = spacesParser(config);\n  const commentParserOpts: ItemParserOpts = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserOpts);\n  const parseParam = paramParser(config, commentParserOpts);\n\n  return (input, out) => {\n    if (!(config.delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while ( // eslint-disable-line curly\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        );\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/http-header-value\n */\nimport { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value  HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser = (/*#__PURE__*/ newHthvParser());\n","/**\n * @packageDocumentation\n * @module @proc7ts/http-header-value\n */\nimport { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string  A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = defaultParserConfig.delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n","import { nextArg } from '@proc7ts/call-thru';\nimport { ContextValueOpts, ContextValues } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport {\n  AfterEvent,\n  afterThe,\n  EventKeeper,\n  EventSender,\n  nextAfterEvent,\n  OnEvent,\n  onSupplied,\n} from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\ntype FetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<Res>,\n    request: Request,\n) => EventSender<Res>;\n\n/**\n * @internal\n */\ntype CombinedFetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n) => OnEvent<Res>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<Res extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>\n    implements ContextUpRef<CombinedFetchAgent<Res>, FetchAgent<Res>> {\n\n  readonly upKey: ContextUpKey.UpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru(\n            (...agents) => {\n              if (agents.length) {\n                return nextArg(combineFetchAgents(agents));\n              }\n\n              const defaultProvider = (): AfterEvent<[CombinedFetchAgent<Res>]> => afterThe(defaultFetchAgent);\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          CombinedFetchAgent<Res>,\n          EventKeeper<FetchAgent<Res>[]> | FetchAgent<Res>,\n          AfterEvent<FetchAgent<Res>[]>>,\n  ): CombinedFetchAgent<Res> {\n\n    let delegated: CombinedFetchAgent<Res>;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    return (next, request) => delegated(next, request);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultFetchAgent<Res extends any[]>(\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n): OnEvent<Res> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<Res extends any[]>(agents: FetchAgent<Res>[]): CombinedFetchAgent<Res> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<Res> = (agentIdx, agentRequest) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter [[HttpFetch]] processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by [[HttpFetch]].\n */\nexport type HttpFetchAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * [[HttpFetch]] call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under [[HttpFetchAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of response object(s) receivers. It is returned as a result of [[HttpFetch]] call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an [[HttpFetchAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent')\n);\n","import { EventEmitter, EventSupply, eventSupply, OnEvent, onEventBy } from '@proc7ts/fun-events';\nimport { DomEventDispatcher } from '@proc7ts/fun-events/dom';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: EventSupply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new (window as any).AbortController();\n        const { signal } = abortController;\n\n        supply = eventSupply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal).on('abort').once(() => abortController.abort());\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of [[HttpFetch]] is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input  The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init  Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an [[HttpFetch]] instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n        'http-fetch',\n        {\n          byDefault: bootstrapDefault(newHttpFetch),\n        },\n    )\n);\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { EventEmitter, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { DomEventDispatcher } from '@proc7ts/fun-events/dom';\nimport {\n  BootstrapContext,\n  BootstrapRoot,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n} from '@wesib/wesib';\n\n/**\n * @internal\n */\nexport type HierarchyRoot = ValueTracker<ComponentContext | undefined>;\n\n/**\n * @internal\n */\nexport const HierarchyRoot = (/*#__PURE__*/ new SingleContextKey<HierarchyRoot>(\n    'hierarchy-root',\n    {\n      byDefault: bsContext => {\n\n        const root: Element = bsContext.get(BootstrapRoot);\n\n        new DomEventDispatcher(root).on<ComponentEvent>('wesib:component').to(\n            ({ context }: ComponentEvent) => context.get(HierarchyUpdates).issue(),\n        );\n\n        return trackValue();\n      },\n    },\n));\n\nconst HierarchyUpdates__key = (/*#__PURE__*/ new SingleContextKey<HierarchyUpdates>(\n    'hierarchy-updates',\n    {\n      byDefault: context => new HierarchyUpdates(context.get(ComponentContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class HierarchyUpdates {\n\n  static get [ContextKey__symbol](): ContextKey<HierarchyUpdates> {\n    return HierarchyUpdates__key;\n  }\n\n  readonly on: OnEvent<[ComponentContext]>;\n  readonly send: (this: void) => void;\n  readonly issue: () => void;\n\n  constructor(context: ComponentContext) {\n\n    const updates = new EventEmitter<[ComponentContext]>();\n    const hierarchyRoot = context.get(BootstrapContext).get(HierarchyRoot);\n\n    this.on = updates.on();\n    this.send = () => updates.send(context);\n    this.issue = () => {\n\n      const parent = findParentContext(context);\n\n      if (parent) {\n        parent[0].get(HierarchyUpdates).send();\n      } else {\n        hierarchyRoot.it = context;\n      }\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport function findParentContext(of: ComponentContext): [ComponentContext, boolean] | undefined {\n\n  const root = of.get(BootstrapContext).get(BootstrapRoot);\n  let element: Node = of.element;\n  let immediate = true;\n\n  if (element === root) {\n    return;\n  }\n  for (;;) {\n\n    const parent = element.parentNode;\n\n    if (!parent) {\n      return;\n    }\n\n    const ctx: ComponentContext = (parent as any)[ComponentContext__symbol];\n\n    if (ctx) {\n      return [ctx, immediate];\n    }\n    if (parent === root) {\n      return;\n    }\n\n    immediate = false;\n    element = parent;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { noop } from '@proc7ts/call-thru';\nimport {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  ContextValueSpec,\n  SingleContextKey,\n} from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  afterEventBy,\n  EventReceiver,\n  EventSupply,\n  eventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  EventSupplyPeer,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { BootstrapContext, ComponentContext } from '@wesib/wesib';\nimport { newHierarchyRegistry } from './hierarchy-registry.impl';\nimport { findParentContext, HierarchyRoot, HierarchyUpdates } from './hierarchy-updates.impl';\n\n/**\n * @internal\n */\nconst HierarchyContext__key = (/*#__PURE__*/ new SingleContextKey<HierarchyContext>(\n    'hierarchy-context',\n    {\n      byDefault: context => new HierarchyContext$(context.get(ComponentContext)),\n    },\n));\n\n/**\n * Component's hierarchy context.\n *\n * Passes provided values to hierarchy contexts of nested components.\n *\n * Available as component context value.\n *\n * @typeparam T  A type of component.\n */\nexport abstract class HierarchyContext<T extends object = any> extends ContextValues implements EventSupplyPeer {\n\n  /**\n   * A key of component context value containing its hierarchy context instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<HierarchyContext> {\n    return HierarchyContext__key;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this.context);\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of enclosing component's hierarchy context.\n   *\n   * May send `undefined` when component is outside of hierarchy. E.g. when it is disconnected.\n   *\n   * @returns An `AfterEvent` of enclosing hierarcy context.\n   */\n  abstract up(): AfterEvent<[HierarchyContext?]>;\n\n  /**\n   * Starts sending enclosing component's hierarchy context and updates to the given `receiver`\n   *\n   * May send `undefined` when component is outside of hierarchy. E.g. when it is disconnected.\n   *\n   * @param receiver  Target receiver of enclosing hierarchy context.\n   *\n   * @returns Enclosing hierarchy context supply.\n   */\n  abstract up(receiver: EventReceiver<[HierarchyContext?]>): EventSupply;\n\n  /**\n   * Assigns enclosing component to use by default.\n   *\n   * The provided component will be treated as enclosing one until component element connected. After that the real\n   * enclosing component will be used instead.\n   *\n   * @param enclosing  Enclosing component's context to assign, or nothing to remove one.\n   *\n   * @returns `this` instance.\n   */\n  abstract inside(enclosing?: ComponentContext): this;\n\n  /**\n   * Provides hierarchy context value.\n   *\n   * If provided value is updatable (i.e. its key implements `ContextUpKey`), then it will be available in this context,\n   * as well as in all nested hierarchy contexts. Otherwise the value will be available in this context only.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, Deps, Src, Seed>,\n  ): () => void;\n\n}\n\nclass HierarchyContext$<T extends object> extends HierarchyContext<T> {\n\n  private readonly _parent: ValueTracker<HierarchyContext | undefined>;\n  private readonly _registry: ContextRegistry<HierarchyContext<T>>;\n  readonly get: HierarchyContext<T>['get'];\n\n  constructor(readonly context: ComponentContext<T>) {\n    super();\n\n    const parent = this._parent = trackValue<HierarchyContext>();\n\n    context.whenConnected(noop).cuts(parent);\n\n    const registry = this._registry = newHierarchyRegistry<T>(this.up());\n\n    this.get = registry.newValues().get;\n  }\n\n  provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, Deps, Src, Seed>,\n  ): () => void {\n\n    const off = this._registry.provide(spec);\n\n    eventSupplyOf(this).whenOff(off);\n\n    return off;\n  }\n\n  up(): AfterEvent<[HierarchyContext?]>;\n  up(receiver: EventReceiver<[HierarchyContext?]>): EventSupply;\n  up(receiver?: EventReceiver<[HierarchyContext?]>): AfterEvent<[HierarchyContext?]> | EventSupply {\n    return (this.up = afterEventBy<[HierarchyContext?]>(\n        receiver => {\n\n          const { supply } = receiver;\n\n          supply.needs(this);\n\n          const parentHierarchy = trackValue<HierarchyContext>();\n\n          parentHierarchy.by(this._parent);\n          supply.cuts(parentHierarchy);\n\n          const rootSupply = eventSupply().needs(supply);\n          const parentSupply = eventSupply().needs(supply);\n          const updateParent = (): void => {\n\n            const parent = findParentContext(this.context);\n\n            if (parent) {\n\n              const [parentCtx, immediate] = parent;\n\n              parentHierarchy.it = parentCtx.get(HierarchyContext);\n              rootSupply.off();\n              if (immediate) {\n                parentSupply.off();\n              }\n            } else {\n              parentHierarchy.it = undefined;\n            }\n          };\n\n          this.context.get(BootstrapContext).get(HierarchyRoot).read({\n            supply: rootSupply,\n            receive: () => this.context.connected && updateParent(),\n          });\n          parentHierarchy.read().tillOff(parentSupply).consume(\n              newParent => newParent && newParent.context.get(HierarchyUpdates).on.to(updateParent),\n          );\n          parentHierarchy.read(receiver);\n          this.context.whenConnected({\n            supply: eventSupply().needs(supply),\n            receive: updateParent,\n          });\n        },\n    ).share().F)(receiver);\n  }\n\n  inside(enclosing?: ComponentContext): this {\n    this._parent.it = enclosing && enclosing.get(HierarchyContext);\n    return this;\n  }\n\n}\n","import { nextArgs } from '@proc7ts/call-thru';\nimport { ContextRegistry, ContextSeedKey } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { HierarchyContext } from './hierarchy-context';\n\n/**\n * @internal\n */\nexport function newHierarchyRegistry<T extends object>(\n    up: AfterEvent<[HierarchyContext?]>,\n): ContextRegistry<HierarchyContext<T>> {\n  return new ContextRegistry(\n      <Src, Seed>(key: ContextSeedKey<Src, Seed>) => isContextSeedUpKey(key)\n          ? up.keepThru(\n              upper => upper ? nextAfterEvent(upper.get(key)) : nextArgs(),\n          ) as unknown as Seed\n          : undefined,\n  );\n}\n\n/**\n * @internal\n */\nfunction isContextSeedUpKey<Src>(\n    key: ContextSeedKey<Src | EventKeeper<Src[]>, any>,\n): key is ContextUpKey.SeedKey<Src> {\n  return 'upKey' in key;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { ComponentClass, ComponentContext } from '@wesib/wesib';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * Arbitrary element node within component tree. Either bound to some component or not.\n */\nexport type ElementNode =\n    | RawElementNode\n    | ComponentNode;\n\n/**\n * Component tree node representing arbitrary element.\n *\n * This is a base interface of all element node implementations.\n */\nexport interface ComponentTreeNode {\n\n  /**\n   * The element itself.\n   */\n  readonly element: any;\n\n  /**\n   * A context of component bound to this element, if any.\n   */\n  readonly context?: ComponentContext<any>;\n\n  /**\n   * Parent element node, or `null` if element has no parent.\n   */\n  readonly parent: ElementNode | null;\n\n  /**\n   * Selects component nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested components.\n   * @param mode  Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select(\n      selector: string,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode>;\n\n  /**\n   * Selects component nodes of the given type.\n   *\n   * @param componentType  Nested component type with custom element name.\n   * @param mode  Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select<T extends object>(\n      componentType: ComponentClass<T>,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode<T>>;\n\n  /**\n   * Selects element nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested elements. E.g. CSS class selector.\n   * @param mode  A mode of node picking from component tree.\n   *\n   * @returns Dynamically updatable list of matching element nodes.\n   */\n  select(\n      selector: string,\n      mode: ElementPickMode,\n  ): ElementNodeList;\n\n  /**\n   * Tracks element attribute.\n   *\n   * `null` attribute value corresponds to its absence. Setting it to `null` removes attribute.\n   *\n   * @param name  Target attribute name.\n   *\n   * @returns Target attribute's value tracker.\n   */\n  attribute(name: string): ValueTracker<string | null>;\n\n  /**\n   * Tracks element element property.\n   *\n   * The changes are tracked with `StateTracker`. So it is expected that the target property notifies on its changes\n   * with state updater. E.g. when it is defined by `@DomProperty` decorator.\n   *\n   * @param key  Target property key.\n   *\n   * @returns Target property's value tracker.\n   */\n  property<V>(key: PropertyKey): ValueTracker<V>;\n\n}\n\n/**\n * Element node representing raw element not bound to any component.\n */\nexport interface RawElementNode extends ComponentTreeNode {\n\n  readonly context?: undefined;\n\n}\n\n/**\n * Element node representing an element bound to some component.\n */\nexport interface ComponentNode<T extends object = any> extends ComponentTreeNode {\n\n  readonly context: ComponentContext<T>;\n\n}\n\n/**\n * A key of component context value containing a component node instance.\n */\nexport const ComponentNode: SingleContextRef<ComponentNode> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentNode>('component-node')\n);\n\n/**\n * A mode of node picking from component tree.\n */\nexport interface ElementPickMode {\n\n  /**\n   * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n   */\n  all?: boolean;\n\n  /**\n   * Set to `true` to select from entire subtree. Otherwise - select from element child nodes only.\n   */\n  deep?: boolean;\n\n}\n\n/**\n * A mode that picks component nodes from component tree.\n */\nexport interface ComponentPickMode extends ElementPickMode {\n\n  all?: false;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { ElementNode } from './element-node';\n\n/**\n * Dynamically updatable list of selected element nodes.\n *\n * It is an iterable of nodes.\n *\n * Implements an `EventSender` interface by sending added and removed nodes arrays.\n *\n * Implements an `EventKeeper` interface by sending updated node list.\n */\nexport abstract class ElementNodeList<N extends ElementNode = ElementNode>\n    implements Iterable<N>, EventSender<[N[], N[]]>, EventKeeper<[ElementNodeList<N>]> {\n\n  /**\n   * Builds an `OnEvent` sender of this list changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns An `OnEvent` sender of added an removed node arrays.\n   */\n  abstract onUpdate(): OnEvent<[N[], N[]]>;\n\n  /**\n   * Starts sending this list changes to the given `receiver`\n   *\n   * @param receiver  Target receiver of added an removed node arrays.\n   *\n   * @returns List changes supply.\n   */\n  abstract onUpdate(receiver: EventReceiver<[N[], N[]]>): EventSupply;\n\n  abstract [Symbol.iterator](): Iterator<N>;\n\n  [OnEvent__symbol](): OnEvent<[N[], N[]]> {\n    return this.onUpdate();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of current node list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns An `AfterEvent` keeper of this list.\n   */\n  abstract read(): AfterEvent<[ElementNodeList<N>]>;\n\n  /**\n   * Starts sending current node list and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of this node list.\n   *\n   * @returns Node list supply.\n   */\n  abstract read(receiver: EventReceiver<[ElementNodeList<N>]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[ElementNodeList<N>]> {\n    return this.read();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of tracked list changes.\n   *\n   * Sends current nodes immediately upon receiver registration as added ones.\n   *\n   * @returns An `AfterEvent` sender of arrays of added and removed nodes.\n   */\n  abstract track(): AfterEvent<[readonly N[], readonly N[]]>;\n\n  /**\n   * Starts sending tracked list changes to the given `receiver`.\n   *\n   * Sends current nodes immediately upon receiver registration as added ones.\n   *\n   * @param receiver  Target receiver of arrays of added and removed nodes.\n   *\n   * @returns Tracked list changes supply.\n   */\n  abstract track(receiver: EventReceiver<[readonly N[], readonly N[]]>): EventSupply;\n\n  /**\n   * Builds an `AfterEvent` keeper of the first node in this list.\n   *\n   * @returns `AfterEvent` keeper of either the first node, or `undefined` when the list is empty.\n   */\n  abstract first(): AfterEvent<[N?]>;\n\n  /**\n   * Starts sending the first node of this list and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of either the first node, or `undefined` when the list is empty.\n   *\n   * @returns The first node supply.\n   */\n  abstract first(receiver: EventReceiver<[N?]>): EventSupply;\n\n}\n","import { filterIt, flatMapIt, itsEach, itsFirst, itsIterator, mapIt, overArray } from '@proc7ts/a-iterable';\nimport { isPresent, nextArg, valuesProvider } from '@proc7ts/call-thru';\nimport {\n  AfterEvent,\n  afterEventBy,\n  afterSent,\n  afterSupplied,\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  OnEvent,\n  onEventBy,\n} from '@proc7ts/fun-events';\nimport { html__naming } from '@proc7ts/namespace-aliaser';\nimport {\n  BootstrapContext,\n  ComponentClass,\n  DefaultNamespaceAliaser,\n  ElementObserver,\n  ElementObserverInit,\n  isElement,\n} from '@wesib/wesib';\nimport { ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * @internal\n */\nconst WATCH_DEEP: ElementObserverInit = { subtree: true };\n\n/**\n * @internal\n */\nexport function elementNodeList<N extends ElementNode>(\n    bsContext: BootstrapContext,\n    root: Element,\n    selectorOrType: string | ComponentClass<any>,\n    nodeOf: (node: Element, optional?: boolean) => N | undefined,\n    { deep, all }: ElementPickMode,\n): ElementNodeList<N> {\n\n  const updates = new EventEmitter<[N[], N[]]>();\n  const init = deep ? WATCH_DEEP : undefined;\n  let cache = new Set<Element>();\n  let iterable: Iterable<N> | undefined;\n  let selector: string | undefined;\n  const overNodes: (nodes: NodeList) => Iterable<Node> = deep ? overNodeSubtree : overArray;\n\n  if (typeof selectorOrType === 'string') {\n    selector = selectorOrType;\n  } else {\n    bsContext.whenDefined(selectorOrType).then(({ elementDef: { name } }) => {\n      iterable = undefined;\n      if (name) {\n        selector = html__naming.name(name, bsContext.get(DefaultNamespaceAliaser));\n        if (updates.size) {\n          // Refresh selection after component name resolution.\n          // This is needed  when new document loaded.\n\n          const selected = refresh();\n\n          if (selected.size) {\n\n            const added = Array.from(\n                filterIt<N | undefined, N>(\n                    mapIt(selected, node => nodeOf(node)),\n                    isPresent,\n                ),\n            );\n\n            /* istanbul ignore if. Can not test native custom element */\n            if (added.length) {\n              updates.send(added, []);\n            }\n          }\n        }\n      }\n    }).catch(console.error);\n  }\n\n  if (!all) {\n    root.addEventListener('wesib:component', event => {\n\n      const element = event.target as Element;\n\n      if (cache.has(element)) {\n\n        const node = nodeOf(element) as N;\n\n        updates.send([node], []);\n      }\n    });\n  }\n\n  class ElementNodeList$ extends ElementNodeList<N> {\n\n    onUpdate(): OnEvent<[N[], N[]]>;\n    onUpdate(receiver: EventReceiver<[N[], N[]]>): EventSupply;\n    onUpdate(receiver?: EventReceiver<[N[], N[]]>): OnEvent<[N[], N[]]> | EventSupply {\n\n      const observer = bsContext.get(ElementObserver)(update);\n\n      return (this.onUpdate = onEventBy<[N[], N[]]>(receiver => {\n\n        const firstReceiver = !updates.size;\n        const supply = updates.on(receiver);\n\n        if (firstReceiver) {\n          refresh();\n          observer.observe(root, init);\n        }\n\n        return supply.whenOff(() => {\n          if (!updates.size) {\n            observer.disconnect();\n            clearCache(); // clear cache as there is no more receivers\n          }\n        });\n      }).F)(receiver);\n    }\n\n    read(): AfterEvent<[ElementNodeList<N>]>;\n    read(receiver: EventReceiver<[ElementNodeList<N>]>): EventSupply;\n    read(receiver?: EventReceiver<[ElementNodeList<N>]>): AfterEvent<[ElementNodeList<N>]> | EventSupply {\n      return (this.read = afterSent<[ElementNodeList<N>]>(\n          this.onUpdate().thru(() => this),\n          valuesProvider(this),\n      ).F)(receiver);\n    }\n\n    track(): AfterEvent<[readonly N[], readonly N[]]>;\n    track(receiver: EventReceiver<[readonly N[], readonly N[]]>): EventSupply;\n    track(\n        receiver?: EventReceiver<[readonly N[], readonly N[]]>,\n    ): AfterEvent<[readonly N[], readonly N[]]> | EventSupply {\n\n      const onUpdate: OnEvent<[readonly N[], readonly N[]]> = this.onUpdate();\n\n      return (this.track = afterEventBy<[readonly N[], readonly N[]]>(receiver => {\n\n        const initialEmitter = new EventEmitter<[readonly N[], readonly N[]]>();\n\n        initialEmitter.on(receiver);\n        initialEmitter.send(Array.from(this), []);\n\n        onUpdate.to(receiver);\n      }).F)(receiver);\n    }\n\n    first(): AfterEvent<[N?]>;\n    first(receiver: EventReceiver<[N?]>): EventSupply;\n    first(receiver?: EventReceiver<[N?]>): AfterEvent<[N?]> | EventSupply {\n      return (this.first = afterSupplied(this.read()).keepThru(\n          list => nextArg<N | undefined>(itsFirst(list)),\n      ).F)(receiver);\n    }\n\n    [Symbol.iterator](): Iterator<N> {\n      return itsIterator(iterable || (iterable = filterIt<N | undefined, N>(\n          mapIt(\n              elements(),\n              element => nodeOf(element),\n          ),\n          isPresent,\n      )));\n    }\n\n  }\n\n  return new ElementNodeList$();\n\n  function elements(): Set<Element> {\n    return updates.size ? cache : refresh();\n  }\n\n  function clearCache(): void {\n    iterable = undefined;\n    cache.clear();\n  }\n\n  function refresh(): Set<Element> {\n    iterable = undefined;\n\n    const list = select();\n\n    if (updates.size) {\n      cache = list; // cache is for receivers only\n    }\n\n    return list;\n  }\n\n  function select(): Set<Element> {\n\n    const sel = selector;\n\n    if (!sel) {\n      return new Set();\n    }\n    if (deep) {\n      return new Set(overArray(root.querySelectorAll(sel)));\n    }\n    return new Set(\n        filterIt(\n            overArray(root.children),\n            item => item.matches(sel),\n        ),\n    );\n  }\n\n  function update(mutations: MutationRecord[]): void {\n\n    const added: N[] = [];\n    const removed: N[] = [];\n\n    mutations.forEach(mutation => {\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overNodes(mutation.removedNodes), removeNode),\n              isPresent,\n          ),\n          node => removed.push(node),\n      );\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overNodes(mutation.addedNodes), addNode),\n              isPresent,\n          ),\n          node => added.push(node),\n      );\n    });\n    if (added.length || removed.length) {\n      updates.send(added, removed);\n    }\n  }\n\n  function addNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (selector && node.matches(selector) && !cache.has(node)) {\n      cache.add(node);\n      return nodeOf(node);\n    }\n    return;\n  }\n\n  function removeNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (!cache.delete(node)) {\n      return;\n    }\n    return nodeOf(node, true);\n  }\n\n}\n\nfunction overNodeSubtree(nodes: NodeList): Iterable<Node> {\n  return flatMapIt(\n      overArray(nodes),\n      node => [node, ...overNodeSubtree(node.childNodes)],\n  );\n}\n","import {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\n\n/**\n * @internal\n */\nclass AttributesObserver {\n\n  private readonly _emitters = new Map<string, EventEmitter<[string | null, string | null]>>();\n  private _observer?: MutationObserver;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n  }\n\n  private get observer(): MutationObserver {\n    if (this._observer) {\n      return this._observer;\n    }\n\n    const Observer: typeof MutationObserver = (this._bs.get(BootstrapWindow) as any).MutationObserver;\n\n    return this._observer = new Observer(mutations => this._update(mutations));\n  }\n\n  observe(name: string, receiver: EventReceiver<[string | null, string | null]>): EventSupply {\n\n    const self = this;\n    const observer = this.observer;\n    const emitter = this._emitter(name);\n    const rcv = eventReceiver(receiver);\n    const supply = emitter.on({\n      supply: eventSupply(() => {\n        this._emitters.delete(name);\n        observer.disconnect();\n        if (this._emitters.size) {\n          reconnect();\n        } else {\n          this._observer = undefined;\n        }\n      }).needs(rcv.supply),\n      receive: (ctx, newValue, oldValue) => rcv.receive(ctx, newValue, oldValue),\n    });\n\n    observer.disconnect();\n    reconnect();\n\n    return supply;\n\n    function reconnect(): void {\n      self._update(observer.takeRecords());\n      observer.observe(self.element, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: Array.from(self._emitters.keys()),\n      });\n    }\n  }\n\n  private _update(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n\n      const attributeName = mutation.attributeName as string;\n      const emitter = this._emitters.get(attributeName);\n\n      if (emitter) {\n        emitter.send(this.element.getAttribute(attributeName) as string, mutation.oldValue);\n      }\n    });\n  }\n\n  private _emitter(name: string): EventEmitter<[string | null, string | null]> {\n\n    const emitter = new EventEmitter<[string | null, string | null]>();\n\n    this._emitters.set(name, emitter);\n\n    return emitter;\n  }\n\n}\n\n/**\n * @internal\n */\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  private readonly _updates = new EventEmitter<[string | null, string | null]>();\n\n  constructor(\n      private readonly _observer: AttributesObserver,\n      private readonly _name: string,\n  ) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._updates);\n  }\n\n  get it(): string | null {\n    return this._observer.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (value != null) {\n      this._observer.element.setAttribute(this._name, value);\n    } else {\n      this._observer.element.removeAttribute(this._name);\n    }\n  }\n\n  on(): OnEvent<[string | null, string | null]>;\n  on(receiver: EventReceiver<[string | null, string | null]>): EventSupply;\n  on(receiver?: EventReceiver<[string | null, string | null]>): OnEvent<[string | null, string | null]> | EventSupply {\n\n    let observeSupply = noEventSupply();\n\n    return (this.on = onEventBy(receiver => {\n      if (!this._updates.size) {\n        observeSupply = this._observer.observe(\n            this._name,\n            (newValue, oldValue) => this._updates.send(newValue, oldValue),\n        );\n      }\n      receiver.supply.needs(observeSupply);\n      this._updates.on(receiver).whenOff(reason => {\n        if (!this._updates.size) {\n          observeSupply.off(reason);\n        }\n      });\n    }).F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeAttributes {\n\n  private readonly _attrs = new Map<string, AttributeTracker>();\n  private readonly _observer: AttributesObserver;\n\n  constructor(bs: BootstrapContext, element: any) {\n    this._observer = new AttributesObserver(bs, element);\n  }\n\n  get(name: string): ValueTracker<string | null> {\n\n    const existing = this._attrs.get(name);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new AttributeTracker(this._observer, name);\n\n    this._attrs.set(name, created);\n\n    return created;\n  }\n\n}\n","import {\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { ComponentContext, ComponentState, domPropertyPathTo } from '@wesib/wesib';\n\n/**\n * @internal\n */\nclass PropertyTracker<T> extends ValueTracker<T> {\n\n  private readonly _updates = new EventEmitter<[T, T]>();\n\n  constructor(\n      private readonly _element: any,\n      private readonly _key: PropertyKey,\n  ) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._updates);\n  }\n\n  get it(): T {\n    return this._element[this._key];\n  }\n\n  set it(value: T) {\n    this._element[this._key] = value;\n  }\n\n  on(): OnEvent<[T, T]>;\n  on(receiver: EventReceiver<[T, T]>): EventSupply;\n  on(receiver?: EventReceiver<[T, T]>): OnEvent<[T, T]> | EventSupply {\n    return (this.on = this._updates.on().F)(receiver);\n  }\n\n  bind(context: ComponentContext): void {\n\n    const propertyState = context.get(ComponentState).track(domPropertyPathTo(this._key));\n\n    propertyState.onUpdate().to({\n      supply: eventSupplyOf(this),\n      receive: (_ctx, _path, newValue: any, oldValue: any) => this._updates.send(newValue, oldValue),\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeProperties {\n\n  private readonly _props = new Map<PropertyKey, PropertyTracker<any>>();\n  private _context?: ComponentContext<any>;\n\n  constructor(private readonly _element: any) {\n  }\n\n  bind(context: ComponentContext): void {\n    this._context = context;\n    this._props.forEach(prop => prop.bind(context));\n  }\n\n  get<T>(key: PropertyKey): ValueTracker<T> {\n\n    const existing = this._props.get(key);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new PropertyTracker<any>(this._element, key);\n\n    if (this._context) {\n      created.bind(this._context);\n    }\n    this._props.set(key, created);\n\n    return created;\n  }\n\n}\n","import { ValueTracker } from '@proc7ts/fun-events';\nimport {\n  BootstrapContext,\n  ComponentClass,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n  ElementAdapter,\n} from '@wesib/wesib';\nimport { ComponentNode, ComponentTreeNode, ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeList } from './element-node-list.impl';\nimport { NodeAttributes } from './node-attributes.impl';\nimport { NodeProperties } from './node-properties.impl';\n\n/**\n * @internal\n */\nconst ElementNode__symbol = (/*#__PURE__*/ Symbol('element-node'));\n\n/**\n * @internal\n */\nclass ElementNode$ implements ComponentTreeNode {\n\n  private readonly _attrs: NodeAttributes;\n  private readonly _props: NodeProperties;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n    this._attrs = new NodeAttributes(_bs, element);\n    this._props = new NodeProperties(element);\n    (element as any)[ElementNode__symbol] = this;\n\n    const context = (element as any)[ComponentContext__symbol] as ComponentContext<any> | undefined;\n\n    if (context) {\n      this._bind(context);\n    } else {\n      element.addEventListener('wesib:component', event => this._bind((event as ComponentEvent).context));\n    }\n  }\n\n  get context(): ComponentContext<any> | undefined {\n    return (this.element as any)[ComponentContext__symbol];\n  }\n\n  get parent(): ElementNode | null {\n\n    const parent = this.element.parentNode;\n\n    return parent && elementNodeOf(this._bs, parent as Element);\n  }\n\n  select(selector: string | ComponentClass<any>, mode?: ElementPickMode): ElementNodeList<any> {\n    return selectNodes(this._bs, this.element, selector, mode);\n  }\n\n  attribute(name: string): ValueTracker<string | null> {\n    return this._attrs.get(name);\n  }\n\n  property<V>(key: PropertyKey): ValueTracker<V> {\n    return this._props.get(key);\n  }\n\n  private _bind(context: ComponentContext): void {\n    this._props.bind(context);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function elementNodeOf(bsContext: BootstrapContext, element: Element, optional?: boolean): ElementNode {\n\n  const existing: ElementNode = (element as any)[ElementNode__symbol];\n\n  return (existing || optional) ? existing : new ElementNode$(bsContext, element);\n}\n\n/**\n * @internal\n */\nfunction selectNodes(\n    bsContext: BootstrapContext,\n    root: Element,\n    selector: string | ComponentClass<any>,\n    mode: ElementPickMode = {},\n): ElementNodeList<any> {\n  if (mode.all) {\n    return elementNodeList<ElementNode>(\n        bsContext,\n        root,\n        selector,\n        (element, optional) => elementNodeOf(bsContext, element, optional),\n        mode,\n    );\n  }\n\n  const adapter = bsContext.get(ElementAdapter);\n\n  return elementNodeList<ComponentNode>(\n      bsContext,\n      root,\n      selector,\n      (element, optional) => adapter(element) && elementNodeOf(bsContext, element, optional) as ComponentNode,\n      mode,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapContext, ComponentContext, FeatureDef, FeatureDef__symbol, StateSupport } from '@wesib/wesib';\nimport { ComponentNode } from './element-node';\nimport { elementNodeOf } from './element-node.impl';\n\n/**\n * @internal\n */\nconst ComponentTreeSupport__feature: FeatureDef = {\n  needs: StateSupport,\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentNode,\n      by(context: ComponentContext) {\n        return elementNodeOf(context.get(BootstrapContext), context.element) as ComponentNode;\n      },\n    });\n  },\n};\n\n/**\n * Component tree support feature.\n *\n * Provides a [[ComponentNode]] instance for each component.\n */\nexport class ComponentTreeSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ComponentTreeSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\n/**\n * Extracts URL contained in the hash of another URL.\n *\n * Extracted hash URL is based on origin of the original URL. Still, it may be absolute one.\n *\n * Input URL is never altered.\n *\n * @param url  An URL to extract hash from.\n *\n * @returns URL extracted from hash.\n */\nexport function getHashURL(url: URL): URL {\n  return new URL(url.hash.substring(1), url.origin);\n}\n\n/**\n * Creates an URL based on original one, but with hash substituted by the given hash URL.\n *\n * The hash URL is substituted as following:\n *\n * 1. If the hash URL's origin is not the same as the one of the base one, or if it contains a username,\n *    then absolute hash URL is substituted:\n * 2. Otherwise:\n *    - pathname is substituted, unless it is equal to `/` and no hash and search parameters present,\n *    - search parameters are substituted when at least one present,\n *    - hash is substituted only when present.\n *\n * Input URLs are never altered.\n *\n * @param url  Base URL.\n * @param hashURL  Hash URL to substitute.\n *\n * @returns URL with updated hash.\n */\nexport function setHashURL(url: URL, hashURL: URL): URL {\n  if (hashURL.origin !== url.origin || hashURL.username) {\n    return new URL('#' + hashURL, url);\n  }\n\n  const { pathname, search, hash } = hashURL;\n  const result = new URL('', url);\n\n  result.hash = (search || hash || pathname.length > 1) ? (pathname + search + hash) : (search + hash);\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = (/*#__PURE__*/ Symbol('page-param'));\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to [[LeavePageEvent]]). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeparam T  Parameter value type.\n * @typeparam I  Parameter input type.\n */\nexport abstract class PageParam<T, I> implements PageParam.Ref<T, I> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}. It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page  A page to assign navigation parameter to.\n   * @param input  Parameter input used to construct its initial value.\n   * @param context  Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: I, context: PageParamContext): PageParam.Handle<T, I>;\n\n  /**\n   * Creates default page parameter handle.\n   *\n   * This method is called when {@link Page.get requesting page parameter} which value is not present in the page.\n   * The value handle returned is assigned to the page.\n   *\n   * Returns nothing by default.\n   *\n   * @param _page  A page to assign navigation parameter to.\n   * @param _context  Page parameter context.\n   *\n   * @returns New page parameter value handle or nothing if there is no default value.\n   */\n  byDefault(_page: Page, _context: PageParamContext): PageParam.Handle<T, I> | undefined {\n    return;\n  }\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface Ref<T, I> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, I>;\n\n  }\n\n  /**\n   * Page navigation parameter that has default value.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface WithDefaults<T, I> extends PageParam<T, I> {\n\n    byDefault(page: Page, context: PageParamContext): PageParam.Handle<T, I>;\n\n  }\n\n  export namespace WithDefaults {\n\n    /**\n     * A reference to page navigation parameter that has default value.\n     *\n     * @typeparam T  Parameter value type.\n     * @typeparam I  Parameter input type.\n     */\n    export interface Ref<T, I> {\n\n      /**\n       * Referred page navigation parameter instance.\n       */\n      readonly [PageParam__symbol]: WithDefaults<T, I>;\n\n    }\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface Handle<T, I> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input  Parameter input to use when updating its value.\n     */\n    put(input: I): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before [[LeavePageEvent]] is fired for each parameter handle of current page.\n     *\n     * @param to  A page to transfer parameter to.\n     * @param when  When the transfer happens. Either `pretend`, `pre-open`, `pre-replace`, `open`, or `return`.\n     * `return` is used when return to page generated by another app version. E.g. from the page that has been\n     * reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(to: Page, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): Handle<T, I> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page  Entered page.\n     * @param when  When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at  The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { nextArg } from '@proc7ts/call-thru';\nimport { ContextValueOpts, ContextValues } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from '@proc7ts/fun-events';\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n * @param when  When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n * @param from  The page to leave.\n * @param to  Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pretend' | 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\n/**\n * @internal\n */\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent> {\n\n  readonly upKey: ContextUpKey.UpKey<NavigationAgent.Combined, NavigationAgent>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        opts => {\n\n          const { document } = opts.context.get(BootstrapWindow);\n\n          return opts.seed.keepThru(\n              (...agents) => {\n                if (agents.length) {\n                  return nextArg(combinedAgent);\n                }\n\n                const defaultProvider = (): AfterEvent<[NavigationAgent.Combined]> => afterThe(defaultNavigationAgent);\n\n                return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n\n                function combinedAgent(\n                    next: (this: void, target: Navigation.URLTarget) => void,\n                    when: 'pretend' | 'pre-open' | 'pre-replace',\n                    from: Page,\n                    to: Page,\n                ): void {\n\n                  return navigate(0, to);\n\n                  function navigate(agentIdx: number, agentTo: Page): void {\n\n                    const agent = agents[agentIdx];\n\n                    if (!agent) {\n                      return next(agentTo);\n                    }\n\n                    agent(\n                        (\n                            {\n                              url: nextURL = agentTo.url,\n                              title: nextTitle = agentTo.title,\n                              data: nextData = agentTo.data,\n                            }: Navigation.Target = agentTo,\n                        ) => navigate(\n                            agentIdx + 1,\n                            {\n                              url: new URL(String(nextURL), document.baseURI),\n                              title: nextTitle,\n                              data: nextData,\n                              get visited() {\n                                return agentTo.visited;\n                              },\n                              get current() {\n                                return agentTo.current;\n                              },\n                              get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n                                return agentTo.get(ref);\n                              },\n                              put(ref, input) {\n                                agentTo.put(ref, input);\n                              },\n                            },\n                        ),\n                        when,\n                        from,\n                        agentTo,\n                    );\n                  }\n                }\n              },\n          );\n        },\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          NavigationAgent.Combined,\n          EventKeeper<NavigationAgent[]> | NavigationAgent,\n          AfterEvent<NavigationAgent[]>>,\n  ): NavigationAgent.Combined {\n\n    let delegated: NavigationAgent.Combined;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    return (next, when, from, to) => delegated(next, when, from, to);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavigationAgent(\n    next: (this: void, target: Navigation.URLTarget) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n  next(to);\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under [[NavigationAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n   * one. Not calling this function effectively prevents navigation.\n   * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n   * @param when  When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n   * @param from  The page to leave.\n   * @param to  Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pretend' | 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an [[NavigationAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> = (\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { DomEventListener, OnDomEvent } from '@proc7ts/fun-events/dom';\nimport { EnterPageEvent, LeavePageEvent, NavigationEvent, StayOnPageEvent } from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\n/**\n * @internal\n */\nconst Navigation__key = (/*#__PURE__*/ new SingleContextKey<Navigation>('navigation'));\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value when [[NavigationSupport]] feature is enabled.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * Current page.\n   */\n  abstract readonly page: Page;\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * Build an `OnDomEvent` sender of {@link EnterPageEvent enter page events}.\n   *\n   * @returns An `OnDomEvent` sender of {@link EnterPageEvent enter page events}.\n   */\n  abstract onEnter(): OnDomEvent<EnterPageEvent>;\n\n  /**\n   * Starts sending {@link EnterPageEvent enter page events} to the given `listener`.\n   *\n   * @param listener  Target listener of {@link EnterPageEvent enter page events}.\n   *\n   * @returns {@link EnterPageEvent Enter page events} supply.\n   */\n  abstract onEnter(listener: DomEventListener<EnterPageEvent>): EventSupply;\n\n  /**\n   * Builds an `OnDomEvent` sender of {@link LeavePageEvent leave page events}.\n   *\n   * The registered listener may cancel navigation by calling `preventDefault()` method of received event.\n   *\n   * @returns `OnDomEvent` sender of {@link LeavePageEvent leave page events}.\n   */\n  abstract onLeave(): OnDomEvent<LeavePageEvent>;\n\n  /**\n   * Starts sending {@link LeavePageEvent leave page events} to the given `listener`.\n   *\n   * The registered listener may cancel navigation by calling `preventDefault()` method of received event.\n   *\n   * @param listener  Target listener of {@link LeavePageEvent leave page events}.\n   *\n   * @returns {@link LeavePageEvent Leave page events} supply.\n   */\n  abstract onLeave(listener: DomEventListener<LeavePageEvent>): EventSupply;\n\n  /**\n   * Builds an `OnDomEvent` {@link StayOnPageEvent stay on page events}.\n   *\n   * The registered listener is informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   *\n   * @returns `OnDomEvent` sender of {@link StayOnPageEvent stay on page events}.\n   */\n  abstract onStay(): OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * Starts sending {@link StayOnPageEvent stay on page events} to the given `listener`.\n   *\n   * @param listener  Target listener of {@link StayOnPageEvent stay on page events}.\n   *\n   * @returns {@link StayOnPageEvent Stay on page events} supply.\n   */\n  abstract onStay(listener: DomEventListener<StayOnPageEvent>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of {@link NavigationEvent navigation events}.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of {@link NavigationEvent navigation events}.\n   */\n  abstract on(): OnEvent<[NavigationEvent]>;\n\n  /**\n   * Starts sending of {@link NavigationEvent navigation events} to the given `receiver`.\n   *\n   * @param receiver  Target receiver of {@link NavigationEvent navigation events}.\n   *\n   * @returns {@link NavigationEvent Navigation events} supply.\n   */\n  abstract on(receiver: EventReceiver<[NavigationEvent]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of {@link page current page}.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns An `AfterEvent` keeper of {@link page current page}.\n   */\n  abstract read(): AfterEvent<[Page]>;\n\n  /**\n   * Starts sending {@link page current page} and updates to the given `receiver.\n   *\n   * @param receiver  Target receiver of {@link page current page}.\n   *\n   * @returns {@link page Current page} supply.\n   */\n  abstract read(receiver: EventReceiver<[Page]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read();\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta  Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target  Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target  Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url  An URL to replace the the current one with.\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   * @param ref  A reference to page navigation parameter to apply.\n   * @param input  Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeparam T  Parameter value type.\n     * @typeparam I  Parameter input type.\n     * @param ref  A reference to page navigation parameter to apply.\n     * @param input  Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target  Either navigation target or URL to navigate to. Navigates to current page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target  Either navigation target or URL to replace the latest history entry with. Navigates to current\n     * page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Pretends navigation.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target  Either navigation target or URL to pretend navigation to.\n     * @param callback A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        target: Navigation.Target | string | URL,\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation to the same page.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param callback A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation and builds navigation target.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target  Either navigation target or URL to pretend navigation to. Prepends navigation to current page\n     * when omitted.\n     *\n     * @returns Either Navigation target with URL value, or `undefined` when navigation failed.\n     */\n    pretend(\n        target?: Navigation.Target | string | URL,\n    ): URLTarget | undefined;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to [[Navigation.open]] and [[Navigation.replace]] methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextValues } from '@proc7ts/context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { itsEach } from '@proc7ts/a-iterable';\nimport { noop } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\nconst NavHistory__key = (/*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'nav-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n));\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object' ? { data: state } : state[NAV_DATA_KEY];\n}\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol](): ContextKey<NavHistory> {\n    return NavHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry): void {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        data,\n      },\n    };\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      get url() {\n        return target.url;\n      },\n      get title() {\n        return target.title;\n      },\n      get data() {\n        return target.data;\n      },\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(param);\n\n    if (handle) {\n      return handle.get();\n    }\n\n    const newHandle = param.byDefault(this.page, this._newContext());\n\n    return newHandle && this._init(param, newHandle);\n  }\n\n  put<T, I>(ref: PageParam.Ref<T, I>, input: I): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, I> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    return this._init(param, param.create(this.page, input, this._newContext()));\n  }\n\n  private _newContext(): PageParamContext {\n\n    const registry = new ContextRegistry<ParamContext>(this._bsContext);\n\n    class ParamContext extends PageParamContext {\n\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n\n    }\n\n    return new ParamContext();\n  }\n\n  private _init<T, I>(param: PageParam<T, I>, handle: PageParam.Handle<T, I>): T {\n    this._params.set(param, handle);\n\n    if (this.page.current && handle.enter) {\n      handle.enter(this.page, 'init');\n    }\n\n    return handle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): void {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page): void {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave(): void {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget(): void {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void): void {\n    this._update = update;\n  }\n\n  apply(): void {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","import { noop } from '@proc7ts/call-thru';\nimport { AfterEvent, EventReceiver, EventSupply, onAny, OnEvent, trackValue } from '@proc7ts/fun-events';\nimport { DomEventDispatcher, DomEventListener, OnDomEvent } from '@proc7ts/fun-events/dom';\nimport { BootstrapContext, BootstrapWindow, mergeFunctions } from '@wesib/wesib';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { Navigation as Navigation } from './navigation';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\nexport function createNavigation(context: BootstrapContext): Navigation {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate').to(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange').to(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  type NavTarget = { -readonly [K in keyof Navigation.URLTarget]: Navigation.URLTarget[K] };\n\n  class Navigation$ extends Navigation {\n\n    get page(): Page {\n      return nav.it.page;\n    }\n\n    get length(): number {\n      return history.length;\n    }\n\n    onEnter(): OnDomEvent<EnterPageEvent>;\n    onEnter(listener: DomEventListener<EnterPageEvent>): EventSupply;\n    onEnter(listener?: DomEventListener<EnterPageEvent>): OnDomEvent<EnterPageEvent> | EventSupply {\n      return (this.onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage).F)(listener);\n    }\n\n    onLeave(): OnDomEvent<LeavePageEvent>;\n    onLeave(listener: DomEventListener<LeavePageEvent>): EventSupply;\n    onLeave(listener?: DomEventListener<LeavePageEvent>): OnDomEvent<LeavePageEvent> | EventSupply {\n      return (this.onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage).F)(listener);\n    }\n\n    onStay(): OnDomEvent<StayOnPageEvent>;\n    onStay(listener: DomEventListener<StayOnPageEvent>): EventSupply;\n    onStay(listener?: DomEventListener<StayOnPageEvent>): OnDomEvent<StayOnPageEvent> | EventSupply {\n      return (this.onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage).F)(listener);\n    }\n\n    /**\n     * Builds an `OnEvent` sender of {@link NavigationEvent navigation events}.\n     *\n     * The `[OnEvent__symbol]` property is an alias of this one.\n     *\n     * @returns `OnEvent` sender of {@link NavigationEvent navigation events}.\n     */\n    on(): OnEvent<[NavigationEvent]>;\n    on(receiver: EventReceiver<[NavigationEvent]>): EventSupply;\n    on(receiver?: EventReceiver<[NavigationEvent]>): OnEvent<[NavigationEvent]> | EventSupply {\n      return (this.on = onAny<[NavigationEvent]>(this.onEnter(), this.onLeave(), this.onStay()).F)(receiver);\n    }\n\n    read(): AfterEvent<[Page]>;\n    read(receiver: EventReceiver<[Page]>): EventSupply;\n    read(receiver?: EventReceiver<[Page]>): AfterEvent<[Page]> | EventSupply {\n      return (this.read = nav.read().keepThru(entry => entry.page).F)(receiver);\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation$();\n\n  function withParam(applyParams: (page: Page) => void): Navigation.Parameterized {\n    return {\n      with<TT, II>(ref: PageParam.Ref<TT, II>, input: II): Navigation.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target?: Navigation.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target?: Navigation.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n      pretend<T>(\n          targetOrCallback?: Navigation.Target | string | URL | ((this: void, from: Page, to: Page) => T),\n          callback: (this: void, from: Page, to: Page) => T = (_from, to) => to as unknown as T,\n      ): T | undefined {\n\n        let target: Navigation.Target | string | URL | undefined;\n\n        if (typeof targetOrCallback === 'function') {\n          callback = targetOrCallback;\n          target = undefined;\n        } else {\n          target = targetOrCallback;\n        }\n\n        const navTarget = navTargetOf(target);\n        const fromEntry = nav.it;\n        const toEntry = newEntry('pretend', fromEntry, navTarget, applyParams);\n\n        try {\n          return applyAgent('pretend', fromEntry, navTarget, toEntry)\n              ? callback(fromEntry.page, toEntry.page)\n              : undefined;\n        } finally {\n          toEntry.stay(nav.it.page);\n        }\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function navTargetOf(target?: Navigation.Target | string | URL): NavTarget {\n    if (target == null || typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target?: Navigation.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const navTarget = navTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined = undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n        navHistory[when](toEntry, nav);\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = newEntry(whenLeave, fromEntry, navTarget, applyParams);\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      if (!dispatcher.dispatch(leavePage)\n          || next !== promise\n          || !applyAgent(whenLeave, fromEntry, navTarget, toEntry)) {\n        return stay(toEntry);\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: navTarget,\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n\n  function newEntry(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      applyParams: (page: Page) => void,\n  ): PageEntry {\n\n    const toEntry = navHistory.newEntry(navTarget);\n\n    try {\n      fromEntry.transfer(toEntry, whenLeave);\n      applyParams(toEntry.page);\n    } catch (e) {\n      toEntry.stay(nav.it.page);\n      throw e;\n    }\n\n    return toEntry;\n  }\n\n  function applyAgent(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      toEntry: PageEntry,\n  ): boolean {\n\n    let navigated = false;\n\n    agent(\n        ({ url, data, title }) => {\n          navigated = true;\n          navTarget.url = url;\n          navTarget.data = data;\n          navTarget.title = title;\n        },\n        whenLeave,\n        fromEntry.page,\n        toEntry.page,\n    );\n\n    return navigated;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { createNavigation } from './navigation.impl';\n\n/**\n * @internal\n */\nconst NavigationSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: Navigation, by: createNavigation });\n  },\n};\n\n/**\n * Browser navigation support feature.\n *\n * Makes [[Navigation]] available in bootstrap context.\n */\nexport class NavigationSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return NavigationSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { mapIt } from '@proc7ts/a-iterable';\nimport { nextArgs, noop } from '@proc7ts/call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  eventSupply,\n  EventSupply,\n  nextAfterEvent,\n} from '@proc7ts/fun-events';\nimport { css__naming, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport {\n  Class,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultNamespaceAliaser,\n  ElementRenderScheduler,\n  RenderDef,\n  Wesib__NS,\n} from '@wesib/wesib';\nimport { ComponentNode, ComponentTreeSupport, ElementNode, ElementPickMode } from '../tree';\nimport { getHashURL } from './hash-url';\nimport { Navigation } from './navigation';\nimport { NavigationSupport } from './navigation-support.feature';\nimport { Page } from './page';\n\n/**\n * @internal\n */\ninterface ActiveNavLink {\n  supply(): EventSupply;\n}\n\n/**\n * @internal\n */\ntype ActiveNavLinks = Map<ElementNode, ActiveNavLink>;\n\n/**\n * Creates component decorator that marks navigation link(s) inside decorated component active.\n *\n * Marks navigation links with highest weight.\n *\n * Enables [[ComponentTreeSupport]] and [[NavigationSupport]] features.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Navigation link activation definition.\n *\n * @returns New component decorator.\n */\nexport function ActivateNavLink<T extends ComponentClass = Class>(\n    def: ActivateNavLinkDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const { select = 'a', pick = { all: true, deep: true } } = def;\n\n  return Component({\n    feature: {\n      needs: [ComponentTreeSupport, NavigationSupport],\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const activate = activateNavLink(context, def);\n        const weigh = navLinkWeight(def);\n        const navigation = context.get(Navigation);\n        const componentNode = context.get(ComponentNode);\n\n        context.whenConnected(() => {\n\n          let active: ActiveNavLinks = new Map();\n\n          navigation.read().tillOff(context).consume(\n              page => componentNode.select(select, pick).read().keepThru_(\n                  nodes => nextAfterEvent(afterEach(\n                      ...mapIt(nodes, node => weigh({ node, context, page })),\n                  )),\n              ).consume(\n                  (...weights: NavLinkWeight[]) => {\n\n                    const selected = selectActiveNavLinks(weights);\n                    const newActive: ActiveNavLinks = new Map();\n                    const result = eventSupply();\n\n                    selected.forEach(node => {\n\n                      let activeLink: ActiveNavLink;\n                      const existing = active.get(node);\n\n                      if (existing) {\n                        newActive.set(node, existing);\n                        activeLink = existing;\n                      } else {\n                        activeLink = activate({ node, context, page });\n                        newActive.set(node, activeLink);\n                      }\n\n                      activeLink.supply().needs(result);\n                    });\n\n                    active = newActive;\n\n                    return result;\n                  },\n              ),\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation link activation definition.\n *\n * Defines a set of element nodes considered to be navigation links. Each matching node is {@link weigh weighed}\n * against {@link Navigation.read current page}, and the link with highest weight is marked [[active]].\n *\n * @typeparam T  A type of component.\n */\nexport interface ActivateNavLinkDef<T extends object = any> {\n\n  /**\n   * Navigation links CSS selector.\n   *\n   * `a` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of navigation link node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Qualified name of CSS class to mark the active element with.\n   *\n   * The `active` class in Wesib namespace is used by default.\n   */\n  readonly active?: QualifiedName;\n\n  /**\n   * Rendering definition options to pass to nav links render scheduler.\n   */\n  readonly render?: RenderDef.Options;\n\n  /**\n   * Weighs matching navigation link.\n   *\n   * This method will be called for each navigation link on each current page update.\n   *\n   * By default:\n   * 1. If the link path has neither hash, nor search parameters, then:\n   * 1.1. Checks whether page URL path starts with the link's one.\n   * 1.2. If so, then uses link path length as weight.\n   * 2. If the link path has search parameters, but has no hash, then requires the page path to be the same as link's\n   *    one, and page search parameters include all of the link's ones. The number of link search parameters plus the\n   *    link path length is used as weight.\n   * 3. If the link path has a hash, then requires the page path and search parameters to be the same as link's ones,\n   *    and their hashes are treated as {@link getHashURL URLs}. The weight is calculated by applying steps 1, 2, and 3\n   *    to hash URLs increased by the link path length and the number of search parameters.\n   *\n   * Ignores search parameters with names starting and ending with double underscores. Like `__wesib_app_rev__`.\n   *\n   * @param node  Navigation link node to weigh.\n   * @param page  Current navigation page.\n   * @param context  Decorated component context.\n   *\n   * @returns Either navigation link weight, or its keeper. Non-positive wights means the page URL doesn't match\n   * the link at all.\n   */\n  weigh?(\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): number | EventKeeper<[number]>;\n\n  /**\n   * Changes navigation link activity state.\n   *\n   * This method is called each time the active link changed.\n   *\n   * @param active  Whether to make target link active (`true`), or inactive (`false`).\n   * @param node  Navigation link node to update activity state of.\n   * @param page  Current navigation page.\n   * @param context  Decorated component context.\n   */\n  activate?(\n      active: boolean,\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n}\n\n/**\n * @internal\n */\ntype NavLinkWeight = [ElementNode, number];\n\n/**\n * @internal\n */\ninterface NavLinkOpts {\n  node: ElementNode;\n  page: Page;\n  context: ComponentContext;\n}\n\n/**\n * @internal\n */\nfunction selectActiveNavLinks(weights: NavLinkWeight[]): ElementNode[] {\n\n  let maxWeight = 0;\n  let active: ElementNode[] = [];\n\n  weights.forEach(([node, weight]) => {\n    if (weight > maxWeight) {\n      maxWeight = weight;\n      active = [node];\n    } else if (weight === maxWeight) {\n      active.push(node);\n    }\n  });\n\n  return active;\n}\n\n/**\n * @internal\n */\nfunction navLinkWeight(\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => AfterEvent<NavLinkWeight> {\n  if (!def.weigh) {\n    return defaultNavLinkWeight;\n  }\n  return opts => {\n\n    const weight = def.weigh!(opts);\n\n    if (typeof weight === 'number') {\n      return afterThe(opts.node, weight);\n    }\n\n    let supplier: AfterEvent<NavLinkWeight> = afterSupplied(weight).keepThru_(\n        weight => nextArgs(opts.node, weight),\n    );\n\n    return afterEventBy<NavLinkWeight>(receiver => {\n      supplier.to({\n        supply: eventSupply()\n            .needs(receiver.supply)\n            .whenOff(() => {\n              // Fall back to zero weight once the weight supply cut off\n              supplier = afterThe(opts.node, 0);\n              supplier.to(receiver);\n            }),\n        receive: receiver.receive.bind(receiver),\n      });\n    });\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkWeight(\n    {\n      node,\n      page,\n    }: NavLinkOpts,\n): AfterEvent<NavLinkWeight> {\n\n  const element: Element = node.element;\n  const href = element.getAttribute('href');\n\n  if (href == null) {\n    return afterThe(node, -1);\n  }\n\n  const linkURL = new URL(href, element.ownerDocument!.baseURI);\n\n  return afterThe(node, calcNavLinkWeight(linkURL, page.url));\n}\n\n/**\n * @internal\n */\nfunction calcNavLinkWeight(linkURL: URL, pageURL: URL): number {\n  if (linkURL.origin !== pageURL.origin) {\n    return -1;\n  }\n\n  const linkDir = navLinkPath2dir(linkURL);\n  const pageDir = navLinkPath2dir(pageURL);\n\n  if (linkURL.hash) {\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    // Require search parameters to be equal\n\n    const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n    if (searchParamWeight < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n      return -1;\n    }\n\n    return linkURL.pathname.length\n        + searchParamWeight\n        + calcNavLinkWeight(getHashURL(linkURL), getHashURL(pageURL));\n  }\n\n  const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n  if (searchParamWeight) {\n    if (searchParamWeight < 0) {\n      return -1;\n    }\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    return linkURL.pathname.length + searchParamWeight;\n  }\n\n  if (!pageDir.startsWith(linkDir)) {\n    return -1;\n  }\n\n  return linkURL.pathname.length;\n}\n\n/**\n * @internal\n */\nfunction navLinkPath2dir(url: URL): string {\n\n  const path = url.pathname;\n\n  return path.endsWith('/') ? path : path + '/';\n}\n\n/**\n * @internal\n */\nfunction navLinkSearchParamsWeight(\n    { searchParams: linkParams }: URL,\n    { searchParams: pageParams }: URL,\n): number {\n\n  let weight = 0;\n\n  linkParams.forEach((_value, key) => {\n    if (!isIgnoredSearchParam(key)) {\n\n      const pageValues = new Set(pageParams.getAll(key));\n\n      if (weight >= 0) {\n        if (linkParams.getAll(key).every(linkValue => pageValues.has(linkValue))) {\n          weight += 1;\n        } else {\n          weight = -1;\n        }\n      }\n    }\n  });\n\n  return weight;\n}\n\n/**\n * @internal\n */\nfunction isIgnoredSearchParam(key: string): boolean {\n  return key.startsWith('__') && key.endsWith('__');\n}\n\n/**\n * @internal\n */\nconst NavLinkRenderSchedule__symbol = (/*#__PURE__*/ Symbol('nav-link-render-schedule'));\n\n/**\n * @internal\n */\nconst defaultActiveNavLinkClass: QualifiedName = ['active', Wesib__NS];\n\n/**\n * @internal\n */\nfunction activateNavLink(\n    context: ComponentContext,\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => ActiveNavLink {\n\n  const scheduler = context.get(ElementRenderScheduler);\n  const { render, active = defaultActiveNavLinkClass } = def;\n  const activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n  const activate = def.activate ? def.activate.bind(def) : noop;\n  const assignClass = (active: boolean, { node }: { node: ElementNode }): void => {\n\n    const element: Element = node.element;\n    const { classList } = element;\n\n    if (active) {\n      classList.add(activeClass);\n    } else {\n      classList.remove(activeClass);\n    }\n  };\n\n  return opts => {\n\n    const { element } = opts.node;\n    const schedule = element[NavLinkRenderSchedule__symbol]\n        || (element[NavLinkRenderSchedule__symbol] = scheduler(render));\n    const makeActive = (active: boolean): void => {\n      schedule(() => assignClass(active, opts));\n      activate(active, opts);\n    };\n\n    makeActive(true);\n\n    let lastSupply: EventSupply | undefined;\n\n    return {\n      supply(): EventSupply {\n\n        const supply = lastSupply = eventSupply(() => {\n          if (lastSupply === supply) {\n            makeActive(false);\n          }\n        });\n\n        return supply;\n      },\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ArraySet, Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { NavigationSupport } from './navigation-support.feature';\nimport { Page } from './page';\n\n/**\n * Creates component decorator that handles events (e.g. clicks) on navigation links.\n *\n * Such events would lead to {@link Navigation navigation actions} instead of default ones.\n *\n * Enables [[NavigationSupport]] feature.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Navigation links handler definition.\n *\n * @returns New component decorator.\n */\nexport function HandleNavLinks<T extends ComponentClass = Class>(\n    def: HandleNavLinksDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const handle = def.handle ? def.handle.bind(def) : defaultHandleNavLinks(def);\n  const events = new ArraySet(def.event || 'click');\n\n  return Component({\n    feature: {\n      needs: NavigationSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n        context.whenConnected(() => {\n\n          const navigation = context.get(Navigation);\n\n          for (const eventType of events) {\n            context.on(eventType).to(event => {\n              navigation.read().once(\n                  page => handle({\n                    event,\n                    page,\n                    context,\n                    navigation,\n                  }),\n              );\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation links handler definition.\n *\n * @typeparam T  A type of component.\n */\nexport interface HandleNavLinksDef<T extends object = any> {\n\n  /**\n   * Type or types of events to handle.\n   *\n   * `click` by default.\n   */\n  readonly event?: string | readonly string[];\n\n  /**\n   * Handles event by performing navigation action.\n   *\n   * Every {@link event} sent by one of elements inside decorated component is passed to this function. In response\n   * it may perform a navigation event.\n   *\n   * By default handles events on anchor tags. When such tag contains an `href` attribute containing same-origin URL\n   * it {@link Navigation.open opens} a page at this URL instead of default action. It also prevents navigation\n   * if URL didn't change.\n   *\n   * @param event  A click event to handle.\n   * @param page  Current navigation page.\n   * @param navigation  Navigation service to use.\n   * @param context  Component context.\n   */\n  handle?(\n      {\n        event,\n        page,\n        navigation,\n        context,\n      }: {\n        event: Event;\n        page: Page;\n        navigation: Navigation;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n  /**\n   * Extracts hyper-reference of clicked element.\n   *\n   * Extracts hyper-reference from `href` attribute of event target.\n   *\n   * @param event  A click event to handle.\n   *\n   * @returns Extracted hyper-reference, or nothing if it can not be extracted. Event will be ignored in this case.\n   */\n  href?(event: Event): string | undefined | null;\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkHref(event: Event): string | null {\n\n  const target = event.target as Element;\n\n  return target.getAttribute('href');\n}\n\n/**\n * @internal\n */\nfunction defaultHandleNavLinks(\n    def: HandleNavLinksDef,\n): (\n    opts: {\n      event: Event;\n      page: Page;\n      navigation: Navigation;\n    },\n) => void {\n\n  const getHref = def.href ? def.href.bind(def) : defaultNavLinkHref;\n\n  return ({\n    event,\n    page,\n    navigation,\n  }) => {\n\n    const href = getHref(event);\n\n    if (href == null) {\n      return;\n    }\n\n    const target = event.target as Element;\n    const pageURL = page.url;\n    const url = new URL(href, target.ownerDocument!.baseURI);\n\n    if (url.origin !== pageURL.origin) {\n      return; // External link\n    }\n\n    event.preventDefault();\n    if (pageURL.href !== url.href) {\n      navigation.open(href).catch(console.error);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { itsEach, overArray } from '@proc7ts/a-iterable';\nimport { isElement } from '@wesib/wesib';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContent]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param before  The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContent]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: N, to: N) => void),\n    importContent: (this: void, from: N, to: N) => void = importNodeContent,\n): N {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = to.ownerDocument!;\n\n  if (isElement(from)) {\n\n    const elementClone = doc.createElement(from.tagName.toLowerCase()) as Node as (Element & N);\n\n    from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)!));\n    importContent(from, elementClone);\n    to.insertBefore(elementClone, before);\n\n    return elementClone;\n  }\n\n  const nodeClone = doc.importNode(from, false);\n\n  to.insertBefore(nodeClone, before);\n\n  return nodeClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from  The node which contents to import.\n * @param to  The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  itsEach(\n      overArray(from.childNodes),\n      node => importNode(node, to),\n  );\n}\n","import { nextArgs, nextSkip } from '@proc7ts/call-thru';\nimport { eventSupply, EventSupply, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: EventSupply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = eventSupply().whenOff(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad.to(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.cuts(trackSupply).cuts(tracker);\n\n        tracked = {\n          on: tracker.read().thru_(\n              response => response ? nextArgs(response) : nextSkip(),\n          ),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on.tillOff(supply).to(receiver).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          }).catch(console.error);\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import { flatMapIt, itsEach, itsIterator } from '@proc7ts/a-iterable';\nimport { noop } from '@proc7ts/call-thru';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n} from '@proc7ts/fun-events';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\nclass PageLoadRequestsParam$ extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam$();\n\n/**\n * @internal\n */\nexport class PageLoadRequests implements Iterable<PageLoadReq> {\n\n  private readonly _map = new Map<EventSupply, PageLoadReq[]>();\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {}\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    for (const request of this) {\n      if (!request.fragment) {\n        return [];\n      }\n      result.push(request.fragment);\n    }\n\n    return result;\n  }\n\n  [Symbol.iterator](): Iterator<PageLoadReq> {\n    return itsIterator(flatMapIt(this._map.values()));\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = eventSupply();\n    let loadSupply = noEventSupply();\n\n    return {\n      get() {/* void */},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page, when) {\n        if (when === 'pretend') {\n          return;\n        }\n\n        const transferred = self._transfer();\n\n        to.put(PageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = eventSupply().needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page)\n              .tillOff(loadSupply)\n              .to(response => emitter.send(response))\n              .whenOff(error => {\n                if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n                  // Report current page load error as failed load response\n                  emitter.send({\n                    ok: false as const,\n                    page,\n                    error,\n                  });\n                }\n              });\n\n          return supply;\n        }).share();\n\n        itsEach(\n            self,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment).to({\n              supply: eventSupply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest): void {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, Array.from(list));\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.thru_(\n          response => response.ok\n              ? {\n                ...response,\n                fragment: (\n                    fragment.tag != null\n                        ? response.document.getElementsByTagName(fragment.tag)[0]\n                        : response.document.getElementById(fragment.id)\n                ) || undefined,\n              }\n              : response,\n      )\n      : onLoad;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under [[PageLoadAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of loaded document.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an [[PageLoadAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { noop, valueProvider } from '@proc7ts/call-thru';\nimport { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url  An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> = (\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) })\n);\n","import { itsReduction } from '@proc7ts/a-iterable';\nimport { nextEach } from '@proc7ts/call-thru';\nimport { SingleContextKey } from '@proc7ts/context-values';\nimport { EventNotifier, onAsync, OnEvent, onEventBy } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { hthvParse, hthvQuote } from '@proc7ts/http-header-value';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = (/*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n));\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser: DOMParser = new (window as any).DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ Accept: 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request).to(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      requestPageFragments(page, fetchRequest);\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const dispatcher = new EventNotifier<[PageLoadResponse]>();\n\n        dispatcher.on(receiver);\n        dispatcher.send({ page });\n\n        onAsync(httpFetch(fetchRequest).thru_(\n            response => Promise.all([response, response.text()]),\n        )).thru_(\n            (...batch: [Response, string][]) => nextEach(batch),\n            ([response, text]): PageLoadResponse => {\n              if (!response.ok) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error: response.status,\n                };\n              }\n              try {\n                return {\n                  ok: true as const,\n                  page,\n                  response,\n                  document: parsePageDocument(parser, url, response, text),\n                };\n              } catch (error) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error,\n                };\n              }\n            },\n        ).to(receiver);\n      });\n    }\n  };\n}\n\nfunction requestPageFragments(page: Page, request: Request): void {\n\n  const fragments = page.get(PageLoadRequestsParam)?.fragments;\n\n  if (fragments && fragments.length) {\n    request.headers.set(\n        'Accept-Fragment',\n        itsReduction(\n            fragments,\n            (header, fragment) => (header ? header + ', ' : '') + (\n                fragment.tag != null\n                    ? 'tag=' + hthvQuote(fragment.tag)\n                    : 'id=' + hthvQuote(fragment.id)\n            ),\n            '',\n        ),\n    );\n  }\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as SupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/call-thru\n */\nimport { CallChain } from '../call-chain';\nimport { nextCall, NextCall } from '../next-call';\n\n/**\n * Builds a next chained call that passes each provided element to the next pass.\n *\n * Note that default [[CallChain]] supported by [[callThru]] would return only the last element.\n *\n * @typeparam T  A type of element to pass down the chain.\n * @param elements  An iterable of elements to pass down the chain.\n *\n * @returns A multi-call of the next pass with each element.\n */\nexport function nextEach<T>(elements: Iterable<T>): NextCall<CallChain, [T], T> {\n  return nextCall((chain, pass) => {\n    for (const element of elements) {\n      chain.pass(pass, element);\n    }\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nclass PageLoadParam$ extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext): PageParam.Handle<void, PageLoadRequest> {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(PageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const PageLoadParam: PageParam<void, PageLoadRequest> = (/*#__PURE__*/ new PageLoadParam$());\n","import { ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { AfterEvent, afterThe } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = (/*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<PageLoadURLModifier[]>;\n  readonly agent: AfterEvent<PageLoadAgent[]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe(\n          (next, request) => next(new Request(request.url, request))\n              .thru_(\n                  response => {\n                    if (response.ok) {\n\n                      const newRev = appRev(response.document);\n\n                      if (newRev && newRev !== rev) {\n\n                        const url = new URL(response.page.url.href);\n\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                      }\n                    }\n\n                    return response;\n                  },\n              ),\n      );\n    }\n  }\n\n}\n\nfunction appRev(doc: Document): string | null | undefined {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","import { filterIt, itsEach, mapIt, overArray } from '@proc7ts/a-iterable';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, overArray(doc.scripts)),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, overArray(response.document.querySelectorAll('script'))),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      },\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: Iterable<HTMLScriptElement>,\n): Iterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterIt(\n          scripts,\n          script => !!script.src,\n      ),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","import { itsEach, itsFirst, overArray } from '@proc7ts/a-iterable';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      },\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { NavigationSupport } from '../navigation-support.feature';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature: FeatureDef = {\n  needs: NavigationSupport,\n  setup(setup) {\n    setup.provide({\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    });\n    setup.provide({\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    });\n    setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n    setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n    setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n  },\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { noop, valueProvider } from '@proc7ts/call-thru';\nimport { eventSupply } from '@proc7ts/fun-events';\nimport {\n  BootstrapWindow,\n  Class,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  ElementRenderScheduler,\n  RenderDef,\n  StateSupport,\n} from '@wesib/wesib';\nimport { importNodeContent } from '../../util';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageLoadParam } from './page-load-param';\nimport { PageFragmentRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadSupport } from './page-load-support.feature';\n\n/**\n * Creates component decorator that includes page contents into decorated component's element.\n *\n * The page is loaded and included whenever it is {@link Navigation.onEnter entered}.\n *\n * Utilizes [[PageLoadParam]] navigation parameter.\n *\n * Enables [[StateSupport]], [[NavigationSupport]], and [[PageLoadSupport]] features.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Page inclusion definition.\n *\n * @returns New component decorator.\n */\nexport function IncludePage<T extends ComponentClass = Class>(\n    def: IncludePageDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const onResponse = def.onResponse ? def.onResponse.bind(def) : noop;\n  const contentKey = def.contentKey ? def.contentKey.bind(def) : defaultPageContentKey;\n\n  return Component({\n    feature: {\n      needs: [PageLoadSupport, StateSupport],\n    },\n    define(context) {\n      context.whenComponent(context => {\n\n        const { fragment, render } = def;\n        const document = context.get(BootstrapWindow).document;\n        const schedule = context.get(ElementRenderScheduler)(render);\n        const navigation = context.get(Navigation);\n        let lastPageURL: string | undefined = contentKey(navigation.page);\n        let detectFragment: () => PageFragmentRequest;\n\n        if (fragment) {\n          detectFragment = valueProvider(fragment);\n        } else {\n          detectFragment = () => {\n\n            const { element: { id, tagName: tag } }: { element: Element } = context;\n\n            return id ? { id } : { tag };\n          };\n        }\n\n        context.whenConnected(() => {\n\n          const range = document.createRange();\n\n          range.selectNodeContents(context.contentRoot);\n\n          navigation.read().once(page => {\n            page.put(\n                PageLoadParam,\n                {\n                  fragment: detectFragment(),\n                  receiver: {\n                    supply: eventSupply().needs(context),\n                    receive: (_ctx, response) => handleResponse(response),\n                  },\n                },\n            );\n          });\n\n          function handleResponse(response: PageLoadResponse): void {\n\n            const newPageURL = contentKey(response.page);\n\n            if (newPageURL === lastPageURL) {\n              return; // Only hash changed. Do not refresh the page.\n            }\n\n            if (!response.ok) {\n              schedule(() => onResponse({ context, range, response }));\n              return;\n            }\n\n            lastPageURL = newPageURL;\n            schedule(() => {\n              range.deleteContents();\n\n              const target = document.createDocumentFragment();\n              const { fragment } = response;\n\n              if (fragment) {\n                importNodeContent(fragment, target);\n                range.insertNode(target);\n              }\n\n              onResponse({ context, range, response });\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction defaultPageContentKey({ url }: Page): string {\n  return new URL('', url).href;\n}\n\n/**\n * Page inclusion definition.\n *\n * Configures {@link IncludePage @LoadPage} decorator.\n *\n * @typeparam T  A type of component.\n */\nexport interface IncludePageDef<T extends object = any> {\n\n  /**\n   * Page fragment to include.\n   *\n   * By default uses custom element identifier if present, or element tag name otherwise.\n   */\n  readonly fragment?: PageFragmentRequest;\n\n  /**\n   * Rendering options.\n   */\n  readonly render?: RenderDef.Options;\n\n  /**\n   * Builds content key for the given page.\n   *\n   * The loaded content will replace already included one only when their content key differ.\n   *\n   * By default uses page URL without hash part as a key. This prevents content refresh when only URL hash changes.\n   *\n   * @param page  Target page. Either loaded or not.\n   *\n   * @returns Content key.\n   */\n  contentKey?(page: Page): any;\n\n  /**\n   * Performs additional actions during page load.\n   *\n   * This method is called inside page contents render schedule for {@link PageLoadResponse each stage} of page\n   * load. At the final stage it is called after loaded page contents included.\n   *\n   * This method can be used e.g. to indicate the page load progress.\n   *\n   * @param context  Decorated component context.\n   * @param response  Page load response.\n   * @param range  Document range the loaded page contents going to replace.\n   */\n  onResponse?(\n      {\n        context,\n        response,\n        range,\n      }: {\n        context: ComponentContext<T>;\n        response: PageLoadResponse;\n        range: Range;\n      },\n  ): void;\n\n}\n","import cssesc from 'cssesc';\n\n/**\n * @internal\n */\nexport function cssescId(id: string): string {\n  return cssesc(id, { isIdentifier: true });\n}\n\n/**\n * @internal\n */\nexport const IMPORTANT_CSS_SUFFIX = '!important';\n","/**\n * @internal\n */\nexport function isReadonlyArray<T>(value: any): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): array is readonly [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: T[]): array is [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): boolean {\n  return !!array.length;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { StypColor } from './color';\nimport { StypNumeric } from './numeric';\nimport { StypPriority } from './priority';\nimport { StypURL } from './url';\n\n/**\n * CSS property value.\n *\n * This is either a scalar value, or {@link StypValueStruct structured} one.\n *\n * @category CSS Value\n */\nexport type StypValue =\n    | string\n    | number\n    | boolean\n    | undefined\n    | StypNumeric<any>\n    | StypURL\n    | StypColor;\n\n/**\n * Structured property CSS value. E.g. [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length),\n * [percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/percentage),\n * [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value), etc.\n *\n * @category CSS Value\n * @typeparam Self  A type of itself.\n */\nexport abstract class StypValueStruct<Self extends StypValueStruct<Self>> {\n\n  /**\n   * CSS property value priority.\n   *\n   * The value [[StypPriority.Important]] and above means the property is `!important`. Everything else means normal\n   * priority.\n   *\n   * The property value with higher priority number takes precedence over the one with lower one.\n   */\n  readonly priority: number;\n\n  /**\n   * Constructs structured CSS property value.\n   *\n   * @param opts  Construction options.\n   */\n  protected constructor(opts?: StypValue.Opts) {\n    this.priority = opts && opts.priority || StypPriority.Default;\n  }\n\n  /**\n   * Checks whether this value equals to CSS property value.\n   *\n   * @param other  CSS property value to compare with.\n   */\n  abstract is(other: StypValue): boolean;\n\n  /**\n   * Creates structured CSS value with the given `priority`.\n   *\n   * @param priority  New priority.\n   *\n   * @returns Either a new value equal to this one but having the given `priority`, or this one if `priority` did\n   * not change.\n   */\n  abstract prioritize(priority: number): Self;\n\n  /**\n   * Creates `!important` variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to [[StypPriority.Important]],\n   * or this one if already the case.\n   */\n  important(): Self {\n    return this.prioritize(StypPriority.Important);\n  }\n\n  /**\n   * Creates usual (not `!important`) variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to [[StypPriority.Usual]],\n   * or this one if already the case.\n   */\n  usual(): Self {\n    return this.prioritize(StypPriority.Usual);\n  }\n\n  /**\n   * Maps the given CSS property value to the value of this one's type. Defaults to this value if mapping is not\n   * possible.\n   *\n   * This method allows to use an structured value instance as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source  A raw property value that should be converted.\n   *\n   * @returns Mapped property value.\n   */\n  abstract by(source: StypValue): StypValue;\n\n  /**\n   * Returns textual representation of this value.\n   *\n   * Textual representation never contains an `!important` suffix.\n   *\n   * @returns A textual representation of this value to use as CSS property value.\n   */\n  abstract toString(): string;\n\n}\n\nexport namespace StypValue {\n\n  /**\n   * Construction options of structured property CSS value.\n   */\n  export interface Opts {\n\n    /**\n     * Constructed value priority.\n     *\n     * The value [[StypPriority.Important]] and above means the property is `!important`. Everything else means normal\n     * priority.\n     */\n    readonly priority?: number;\n\n  }\n\n}\n\n/**\n * Checks whether two CSS property values are equal.\n *\n * Compares scalar values verbatim. Compares structured values using their [[StypValueStruct.is]] method. The latter\n * method is applied when at least one of the values is structured.\n *\n * @category CSS Value\n * @param first  The first CSS property value to compare.\n * @param second  The second CSS property value to compare.\n *\n * @returns `true` if `first` equals to `second`, or `false otherwise.\n */\nexport function stypValuesEqual(first: StypValue, second: StypValue): boolean {\n  if (first === second) {\n    return true;\n  }\n  if (typeof first === 'object') {\n    return first.is(second);\n  }\n  if (typeof second === 'object') {\n    return second.is(first);\n  }\n  return false;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { StypValue, StypValueStruct } from '../value';\n\n/**\n * Structured [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) CSS property value.\n *\n * Colors are represented by either `rgb()`, or `hsl()` functional notations.\n *\n * @category CSS Value\n */\nexport type StypColor = StypRGB | StypHSL;\n\n/**\n * Structured color CSS property value base.\n *\n * @category CSS Value\n */\nexport abstract class StypColorStruct<Self extends StypColorStruct<Self, Coords>, Coords>\n    extends StypValueStruct<Self> {\n\n  /**\n   * Color value type corresponding to color coordinates. Either `rgb` or `hsl`\n   */\n  abstract readonly type: 'rgb' | 'hsl';\n\n  /**\n   * This color in RGB coordinates.\n   */\n  abstract readonly rgb: StypRGB;\n\n  /**\n   * This color in HSL coordinates.\n   */\n  abstract readonly hsl: StypHSL;\n\n  /**\n   * Constructs another color value with updated coordinates.\n   *\n   * @param coords  Either partial color coordinates to apply or a function returning them and accepting this color\n   * instance as its only argument. Missing values are taken from this color.\n   *\n   * @returns Updated color value.\n   */\n  abstract set(coords: Partial<Coords> | ((this: void, color: this) => Partial<Coords>)): Self;\n\n}\n\n/**\n * CSS property value representing [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors)\n * in `rgb()` or `rgba()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypRGB extends StypColorStruct<StypRGB, StypRGB.Coords> implements StypRGB.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  /**\n   * `rgb` value type.\n   */\n  get type(): 'rgb' {\n    return 'rgb';\n  }\n\n  /**\n   * Red color value between `0` and `255`.\n   */\n  readonly r: number;\n\n  /**\n   * Green color value between `0` and `255`.\n   */\n  readonly g: number;\n\n  /**\n   * Blue color value between `0` and `255`.\n   */\n  readonly b: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs RGB color value.\n   *\n   * @param coords  Color coordinates.\n   * @param opts  Construction options.\n   */\n  constructor(coords: StypRGB.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.r = intCoord(coords.r, 255);\n    this.g = intCoord(coords.g, 255);\n    this.b = intCoord(coords.b, 255);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get rgb(): this {\n    return this;\n  }\n\n  /**\n   * This color in HSL coordinates.\n   */\n  get hsl(): StypHSL {\n\n    const { a } = this;\n    const r = this.r * 100 / 255;\n    const g = this.g * 100 / 255;\n    const b = this.b * 100 / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = Math.round((max + min) / 2);\n\n    if (max === min) {\n      return new StypHSL({ h: 0, s: 0, l, a }, this);\n    }\n\n    const d = max - min;\n    const s = Math.round(l > 50 ? d * 100 / (200 - max - min) : d * 100 / (max + min));\n    let h: number;\n\n    switch (max) {\n    case r:\n      h = ((g - b) / d) + (g < b ? 6 : 0);\n      break;\n    case g:\n      h = ((b - r) / d) + 2;\n      break;\n    default:\n      h = ((r - g) / d) + 4;\n      break;\n    }\n    h *= 60;\n    h = Math.round(h);\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  by(source: StypValue): StypColor {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.r === this.r\n        && other.g === this.g\n        && other.b === this.b\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypRGB {\n    return this.priority === priority ? this : new StypRGB(this, { priority });\n  }\n\n  set(coords: Partial<StypRGB.Coords> | ((this: void, color: this) => Partial<StypRGB.Coords>)): StypRGB {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { r = this.r, g = this.g, b = this.b, a = this.a } = coords;\n\n    return new StypRGB({ r, g, b, a }, this);\n  }\n\n  toString(): string {\n\n    const rgb = `${this.r}, ${this.g}, ${this.b}`;\n\n    return this.a === 1 ? `rgb(${rgb})` : `rgba(${rgb}, ${this.a})`;\n\n  }\n\n}\n\nexport namespace StypRGB {\n\n  /**\n   * [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Red color value between `0` and `255`.\n     */\n    r: number;\n\n    /**\n     * Green color value between `0` and `255`.\n     */\n    g: number;\n\n    /**\n     * Blue color value between `0` and `255`.\n     */\n    b: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * CSS property value representing [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors)\n * in `hsl()` or `hsla()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypHSL extends StypColorStruct<StypHSL, StypHSL.Coords> implements StypHSL.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'hsl' {\n    return 'hsl';\n  }\n\n  /**\n   * Hue angle value in degrees between `0` and `360`.\n   */\n  readonly h: number;\n\n  /**\n   * Saturation percentage.\n   */\n  readonly s: number;\n\n  /**\n   * Lightness percentage.\n   */\n  readonly l: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs HSL color value.\n   *\n   * @param coords  Color coordinates.\n   * @param opts  Construction options.\n   */\n  constructor(coords: StypHSL.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.h = angleCoord(coords.h);\n    this.s = coord(coords.s, 100);\n    this.l = coord(coords.l, 100);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   */\n  get rgb(): StypRGB {\n\n    const { a } = this;\n    const s = this.s / 100;\n    const l = this.l / 100;\n\n    if (!s) {\n\n      const c = l * 255;\n\n      return new StypRGB({ r: c, g: c, b: c, a }, this);\n    }\n\n    const q = l < 0.5 ? l * (1 + s) : (l + s) - (l * s);\n    const p = (2 * l) - q;\n    const hueAsFraction = this.h / 360;\n\n    return new StypRGB(\n        {\n          r: hueToRgb(p, q, hueAsFraction + (1.0 / 3.0)),\n          g: hueToRgb(p, q, hueAsFraction),\n          b: hueToRgb(p, q, hueAsFraction - (1.0 / 3.0)),\n          a,\n        },\n        this,\n    );\n  }\n\n  /**\n   * This color in HSL coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get hsl(): this {\n    return this;\n  }\n\n  by(source: StypValue): StypColor {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.h === this.h\n        && other.s === this.s\n        && other.l === this.l\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypHSL {\n    return this.priority === priority ? this : new StypHSL(this, { priority });\n  }\n\n  set(coords: Partial<StypHSL.Coords> | ((this: void, color: this) => Partial<StypHSL.Coords>)): StypHSL {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { h = this.h, s = this.s, l = this.l, a = this.a } = coords;\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  toString(): string {\n\n    const hsl = `${this.h}, ${this.s}%, ${this.l}%`;\n\n    return this.a === 1 ? `hsl(${hsl})` : `hsla(${hsl}, ${this.a})`;\n  }\n\n}\n\nexport namespace StypHSL {\n\n  /**\n   * [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Hue angle value in degrees.\n     */\n    h: number;\n\n    /**\n     * Saturation percentage.\n     */\n    s: number;\n\n    /**\n     * Lightness percentage.\n     */\n    l: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * @category CSS Value\n */\nexport const StypColor = {\n\n  /**\n   * Maps the given CSS property value to color. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a [[StypColor]] object as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source  A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  by(source: StypValue): StypColor | undefined {\n    if (typeof source === 'object' && (source.type === 'rgb' || source.type === 'hsl')) {\n      return source;\n    }\n    return;\n  },\n\n};\n\n/**\n * @internal\n */\nfunction angleCoord(value: number): number {\n  value = value % 360;\n  return value < 0 ? 360 + value : value;\n}\n\n/**\n * @internal\n */\nfunction intCoord(value: number, max: number): number {\n  return coord(Math.round(value), max);\n}\n\n/**\n * @internal\n */\nfunction coord(value: number, max: number): number {\n  return Math.max(Math.min(value, max), 0);\n}\n\n/**\n * @internal\n */\nfunction hueToRgb(p: number, q: number, t: number): number {\n\n  let newT = t;\n\n  if (newT < 0) {\n    newT += 1;\n  } else if (newT > 1) {\n    newT -= 1;\n  }\n\n  let result;\n\n  if (newT < 1.0 / 6.0) {\n    result = p + ((q - p) * (6 * newT));\n  } else if (newT < 1.0 / 2.0) {\n    result = q;\n  } else if (newT < 2.0 / 3.0) {\n    result = p + (((q - p) * ((2.0 / 3.0) - newT)) * 6);\n  } else {\n    result = p;\n  }\n\n  return result * 255;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { StypColor, StypRGB } from './color';\n\n/**\n * Mixes two colors.\n *\n * Both the `weight` and the relative opacity of each color determines how much of each color is in the result.\n *\n * @category CSS Value\n * @param color1  First color to mix\n * @param color2  Second color to mix.\n * @param weight  A number between `0` and `1`. A larger weight indicates that more of `color1` should be used, and a\n * smaller weight indicates that more of `color2` should be used.\n *\n * @returns Mixed color.\n */\nexport function mixStypColors(color1: StypColor, color2: StypColor, weight: number): StypColor {\n\n  const w = weight * 2 - 1;\n  const rgba1 = color1.rgb;\n  const rgba2 = color2.rgb;\n  const aDiff = rgba1.a - rgba2.a;\n  const w1 = (((w * aDiff === -1) ? w : (w + aDiff) / (1 + w * aDiff)) + 1) / 2.0;\n  const w2 = 1 - w1;\n  return new StypRGB(\n      {\n        r: rgba1.r * w1 + rgba2.r * w2,\n        g: rgba1.g * w1 + rgba2.g * w2,\n        b: rgba1.b * w1 + rgba2.b * w2,\n        a: rgba1.a * weight + rgba2.a * (1 - weight),\n      },\n      color1,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { StypValue, StypValueStruct } from '../value';\nimport { StypZero } from './zero';\n\n/**\n * Structured numeric CSS property value.\n *\n * This represents either dimension, zero value, or a `calc()` CSS function call.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n * @typeparam Zero  A type of zero value. [[StypZero]] by default.\n */\nexport type StypNumeric<Unit extends string, Zero extends StypZero<Unit> | StypDimension<Unit> = StypZero<Unit>> =\n    | StypDimension<Unit>\n    | StypCalc<Unit>\n    | Zero;\n\n/**\n * Base implementation of structured numeric CSS property value.\n *\n * @category CSS Value\n * @typeparam Self  A type of itself.\n * @typeparam Unit  Allowed unit type.\n */\nexport abstract class StypNumericStruct<Self extends StypNumericStruct<Self, Unit>, Unit extends string>\n    extends StypValueStruct<Self> {\n\n  /**\n   * A type of structured numeric CSS property value.\n   */\n  abstract type: 'dimension' | 'calc' | 0;\n\n  readonly dim: StypDimension.Kind<Unit>;\n\n  constructor(opts: StypDimension.Opts<Unit>) {\n    super(opts);\n    this.dim = opts.dim;\n  }\n\n  /**\n   * Tries to converts this numeric value to another dimension.\n   *\n   * Does not actually construct a value in another dimension, as long as dimension unit supported by both dimensions.\n   *\n   * @typeparam U  A unit type allowed in target dimension.\n   * @param dim  Target dimension.\n   *\n   * @returns Either a value in dimension compatible with `dim`, or `undefined` if this value's unit is not supported\n   * by `dim`.\n   */\n  abstract toDim<U extends string>(dim: StypDimension.Kind<U>): StypNumeric<U> | undefined;\n\n  abstract add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  abstract add(addendum: number, unit: Unit): StypNumeric<Unit>;\n\n  abstract sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  abstract sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  abstract mul(multiplier: number): StypNumeric<Unit>;\n\n  abstract div(divisor: number): StypNumeric<Unit>;\n\n  abstract negate(): StypNumeric<Unit>;\n\n  by(source: StypValue): StypNumeric<Unit> {\n    return this.dim.by(source) || this as StypNumeric<Unit>;\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns CSS value text without `!important` or `calc()`.\n   */\n  abstract toFormula(): string;\n\n  toString(): string {\n    return this.toFormula();\n  }\n\n}\n\n/**\n * Structured [dimension](https://developer.mozilla.org/en-US/docs/Web/CSS/dimension) value with unit.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed units type.\n */\nexport interface StypDimension<Unit extends string>\n    extends StypValueStruct<StypDimension<Unit>>, StypNumericStruct<StypDimension<Unit>, Unit> {\n\n  readonly type: 'dimension';\n\n  readonly dim: StypDimension.Kind<Unit>;\n\n  /**\n   * Dimension value.\n   */\n  readonly val: number;\n\n  /**\n   * Dimension unit.\n   */\n  readonly unit: Unit;\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit?: Unit): StypNumeric<Unit>;\n\n  by(source: StypValue): StypNumeric<Unit>;\n\n}\n\nexport namespace StypDimension {\n\n  /**\n   * A kind of dimensions. E.g. angle, length, percentage, etc.\n   *\n   * It is perfectly fine to use dimensions interchangeably as long as dimension units are compatible.\n   *\n   * @typeparam Unit  Allowed units type.\n   */\n  export interface Kind<Unit extends string> {\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports and, in addition, supporting percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if supports percents.\n     */\n    readonly pt?: Kind<Unit | '%'>;\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports, except percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if does not support percents.\n     */\n    readonly noPt: Kind<Exclude<Unit, '%'>>;\n\n    /**\n     * Zero value of this kind.\n     *\n     * Typically, this is unit-less [[StypZero]]. But some dimensions require units.\n     */\n    readonly zero: StypDimension<Unit> | StypZero<Unit>;\n\n    /**\n     * Constructs dimension value.\n     *\n     * @param val  Numeric dimension value.\n     * @param unit  Dimension unit.\n     *\n     * @returns Constructed dimension value. Either [[StypDimension]] instance, or [[StypZero]] if `val` is `0` and\n     * this dimension kind supports unitless zero.\n     */\n    of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit>;\n\n    /**\n     * Maps the given CSS property value to the one compatible with this dimension kind. Defaults to `undefined`\n     * if mapping is not possible.\n     *\n     * This method allows to use a dimension kind as {@link StypMapper.Mapping CSS property mapping}.\n     *\n     * Any scalar or non-numeric value is mapped to `undefined`. A numeric value is converted to this dimension by\n     * [[StypNumericStruct.toDim]] method.\n     *\n     * @param source  A raw property value that should be converted.\n     *\n     * @returns Mapped property value or `undefined`.\n     */\n    by(source: StypValue): StypNumeric<Unit, StypDimension<Unit> | StypZero<Unit>> | undefined;\n\n  }\n\n  export namespace Kind {\n\n    /**\n     * A kind of dimension with unit-less zero. E.g. angle or length.\n     *\n     * @typeparam Unit  Allowed units type.\n     */\n    export interface UnitlessZero<Unit extends string> extends Kind<Unit> {\n\n      readonly pt?: UnitlessZero<Unit | '%'>;\n\n      readonly noPt: UnitlessZero<Exclude<Unit, '%'>>;\n\n      /**\n       * Zero value of this kind without unit.\n       */\n      readonly zero: StypZero<Unit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val  Numeric dimension value.\n       * @param unit  Dimension unit.\n       *\n       * @returns Constructed dimension value. Either [[StypDimension]] instance, or [[StypZero]] if `val` is `0`.\n       */\n      of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit>;\n\n      by(source: StypValue): StypNumeric<Unit> | undefined;\n\n    }\n\n    /**\n     * A kind of dimension which zero value has unit. E.g. frequency or resolution.\n     *\n     * @typeparam Unit  Allowed units type.\n     */\n    export interface UnitZero<Unit extends string> extends Kind<Unit> {\n\n      readonly pt?: UnitZero<Unit | '%'>;\n\n      readonly noPt: UnitZero<Exclude<Unit, '%'>>;\n\n      /**\n       * Zero value of this kind that has unit.\n       */\n      readonly zero: StypDimension<Unit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val  Numeric dimension value.\n       * @param unit  Dimension unit.\n       *\n       * @returns Constructed dimension value as a [[StypDimension]] instance.\n       */\n      of(val: number, unit: Unit): StypDimension<Unit>;\n\n      by(source: StypValue): StypNumeric<Unit, StypDimension<Unit>> | undefined;\n\n    }\n\n  }\n\n  /**\n   * Construction options of dimensions.\n   *\n   * @typeparam Unit  Allowed units type.\n   */\n  export interface Opts<Unit extends string> extends StypValue.Opts {\n\n    /**\n     * A kind of dimension.\n     */\n    dim: Kind<Unit>;\n\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation.\n *\n * This is either a {@link StypAddSub addition/subtraction}, or {@link StypMulDiv multiplication/division}.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport type StypCalc<Unit extends string> = StypAddSub<Unit> | StypMulDiv<Unit>;\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport interface StypAddSub<Unit extends string> extends StypNumericStruct<StypAddSub<Unit>, Unit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<Unit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '+' | '-';\n\n  /**\n   * Right operand.\n   */\n  readonly right: StypNumeric<Unit>;\n\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @category CSS Value\n * @typeparam Unit  Allowed unit type.\n */\nexport interface StypMulDiv<Unit extends string> extends StypNumericStruct<StypMulDiv<Unit>, Unit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<Unit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '*' | '/';\n\n  /**\n   * Right operand.\n   */\n  readonly right: number;\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { itsEach, overKeys } from '@proc7ts/a-iterable';\nimport { StypProperties } from '../rule';\nimport { StypValue } from './value';\n\n/**\n * A type of function that maps CSS properties to something else.\n *\n * @category CSS Value\n * @typeparam R  A type of mapped properties. This is a mapping result type.\n */\nexport type StypMapper<R> =\n/**\n * @param from  CSS properties to map.\n *\n * @returns Mapping result.\n */\n    (this: void, from: StypProperties) => R;\n\nexport namespace StypMapper {\n\n  /**\n   * CSS property mapping.\n   *\n   * It is used to recognize raw property value and convert it to the one of the given type.\n   *\n   * It is one of:\n   * - Default property value. Replaces the source property value, unless the the have the same type.\n   * - A mapping function. Replaces the source property value with the result of this function call.\n   * - An object containing mapping method called `by()`. Replaces the source property value with the result of this\n   *   method call.\n   *\n   * @typeparam R  A type of mapped properties. This is an object containing mapped properties.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export type Mapping<R, K extends keyof R> =\n      | MappingFunction<R, K>\n      | MappingObject<R, K>\n      | R[K];\n\n  /**\n   * CSS property mapping function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export type MappingFunction<R, K extends keyof R> =\n  /**\n   * @param source  A raw property value that should be converted.\n   * @param mapped  An object granting access to other mapped properties.\n   * @param key  A key of converted property.\n   *\n   * @returns Mapped property value.\n   */\n      (this: void, source: StypValue, mapped: Mapped<R>, key: K) => R[K];\n\n  /**\n   * CSS property mapping object.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @typeparam K  Type of mapped properties keys.\n   */\n  export interface MappingObject<R, K extends keyof R> {\n\n    /**\n     * Maps CSS property value.\n     *\n     * @param source  A raw property value that should be converted.\n     * @param mapped  An object granting access to other mapped properties.\n     * @param key  A key of converted property.\n     *\n     * @returns Mapped property value.\n     */\n    by(source: StypValue, mapped: Mapped<R>, key: K): R[K];\n\n  }\n\n  /**\n   * Grants access to mapped values.\n   *\n   * Passed as a second argument to mapping function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   */\n  export interface Mapped<R> {\n\n    /**\n     * Original properties to convert.\n     */\n    from: StypProperties;\n\n    /**\n     * Maps the property with the given type accordingly to mapping instruction.\n     *\n     * The mapping is performed at most once per property.\n     *\n     * @param key  Mapped property key.\n     *\n     * @returns Mapped property value.\n     */\n    get<K extends keyof R>(key: K): R[K];\n\n  }\n\n  /**\n   * Mappings of CSS properties.\n   *\n   * Contains mappings for each mapped CSS property with that property name as a key.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   */\n  export type Mappings<R> = { readonly [key in keyof R]: Mapping<R, key>; };\n\n}\n\nexport const StypMapper = {\n\n  /**\n   * Maps CSS properties accordingly to the given `mappings`.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   *\n   * @param mappings  Mappings of CSS properties.\n   * @param from  Raw CSS properties to map.\n   *\n   * @returns Mapped properties.\n   */\n  map<R>(mappings: StypMapper.Mappings<R>, from: StypProperties): R {\n\n    const result: { [key in keyof R]: R[key] } = {} as any;\n    const mapped = {\n      from,\n      get<K extends keyof R>(key: K): R[K] {\n        if (key in result) {\n          return result[key];\n        }\n\n        const mapper = mappingBy<R, K>(mappings[key]);\n        const mappedValue = mapper(from[key as string], this, key);\n\n        result[key] = mappedValue;\n\n        return mappedValue;\n      },\n    };\n\n    itsEach(overKeys(mappings), key => mapped.get(key));\n\n    return result;\n  },\n\n  /**\n   * Creates CSS properties mapper function.\n   *\n   * @typeparam R  A type of mapped properties. This is a mapping result type.\n   * @param mappings  Mappings of CSS properties.\n   *\n   * @returns A function that maps CSS properties accordingly to the given `mappings`.\n   */\n  by<R>(mappings: StypMapper.Mappings<R>): StypMapper<R> {\n    return StypMapper.map.bind<void, StypMapper.Mappings<R>, [StypProperties], R>(undefined, mappings);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction mappingBy<R, K extends keyof R>(\n    mapping: StypMapper.Mapping<R, K> | undefined,\n): StypMapper.MappingFunction<R, K> {\n  switch (typeof mapping) {\n  case 'function':\n    return mapping as StypMapper.MappingFunction<R, K>;\n  case 'object':\n    return (mapping as StypMapper.MappingObject<R, K>).by.bind(mapping);\n  default:\n  }\n\n  const type = typeof mapping;\n\n  return (from: StypValue): R[K] => typeof from === type ? from as any : mapping;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue } from './value';\n\n/**\n * Predefined CSS property value priorities.\n *\n * @category CSS Value\n */\nexport const enum StypPriority {\n\n  /**\n   * Usual, non-important priority.\n   *\n   * This priority is assigned to values by [[StypValueStruct.usual]] method.\n   */\n  Usual = 0,\n\n  /**\n   * Default priority.\n   *\n   * The same as `Usual`. This priority is assigned to values by default.\n   */\n  Default = Usual,\n\n  /**\n   * Important priority.\n   *\n   * This priority corresponds to values with `!important` suffix. It is applied to string values with `!important`\n   * suffix, and can be assigned to structured values using [[StypValueStruct.important]] method.\n   *\n   * All numeric priorities with higher values are rendered as `!important` ones.\n   */\n  Important = 1,\n\n}\n\n/**\n * Splits undefined CSS property value onto non-prioritized value and priority.\n *\n * @category CSS Value\n * @param value  Undefined CSS property value to split.\n *\n * @returns An `[undefined, 0]` tuple.\n */\nexport function stypSplitPriority<T extends StypValue>(value: undefined): [undefined, 0];\n\n/**\n * Splits string CSS property value onto non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value without `!priority` suffix, and numeric priority (0 or 1).\n */\nexport function stypSplitPriority(value: string): [string, 0 | 1];\n\n/**\n * Splits scalar CSS property value onto non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value and `0` priority.\n */\nexport function stypSplitPriority<T extends number | boolean>(value: T): [T, 0];\n\n/**\n * Splits arbitrary CSS property value onto value non-prioritized value and priority.\n *\n * @param value  CSS property value to split.\n *\n * @returns A tuple containing the value and numeric priority.\n */\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number];\n\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number] {\n  if (value == null) {\n    return [undefined as T, StypPriority.Default];\n  }\n\n  switch (typeof value) {\n  case 'object':\n    return [value, value.priority];\n  case 'string':\n    if (value.endsWith(IMPORTANT_CSS_SUFFIX)) {\n      return [\n        value.substring(0, value.length - IMPORTANT_CSS_SUFFIX.length).trim() as T,\n        StypPriority.Important,\n      ];\n    }\n    break;\n  default:\n  }\n\n  return [value, StypPriority.Default];\n}\n","import { StypPriority } from '../priority';\nimport { StypValue, stypValuesEqual } from '../value';\nimport {\n  StypAddSub as StypAddSub_,\n  StypDimension as StypDimension_,\n  StypMulDiv as StypMulDiv_,\n  StypNumeric,\n  StypNumericStruct,\n} from './numeric';\nimport { StypZero } from './zero';\n\n/**\n * @internal\n */\nexport class StypDimension<Unit extends string>\n    extends StypNumericStruct<StypDimension<Unit>, Unit>\n    implements StypDimension_<Unit> {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'dimension' {\n    return 'dimension';\n  }\n\n  /**\n   * The number value.\n   */\n  readonly val: number;\n\n  /**\n   * The unit.\n   */\n  readonly unit: Unit;\n\n  /**\n   * Constructs new structured dimension value.\n   *\n   * @param val  The numeric value.\n   * @param unit  The unit.\n   * @param opts  CSS value options.\n   */\n  constructor(val: number, unit: Unit, opts: StypDimension_.Opts<Unit>) {\n    super(opts);\n    this.val = val;\n    this.unit = unit;\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypDimension_<U> | undefined {\n\n    const thisDim: StypDimension_.Kind<any> = this.dim;\n\n    if (dim === thisDim /* same dimension */\n        || dim === thisDim.pt /* !% to compatible +% */\n        || dim === (this.unit === '%' ? dim.pt /* % to any +% */ : thisDim.noPt /* !% to compatible -% */)) {\n      return this as StypDimension_<any>;\n    }\n\n    return;\n  }\n\n  is(other: StypValue): boolean {\n    if (other === this) {\n      return true;\n    }\n    return typeof other === 'object'\n        && other.type === this.type\n        && this.unit === other.unit\n        && this.val === other.val\n        && this.priority === other.priority;\n  }\n\n  prioritize(priority: number): StypDimension<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypDimension(this.val, this.unit, { dim: this.dim, priority });\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit || this.unit, this);\n    }\n    if (addendum.type === 'dimension' && this.unit === addendum.unit) {\n      return stypDimension(this.val + addendum.val, this.unit, this);\n    }\n    return stypAddSub(this, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit?: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit || this.unit, this);\n    }\n    if (subtrahend.type === 'dimension' && this.unit === subtrahend.unit) {\n      return stypDimension(this.val - subtrahend.val, this.unit, this);\n    }\n    return stypAddSub(this, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return multiplier === 1 ? this : stypDimension(this.val * multiplier, this.unit, this);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return divisor === 1 ? this : stypDimension(this.val / divisor, this.unit, this);\n  }\n\n  negate(): StypNumeric<Unit> {\n    return stypDimension(-this.val, this.unit, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `<value><unit>` or just `0`.\n   */\n  toFormula(): string {\n    return this.val + this.unit;\n  }\n\n}\n\n/**\n * Constructs structured [dimension] CSS property value.\n *\n * @param val  Numeric value.\n * @param unit  Value unit.\n * @param opts  Construction options.\n *\n * @returns Either [[StypDimension]], or [[StypZero]] if `val === 0`.\n *\n * [dimension]: https://developer.mozilla.org/en-US/docs/Web/CSS/dimension\n *\n * @internal\n */\nexport function stypDimension<Unit extends string>(\n    val: number,\n    unit: Unit,\n    opts: StypDimension_.Opts<Unit>,\n): StypDimension_<Unit> | StypZero<Unit> {\n  return val\n      ? new StypDimension<Unit>(val, unit, opts)\n      : opts.dim.zero.prioritize(opts.priority || StypPriority.Default);\n}\n\n/**\n * @internal\n */\nexport abstract class StypCalcBase<\n    Self extends StypCalcBase<Self, Op, Right, Unit>,\n    Op extends '+' | '-' | '*' | '/',\n    Right extends number | StypNumeric<Unit>,\n    Unit extends string>\n    extends StypNumericStruct<Self, Unit> {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'calc' {\n    return 'calc';\n  }\n\n  readonly left: StypNumeric<Unit>;\n  readonly op: Op;\n  readonly right: Right;\n\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(\n      left: StypNumeric<Unit>,\n      op: Op,\n      right: Right,\n      opts: StypDimension_.Opts<Unit>,\n  ) {\n    super(opts);\n    this.left = left.usual();\n    this.op = op;\n    this.right = right;\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object' && other.type === this.type) {\n      return this.op === other.op\n          && this.left.is(other.left)\n          && stypValuesEqual(this.right, other.right)\n          && this.priority === other.priority;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as Unit, this);\n    }\n    return stypAddSub(this as StypNumeric<Unit>, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as Unit, this);\n    }\n    return stypAddSub(this as StypNumeric<Unit>, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return stypMul(this as StypNumeric<Unit>, multiplier);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return stypDiv(this as StypNumeric<Unit>, divisor);\n  }\n\n  abstract negate(): StypNumeric<Unit>;\n\n  abstract prioritize(priority: number): Self;\n\n  abstract toFormula(): string;\n\n  toString(): string {\n    return 'calc' + super.toString();\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @typeparam Unit  Allowed unit type.\n *\n * @internal\n */\nexport class StypAddSub<Unit extends string>\n    extends StypCalcBase<StypAddSub<Unit>, '+' | '-', StypNumeric<Unit>, Unit>\n    implements StypAddSub_<Unit> {\n\n  constructor(left: StypNumeric<Unit>, op: '+' | '-', right: StypNumeric<Unit>, opts: StypDimension_.Opts<Unit>) {\n    super(left, op, right.usual(), opts);\n  }\n\n  prioritize(priority: number): StypAddSub<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypAddSub(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypAddSub<U> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    const right = this.right.toDim(dim);\n\n    if (!right) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any> && right === this.right as StypNumeric<any>) {\n      return this as StypAddSub<any>;\n    }\n\n    return new StypAddSub<U>(left, this.op, right, { dim, priority: this.priority });\n  }\n\n  negate(): StypNumeric<Unit> {\n    return this.op === '-'\n        ? new StypAddSub(this.right, this.op, this.left, this)\n        : new StypAddSub(this.left.negate(), '-', this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right.toFormula()})`;\n  }\n\n}\n\nfunction stypAddSub<Unit extends string>(\n    left: StypNumeric<Unit>,\n    op: '+' | '-',\n    right: StypNumeric<Unit>,\n): StypNumeric<Unit> {\n  return !right.type ? left : new StypAddSub(left, op, right, left);\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @typeparam Unit  Allowed unit type.\n *\n * @internal\n */\nexport class StypMulDiv<Unit extends string>\n    extends StypCalcBase<StypMulDiv<Unit>, '*' | '/', number, Unit>\n    implements StypMulDiv_<Unit> {\n\n  prioritize(priority: number): StypMulDiv<Unit> {\n    return this.priority === priority\n        ? this\n        : new StypMulDiv(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<U extends string>(dim: StypDimension_.Kind<U>): StypMulDiv<U> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any>) {\n      return this as StypMulDiv<any>;\n    }\n\n    return new StypMulDiv<U>(left, this.op, this.right, { dim, priority: this.priority });\n  }\n\n  mul(multiplier: number): StypNumeric<Unit> {\n    return (this.op === '*'\n        ? stypMul(this.left, this.right * multiplier)\n        : stypDiv(this.left, this.right / multiplier))\n        .prioritize(this.priority);\n  }\n\n  div(divisor: number): StypNumeric<Unit> {\n    return (this.op === '/'\n        ? stypDiv(this.left, this.right * divisor)\n        : stypMul(this.left, this.right / divisor))\n        .prioritize(this.priority);\n  }\n\n  negate(): StypNumeric<Unit> {\n    return new StypMulDiv(this.left, this.op, -this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right})`;\n  }\n\n}\n\nfunction stypMul<Unit extends string>(left: StypNumeric<Unit>, right: number): StypNumeric<Unit> {\n  return !right\n      ? left.dim.zero.prioritize(left.priority)\n      : right === 1\n          ? left.prioritize(left.priority)\n          : new StypMulDiv(left, '*', right, left);\n}\n\nfunction stypDiv<Unit extends string>(left: StypNumeric<Unit>, right: number): StypNumeric<Unit> {\n  return right === 1\n      ? left.prioritize(left.priority)\n      : new StypMulDiv(left, '/', right, left);\n}\n\n/**\n * @internal\n */\nexport function isStypNumeric(source: StypValue): source is StypNumeric<any, any> {\n  return typeof source === 'object' && (source.type === 'dimension' || source.type === 'calc' || source.type === 0);\n}\n","import { StypPriority } from '../priority';\nimport { StypValue } from '../value';\nimport { StypDimension, StypNumeric, StypNumericStruct } from './';\nimport { stypDimension } from './numeric.impl';\nimport { StypZero } from './zero';\n\nclass Zero<Unit extends string> extends StypNumericStruct<Zero<Unit>, Unit> implements StypZero<Unit> {\n\n  constructor(private readonly _byPriority: ZeroByPriority<Unit>, opts: StypDimension.Opts<Unit>) {\n    super(opts);\n  }\n\n  get type(): 0 {\n    return 0;\n  }\n\n  toDim<U extends string>(dim: StypDimension.Kind<U>): StypDimension<U> | StypZero<U> {\n    return dim.zero.prioritize(this.priority);\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object') {\n      return other.type === this.type && other.priority === this.priority;\n    }\n    if (other === 0 || other === '0') {\n      return this.priority === StypPriority.Usual;\n    }\n    if (other === '0 !important') {\n      return this.priority === StypPriority.Important;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  add(addendum: number, unit?: Unit): StypNumeric<Unit>;\n\n  add(addendum: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as Unit, this);\n    }\n    return addendum.prioritize(this.priority);\n  }\n\n  sub(subtrahend: StypNumeric<Unit>): StypNumeric<Unit>;\n\n  sub(subtrahend: number, unit: Unit): StypNumeric<Unit>;\n\n  sub(subtrahend: StypNumeric<Unit> | number, unit?: Unit): StypNumeric<Unit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as Unit, this);\n    }\n    return subtrahend.negate().prioritize(this.priority);\n  }\n\n  mul(): this {\n    return this;\n  }\n\n  div(): this {\n    return this;\n  }\n\n  negate(): this {\n    return this;\n  }\n\n  prioritize(priority: number): Zero<Unit> {\n    return this._byPriority.get(priority);\n  }\n\n  important(): Zero<Unit> {\n    return this._byPriority.important;\n  }\n\n  usual(): Zero<Unit> {\n    return this._byPriority.usual;\n  }\n\n  toFormula(): string {\n    return '0';\n  }\n\n}\n\nclass ZeroByPriority<Unit extends string> {\n\n  readonly usual: Zero<Unit>;\n  readonly important: Zero<Unit>;\n\n  constructor(readonly dim: StypDimension.Kind<Unit>) {\n    this.usual = new Zero(this, { dim });\n    this.important = new Zero(this, { dim, priority: StypPriority.Important });\n  }\n\n  get(priority: number): Zero<Unit> {\n    switch (priority) {\n    case StypPriority.Usual: return this.usual;\n    case StypPriority.Important: return this.important;\n    }\n    return new Zero(this, { dim: this.dim, priority });\n  }\n\n}\n\n/**\n * @internal\n */\nexport function newStypZero<Unit extends string>(dim: StypDimension.Kind.UnitlessZero<Unit>): StypZero<Unit> {\n  return new ZeroByPriority<Unit>(dim).usual;\n}\n","import { StypValue } from '../value';\nimport { StypDimension, StypNumeric } from './numeric';\nimport { isStypNumeric, StypDimension as StypDimension_ } from './numeric.impl';\nimport { StypZero } from './zero';\nimport { newStypZero } from './zero.impl';\n\n/**\n * @internal\n */\nexport function unitlessZeroDimensionKind<Unit extends string>(\n    {\n      pt,\n      noPt,\n    }: {\n      pt: () => StypDimension.Kind.UnitlessZero<Unit | '%'>;\n      noPt: () => StypDimension.Kind.UnitlessZero<Exclude<Unit, '%'>>;\n    },\n): StypDimension.Kind.UnitlessZero<Unit> {\n\n  const dimension: StypDimension.Kind.UnitlessZero<Unit> = {\n\n    get zero(): StypZero<Unit> {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return zero;\n    },\n\n    get pt() {\n      return pt();\n    },\n\n    get noPt() {\n      return noPt();\n    },\n\n    of(val: number, unit: Unit): StypDimension<Unit> | StypZero<Unit> {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return val ? new StypDimension_(val, unit, { dim: this }) : zero;\n    },\n\n    by(source: StypValue): StypNumeric<Unit> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n\n      const numeric: StypNumeric<any, any> = source;\n\n      return numeric.toDim(this);\n    },\n\n  };\n\n  const zero = newStypZero<Unit>(dimension);\n\n  return dimension;\n}\n\n/**\n * @internal\n */\nexport function unitZeroDimensionKind<Unit extends string>(\n    {\n      zeroUnit,\n      withPercent,\n      noPercent,\n    }: {\n      zeroUnit: Unit;\n      withPercent?: () => StypDimension.Kind.UnitZero<Unit | '%'>;\n      noPercent?: () => StypDimension.Kind.UnitZero<Exclude<Unit, '%'>>;\n    },\n): StypDimension.Kind.UnitZero<Unit> {\n\n  const dim: StypDimension.Kind.UnitZero<Unit> = {\n\n    get pt() {\n      return withPercent && withPercent();\n    },\n\n    get noPt() {\n      return noPercent ? noPercent() : this as StypDimension.Kind.UnitZero<Exclude<Unit, '%'>>;\n    },\n\n    get zero(): StypDimension<Unit> {\n      return zero;// eslint-disable-line @typescript-eslint/no-use-before-define\n    },\n\n    of(val: number, unit: Unit): StypDimension<Unit> {\n      return new StypDimension_(val, unit, { dim: this });\n    },\n\n    by(source: StypValue): StypNumeric<Unit, StypDimension<Unit>> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n\n      const numeric: StypNumeric<any, any> = source;\n\n      return numeric.toDim(this);\n    },\n\n  };\n\n  const zero = new StypDimension_(0, zeroUnit, { dim });\n\n  return dim;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { StypDimension, StypNumeric } from '../numeric';\nimport { unitlessZeroDimensionKind } from '../numeric/dimension-kind.impl';\n\n/**\n * Structured [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) property value.\n *\n * Can be constructed using `StypLength.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLength = StypNumeric<StypLength.Unit>;\n\nexport namespace StypLength {\n\n  /**\n   * Supported length units, excluding percent.\n   */\n  export type Unit = 'cap' | 'ch' | 'em' | 'ex' | 'ic' | 'lh' | 'rem' | 'rlh'\n      | 'vh' | 'vw' | 'vi' | 'vb' | 'vmin' | 'vmax'\n      | 'px' | 'cm' | 'mm' | 'Q' | 'in' | 'pc' | 'pt';\n\n}\n\nexport const StypLength: StypDimension.Kind.UnitlessZero<StypLength.Unit> = (/*#__PURE__*/ unitlessZeroDimensionKind({\n  pt() {\n    return StypLengthPt;// eslint-disable-line @typescript-eslint/no-use-before-define\n  },\n  noPt() {\n    return StypLength;\n  },\n}));\n\n/**\n * Structured [length-percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage) CSS property\n * value.\n *\n * Can be constructed using `StypLengthPt.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLengthPt = StypNumeric<StypLengthPt.Unit>;\n\nexport namespace StypLengthPt {\n\n  /**\n   * Supported length units, including percent.\n   */\n  export type Unit = StypLength.Unit | '%';\n\n}\n\nexport const StypLengthPt: StypDimension.Kind.UnitlessZero<StypLengthPt.Unit> = (\n    /*#__PURE__*/ unitlessZeroDimensionKind({\n      pt() {\n        return StypLengthPt;\n      },\n      noPt() {\n        return StypLength;\n      },\n    })\n);\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport cssesc from 'cssesc';\nimport { stypSplitPriority } from './priority';\nimport { StypValue, StypValueStruct } from './value';\n\n/**\n * Structured [URL](https://developer.mozilla.org/en-US/docs/Web/CSS/url) CSS property value.\n *\n * @category CSS Value\n */\nexport class StypURL extends StypValueStruct<StypURL> {\n\n  /**\n   * Target URL.\n   */\n  readonly url: string;\n\n  /**\n   * `url` value type.\n   */\n  get type(): 'url' {\n    return 'url';\n  }\n\n  /**\n   * Maps the given CSS property value to URL. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a [[StypURL]] class as [CSS property mapping][[StypMapper.Mapping]].\n   *\n   * Strings are treated as URLs (without `url()` functional syntax). `!important` suffix is respected.\n   *\n   * @param source  A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  static by(source: StypValue): StypURL | undefined {\n    switch (typeof source) {\n    case 'string': {\n\n      const [url, priority] = stypSplitPriority(source);\n\n      return new StypURL(url, { priority });\n    }\n    case 'object':\n      if (source.type === 'url') {\n        return source;\n      }\n      break;\n    default:\n    }\n    return;\n  }\n\n  /**\n   * Constructs URL value.\n   *\n   * @param url  Target URL.\n   * @param opts  Construction options.\n   */\n  constructor(url: string, opts?: StypValue.Opts) {\n    super(opts);\n    this.url = url;\n  }\n\n  by(source: StypValue): StypURL {\n    return StypURL.by(source) || this;\n  }\n\n  prioritize(priority: number): StypURL {\n    return priority === this.priority ? this : new StypURL(this.url, { priority });\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === 'url'\n        && other.url === this.url\n        && other.priority === this.priority;\n  }\n\n  toString(): string {\n    return `url('${cssesc(this.url)}')`;\n  }\n\n}\n","import { filterIt, itsIterator, itsReduction, overEntries } from '@proc7ts/a-iterable';\nimport { asis, isPresent, nextSkip, NextSkip, valuesProvider } from '@proc7ts/call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  isEventSender,\n} from '@proc7ts/fun-events';\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue, stypValuesEqual } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * @internal\n */\nexport const noStypProperties: AfterEvent<[StypProperties]> = (/*#__PURE__*/ afterThe({}));\n\n/**\n * @internal\n */\nexport function noStypPropertiesSpec(): AfterEvent<[StypProperties]> {\n  return noStypProperties;\n}\n\n/**\n * @internal\n */\nexport function stypPropertiesBySpec(rule: StypRule, spec?: StypProperties.Spec): AfterEvent<[StypProperties]> {\n  if (!spec) {\n    return noStypProperties;\n  }\n  if (typeof spec !== 'string') {\n    if (isEventKeeper(spec)) {\n      return preventDuplicates(spec);\n    }\n    if (isEventSender(spec)) {\n      return preventDuplicates(propertiesKeeper(spec));\n    }\n    if (typeof spec === 'function') {\n\n      const senderOrProperties = spec(rule);\n\n      if (typeof senderOrProperties !== 'string') {\n        if (isEventKeeper(senderOrProperties)) {\n          return preventDuplicates(senderOrProperties);\n        }\n        if (isEventSender(senderOrProperties)) {\n          return preventDuplicates(propertiesKeeper(senderOrProperties));\n        }\n      }\n\n      return afterThe(propertiesMap(senderOrProperties));\n    }\n  }\n\n  return afterThe(propertiesMap(spec));\n}\n\nfunction propertiesKeeper(sender: EventSender<[string | StypProperties]>): AfterEvent<[string | StypProperties]> {\n  return afterSupplied(sender, valuesProvider({}));\n}\n\nfunction preventDuplicates(properties: EventKeeper<[string | StypProperties]>): AfterEvent<[StypProperties]> {\n  return afterSupplied(properties).keepThru(\n      propertiesMap,\n      passNonDuplicate(),\n      asis as (props: StypProperties) => StypProperties, // Needed to satisfy signature\n  );\n}\n\nfunction passNonDuplicate(): (update: StypProperties) => StypProperties | NextSkip {\n\n  let stored: StypProperties | undefined;\n\n  return update => {\n    if (stored && propertiesEqual(update, stored)) {\n      return nextSkip();\n    }\n    return stored = { ...update };\n  };\n}\n\nfunction propertiesMap(properties: string | StypProperties): StypProperties {\n  return typeof properties === 'string' ? { $$css: properties } : properties;\n}\n\nfunction propertiesEqual(first: StypProperties, second: StypProperties): boolean {\n\n  const s = itsIterator(propertyEntries(second));\n\n  for (const [key, value] of propertyEntries(first)) {\n\n    const { value: sentry } = s.next();\n\n    if (!sentry || key !== sentry[0] || !stypValuesEqual(value, sentry[1])) {\n      return false;\n    }\n  }\n\n  return !s.next().value;\n}\n\nfunction propertyEntries(properties: StypProperties): Iterable<[keyof StypProperties, StypValue]> {\n  return filterIt(overEntries(properties), isPresent);\n}\n\n/**\n * @internal\n */\nexport function mergeStypProperties(\n    base: AfterEvent<[StypProperties]>,\n    addendum: AfterEvent<[StypProperties]>,\n): AfterEvent<[StypProperties]> {\n  return preventDuplicates(\n      afterAll({ base, addendum }).keepThru(\n          ({ base: [baseProperties], addendum: [addendumProperties] }) => addValues(baseProperties, addendumProperties),\n      ),\n  );\n}\n\nfunction addValues(base: StypProperties, addendum: StypProperties): StypProperties {\n  return itsReduction(\n      overEntries(addendum),\n      (result, [k, v]) => addValue(result, k, v),\n      { ...base },\n  );\n}\n\nfunction addValue(\n    properties: StypProperties.Mutable,\n    key: keyof StypProperties,\n    value: StypValue,\n): StypProperties.Mutable {\n  if (priorityOf(properties[key]) <= priorityOf(value)) {\n    delete properties[key];\n    properties[key] = value;\n  }\n  return properties;\n}\n\nfunction priorityOf(value: StypValue): number {\n  switch (typeof value) {\n  case 'string':\n    return value.endsWith(IMPORTANT_CSS_SUFFIX) ? 1 : 0;\n  case 'object':\n    return value.priority;\n  default:\n    return 0;\n  }\n}\n","import { flatMapIt } from '@proc7ts/a-iterable';\nimport { compareNames, isQualifiedName, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { isNotEmptyArray, isReadonlyArray } from '../internal';\nimport { StypPureSelector } from './pure-selector';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSubSelector } from './sub-selector';\n\n/**\n * @internal\n */\nexport function isCombinator(\n    item: string | StypSelector.Part | StypSelector.Combinator,\n): item is StypSelector.Combinator {\n  return item === '>' || item === '+' || item === '~';\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized {\n  if (!isReadonlyArray(selector)) {\n    return [normalizeKey(selector)];\n  }\n\n  const normalized: StypSelector.Mutable = [];\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (const item of selector) {\n\n    const prevCombinator = combinator;\n\n    if (combinator) {\n      normalized.push(combinator);\n      combinator = undefined;\n    }\n\n    let part: StypSelector.NormalizedPart;\n\n    if (isCombinator(item)) {\n      combinator = item;\n      if (!prevCombinator) {\n        continue;\n      }\n      part = {};\n    } else {\n      part = normalizeKey(item);\n    }\n\n    normalized.push(part);\n  }\n  if (combinator) {\n    normalized.push(combinator, {});\n  }\n\n  return normalized;\n}\n\nfunction normalizeKey(key: StypSelector.Part | string): StypSelector.NormalizedPart {\n  if (typeof key === 'string') {\n    if (!key) {\n      return {};\n    }\n    return { s: key };\n  }\n  return normalizeStypSelectorPart(key);\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelectorPart(part: StypSelector.Part): StypSelector.NormalizedPart {\n\n  const ns = part.ns || undefined;\n  const i = part.i || undefined;\n  const c = normalizeClasses(part.c);\n  const u = normalizeSubSelectors(part.u);\n\n  return {\n    ns,\n    e: (part.e !== '*' || !ns && !i && !c && u && isPseudoSubSelector(u[0])) && part.e || undefined,\n    i,\n    c,\n    u,\n    s: part.s || undefined,\n    $: normalizeQualifiers(part.$),\n  };\n}\n\nfunction normalizeClasses(\n    classes: QualifiedName | readonly QualifiedName[] | undefined,\n): readonly [QualifiedName, ...QualifiedName[]] | undefined {\n  if (!classes) {\n    return;\n  }\n  if (isQualifiedName(classes)) {\n    return [classes];\n  }\n\n  const result = classes.filter(c => !!c);\n\n  return isNotEmptyArray(result) ? result.sort(compareNames) : undefined;\n}\n\nfunction normalizeSubSelectors(\n    subs: StypSubSelector | readonly StypSubSelector[] | undefined,\n): readonly [StypSubSelector.Normalized, ...StypSubSelector.Normalized[]] | undefined {\n  if (!subs) {\n    return;\n  }\n  if (/*#__INLINE__*/ isSubSelectorsArray(subs)) {\n\n    const result = subs.map(normalizeSubSelector);\n\n    return isNotEmptyArray(result) ? result : undefined;\n  }\n\n  return [normalizeSubSelector(subs)];\n}\n\nfunction isSubSelectorsArray(\n    subs: StypSubSelector | readonly StypSubSelector[],\n): subs is readonly StypSubSelector[] {\n  return typeof subs[0] !== 'string';\n}\n\nfunction normalizeSubSelector(sub: StypSubSelector): StypSubSelector.Normalized {\n  if (!isPseudoSubSelector(sub)) {\n    return sub;\n  }\n  if (sub.length < 3) {\n    return sub as StypSubSelector.Normalized;\n  }\n\n  const [prefix, name, ...params] = sub;\n\n  if (/*#__INLINE__*/ isSubSelectorParametersArray(params)) {\n    return [prefix, name, ...params.map(normalizeStypSelector)];\n  }\n\n  return [prefix, name, normalizeStypSelector(params)];\n}\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector.Normalized): sub is StypSubSelector.NormalizedPseudo;\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo;\n\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo {\n  return sub.length > 1 && (sub[0] === ':' || sub[0] === '::');\n}\n\nfunction isSubSelectorParametersArray(\n    param: StypSubSelector.Parameter | readonly StypSubSelector.Parameter[],\n): param is readonly StypSubSelector.Parameter[] {\n  return isReadonlyArray(param[0]);\n}\n\nfunction normalizeQualifiers(\n    qualifiers: string | readonly string[] | undefined,\n): readonly [string, ...string[]] | undefined {\n  if (!qualifiers) {\n    return;\n  }\n\n  if (!isReadonlyArray(qualifiers)) {\n    qualifiers = Array.from(exposeQualifier(qualifiers));\n  } else {\n    qualifiers = Array.from(new Set(flatMapIt(qualifiers, exposeQualifier))).sort();\n  }\n\n  return isNotEmptyArray(qualifiers) ? qualifiers : undefined;\n}\n\nconst noQualifiers: Set<string> = new Set();\n\nfunction exposeQualifier(qualifier: string): Set<string> {\n  if (!qualifier) {\n    return noQualifiers;\n  }\n\n  const eqIdx = qualifier.indexOf('=');\n  const name = eqIdx < 0 ? qualifier : qualifier.substring(0, eqIdx);\n  const exposed = new Set<string>();\n  let lastExposed: string | undefined;\n\n  for (const part of name.split(':')) {\n    if (lastExposed) {\n      lastExposed += ':' + part;\n    } else {\n      lastExposed = part;\n    }\n    exposed.add(lastExposed);\n  }\n  if (eqIdx >= 0) {\n    exposed.add(qualifier);\n  }\n\n  return exposed;\n}\n\nconst noKeyAndTail: [[]] = [[]];\n\n/**\n * @internal\n */\nexport function stypRuleKeyAndTail(\n    selector: StypSelector.Normalized,\n): readonly [[]] | readonly [StypRuleKey.Nested, StypSelector.Normalized?] {\n  if (!selector.length) {\n    return noKeyAndTail;\n  }\n\n  let i = 0;\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (;;) {\n\n    const part = selector[i++];\n\n    if (isCombinator(part)) {\n      combinator = part;\n      continue;\n    }\n\n    const key: StypRuleKey = combinator ? [combinator, part] : [part];\n\n    return [key, selector.slice(i)];\n  }\n}\n\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * @internal\n */\nexport function stypOuterSelector(\n    selector: StypSelector.Normalized,\n): StypSelector.Normalized | undefined {\n\n  let i = selector.length - 1;\n\n  if (i <= 0) {\n    return i ? undefined : rootSelector;\n  }\n\n  do {\n    --i;\n    switch (selector[i]) {\n    case '>':\n      return selector.slice(0, i);\n    case '+':\n    case '~':\n      --i;\n      continue;\n    default:\n      return selector.slice(0, i + 1);\n    }\n  } while (i > 0);\n\n  return;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { namesEqual, NamespaceDef, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { normalizeStypSelectorPart } from './selector.impl';\n\n/**\n * CSS rule query.\n *\n * It may represent a selector like `element-name#id.class1.classN` with any of sub-parts omitted.\n *\n * Queries are used to grab a subset of matching rules from `StypRule`.\n *\n * All of its properties are optional.\n *\n * @category CSS Rule\n */\nexport interface StypQuery {\n\n  /**\n   * Element namespace.\n   */\n  readonly ns?: string | NamespaceDef;\n\n  /**\n   * Element name.\n   *\n   * This is the same as `*` when absent.\n   */\n  readonly e?: QualifiedName;\n\n  /**\n   * Element identifier.\n   */\n  readonly i?: QualifiedName;\n\n  /**\n   * Element class name or names.\n   */\n  readonly c?: QualifiedName | readonly QualifiedName[];\n\n  /**\n   * Qualifier or qualifiers.\n   */\n  readonly $?: string | readonly string[];\n\n}\n\nexport namespace StypQuery {\n\n  /**\n   * Normalized CSS rule query.\n   */\n  export type Normalized = StypQuery & StypSelector.NormalizedPart;\n\n}\n\n/**\n * Normalizes arbitrary CSS rule query.\n *\n * @category CSS Rule\n * @param query  CSS rule query to normalize.\n *\n * @returns Normalized CSS rule query.\n */\nexport function stypQuery(query: StypQuery): StypQuery.Normalized {\n  return normalizeStypSelectorPart(query);\n}\n\n/**\n * Checks whether the given structured CSS `selector` matches target `query`.\n *\n * @category CSS Rule\n * @param selector  Normalized structured CSS selector.\n * @param query  Normalized CSS rule query.\n *\n * @returns `true` if `selector` matches the `query`, or `false` otherwise.\n */\nexport function stypSelectorMatches(\n    selector: StypSelector.Normalized | StypPureSelector.Normalized,\n    query: StypQuery.Normalized,\n): boolean {\n  if (!selector.length) {\n    return false;\n  }\n\n  const part = selector[selector.length - 1] as StypSelector.NormalizedPart;\n\n  if (query.ns && part.ns !== query.ns) {\n    return false;\n  }\n  if (query.e && part.e !== query.e) {\n    return false;\n  }\n  if (query.i && part.i !== query.i) {\n    return false;\n  }\n  if (query.c && !classesMatch(part.c, query.c)) {\n    return false;\n  }\n  // noinspection RedundantIfStatementJS\n  if (query.$ && !classesMatch(part.$, query.$)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * @internal\n */\nfunction classesMatch(\n    classes: readonly QualifiedName[] | undefined,\n    query: readonly QualifiedName[],\n): boolean | undefined {\n  return classes && query.every(qClass => classes.find(mClass => namesEqual(qClass, mClass)));\n}\n","import { StypSelector } from './index';\nimport { StypPureSelector } from './pure-selector';\nimport { normalizeStypSelector } from './selector.impl';\n\n/**\n * Converts normalized pure CSS selector part to normalized pure CSS selector.\n *\n * @category CSS Rule\n * @param selector  Normalized pure CSS selector part.\n *\n * @returns Normalized pure CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * Converts normalized structured CSS selector part to normalized structured CSS selector.\n *\n * @category CSS Rule\n * @param selector  Normalized CSS selector part.\n *\n * @returns Normalized structured CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * Normalizes arbitrary pure CSS selector.\n *\n * @param selector  CSS selector to normalize.\n *\n * @returns Normalized pure CSS selector.\n */\nexport function stypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * Normalizes arbitrary structured CSS selector.\n *\n * @param selector  CSS selector to normalize.\n *\n * @returns Normalized structured CSS selector.\n */\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized {\n  return normalizeStypSelector(selector);\n}\n","import {\n  css__naming,\n  html__naming,\n  id__naming,\n  NamespaceAliaser,\n  NamespaceDef,\n  newNamespaceAliaser,\n} from '@proc7ts/namespace-aliaser';\nimport cssesc from 'cssesc';\nimport { cssescId } from '../internal';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSelectorFormat } from './selector-text';\nimport { isCombinator, isPseudoSubSelector } from './selector.impl';\nimport { StypSubSelector } from './sub-selector';\n\nconst ruleKeyTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${cssescId(qualifier)}`;\n  },\n};\n\n/**\n * @internal\n */\nexport function stypRuleKeyText(key: StypRuleKey): string {\n  return formatStypSelector(key, ruleKeyTextOpts);\n}\n\nconst displayTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${qualifier}`;\n  },\n};\n\n/**\n * @internal\n */\nexport function stypSelectorDisplayText(selector: StypSelector.Normalized): string {\n  return formatStypSelector(selector, displayTextOpts);\n}\n\nconst defaultFormat: StypSelectorFormat = {};\n\n/**\n * @internal\n */\nexport function formatStypSelector(\n    selector: StypSelector.Normalized,\n    {\n      qualify,\n      nsAlias = newNamespaceAliaser(),\n    }: StypSelectorFormat = defaultFormat,\n): string {\n\n  const format: ItemFormat = { qualify, nsAlias };\n\n  return selector.reduce(\n      (result, item) => {\n        if (isCombinator(item)) {\n          return result + item;\n        }\n        if (result && !isCombinator(result[result.length - 1])) {\n          result += ' ';\n        }\n        return result + formatItem(item, format);\n      },\n      '',\n  );\n}\n\ninterface ItemFormat extends StypSelectorFormat {\n  nsAlias: NamespaceAliaser;\n}\n\nfunction formatItem(\n    item: StypSelector.NormalizedPart,\n    {\n      qualify,\n      nsAlias,\n    }: ItemFormat,\n): string {\n\n  const { ns, e, i, c, s, u, $ } = item;\n  let hasProperties = false;\n  let out = '';\n\n  if (i) {\n    hasProperties = true;\n    out += `#${cssescId(id__naming.name(i, nsAlias))}`;\n  }\n  if (c) {\n    hasProperties = true;\n    out = c.reduce<string>(\n        (result, className) => `${result}.${cssescId(css__naming.name(className, nsAlias))}`,\n        out,\n    );\n  }\n  if (u) {\n    hasProperties = true;\n\n    const subFormat: ItemFormat = { nsAlias };\n\n    out = u.reduce(\n        (result, sub) => formatSubSelector(result, sub, subFormat),\n        out,\n    );\n  }\n  if (s) {\n    hasProperties = true;\n    out += s;\n  }\n  if (qualify && $) {\n    out = $.reduce((result, qualifier) => result + qualify(qualifier), out);\n  }\n  if (ns) {\n\n    const alias = xmlNs(ns, nsAlias);\n\n    if (alias) {\n      out = `${alias}|${e || '*'}${out}`;\n    } else {\n      out = qualifyElement();\n    }\n  } else {\n    out = qualifyElement();\n  }\n\n  return out;\n\n  function qualifyElement(): string {\n    if (hasProperties) {\n      return `${e ? html__naming.name(e, nsAlias) : ''}${out}`;\n    }\n    return `${e ? html__naming.name(e, nsAlias) : '*'}${out}`;\n  }\n}\n\nfunction formatSubSelector(\n    out: string,\n    sub: StypSubSelector.Normalized,\n    format: ItemFormat,\n): string {\n  if (isPseudoSubSelector(sub)) {\n    out += sub[0] + sub[1];\n\n    const len = sub.length;\n\n    if (len > 2) {\n      out += '(' + formatStypSelector(sub[2], format);\n      for (let i = 3; i < sub.length; ++i) {\n        out += ',' + formatStypSelector(sub[i] as StypSubSelector.NormalizedParameter, format);\n      }\n      out += ')';\n    }\n\n    return out;\n  }\n\n  const [attrName, attrOp, attrVal, attrFlag] = sub;\n\n  out += '[' + cssescId(attrName);\n  if (attrOp) {\n    out += attrOp + cssesc(attrVal!, { quotes: 'double', wrap: true });\n  }\n  if (attrFlag) {\n    out += ' ' + attrFlag;\n  }\n\n  return out + ']';\n}\n\nfunction xmlNs(ns: string | NamespaceDef, nsAlias: NamespaceAliaser): string | undefined {\n  return typeof ns === 'string' ? ns : ns.url ? nsAlias(ns) : undefined;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { filterIt, itsReduction, ObjectEntry, overEntries } from '@proc7ts/a-iterable';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { isNotEmptyArray } from '../../internal';\nimport { StypProperties, StypRule } from '../../rule';\nimport { mergeStypProperties } from '../../rule/properties.impl';\nimport { StypSelector, stypSelector } from '../../selector';\nimport { isCombinator } from '../../selector/selector.impl';\nimport { stypSplitPriority, StypValue } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * @internal\n */\nclass AtRulesRenderer implements StypRenderer.Spec {\n\n  constructor(private readonly _rule: StypRule) {\n  }\n\n  read(properties: AfterEvent<[StypProperties]>): AfterEvent<[StypProperties]> {\n\n    let outer = this._rule.outer;\n\n    while (outer) {\n      properties = mergeStypProperties(outer.read().keepThru(onlyAtProperties), properties);\n      outer = outer.outer;\n    }\n\n    return properties;\n  }\n\n  render(producer: StyleProducer, properties: StypProperties): void {\n\n    const { selector } = producer;\n    let { writer } = producer;\n\n    if (!writer.isGroup) {\n      producer.render(properties);\n      return;\n    }\n\n    let sheet = writer;\n    const extracted = extractAtSelectors(selector);\n\n    if (!extracted) {\n      producer.render(properties);\n      return;\n    }\n\n    const [atSelectors, restSelector] = extracted;\n\n    for (const atSelector of atSelectors) {\n\n      const [name, params] = buildAtSelector(properties, atSelector);\n\n      if (params) {\n        writer = sheet = sheet.addGroup(name, params);\n      } else {\n        writer = sheet.addStyle(name);\n        break;\n      }\n    }\n\n    producer.render(properties, { writer, selector: restSelector });\n  }\n\n}\n\n/**\n * @internal\n */\nfunction buildAtSelector(\n    properties: StypProperties,\n    [key, [names, customQuery]]: [string, [Set<string>, string?]],\n): [string, string?] {\n\n  let query = '';\n  const addQuery = (q?: StypValue): void => {\n    if (q) {\n      if (query) {\n        query += ' and ';\n      }\n      query += q;\n    }\n  };\n\n  for (const name of names) {\n\n    const [namedQuery] = stypSplitPriority(properties[name]);\n\n    addQuery(namedQuery);\n  }\n\n  addQuery(customQuery);\n\n  return query ? [key, query] : [key];\n}\n\n/**\n * CSS stylesheet renderer of at-rules like `@media` queries.\n *\n * At-rules are represented by qualifiers which names start with `@` symbol. Qualifier names are used as at-rules keys,\n * and their values - as queries. If the rest of the selector is not empty, then properties are rendered in CSS\n * rule nested inside at-rule. Otherwise the properties are rendered in at-rule.\n *\n * So, for example CSS rule with `{ c: 'screen-only', $: '@media=screen' }` selector would be rendered as\n * ```css\n * @media screen {\n *   .screen-only {\n *      \\/* CSS properties *\\/\n *   }\n * }\n * ```\n *\n * Another option is to use named at-rules qualifiers. When named qualifier is used, the corresponding property is\n * searched in CSS rule and all of its outer rules. The values of all matching properties are used as queries.\n *\n * So the above example could be written as: `{ c: 'screen-only', $: '@media:screen' }` if CSS rule (or its outer\n * one) contains property `@media:screen` with value `screen`.\n *\n * Enabled by default in [[produceStyle]] function.\n *\n * @category Rendering\n */\nexport const stypRenderAtRules: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER,\n\n  create(rule) {\n    return new AtRulesRenderer(rule);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction onlyAtProperties(properties: StypProperties): StypProperties {\n  return itsReduction(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          isAtEntry,\n      ),\n      (result: StypProperties.Mutable, [key, value]: ObjectEntry<StypProperties, string>) => {\n        result[key] = value;\n        return result;\n      },\n      {},\n  );\n}\n\n/**\n * @internal\n */\nfunction isAtEntry(entry: ObjectEntry<StypProperties>): entry is ObjectEntry<StypProperties, string> {\n  return String(entry[0])[0] === '@';\n}\n\n/**\n * @internal\n */\nfunction extractAtSelectors(\n    selector: StypSelector.Normalized,\n): [Map<string, [Set<string>, string?]>, StypSelector.Normalized] | undefined {\n\n  const atSelectors = new Map<string, [Set<string>, string?]>();\n  const rest: StypSelector.Mutable = [];\n\n  for (const part of selector) {\n    if (isCombinator(part)) {\n      rest.push(part);\n    } else {\n      rest.push(extractPartAtSelectors(part, atSelectors));\n    }\n  }\n\n  if (!atSelectors.size) {\n    return; // No at-rule qualifiers found.\n  }\n\n  return [atSelectors, stypSelector(rest)];\n}\n\n/**\n * @internal\n */\nfunction extractPartAtSelectors(\n    part: StypSelector.NormalizedPart,\n    atSelectors: Map<string, [Set<string>, string?]>,\n): StypSelector.NormalizedPart {\n\n  const qualifiers = part.$;\n\n  if (!qualifiers) {\n    return part;\n  }\n\n  const restQualifies: string[] = [];\n\n  for (const qualifier of qualifiers) {\n    if (qualifier[0] === '@') {\n      addAtSelector(atSelectors, qualifier);\n    } else {\n      restQualifies.push(qualifier);\n    }\n  }\n\n  if (restQualifies.length === qualifiers.length) {\n    return part; // No at-rule qualifiers found\n  }\n  if (isNotEmptyArray(restQualifies)) {\n    return { ...part, $: restQualifies };\n  }\n\n  return { ...part, $: undefined };\n}\n\n/**\n * @internal\n */\nfunction addAtSelector(atSelectors: Map<string, [Set<string>, string?]>, qualifier: string): void {\n\n  const eqIdx = qualifier.indexOf('=');\n  let name: string;\n  let query: string | undefined;\n\n  if (eqIdx < 0) {\n    name = qualifier;\n  } else {\n    name = qualifier.substring(0, eqIdx);\n    query = qualifier.substring(eqIdx + 1);\n  }\n\n  const colonIdx = name.indexOf(':');\n  const key = colonIdx < 0 ? name : name.substring(0, colonIdx);\n  const atSelector = atSelectors.get(key);\n\n  if (!atSelector) {\n    atSelectors.set(key, [new Set<string>().add(name), query]);\n  } else {\n\n    const [names, prevQuery] = atSelector;\n\n    names.add(name);\n    if (query) {\n      atSelector[1] = prevQuery ? `${prevQuery} and ${query}` : query;\n    }\n  }\n}\n","/**\n * @internal\n */\nexport const FIRST_RENDER_ORDER = -0xffff;\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { overEntries } from '@proc7ts/a-iterable';\nimport { StypProperties } from '../../rule';\nimport { stypSplitPriority, StypURL, StypValue } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { StypWriter } from '../writer';\nimport { stypRenderAtRules } from './at-rules.renderer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * CSS stylesheet renderer of global at-rules.\n *\n * It renders at-rules that should stay at the top level:\n * - `@namespace`\n * - `@import`\n *\n * At-rule parameters are taken from root CSS rule properties and treated as following.\n *\n * **`@import:url`** property value is treated as media query and appended after stylesheet URL. I.e.\n * ```json\n * {\n *     \"@import:path/to/included.css\": \"screen\"\n * }\n * ```\n * becomes\n * ```css\n * @import url(path/to/included.css) screen;\n * ```\n *\n * **`@namespace`** property value is treated as default namespace URL. I.e.\n * ```json\n * {\n *     \"@namespace\": \"http://www.w3.org/1999/xhtml\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace url(http://www.w3.org/1999/xhtml);\n * ```\n *\n * **`@namespace:prefix`** property value is treated as namespace URL with the given prefix. I.e\n * ```json\n * {\n *     \"@namespace:svg\": \"http://www.w3.org/2000/svg\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace svg url(http://www.w3.org/2000/svg);\n * ```\n *\n * Enabled by default in [[produceStyle]] function.\n *\n * @category Rendering\n */\nexport const stypRenderGlobals: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER + 1,\n\n  needs: stypRenderAtRules,\n\n  render(producer: StyleProducer, properties: StypProperties) {\n\n    const rootRule = !producer.rule.selector.length;\n\n    const { sheet } = producer;\n    let importIndex = 0;\n    let nsIndex = 0;\n\n    for (const [k, v] of overEntries(properties)) {\n\n      const key = String(k);\n\n      if (key[0] === '@') {\n\n        const [value] = stypSplitPriority(v);\n        const importDelta = rootRule ? renderImport(sheet, importIndex, key, value) : 0;\n\n        importIndex += importDelta;\n        nsIndex += importDelta;\n\n        const url = StypURL.by(value);\n\n        if (url) {\n          nsIndex += renderDefaultNamespace(sheet, nsIndex, key, url);\n          nsIndex += renderNamespacePrefix(sheet, nsIndex, key, url);\n        }\n      }\n    }\n\n    producer.render(properties);\n  },\n\n};\n\n/**\n * @internal\n */\nconst IMPORT_PREFIX = '@import:';\n\n/**\n * @internal\n */\nfunction renderImport(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    value: StypValue,\n): number {\n  if (!key.startsWith(IMPORT_PREFIX)) {\n    return 0;\n  }\n\n  const url = new StypURL(key.substring(IMPORT_PREFIX.length));\n  let css = String(url);\n\n  if (value) {\n    css += ' ' + value;\n  }\n\n  sheet.addGlobal('@import', css, index);\n\n  return 1;\n}\n\n/**\n * @internal\n */\nfunction renderDefaultNamespace(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    url: StypURL,\n): number {\n  if (key !== '@namespace') {\n    return 0;\n  }\n\n  sheet.addGlobal('@namespace', String(url), index);\n\n  return 1;\n}\n\n/**\n * @internal\n */\nconst NS_PREFIX = '@namespace:';\n\n/**\n * @internal\n */\nfunction renderNamespacePrefix(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    url: StypURL,\n): number {\n  if (!key.startsWith(NS_PREFIX)) {\n    return 0;\n  }\n\n  const prefix = key.substring(NS_PREFIX.length);\n\n  sheet.addGlobal('@namespace', `${prefix} ${url}`, index);\n\n  return 1;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/a-iterable';\nimport hyphenateStyleName from 'hyphenate-style-name';\nimport { StypProperties } from '../../rule';\nimport { stypSplitPriority } from '../../value';\nimport { StyleProducer } from '../style-producer';\n\n/**\n * Renders CSS properties.\n *\n * This renderer is always present, so there is typically no need to use it explicitly.\n *\n * @category Rendering\n */\nexport function stypRenderProperties(producer: StyleProducer, properties: StypProperties): void {\n\n  const style = producer.addStyle();\n\n  itsEach(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          notCustomProperty,\n      ),\n      ([k, v]) => {\n\n        const [value, priority] = stypSplitPriority(v);\n\n        style.set(hyphenateStyleName(k), `${value}`, priority);\n      },\n  );\n\n  producer.render(properties, { writer: style });\n}\n\n/**\n * @internal\n */\nfunction notCustomProperty(\n    entry: ObjectEntry<StypProperties>,\n): entry is ObjectEntry<Required<StypProperties>, string> {\n\n  const [key, value] = entry;\n\n  if (value == null) {\n    return false;\n  }\n\n  const first = String(key)[0];\n\n  return first >= 'a' && first <= 'z' || first >= 'A' && first <= 'Z';\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { StypProperties } from '../../rule';\nimport { StyleProducer } from '../style-producer';\n\n/**\n * Renders raw CSS text. I.e. the contents of [[StypProperties.Generic.$$css]] property.\n *\n * It should be rendered before CSS properties normally to add the rendered rule as a first one.\n *\n * Enabled by default in [[produceStyle]] function.\n *\n * @category Rendering\n */\nexport function stypRenderText(producer: StyleProducer, properties: StypProperties): void {\n\n  const css = properties.$$css;\n\n  if (!css) {\n    producer.render(properties);\n  } else {\n\n    const style = producer.addStyle();\n\n    style.replace(css);\n    producer.render(properties, { writer: style });\n  }\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { filterIt, itsEmpty, itsReduction, mapIt, overArray } from '@proc7ts/a-iterable';\nimport { isPresent } from '@proc7ts/call-thru';\nimport { NamespaceDef } from '@proc7ts/namespace-aliaser';\nimport { StypProperties } from '../../rule';\nimport { StypSelector } from '../../selector';\nimport { isCombinator } from '../../selector/selector.impl';\nimport { StypURL } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { stypRenderGlobals } from './globals.renderer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * CSS stylesheet renderer of global XML namespace definitions.\n *\n * Renders `@namespace` declarations for CSS selectors containing namespace definitions.\n *\n * Enabled by default in [[produceStyle]] function.\n *\n * @category Rendering\n */\nexport const stypRenderXmlNs: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER,\n\n  needs: stypRenderGlobals,\n\n  render(producer: StyleProducer, properties: StypProperties) {\n\n    const xmlNsDefs = extractXmlNsDefs(producer.selector);\n\n    producer.render(itsEmpty(xmlNsDefs) ? properties : declareNss());\n\n    function declareNss(): StypProperties {\n      return itsReduction(xmlNsDefs, declareNs, { ...properties });\n    }\n\n    function declareNs(result: StypProperties.Mutable, ns: NamespaceDef): StypProperties.Mutable {\n\n      const alias = producer.nsAlias(ns);\n\n      result[`@namespace:${alias}`] = new StypURL(ns.url);\n\n      return result;\n    }\n  },\n\n};\n\n/**\n * @internal\n */\nfunction extractXmlNsDefs(selector: StypSelector.Normalized): Iterable<NamespaceDef> {\n  return filterIt<NamespaceDef | null, NamespaceDef>(\n      mapIt(\n          overArray(selector),\n          part => !isCombinator(part) && part.ns && typeof part.ns !== 'string' ? part.ns : null,\n      ),\n      isPresent,\n  );\n}\n","import { newRenderSchedule, RenderScheduler } from '@proc7ts/render-scheduler';\nimport { isReadonlyArray } from '../../internal';\nimport { StypRule } from '../../rule';\nimport { StypFormat } from '../format';\nimport { StypRenderer } from '../renderer';\nimport { stypRenderProperties } from '../renderers';\n\n/**\n * @internal\n */\nexport interface StypRendererSpecFactory extends StypRenderer.Factory {\n  create(rule: StypRule): StypRenderer.Spec;\n}\n\n/**\n * @internal\n */\nexport function stypRenderFactories(format: StypFormat): readonly StypRendererSpecFactory[] {\n\n  const factories = new Map<StypRenderer, StypRendererSpecFactory>();\n\n  addRenderers(format.renderer);\n  factories.delete(stypRenderProperties);\n\n  return [...factories.values(), rendererFactory(stypRenderProperties)].sort(compareRenderers);\n\n  function addRenderers(renderers: StypRenderer | readonly StypRenderer[] | undefined): void {\n    if (renderers) {\n      if (isReadonlyArray(renderers)) {\n        renderers.forEach(addRenderer);\n      } else {\n        addRenderer(renderers);\n      }\n    }\n  }\n\n  function addRenderer(renderer: StypRenderer): void {\n    if (factories.has(renderer)) {\n      return;\n    }\n\n    const factory = rendererFactory(renderer);\n\n    factories.set(renderer, factory);\n    addRenderers(factory.needs);\n  }\n}\n\nfunction rendererFactory(renderer: StypRenderer): StypRendererSpecFactory {\n  if (typeof renderer === 'function') {\n    return {\n      create() {\n        return { render: renderer };\n      },\n    };\n  }\n  if (isRendererFactory(renderer)) {\n    return {\n      order: renderer.order,\n      needs: renderer.needs,\n      create(rule) {\n        return rendererSpec(renderer.create(rule));\n      },\n    };\n  }\n\n  const render = renderer.render.bind(renderer);\n\n  return {\n    order: renderer.order,\n    needs: renderer.needs,\n    create() {\n      return { render };\n    },\n  };\n}\n\nfunction isRendererFactory(renderer: StypRenderer): renderer is StypRenderer.Factory {\n  return 'create' in renderer;\n}\n\nfunction compareRenderers(first: StypRenderer.Factory, second: StypRenderer.Factory): number {\n\n  const firstOrder = first.order || 0;\n  const secondOrder = second.order || 0;\n\n  return firstOrder > secondOrder ? 1 : firstOrder < secondOrder ? -1 : 0;\n}\n\nfunction rendererSpec(renderer: ReturnType<StypRenderer.Factory['create']>): StypRenderer.Spec {\n  return typeof renderer === 'function' ? { render: renderer } : renderer;\n}\n\n/**\n * @internal\n */\nexport function stypRenderScheduler(\n    parent: Node,\n    scheduler: RenderScheduler = newRenderSchedule,\n): RenderScheduler {\n  return (options = {}) => {\n\n    const { node = parent, error } = options;\n\n    return scheduler({\n      ...options,\n      node,\n      error: error && error.bind(options),\n    });\n  };\n}\n\n/**\n * @internal\n */\nexport function removeStyleElement(element: HTMLStyleElement): void {\n  element.parentNode?.removeChild(element);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { EventEmitter, EventReceiver, EventSupply, OnEvent } from '@proc7ts/fun-events';\nimport { immediateRenderScheduler, RenderScheduler } from '@proc7ts/render-scheduler';\nimport { StypPriority } from '../../value';\nimport { StypFormat, StypFormatConfig } from '../format';\nimport { StypWriter } from '../writer';\n\n/**\n * Textual CSS production format.\n *\n * Represents each style sheet in textual form and reports it to registered receivers. Such receivers should be\n * registered before {@link produceStyle style production} started in order to receive all style sheets.\n *\n * @category Rendering\n */\nexport interface StypTextFormat extends StypFormat, StypTextFormatConfig {\n\n  /**\n   * Detailed configuration of CSS text pretty print, or `false` for compact output.\n   */\n  readonly pretty: StypTextFormatConfig.PrettyPrint | false;\n\n  /**\n   * Builds an `OnEvent` sender of style sheet textual representation.\n   *\n   * Sends textual representation of each rendered style sheet on each update.\n   *\n   * @returns `OnEvent` sender of {@link StypSheetText} objects.\n   */\n  onSheet(): OnEvent<[StypSheetText]>;\n\n  /**\n   * Starts sending textual representations of style sheets to the given `receiver`.\n   *\n   * @param receiver  Target receiver of style sheet text.\n   */\n  onSheet(receiver: EventReceiver<[StypSheetText]>): EventSupply;\n\n}\n\n/**\n * Configuration of {@link stypTextFormat textual CSS production format}.\n *\n * @category Rendering\n */\nexport interface StypTextFormatConfig extends StypFormatConfig {\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `immediateRenderScheduler` by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n  /**\n   * How to pretty-print generated CSS text.\n   *\n   * - `false` to disable pretty print and generate compact output,\n   * - `true` (default value) for default pretty print,\n   * - {@link StypTextFormatConfig.PrettyPrint detailed configuration object}.\n   */\n  readonly pretty?: boolean | StypTextFormatConfig.PrettyPrint;\n\n}\n\nexport namespace StypTextFormatConfig {\n\n  /**\n   * Detailed configuration of CSS text pretty print.\n   */\n  export interface PrettyPrint {\n\n    /**\n     * Indentation string to use when formatting CSS text.\n     *\n     * Two spaces by default.\n     */\n    indent?: string;\n\n  }\n\n}\n\n/**\n * Style sheet textual representation.\n *\n * This is sent when producing styles in {@link StypTextFormat.onSheet textual format}.\n *\n * @category Rendering\n */\nexport interface StypSheetText {\n\n  /**\n   * Unique style sheet identifier.\n   *\n   * Style sheet is reported with the same identifier on each update.\n   */\n  readonly id: string;\n\n  /**\n   * The textual representation of style sheet formatted accordingly to {@link StypTextFormatConfig options},\n   * or `undefined` to inform that corresponding style sheet have been removed.\n   */\n  readonly css?: string;\n\n}\n\n/**\n * @internal\n */\ninterface StypTextFormatter {\n  readonly pre: string;\n  readonly nv: string;\n  readonly eol: string;\n  indent(): StypTextFormatter;\n}\n\n/**\n * @internal\n */\nconst defaultPrettyPrint: StypTextFormatConfig.PrettyPrint = {\n  indent: '  ',\n};\n\n/**\n * @internal\n */\nconst compactStypTextFormatter: StypTextFormatter = {\n  nv: '',\n  eol: '',\n  pre: '',\n  indent() {\n    return this;\n  },\n};\n\n/**\n * @internal\n */\nclass StypTextFormatter$ implements StypTextFormatter {\n\n  constructor(\n      private readonly _config: StypTextFormatConfig.PrettyPrint,\n      readonly pre = '',\n  ) {\n  }\n\n  get nv(): string {\n    return ' ';\n  }\n\n  get eol(): string {\n    return '\\n';\n  }\n\n  indent(): StypTextFormatter$ {\n    return new StypTextFormatter$(this._config, this.pre + this._config.indent);\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypStyleTextWriter implements StypWriter.Style {\n\n  private readonly nf: StypTextFormatter;\n  private body = '';\n\n  constructor(\n      private readonly f: StypTextFormatter,\n      readonly selector: string,\n  ) {\n    this.nf = f.indent();\n  }\n\n  get isGroup(): false {\n    return false;\n  }\n\n  set(name: string, value: string, priority: number): void {\n\n    const p = priority >= StypPriority.Important ? ' !important' : '';\n    const { pre, nv, eol } = this.nf;\n\n    if (this.body) {\n      this.body += `;${eol}`;\n    }\n\n    this.body += `${pre}${name}:${nv}${value}${p}`;\n  }\n\n  replace(css: string): void {\n    this.body = css.trim();\n    if (this.body.endsWith(';')) {\n      this.body = this.body.substr(0, this.body.length - 1);\n    }\n  }\n\n  toString(): string {\n\n    const { pre, nv, eol } = this.f;\n\n    if (this.body) {\n\n      const afterBody = eol ? `;${eol}` : '';\n\n      return `${pre}${this.selector}${nv}{${eol}${this.body}${afterBody}${pre}}`;\n    }\n\n    return '';\n  }\n\n}\n\n/**\n * @internal\n */\nabstract class AbstractStypGroupTextWriter implements StypWriter.Group {\n\n  readonly _nested: any[] = [];\n\n  protected constructor(readonly nf: StypTextFormatter) {\n  }\n\n  get isGroup(): true {\n    return true;\n  }\n\n  addGroup(name: string, params: string, index?: number): StypWriter.Group {\n    return this._add(new StypGroupTextWriter(this.nf, name, params), index);\n  }\n\n  addStyle(selector: string, index?: number): StypWriter.Style {\n    return this._add(new StypStyleTextWriter(this.nf, selector), index);\n  }\n\n  toString(): string {\n\n    let out = '';\n\n    for (const nested of this._nested) {\n\n      const text = String(nested);\n\n      if (text) {\n        if (out) {\n          out += this.nf.eol;\n        }\n        out += text;\n      }\n    }\n\n    return out;\n  }\n\n  protected _add<N>(nested: N, index = this._nested.length): N {\n    this._nested.splice(index, 0, nested);\n    return nested;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypGroupTextWriter extends AbstractStypGroupTextWriter implements StypWriter.Group {\n\n  constructor(readonly f: StypTextFormatter, readonly name: string, readonly params: string) {\n    super(f.indent());\n  }\n\n  toString(): string {\n\n    const body = super.toString();\n\n    if (!body) {\n      return '';\n    }\n\n    const { pre, nv, eol } = this.f;\n\n    return `${pre}${this.name} ${this.params}${nv}{${eol}${body}${eol}${pre}}`;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypSheetTextWriter extends AbstractStypGroupTextWriter implements StypWriter.Sheet {\n\n  constructor(\n      readonly id: string,\n      readonly f: StypTextFormatter,\n      readonly sender: EventEmitter<[StypSheetText]>,\n  ) {\n    super(f);\n  }\n\n  addGlobal(name: string, value: string, index?: number): void {\n    this._add(`${this.f.pre}${name} ${value};`, index);\n  }\n\n  clear(): void {\n    this._nested.length = 0;\n  }\n\n  remove(): void {\n    this.clear();\n    this.sender.send({ id: this.id });\n  }\n\n  done(): void {\n    this.sender.send({\n      id: this.id,\n      css: this.toString(),\n    });\n  }\n\n}\n\n/**\n * Builds textual CSS production format.\n *\n * It is necessary to register {@link StypTextFormat.onSheet CSS text receiver(s)} prior to start {@link produceStyle\n * style production} in order to receive CSS text for style sheets.\n *\n * @category Rendering\n * @param config  Textual format config.\n *\n * @returns Textual CSS production format.\n */\nexport function stypTextFormat(config: StypTextFormatConfig = {}): StypTextFormat {\n\n  const pretty: StypTextFormatConfig.PrettyPrint | false = config.pretty === true || config.pretty == null\n      ? defaultPrettyPrint\n      : (config.pretty || false);\n  const { scheduler = immediateRenderScheduler } = config;\n  const sender = new EventEmitter<[StypSheetText]>();\n  let onSheet = ((receiver?: EventReceiver<[StypSheetText]>): OnEvent<[StypSheetText]> | EventSupply => (\n      onSheet = sender.on().F\n  )(receiver)) as StypTextFormat['onSheet'];\n  const formatter: StypTextFormatter = pretty ? new StypTextFormatter$(pretty) : compactStypTextFormatter;\n  let idSeq = 0;\n\n  return {\n    ...config,\n    pretty,\n    scheduler,\n    onSheet,\n    addSheet() {\n      return new StypSheetTextWriter(String(++idSeq), formatter, sender);\n    },\n  };\n}\n","import { RenderScheduler } from '@proc7ts/render-scheduler';\nimport { StypFormat } from '../format';\nimport { removeStyleElement, stypRenderScheduler } from './format.impl';\n/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { stypTextFormat, StypTextFormatConfig } from './text.format';\n\n/**\n * Configuration of {@link stypDomFormat DOM style production format}.\n *\n * @category Rendering\n */\nexport interface StypDomFormatConfig extends StypTextFormatConfig {\n\n  /**\n   * Document to add style elements to.\n   *\n   * `parent.ownerDocument` or `window.document` by default.\n   */\n  readonly document?: Document;\n\n  /**\n   * Parent DOM node to add stylesheets to.\n   *\n   * `document.head` by default.\n   *\n   * This node don't have to be attached to document.\n   */\n  readonly parent?: Node;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `newRenderSchedule` for [[parent]] node by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n}\n\n/**\n * Builds DOM style production format.\n *\n * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and fills it with CSS text\n * generated by {@link stypTextFormat textual CSS production format}.\n *\n * This format is generally slower than {@link stypObjectFormat CSS object model production format}, but allows to add\n * `<style>` elements to DOM node outside document. E.g. to `DocumentFragment`.\n *\n * @category Rendering\n * @param config  DOM style format configuration.\n *\n * @returns CSS production format.\n */\nexport function stypDomFormat(\n    config: StypDomFormatConfig = {},\n): StypFormat {\n\n  const {\n    document = config.parent?.ownerDocument || window.document,\n    parent = document.head,\n  } = config;\n  const textFormat = stypTextFormat(config);\n  const scheduler = stypRenderScheduler(parent, config.scheduler);\n  const schedule = scheduler();\n  const elements = new Map<string, HTMLStyleElement>();\n  const supply = textFormat.onSheet(({ id, css }) => {\n    // CSS text is reported within schedule. No need to re-schedule DOM manipulations here.\n\n    let element = elements.get(id);\n\n    if (css == null) { // element exists here\n      elements.delete(id);\n      removeStyleElement(element!);\n    } else if (element) {\n      element.textContent = css;\n    } else {\n      element = document.createElement('style');\n      element.setAttribute('type', 'text/css');\n      element.textContent = css;\n      parent.appendChild(element);\n      elements.set(id, element);\n      supply.whenOff(\n          // Schedule element removal on style sheet removal instead of removing it right away.\n          () => schedule(() => removeStyleElement(element!)),\n      );\n    }\n  });\n\n  return {\n    ...config,\n    scheduler,\n    addSheet(producer) {\n      supply.needs(producer);\n      this.addSheet = textFormat.addSheet.bind(textFormat);\n      return this.addSheet(producer);\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { RenderScheduler } from '@proc7ts/render-scheduler';\nimport { StypPriority } from '../../value';\nimport { StypFormat, StypFormatConfig } from '../format';\nimport { StypWriter } from '../writer';\nimport { removeStyleElement, stypRenderScheduler } from './format.impl';\n\n/**\n * @internal\n */\nclass StypStyleObjectWriter implements StypWriter.Style {\n\n  constructor(private readonly _target: CSSStyleRule) {\n  }\n\n  get isGroup(): false {\n    return false;\n  }\n\n  set(name: string, value: string, priority: number): void {\n    this._target.style.setProperty(name, value, priority >= StypPriority.Important ? 'important' : null);\n  }\n\n  replace(css: string): void {\n    this._target.style.cssText = css;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypGroupObjectWriter implements StypWriter.Group {\n\n  constructor(readonly _target: CSSStyleSheet | CSSGroupingRule) {\n  }\n\n  get isGroup(): true {\n    return true;\n  }\n\n  addGroup(name: string, params: string, index?: number): StypWriter.Group {\n    return new StypGroupObjectWriter(\n        this._add(\n            `${name} ${params}{}`,\n            index,\n        ) as CSSGroupingRule,\n    );\n  }\n\n  addStyle(selector: string, index?: number): StypWriter.Style {\n    return new StypStyleObjectWriter(this._add(`${selector}{}`, index) as CSSStyleRule);\n  }\n\n  protected _add(\n      ruleText: string,\n      index = this._target.cssRules.length,\n  ): CSSRule {\n\n    const idx = this._target.insertRule(ruleText, index);\n\n    return this._target.cssRules[idx];\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypSheetObjectWriter extends StypGroupObjectWriter implements StypWriter.Sheet {\n\n  constructor(private readonly _element: HTMLStyleElement) {\n    super(_element.sheet as CSSStyleSheet);\n  }\n\n  addGlobal(name: string, value: string, index?: number): void {\n    this._add(`${name} ${value};`, index);\n  }\n\n  clear(): void {\n\n    const { cssRules } = this._target;\n\n    while (cssRules.length) {\n      this._target.deleteRule(cssRules.length - 1);\n    }\n  }\n\n  remove(): void {\n    removeStyleElement(this._element);\n  }\n\n  done(): void {\n    /* do nothing */\n  }\n\n}\n\n/**\n * Configuration of {@link stypObjectFormat CSS object model production format}.\n *\n * @category Rendering\n */\nexport interface StypObjectFormatConfig extends StypFormatConfig {\n\n  /**\n   * Parent DOM node to add stylesheets to.\n   *\n   * `document.head` by default.\n   *\n   * This node has to be attached to document.\n   */\n  readonly parent?: Node;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `newRenderSchedule` for [[parent]] node by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n}\n\n/**\n * Builds CSS object model production format.\n *\n * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and builds its style sheet\n * with CSS object model methods.\n *\n * @category Rendering\n * @param config  Object format configuration.\n *\n * @returns CSS production format.\n */\nexport function stypObjectFormat(\n    config: StypObjectFormatConfig = {},\n): StypFormat {\n\n  const { parent = document.head } = config;\n\n  return {\n    ...config,\n    scheduler: stypRenderScheduler(parent, config.scheduler),\n    addSheet() {\n\n      const element = document.createElement('style');\n\n      element.setAttribute('type', 'text/css');\n      element.append(document.createTextNode(''));\n\n      parent.appendChild(element);\n\n      return new StypSheetObjectWriter(element);\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { itsReduction, mapIt } from '@proc7ts/a-iterable';\nimport { noop } from '@proc7ts/call-thru';\nimport {\n  AfterEvent,\n  afterSupplied,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  onSupplied,\n} from '@proc7ts/fun-events';\nimport { NamespaceDef, newNamespaceAliaser } from '@proc7ts/namespace-aliaser';\nimport { newRenderSchedule } from '@proc7ts/render-scheduler';\nimport { StypProperties, StypRule, StypRules } from '../rule';\nimport { StypSelector, stypSelector, StypSelectorFormat, stypSelectorText } from '../selector';\nimport { isCombinator } from '../selector/selector.impl';\nimport { StypFormat } from './format';\nimport { stypRenderFactories } from './formats/format.impl';\nimport { StypRenderer } from './renderer';\nimport { StyleProducer } from './style-producer';\nimport { StypWriter } from './writer';\n\n/**\n * Produces and dynamically updates basic CSS stylesheets based on the given CSS rules.\n *\n * Unlike [[produceStyle]], this function does not enable renderers but the basic one which just renders CSS properties.\n * Only select renderers can be enabled. This can be used to save a bundle size.\n *\n * @category Rendering\n * @param rules  CSS rules to produce stylesheets for. This can be e.g. a [[StypRule.rules]] to render all rules,\n * or a result of [[StypRuleList.grab]] method call to render only matching ones.\n * @param format  Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceBasicStyle(rules: StypRules, format: StypFormat): EventSupply {\n\n  const {\n    rootSelector = { e: 'body' },\n    scheduler = newRenderSchedule,\n    nsAlias = newNamespaceAliaser(),\n  } = format;\n  const supply = eventSupply();\n  const selectorFormat: StypSelectorFormat = { nsAlias };\n  const factories = stypRenderFactories(format);\n  const renderSupply = renderRules(rules);\n  const trackSupply = trackRules();\n\n  return supply.needs(renderSupply)\n      .needs(trackSupply)\n      .cuts(renderSupply)\n      .cuts(trackSupply);\n\n  function styleProducer(\n      rule: StypRule,\n      renderer: StypRenderer.Function,\n      production: {\n        sheet: StypWriter.Sheet;\n        writer: StypWriter;\n        selector: StypSelector.Normalized;\n      },\n  ): StyleProducer {\n\n    class StyleProducer$ implements StyleProducer {\n\n      get [EventSupply__symbol](): EventSupply {\n        return supply;\n      }\n\n      get rule(): StypRule {\n        return rule;\n      }\n\n      get sheet(): StypWriter.Sheet {\n        return production.sheet;\n      }\n\n      get writer(): StypWriter {\n        return production.writer;\n      }\n\n      get selector(): StypSelector.Normalized {\n        return production.selector;\n      }\n\n      nsAlias(ns: NamespaceDef): string {\n        return nsAlias(ns);\n      }\n\n      render(properties: StypProperties, options?: StypRenderer.Options): void {\n        if (!options) {\n          renderer(this, properties);\n        } else {\n          renderer(\n              styleProducer(\n                  rule,\n                  renderer,\n                  {\n                    sheet: production.sheet,\n                    writer: options.writer || production.writer,\n                    selector: options.selector || production.selector,\n                  },\n              ),\n              properties,\n          );\n        }\n      }\n\n      addStyle(_selector: StypSelector.Normalized = production.selector): StypWriter.Style {\n\n        const { writer } = production;\n\n        if (!writer.isGroup) {\n          return writer;\n        }\n\n        return writer.addStyle(selectorText(_selector));\n      }\n\n    }\n\n    return new StyleProducer$();\n  }\n\n  function selectorText(selector: StypSelector.Normalized): string {\n    return stypSelectorText(selector, selectorFormat);\n  }\n\n  function renderRules(rulesToRender: Iterable<StypRule>): EventSupply {\n    return itsReduction<EventSupply, EventSupply>(\n        mapIt(rulesToRender, renderRule),\n        (prev, supply) => eventSupply().cuts(supply).cuts(prev),\n        eventSupply(),\n    );\n  }\n\n  function trackRules(): EventSupply {\n\n    const supply = eventSupply();\n\n    return onSupplied(rules).to({\n      supply,\n      receive: (_ctx, added) => {\n        added.forEach(r => renderRule(r).needs(supply));\n      },\n    });\n  }\n\n  function renderRule(rule: StypRule): EventSupply {\n\n    const [reader, renderer] = rendererForRule(rule);\n    let sheet: StypWriter.Sheet | undefined;\n    const selector = ruleSelector(rule);\n    const schedule = scheduler();\n\n    return reader.to(renderProperties).whenOff(removeStyle);\n\n    function renderProperties(properties: StypProperties): void {\n      schedule(() => {\n        sheet?.clear();\n\n        const producer = styleProducer(\n            rule,\n            renderer,\n            {\n              get sheet() {\n                if (!sheet) {\n                  sheet = format.addSheet(producer);\n                }\n                return sheet;\n              },\n              get writer() {\n                return this.sheet;\n              },\n              selector,\n            },\n        );\n\n        producer.render(properties);\n        sheet?.done();\n      });\n    }\n\n    function removeStyle(): void {\n      schedule(() => {\n\n        const lastSheet = sheet;\n\n        if (lastSheet) {\n          sheet = undefined;\n          return lastSheet.remove();\n        }\n        // Otherwise element is removed before anything rendered.\n        // Should never happen for properly constructed rule.\n      });\n    }\n  }\n\n  function ruleSelector(rule: StypRule): StypSelector.Normalized {\n\n    const selector = rule.selector;\n\n    if (!selector.length) {\n      // Use configured root selector\n      return stypSelector(rootSelector);\n    }\n    if (isCombinator(selector[0])) {\n      // First combinator is relative to root selector\n      return [...stypSelector(rootSelector), ...selector];\n    }\n\n    return selector;\n  }\n\n  function rendererForRule(rule: StypRule): [AfterEvent<[StypProperties]>, StypRenderer.Function] {\n\n    const specs = factories.map(factory => factory.create(rule));\n    const reader = specs.reduce(\n        (read, spec) => spec.read ? afterSupplied(spec.read(read)) : read,\n        rule.read(),\n    );\n\n    return [reader, renderAt(0)];\n\n    function renderAt(index: number): StypRenderer.Function {\n      return (producer, properties) => {\n\n        const nextIndex = index + 1;\n        let nextRenderer: StypRenderer.Function;\n\n        if (nextIndex === factories.length) {\n          nextRenderer = noop;\n        } else {\n          nextRenderer = renderAt(nextIndex);\n        }\n\n        const nextProducer = styleProducer(producer.rule, nextRenderer, producer);\n\n        specs[index].render(nextProducer, properties);\n      };\n    }\n  }\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { NamespaceAliaser } from '@proc7ts/namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { stypSelector } from './selector-constructor';\nimport { formatStypSelector } from './selector-text.impl';\n\n/**\n * Structured CSS selector textual format.\n *\n * @category CSS Rule\n */\nexport interface StypSelectorFormat {\n\n  /**\n   * Qualifier formatting function. When present, it is called for each qualifier to build its\n   * textual representation. When unspecified, the qualifiers won't be attached to resulting CSS selector text.\n   *\n   * @param qualifier  Qualifier to format.\n   *\n   * @returns Textual representation of `qualifier`.\n   */\n  qualify?: (qualifier: string) => string;\n\n  /**\n   * Namespace aliaser to use.\n   *\n   * New instance will be created if not specified.\n   */\n  nsAlias?: NamespaceAliaser;\n\n}\n\n/**\n * Converts structured CSS selector to its textual representation.\n *\n * @category CSS Rule\n * @param selector  Target CSS selector.\n * @param format  CSS selector format.\n *\n * @returns CSS selector string.\n */\nexport function stypSelectorText(selector: StypSelector | StypPureSelector, format?: StypSelectorFormat): string {\n  return formatStypSelector(stypSelector(selector), format);\n}\n","import { isReadonlyArray } from '../../internal';\nimport { StypRenderer } from '../renderer';\nimport { stypRenderAtRules } from './at-rules.renderer';\nimport { stypRenderGlobals } from './globals.renderer';\nimport { stypRenderText } from './text.renderer';\nimport { stypRenderXmlNs } from './xml-ns.renderer';\n\n/**\n * @internal\n */\nexport function defaultStypRenderers(\n    renderer: StypRenderer | readonly StypRenderer[] | undefined,\n): readonly StypRenderer[] {\n\n  const result: StypRenderer[] = [\n    stypRenderAtRules,\n    stypRenderXmlNs,\n    stypRenderGlobals,\n    stypRenderText,\n  ];\n\n  if (renderer) {\n    if (isReadonlyArray(renderer)) {\n      result.push(...renderer);\n    } else {\n      result.push(renderer);\n    }\n  }\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { EventSupply } from '@proc7ts/fun-events';\nimport { StypRules } from '../rule';\nimport { StypFormat } from './format';\nimport { produceBasicStyle } from './produce-basic-style';\nimport { defaultStypRenderers } from './renderers/default-renderers.impl';\n\n/**\n * Produces and dynamically updates CSS stylesheets based on the given CSS rules.\n *\n * Appends `<style>` element(s) to the given parent DOM node (`document.head` by default) and updates them when CSS\n * rules change.\n *\n * This function enables all default renderers. E.g. the one supporting raw CSS text rules. If some of them are not\n * needed a [[produceBasicStyle]] variant of this function may be used instead.\n *\n * @category Rendering\n * @param rules  CSS rules to produce stylesheets for. This can be e.g. a [[StypRule.rules]] to render all rules,\n * or a result of [[StypRuleList.grab]] method call to render only matching ones.\n * @param format  Production format.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceStyle(rules: StypRules, format: StypFormat): EventSupply {\n  return produceBasicStyle(rules, { ...format, renderer: defaultStypRenderers(format.renderer) });\n}\n\n\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { StypQuery, StypRuleKey, StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { StypRules } from './rules';\n\n/**\n * CSS rule.\n *\n * Represents CSS selector and corresponding CSS properties.\n *\n * @category CSS Rule\n */\nexport abstract class StypRule implements EventKeeper<[StypProperties]> {\n\n  /**\n   * A reference to the root CSS rule.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * A reference to outer CSS rule.\n   *\n   * The outer rule is the one for enclosing element.\n   * I.e. for the rule with selector is `a b+c` the parent one is `a b`, while the outer one is `a`.\n   *\n   * This is `null` for the root rule and may be `null` for the rule removed from hierarchy.\n   */\n  abstract readonly outer: StypRule | null;\n\n  /**\n   * CSS selector of this rule.\n   */\n  abstract readonly selector: StypSelector.Normalized;\n\n  /**\n   * A key of this rule in the enclosing one.\n   */\n  abstract readonly key: StypRuleKey;\n\n  /**\n   * Whether this rule's properties are empty.\n   *\n   * This is `true` when the rule properties are constant and empty.\n   *\n   * Empty CSS rules returned from `rule()` method when there is no matching rule found.\n   */\n  abstract readonly empty: boolean;\n\n  /**\n   * Dynamic list of all CSS rules in hierarchy starting from this one.\n   */\n  abstract readonly rules: StypRuleHierarchy;\n\n  /**\n   * Build `AfterEvent` keeper of CSS properties of this rule.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of CSS properties map.\n   */\n  abstract read(): AfterEvent<[StypProperties]>;\n\n  /**\n   * Starts sending CSS properties of this rule and their updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of CSS properties map.\n   *\n   * @returns CSS properties supply.\n   */\n  abstract read(receiver: EventReceiver<[StypProperties]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[StypProperties]> {\n    return this.read();\n  }\n\n  /**\n   * Sets CSS properties of this rule.\n   *\n   * @param properties  CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: StypProperties.Spec): this;\n\n  /**\n   * Appends CSS properties to this rule.\n   *\n   * @param properties  CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  add(properties: StypProperties.Spec): this {\n    return this.rules.add([], properties) as this;\n  }\n\n  /**\n   * Clears CSS properties of this rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n  /**\n   * Removes this rule from hierarchy along with all nested rules.\n   *\n   * @param reason  Optional removal reason.\n   *\n   * @returns `this` (just removed) rule instance.\n   */\n  abstract remove(reason?: any): this;\n\n}\n\n/**\n * Dynamically updated list of CSS rules.\n *\n * This is an iterable of rules, an EventSender` of their updates, and an `EventKeeper` of itself.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleList implements StypRules, EventKeeper<[StypRuleList]> {\n\n  /**\n   * Builds an `AfterEvent` keeper of rule list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of this rule list.\n   */\n  abstract read(): AfterEvent<[StypRuleList]>;\n\n  /**\n   * Starts sending rule list and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of this rule list.\n   *\n   * @returns Rule list supply.\n   */\n  abstract read(receiver: EventReceiver<[StypRuleList]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[StypRuleList]> {\n    return this.read();\n  }\n\n  /**\n   * Builds an `OnEvent` sender of this rule list updates.\n   *\n   * The list updates receiver accepts two arguments:\n   * - An array of added rules\n   * - An array of removed rules.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of rule list updates.\n   */\n  abstract onUpdate(): OnEvent<[StypRule[], StypRule[]]>;\n\n  /**\n   * Starts sending updates to this rule list to the given `receiver`.\n   *\n   * @param receiver  Target receiver of updates to this rule list.\n   *\n   * @returns Rule list updates supply.\n   */\n  abstract onUpdate(receiver: EventReceiver<[StypRule[], StypRule[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n    return this.onUpdate();\n  }\n\n  abstract [Symbol.iterator](): IterableIterator<StypRule>;\n\n  /**\n   * Grabs rules from this list matching the given `query`.\n   *\n   * @param query  CSS rule query to match.\n   *\n   * @returns Dynamic list of rules in this list matching the given query.\n   */\n  abstract grab(query: StypQuery): StypRuleList;\n\n}\n\n/**\n * Dynamic list of all CSS rules in hierarchy starting from its root.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleHierarchy extends StypRuleList {\n\n  /**\n   * Dynamic list containing only root CSS rule.\n   *\n   * This list never changes actually.\n   */\n  abstract readonly self: StypRuleList;\n\n  /**\n   * Dynamic list of all CSS rules directly nested within the root one.\n   */\n  abstract readonly nested: StypRuleList;\n\n  /**\n   * Appends CSS properties to nested rule.\n   *\n   * Creates target rule if necessary.\n   *\n   * @param selector  Target rule selector.\n   * @param properties  Optional CSS properties specifier.\n   *\n   * @returns Modified CSS rule.\n   */\n  abstract add(selector: StypSelector, properties?: StypProperties.Spec): StypRule;\n\n  /**\n   * Returns nested CSS rule matching the given `selector`.\n   *\n   * @param selector  Target rule selector.\n   *\n   * @returns Either matching CSS rule, or `undefined` if not found.\n   */\n  abstract get(selector: StypSelector): StypRule | undefined;\n\n  /**\n   * Watches for CSS rule properties.\n   *\n   * The properties are empty when the watched rule does not exist.\n   *\n   * @param selector  CSS selector of watched rule.\n   *\n   * @returns An `AfterEvent` registrar of CSS properties receiver.\n   */\n  abstract watch(selector: StypSelector): AfterEvent<[StypProperties]>;\n\n}\n","import { filterIt, itsIterable } from '@proc7ts/a-iterable';\nimport { asis, valueProvider, valuesProvider } from '@proc7ts/call-thru';\nimport { AfterEvent, afterSent, EventReceiver, EventSupply, OnEvent, onEventBy, onSupplied } from '@proc7ts/fun-events';\nimport { stypQuery, StypQuery, stypSelectorMatches } from '../selector';\nimport { StypRule, StypRuleList } from './rule';\nimport { StypRules } from './rules';\n\n/**\n * @internal\n */\nexport class Rules extends StypRuleList {\n\n  private readonly _buildList: () => Iterable<StypRule>;\n  private readonly _filterArray: (rules: StypRule[]) => StypRule[];\n  // noinspection JSMismatchedCollectionQueryUpdate\n  private _ruleSet?: Set<StypRule>; // `undefined` updates are not tracked\n\n  constructor(private readonly _list: StypRules, ruleMatches?: (rule: StypRule) => boolean) {\n    super();\n    if (ruleMatches) {\n      this._buildList = () => filterIt(_list, ruleMatches);\n      this._filterArray = rules => rules.filter(ruleMatches);\n    } else {\n      this._buildList = () => _list;\n      this._filterArray = asis;\n    }\n  }\n\n  read(): AfterEvent<[StypRuleList]>;\n  read(receiver: EventReceiver<[StypRuleList]>): EventSupply;\n  read(receiver?: EventReceiver<[StypRuleList]>): AfterEvent<[StypRuleList]> | EventSupply {\n    return (this.read = afterSent<[Rules]>(\n        this.onUpdate().thru(valueProvider(this)),\n        valuesProvider(this),\n    ).F)(receiver);\n  }\n\n  onUpdate(): OnEvent<[StypRule[], StypRule[]]>;\n  onUpdate(receiver: EventReceiver<[StypRule[], StypRule[]]>): EventSupply;\n  onUpdate(receiver?: EventReceiver<[StypRule[], StypRule[]]>): OnEvent<[StypRule[], StypRule[]]> | EventSupply {\n    return (this.onUpdate = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n      const rules = this._ruleSet || (this._ruleSet = new Set(this._buildList()));\n\n      onSupplied(this._list).to({\n        supply: receiver.supply.whenOff(() => this._ruleSet = undefined),\n        receive: (context, added, removed) => {\n          added = this._filterArray(added);\n          removed = this._filterArray(removed);\n          if (removed.length || added.length) {\n            removed.forEach(rule => rules.delete(rule));\n            added.forEach(rule => rules.add(rule));\n            receiver.receive(context, added, removed);\n          }\n        },\n      });\n    }).share().F)(receiver);\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    if (this._ruleSet) {\n      // List changes are tracked.\n      return this._ruleSet.values();\n    }\n    // List changes are not currently tracked.\n    // Request the rules explicitly.\n    return itsIterable(this._buildList());\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function grabRules(list: StypRuleList, query: StypQuery): StypRuleList {\n\n  const q = stypQuery(query);\n\n  return new Rules(list, rule => stypSelectorMatches(rule.selector, q));\n}\n","import { itsIterable } from '@proc7ts/a-iterable';\nimport { valueProvider, valuesProvider } from '@proc7ts/call-thru';\nimport {\n  AfterEvent,\n  afterEventBy,\n  afterSent,\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  nextAfterEvent,\n  OnEvent,\n  OnEvent__symbol,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { StypQuery, StypRuleKey, stypSelector, StypSelector } from '../selector';\nimport { stypRuleKeyText } from '../selector/selector-text.impl';\nimport { stypOuterSelector, stypRuleKeyAndTail } from '../selector/selector.impl';\nimport { StypProperties } from './properties';\nimport { mergeStypProperties, noStypPropertiesSpec, stypPropertiesBySpec } from './properties.impl';\nimport { StypRule, StypRuleHierarchy, StypRuleList } from './rule';\nimport { StypRules } from './rules';\nimport { grabRules, Rules } from './rules.impl';\n\nclass AllRules extends StypRuleHierarchy {\n\n  private readonly _updates = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  readonly self: StypRuleList;\n\n  constructor(private readonly _root: StypRule$, readonly nested: NestedRules) {\n    super();\n    this.self = selfRuleList(_root, this);\n  }\n\n  read(): AfterEvent<[AllRules]>;\n  read(receiver: EventReceiver<[AllRules]>): EventSupply;\n  read(receiver?: EventReceiver<[AllRules]>): AfterEvent<[AllRules]> | EventSupply {\n    return (this.read = afterSent<[AllRules]>(\n        this._updates.on().thru(valueProvider(this)),\n        valuesProvider(this),\n    ).F)(receiver);\n  }\n\n  onUpdate(): OnEvent<[StypRule$[], StypRule$[]]>;\n  onUpdate(receiver: EventReceiver<[StypRule$[], StypRule$[]]>): EventSupply;\n  onUpdate(receiver?: EventReceiver<[StypRule$[], StypRule$[]]>): OnEvent<[StypRule$[], StypRule$[]]> | EventSupply {\n    return (this.onUpdate = this._updates.on().F)(receiver);\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule$> {\n    return iterateAllRules(this._root);\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  add(selector: StypSelector, properties?: StypProperties.Spec): StypRule$ {\n    return extendRule(this._root, stypSelector(selector), properties, true);\n  }\n\n  get(selector: StypSelector): StypRule$ | undefined {\n    return this._get(stypSelector(selector));\n  }\n\n  private _get(selector: StypSelector.Normalized): StypRule$ | undefined {\n\n    const [key, tail] = stypRuleKeyAndTail(selector);\n\n    if (!tail) {\n      return this._root;\n    }\n\n    const found = this.nested._rule(stypRuleKeyText(key));\n\n    if (!found) {\n      return;\n    }\n\n    return found.rules.get(tail);\n  }\n\n  watch(selector: StypSelector): AfterEvent<[StypProperties]> {\n\n    const request = stypSelector(selector);\n\n    return afterEventBy<[StypProperties]>(receiver => {\n\n      const tracker = trackValue<StypProperties>({});\n      const propertiesSupply = this.read().consume(() => {\n\n        const found = this._get(request);\n\n        return found && found\n            .read(properties => tracker.it = properties)\n            .whenOff(() => tracker.it = {});\n      });\n\n      return tracker.read(receiver).cuts(propertiesSupply);\n    }).share();\n  }\n\n  _add(rule: StypRule$, sendUpdate: boolean): void {\n    rule.rules.onUpdate((added, removed) => this._updates.send(added, removed));\n    if (sendUpdate) {\n      this._updates.send(allRules(rule), []);\n    }\n  }\n\n  _remove(reason?: any): void {\n\n    const removed = allRules(this._root);\n\n    this._updates.send([], removed);\n    removed.forEach(rule => {\n      rule.rules._updates.done(reason);\n      rule._spec.done(reason);\n    });\n  }\n\n}\n\nfunction selfRuleList(rule: StypRule$, all: AllRules): StypRuleList {\n\n  const onUpdate = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  const rules = [rule];\n\n  all.onUpdate((_added, removed) => {\n    if (removed[0] === rule) {\n      rules.length = 0;\n      onUpdate.send([], [rule]);\n    }\n  }).cuts(onUpdate);\n\n  class Self implements StypRules {\n\n    [OnEvent__symbol](): OnEvent<[StypRule$[], StypRule$[]]> {\n      return onUpdate.on();\n    }\n\n    [Symbol.iterator](): IterableIterator<StypRule$> {\n      return itsIterable(rules);\n    }\n\n  }\n\n  return new Rules(new Self());\n}\n\nfunction allRules(rule: StypRule$): StypRule$[] {\n  return Array.from(iterateAllRules(rule));\n}\n\nfunction *iterateAllRules(rule: StypRule$): IterableIterator<StypRule$> {\n  yield rule;\n  for (const nested of rule.rules.nested) {\n    yield* allRules(nested);\n  }\n}\n\nclass NestedRules extends StypRuleList {\n\n  readonly _all: AllRules;\n  private readonly _updates = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  private readonly _byKey = new Map<string, StypRule$>();\n\n  constructor(root: StypRule$) {\n    super();\n    this._all = new AllRules(root, this);\n  }\n\n  read(): AfterEvent<[NestedRules]>;\n  read(receiver: EventReceiver<[NestedRules]>): EventSupply;\n  read(receiver?: EventReceiver<[NestedRules]>): AfterEvent<[NestedRules]> | EventSupply {\n    return (this.read = afterSent<[NestedRules]>(\n        this._updates.on().thru(valueProvider(this)),\n        valuesProvider(this),\n    ).F)(receiver);\n  }\n\n  onUpdate(): OnEvent<[StypRule[], StypRule[]]>;\n  onUpdate(receiver: EventReceiver<[StypRule[], StypRule[]]>): EventSupply;\n  onUpdate(receiver?: EventReceiver<[StypRule[], StypRule[]]>): OnEvent<[StypRule[], StypRule[]]> | EventSupply {\n    return (this.onUpdate = this._updates.on().F)(receiver);\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule$> {\n    return this._byKey.values();\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  _rule(key: string): StypRule$ | undefined {\n    return this._byKey.get(key);\n  }\n\n  _add(key: string, rule: StypRule$, sendUpdate: boolean): void {\n    this._byKey.set(key, rule);\n    rule.rules.onUpdate((_added, removed) => {\n      if (removed[0] === rule) {\n        this._byKey.delete(key);\n        this._updates.send([], [rule]);\n      }\n    });\n    if (sendUpdate) {\n      this._updates.send([rule], []);\n    }\n    this._all._add(rule, sendUpdate);\n  }\n\n}\n\n/**\n * @internal\n */\nexport class StypRule$ extends StypRule {\n\n  private readonly _root: StypRule$;\n  private _outer?: StypRule$ | null;\n  private readonly _selector: StypSelector.Normalized;\n  private readonly _key: StypRuleKey;\n  readonly _spec: ValueTracker<StypProperties.Builder>;\n  private readonly _nested: NestedRules;\n\n  get root(): StypRule$ {\n    return this._root;\n  }\n\n  get outer(): StypRule$ | null {\n    if (this._outer !== undefined) {\n      return this._outer;\n    }\n\n    const outerSelector = stypOuterSelector(this.selector);\n\n    return this._outer = outerSelector && this.root.rules.get(outerSelector) || null;\n  }\n\n  get selector(): StypSelector.Normalized {\n    return this._selector;\n  }\n\n  get key(): StypRuleKey {\n    return this._key;\n  }\n\n  get empty(): boolean {\n    return this._spec.it === noStypPropertiesSpec;\n  }\n\n  get rules(): AllRules {\n    return this._nested._all;\n  }\n\n  constructor(\n      root: StypRule$ | undefined,\n      selector: StypSelector.Normalized,\n      key: StypRuleKey,\n      spec: StypProperties.Builder = noStypPropertiesSpec,\n  ) {\n    super();\n    this._root = root || this;\n    this._selector = selector;\n    this._key = key;\n    this._spec = trackValue(spec);\n    this._nested = new NestedRules(this);\n  }\n\n  read(): AfterEvent<[StypProperties]>;\n  read(receiver: EventReceiver<[StypProperties]>): EventSupply;\n  read(receiver?: EventReceiver<[StypProperties]>): AfterEvent<[StypProperties]> | EventSupply {\n    return (this.read = this._spec.read().keepThru(builder => nextAfterEvent(builder(this))).F)(receiver);\n  }\n\n  set(properties?: StypProperties.Spec): this {\n    this._spec.it = properties ? r => stypPropertiesBySpec(r, properties) : noStypPropertiesSpec;\n    return this;\n  }\n\n  remove(reason?: any): this {\n    this.rules._remove(reason);\n    return this;\n  }\n\n}\n\nfunction extendRule(\n    rule: StypRule$,\n    targetSelector: StypSelector.Normalized,\n    properties: StypProperties.Spec | undefined,\n    sendUpdate: boolean,\n): StypRule$ {\n\n  const [key, tail] = stypRuleKeyAndTail(targetSelector);\n\n  if (!tail) {\n    // Target rule\n    rule._spec.it = extendSpec(rule, properties);\n    return rule;\n  }\n\n  const keyText = stypRuleKeyText(key);\n  const found = rule.rules.nested._rule(keyText);\n\n  if (found) {\n    return extendRule(found, tail, properties, sendUpdate);\n  }\n\n  const newNested = new StypRule$(rule.root, [...rule.selector, ...key], key);\n  const result = extendRule(newNested, tail, properties, false); // Send only a top-level update\n\n  rule.rules.nested._add(keyText, newNested, sendUpdate);\n\n  return result;\n}\n\nfunction extendSpec(rule: StypRule$, properties: StypProperties.Spec | undefined): StypProperties.Builder {\n\n  const oldSpec = rule._spec.it;\n\n  if (!properties) {\n    return oldSpec;\n  }\n\n  if (rule.empty) {\n    return r => stypPropertiesBySpec(r, properties);\n  }\n\n  return r => mergeStypProperties(oldSpec(r), stypPropertiesBySpec(r, properties));\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { stypPropertiesBySpec } from './properties.impl';\nimport { StypRule } from './rule';\nimport { StypRule$ as StypRule_ } from './rule.impl';\n\n/**\n * @internal\n */\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * Constructs root CSS rule representing global CSS declarations.\n *\n * All other rules are nested within single root.\n *\n * The root CSS rule selector is empty.\n *\n * @category CSS Rule\n * @param properties  Initial CSS rule properties specifier.\n *\n * @returns New root CSS rule.\n */\nexport function stypRoot(properties?: StypProperties.Spec): StypRule {\n  return new StypRule_(undefined, rootSelector, [], properties ? r => stypPropertiesBySpec(r, properties) : undefined);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { nextArg, valueProvider } from '@proc7ts/call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  isEventKeeper,\n} from '@proc7ts/fun-events';\nimport { StypSelector } from '../selector';\nimport { StypMapper } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * A type safe reference to CSS rule.\n *\n * Allows to access an modify CSS properties of the rule in a type safe manner.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties structure of referenced rule.\n */\nexport abstract class StypRuleRef<T extends StypProperties<T>> implements EventKeeper<[T]> {\n\n  /**\n   * Builds an `AfterEvent` keeper of CSS properties.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of typed CSS properties map.\n   */\n  abstract read(): AfterEvent<[T]>;\n\n  /**\n   * Starts sending CSS properties and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of types CSS properties map.\n   *\n   * @returns CSS properties supply.\n   */\n  abstract read(receiver: EventReceiver<[T]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read();\n  }\n\n  /**\n   * Sets CSS properties of the referenced rule.\n   *\n   * @param properties  CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Appends CSS properties to the references CSS rule.\n   *\n   * @param properties  CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract add(properties: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Clears CSS properties of the referenced rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n}\n\n/**\n * CSS rule referrer.\n *\n * This is a function that obtains CSS rule reference relative to the given root.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties interface of referenced rule.\n */\nexport type RefStypRule<T extends StypProperties<T>> =\n/**\n * @param root  Root CSS rule the constructed reference will be relative to.\n *\n * @returns CSS rule reference.\n */\n    (this: void, root: StypRule) => StypRuleRef<T>;\n\n\n/**\n * @internal\n */\nclass StypRuleRef$<T extends StypProperties<T>> extends StypRuleRef<T> {\n\n  constructor(\n      private readonly _root: StypRule,\n      private readonly _selector: StypSelector,\n      private readonly _map: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>,\n  ) {\n    super();\n  }\n\n  read(): AfterEvent<[T]>;\n  read(receiver: EventReceiver<[T]>): EventSupply;\n  read(receiver?: EventReceiver<[T]>): AfterEvent<[T]> | EventSupply {\n    return (this.read = afterAll({\n      ms: this._map(this._root),\n      ps: this._root.rules.watch(this._selector),\n    }).keepThru(\n        ({\n          ms: [_mappings],\n          ps: [_properties],\n        }) => nextArg<T>(StypMapper.map<T>(_mappings, _properties)),\n    ).F)(receiver);\n  }\n\n  add(properties: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n    this._root.rules.add(this._selector, properties);\n    return this;\n  }\n\n  set(properties?: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n    this._root.rules.add(this._selector).set(properties);\n    return this;\n  }\n\n}\n\n/**\n * @category CSS Rule\n */\nexport const RefStypRule = {\n\n  /**\n   * Constructs a CSS rule referrer that maps original CSS properties accordingly to the given `mappings`.\n   *\n   * @typeparam T  CSS properties structure of referenced rule.\n   * @param selector  CSS selector of target rule.\n   * @param mappings  Either a mappings of CSS properties, an event keeper sending such mappings, or a function\n   * returning one of them and accepting a root CSS rule as its only argument.\n   * The constructed reference will be relative to as its only parameter.\n   *\n   * @returns New CSS rule key instance.\n   */\n  by<T extends StypProperties<T>>(\n      selector: StypSelector,\n      mappings:\n          | StypMapper.Mappings<T>\n          | EventKeeper<[StypMapper.Mappings<T>]>\n          | ((this: void, root: StypRule) => StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>),\n  ): RefStypRule<T> {\n\n    let map: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>;\n\n    if (typeof mappings === 'function') {\n      map = root => mappingsKeeper(mappings(root));\n    } else {\n      map = valueProvider(mappingsKeeper(mappings));\n    }\n\n    return root => new StypRuleRef$(root, selector, map);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction mappingsKeeper<T extends StypProperties<T>>(\n    mappings: StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>,\n): EventKeeper<[StypMapper.Mappings<T>]> {\n  return isEventKeeper(mappings) ? mappings : afterThe(mappings);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { afterAll, AfterEvent, AfterEvent__symbol, EventKeeper, EventReceiver, EventSupply } from '@proc7ts/fun-events';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\nimport { RefStypRule, StypRuleRef } from './rule-ref';\n\n/**\n * Named CSS rule references complying to the CSS properties structure.\n *\n * Implements an event keeper interface by sending named CSS properties structures for each CSS rule reference.\n *\n * @category CSS Rule\n * @typeparam R  A type of target map of named CSS properties structures.\n */\nexport class StypRuleRefs<R extends StypRuleRefs.Struct<R>> implements EventKeeper<[R]> {\n\n  /**\n   * CSS rule references by name.\n   *\n   * Each property in this map is a CSS rule reference corresponding to the same named property in properties structure.\n   * I.e. it has the same name and the same properties structure of referenced rule.\n   */\n  readonly refs: { readonly [K in keyof R]: StypRuleRef<R[K]> };\n\n  /**\n   * Constructs named CSS rules by resolving CSS rule referrers.\n   *\n   * @typeparam R  A type of target map of named CSS properties structures.\n   * @param referrers  Named CSS rule referrers to resolve.\n   * @param root  A root CSS rule the references will be relative to.\n   *\n   * @returns New names CSS rules instance.\n   */\n  static by<R extends StypRuleRefs.Struct<R>>(\n      referrers: { readonly [K in keyof R]: RefStypRule<R[K]> },\n      root: StypRule,\n  ): StypRuleRefs<R>;\n\n  static by<R extends StypRuleRefs.Struct<R>>(\n      referrers: { readonly [name: string]: RefStypRule<any> },\n      root: StypRule,\n  ): StypRuleRefs<R> {\n\n    const refs: { [K in keyof R]?: StypRuleRef<any> } = {};\n\n    for (const key of Object.keys(referrers)) {\n      refs[key as keyof R] = referrers[key](root);\n    }\n\n    return new StypRuleRefs<R>(refs as { [K in keyof R]: StypRuleRef<R[K]> });\n  }\n\n  /**\n   * Constructs named CSS rules.\n   *\n   * @param refs  A map of named CSS rule references.\n   */\n  constructor(refs: { readonly [K in keyof R]: StypRuleRef<R[K]> }) {\n    this.refs = refs;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of named CSS properties structures for each CSS rule reference.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of map of named CSS properties structures.\n   */\n  read(): AfterEvent<[R]>;\n\n  /**\n   * Starts sending named CSS properties structures for each CSS rule reference and updates to the given `receiver`.\n   *\n   * @param receiver Target receiver of map of named CSS properties structures.\n   *\n   * @returns Supply of maps of named CSS properties structures.\n   */\n  read(receiver: EventReceiver<[R]>): EventSupply;\n  read(receiver?: EventReceiver<[R]>): AfterEvent<[R]> | EventSupply {\n\n    const fromAll: AfterEvent<[{ [K in keyof R]: [StypProperties<any>] }]> = afterAll(this.refs);\n\n    return (this.read = (fromAll.keepThru(flattenProperties) as AfterEvent<[R]>).F)(receiver);\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[R]> {\n    return this.read();\n  }\n\n}\n\n/**\n * @internal\n */\nfunction flattenProperties<R extends StypRuleRefs.Struct<R>>(\n    propertiesMap: { readonly [name: string]: [StypProperties<any>] },\n): R {\n\n  const result: { [name: string]: StypProperties<any> } = {};\n\n  for (const name of Object.keys(propertiesMap)) {\n    result[name] = propertiesMap[name][0];\n  }\n\n  return result as R;\n}\n\nexport namespace StypRuleRefs {\n\n  /**\n   * A map of named CSS properties structures.\n   *\n   * Each property in this map corresponds to CSS rule reference with the same CSS properties structure.\n   */\n  export type Struct<R = { readonly [name: string]: StypProperties<any> }> = {\n    readonly [K in keyof R]: StypProperties<any>;\n  };\n\n  /**\n   * A map of named CSS rule referrers.\n   *\n   * These referrers then resolved to the same named CSS rule references.\n   *\n   * @typeparam R  A type of target map of named CSS properties structures.\n   */\n  export type Referrers<R extends Struct<R>> = {\n    readonly [K in keyof R]: RefStypRule<R[K]>;\n  };\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/style-producer\n */\nimport { itsEach } from '@proc7ts/a-iterable';\nimport {\n  EventNotifier,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  isEventSender,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  onEventBy,\n  onNever,\n  onSupplied,\n} from '@proc7ts/fun-events';\nimport { StypRule, StypRuleList } from './rule';\nimport { Rules } from './rules.impl';\n\n/**\n * Dynamically updated CSS rule set.\n *\n * This is an iterable of rules, and an `EventSender` of their updates.\n *\n * @category CSS Rule\n */\nexport interface StypRules extends Iterable<StypRule>, EventSender<[StypRule[], StypRule[]]> {\n\n  [Symbol.iterator](): IterableIterator<StypRule>;\n\n}\n\nexport namespace StypRules {\n\n  /**\n   * A source of CSS rules.\n   *\n   * A dynamically updated CSS rule set can be constructed out of one or more sources by [[stypRules]] and\n   * [[lazyStypRules]] functions.\n   *\n   * This can be one of:\n   * - Single `StypRule` instance.\n   *   A `StypRule.rules.self` is used instead. I.e. a list containing only the rule itself.\n   * - A `StypRules` instance.\n   *   It is used as is.\n   * - A promise of one of the above.\n   *   The resolved value is used as an actual source.\n   *   No rules are available until resolution.\n   * - A function returning one of the above.\n   *   The function call result is used as an actual source.\n   *   The function will be called lazily upon rules access.\n   */\n  export type Source =\n      | StypRule\n      | StypRules\n      | Promise<StypRule | StypRules>\n      | ((this: void) => StypRule | StypRules | Promise<StypRule | StypRules>);\n\n}\n\n/**\n * @internal\n */\nconst noStypRules: StypRuleList = (/*#__PURE__*/ new Rules({\n  [OnEvent__symbol]() {\n    return onNever;\n  },\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    return [][Symbol.iterator]();\n  },\n}));\n\n/**\n * Constructs dynamically updated CSS rule list out of rule sources.\n *\n * @category CSS Rule\n * @param sources  CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function stypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(rulesFromSource)) : noStypRules;\n}\n\n/**\n * @internal\n */\nfunction rulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? evalRules(source) : rulesByValue(source);\n}\n\n/**\n * Constructs lazily updated CSS rule list out of rule sources.\n *\n * In contrast to [[stypRules]] this one does not evaluate sources (e.g. does not call source functions) until there\n * is an updates receiver registered.\n *\n * This means that the constructed rule set won't necessary contain the rules from all sources originally. It will\n * report them as updates instead.\n *\n * @category CSS Rule\n * @param sources  CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function lazyStypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(lazyRulesFromSource)) : noStypRules;\n}\n\n/**\n * @internal\n */\nfunction lazyRulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? lazyRules(source) : rulesByValue(source);\n}\n\n/**\n * @internal\n */\nfunction rulesByList(sources: StypRules[]): StypRuleList {\n  if (sources.length === 1) {\n\n    const source = sources[0];\n\n    return source instanceof StypRuleList ? source : new Rules(source);\n  }\n  return new Rules({\n    *[Symbol.iterator](): IterableIterator<StypRule> {\n      for (const rules of sources) {\n        yield* rules;\n      }\n    },\n    [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n      return onEventBy<[StypRule[], StypRule[]]>(receiver => {\n        sources.forEach(source => onSupplied(source).to({\n          supply: eventSupply().needs(receiver.supply),\n          receive(context, added, removed) {\n            receiver.receive(context, added, removed);\n          },\n        }));\n      }).share();\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction evalRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  let _rules: StypRules | undefined;\n\n  return {\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return rules()[Symbol.iterator]();\n    },\n    [OnEvent__symbol]() {\n      return rules()[OnEvent__symbol]();\n    },\n  };\n\n  function rules(): StypRules {\n    return _rules || (_rules = rulesByValue(source()));\n  }\n}\n\n/**\n * @internal\n */\nfunction lazyRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    const rules = rulesByValue(source());\n\n    reportExistingRules(rules, ruleSet, receiver);\n    rules[OnEvent__symbol]().to({\n      supply: receiver.supply.whenOff(() => ruleSet.clear()),\n      receive(context, added, removed) {\n        removed.forEach(rule => ruleSet.delete(rule));\n        added.forEach(rule => ruleSet.add(rule));\n        receiver.receive(context, added, removed);\n      },\n    });\n  }).share();\n\n  return {\n    [OnEvent__symbol]() {\n      return onEvent;\n    },\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction rulesByValue(source: StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n  return source instanceof StypRule ? source.rules.self : isEventSender(source) ? source : asyncRules(source);\n}\n\n/**\n * @internal\n */\nfunction asyncRules(source: Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    let sourceSupply = noEventSupply();\n    const { supply } = receiver;\n\n    supply.cuts(sourceSupply)\n        .whenOff(() => ruleSet.clear());\n\n    source.then(\n        resolution => {\n          if (!supply.isOff) {\n\n            const rules = resolution instanceof StypRule ? resolution.rules : resolution;\n\n            reportExistingRules(rules, ruleSet, receiver);\n\n            sourceSupply = onSupplied(rules).to({\n              receive(context, added, removed) {\n                removed.forEach(rule => ruleSet.delete(rule));\n                added.forEach(rule => ruleSet.add(rule));\n                receiver.receive(context, added, removed);\n              },\n            }).needs(supply);\n          }\n        },\n    ).catch(\n        error => supply.off(error),\n    );\n  }).share();\n\n  return {\n    [OnEvent__symbol]() {\n      return onEvent;\n    },\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction reportExistingRules(\n    rules: StypRules,\n    ruleSet: Set<StypRule>,\n    receiver: EventReceiver.Generic<[StypRule[], StypRule[]]>,\n): void {\n\n  const existing: StypRule[] = [];\n\n  itsEach(rules, rule => {\n    existing.push(rule);\n    ruleSet.add(rule);\n  });\n  if (existing.length) {\n\n    const dispatcher = new EventNotifier<[StypRule[], StypRule[]]>();\n\n    dispatcher.on(receiver);\n    dispatcher.send(existing, []); // Report existing rules as just added\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { EventSupply } from '@proc7ts/fun-events';\nimport { StypFormat, StypRules } from '@proc7ts/style-producer';\n\n/**\n * Component style producer signature.\n */\nexport type ComponentStyleProducer =\n/**\n * @param rules  CSS rules to produce stylesheets for. This can be e.g. a `StypRule.rules` to render all rules,\n * or a result of `StypRuleList.grab()` method call to render only matching ones.\n * @param format  Style production format.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\n    (\n        rules: StypRules,\n        format: StypFormat,\n    ) => EventSupply;\n\n/**\n * A key of bootstrap, definition, or component context value containing a component style producer.\n */\nexport const ComponentStyleProducer: SingleContextRef<ComponentStyleProducer> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentStyleProducer>('component-style-producer')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { MultiContextKey, MultiContextRef } from '@proc7ts/context-values';\nimport { StypRenderer } from '@proc7ts/style-producer';\n\n/**\n * A CSS renderer that will be enabled by default by {@link ComponentStypFormat component style production format}.\n */\nexport type ComponentStypRenderer = StypRenderer;\n\n/**\n * A key of component context value containing component CSS renderers.\n */\nexport const ComponentStypRenderer: MultiContextRef<ComponentStypRenderer> = (\n    /*#__PURE__*/ new MultiContextKey<ComponentStypRenderer>('component-styp-renderer')\n);\n","import { ContextValues, SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { css__naming, html__naming, NamespaceDef, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { ComponentContext, DefaultNamespaceAliaser, ElementDef } from '@wesib/wesib';\n\n/**\n * @internal\n */\nexport type ElementIdClass = QualifiedName;\n\n/**\n * @internal\n */\nexport const ElementIdClass__NS = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns/element-id-class',\n    'elic',\n    'element-id-class',\n));\n\n/**\n * @internal\n */\nexport const ElementIdClass: SingleContextRef<ElementIdClass> = (/*#__PURE__*/ new SingleContextKey(\n    'unique-element-class',\n    { byDefault: assignElementId },\n));\n\n/**\n * @internal\n */\nlet uniqueClassSeq = 0;\n\n/**\n * @internal\n */\nfunction assignElementId(contextValues: ContextValues): ElementIdClass {\n\n  const aliaser = contextValues.get(DefaultNamespaceAliaser);\n  const context = contextValues.get(ComponentContext);\n  const elementDef = context.get(ElementDef);\n  const name: string = elementDef.name ? html__naming.name(elementDef.name, aliaser) : 'component';\n  const local = `${name}#${++uniqueClassSeq}`;\n  const qualified = ElementIdClass__NS.name(aliaser(ElementIdClass__NS), local, css__naming);\n  const element = context.element as Element;\n\n  element.classList.add(qualified);\n\n  return qualified;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { valueProvider } from '@proc7ts/call-thru';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { EventSupply, eventSupply, eventSupplyOf } from '@proc7ts/fun-events';\nimport { NamespaceAliaser } from '@proc7ts/namespace-aliaser';\nimport { RenderScheduler } from '@proc7ts/render-scheduler';\nimport {\n  lazyStypRules,\n  StypFormat,\n  StypFormatConfig,\n  StypPureSelector,\n  StypRenderer,\n  StypRules,\n  StypSelector,\n  stypSelector,\n  StypSubSelector,\n} from '@proc7ts/style-producer';\nimport { ArraySet, ComponentContext, ShadowContentRoot } from '@wesib/wesib';\nimport { ComponentStyleProducer } from './component-style-producer';\nimport { ComponentStypRenderer } from './component-styp-renderer';\nimport { ElementIdClass } from './element-id-class.impl';\n\n/**\n * Configuration of {@link ComponentStypFormat component style production format}.\n */\nexport interface ComponentStypFormatConfig extends StypFormatConfig {\n\n  /**\n   * Structured CSS selector to use for custom element's host.\n   *\n   * It modifies the selectors of produced CSS rules.\n   *\n   * For custom element with shadow root:\n   * - Replaces root CSS rule selector with `:host(<hostSelector>).\n   * - When `hostSelector` is omitted, then replaces root CSS rule selector with `:host`.\n   * - If CSS rule selector starts with `:host`, then replaces `:host` with `:host(<hostSelector>)`\n   * - If CSS rule selector starts with `:host(<selector>)`, then extends `<selector>` by `hostSelector`.\n   *   I.e. appends CSS classes and sub-selectors to it, and fulfills missing element and identifier selectors.\n   *\n   * For custom element without shadow root either uses provided `hostSelector`, or generates a unique one when omitted.\n   * And additionally:\n   * - Replaces root CSS rule selector it with `hostSelector`.\n   * - If CSS rule selector starts with `:host`, then replaces `:host` with `hostSelector`.\n   * - If CSS rule selector starts with `:host(<selector>), then replaces `:host(<selector>)` with `<selector>` extended\n   *   by `hostSelector`. I.e. appends CSS classes and sub-selectors to it, and fulfills missing element and identifier\n   *   selectors.\n   * - Otherwise prepends CSS rule selector with `hostSelector`.\n   *\n   * This selector should not contain a `:host` sub-selector.\n   */\n  readonly hostSelector?: StypPureSelector.Part | string;\n\n  /**\n   * Root CSS selector is never used for custom elements. A `hostSelector` is applied instead.\n   */\n  readonly rootSelector?: undefined;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * `ElementRenderScheduler` is used when omitted.\n   */\n  readonly scheduler?: RenderScheduler;\n\n  /**\n   * Namespace aliaser to use.\n   *\n   * `DefaultNamespaceAliaser` is used when omitted.\n   */\n  readonly nsAlias?: NamespaceAliaser;\n\n}\n\nconst ComponentStypFormat__symbol = (\n    /*#__PURE__*/ new SingleContextKey<ComponentStypFormat>(\n        'component-styp-format',\n    )\n);\n\n/**\n * Component style production format.\n *\n * This format can be obtained from component context.\n *\n * The formats implemented:\n * - {@link ComponentStypObjectFormat} (the default) renders CSS using CSS object model.\n * - {@link ComponentStypDomFormat} renders CSS as text. May render CSS of disconnected element.\n */\nexport abstract class ComponentStypFormat {\n\n  /**\n   * A key of component context value containing its style production format.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentStypFormat> {\n    return ComponentStypFormat__symbol;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext;\n\n  /**\n   * Produces and dynamically updates component's CSS stylesheets based on the given CSS rules.\n   *\n   * Utilizes {@link newProducer component's producer function}.\n   *\n   * @param rules  A source of CSS rules to produce stylesheets for.\n   * @param config  Style production format configuration.\n   *\n   * @returns CSS rules supply. Once cut off the produced stylesheets are removed.\n   */\n  produce(\n      rules: StypRules.Source,\n      config?: ComponentStypFormatConfig,\n  ): EventSupply {\n\n    const producer = this.newProducer(rules, config);\n    const supply = eventSupply();\n\n    this.context.whenSettled(() => {\n      producer().needs(supply).cuts(supply);\n    });\n\n    return supply;\n  }\n\n  /**\n   * Creates component's CSS stylesheets producer based on the given CSS rules.\n   *\n   * Utilizes {@link ComponentStyleProducer}.\n   *\n   * @param rules  A source of CSS rules to produce stylesheets for.\n   * @param config  Style production format configuration.\n   *\n   * @returns CSS rules producer function returning CSS rules supply. Once cut off the produced stylesheets are removed.\n   */\n  newProducer(\n      rules: StypRules.Source,\n      config?: ComponentStypFormatConfig,\n  ): (this: void) => EventSupply {\n\n    const css = lazyStypRules(rules);\n    let producer: () => EventSupply;\n    const componentSupply = eventSupplyOf(this.context);\n\n    producer = () => {\n\n      const produceStyle = this.context.get(ComponentStyleProducer);\n\n      return produceStyle(css, this.format(config)).needs(componentSupply);\n    };\n\n    // In case the component destroyed already, the producer will be reassigned here _before_ return.\n    componentSupply.whenOff(() => {\n      // Prevent style production once component destroyed.\n      producer = valueProvider(componentSupply);\n    });\n\n    return () => producer();\n  }\n\n  /**\n   * Builds CSS style production format to by its config.\n   *\n   * This method is called by {@link produce} one.\n   *\n   * @param config  Component style production format configuration.\n   *\n   * @returns Component style production format.\n   */\n  abstract format(config?: ComponentStypFormatConfig): StypFormat;\n\n  /**\n   * Builds component-specific style renderer.\n   *\n   * This renderer applies {@link ComponentStypFormatConfig.hostSelector host selector} to generated CSS rules.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config  Component style production format configuration.\n   *\n   * @returns Component style renderer(s).\n   */\n  renderer(\n      config: ComponentStypFormatConfig,\n  ): StypRenderer | readonly StypRenderer[] | undefined {\n\n    const shadowRoot = this.context.get(ShadowContentRoot, { or: null });\n    const { renderer } = config;\n    const renderers = new ArraySet<StypRenderer>(renderer)\n        .add(...this.context.get(ComponentStypRenderer));\n    const hostSelector = config.hostSelector\n        ? stypSelector(config.hostSelector)[0] as StypPureSelector.NormalizedPart\n        : undefined;\n\n    renderers.add(shadowRoot\n        ? shadowRenderer(hostSelector)\n        : noShadowRenderer(hostSelector || { c: [this.context.get(ElementIdClass)] }));\n\n    return renderers.value;\n  }\n\n}\n\n\n/**\n * @internal\n */\nfunction shadowRenderer(hostSelector: StypPureSelector.NormalizedPart | undefined): StypRenderer {\n  return {\n    order: -100,\n    render(producer, properties) {\n\n      let { selector } = producer;\n\n      if (!selector.length) {\n        selector = [hostSelector || { u: [[':', 'host']] }];\n      } else if (hostSelector) {\n\n        const [rest, host] = extractHostSelector(selector);\n\n        if (host) {\n          if (host.length) {\n            selector = [{ u: [[':', 'host', extendHostSelector(host, hostSelector)]] }, ...rest];\n          } else {\n            selector = [{ u: [[':', 'host', [hostSelector]]] }, ...rest];\n          }\n        }\n      }\n\n      producer.render(properties, { selector });\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction noShadowRenderer(hostSelector: StypPureSelector.NormalizedPart): StypRenderer {\n  return {\n    order: -100,\n    render(producer, properties) {\n\n      let { selector } = producer;\n\n      if (!selector.length) {\n        selector = [hostSelector];\n      } else {\n\n        const [rest, host] = extractHostSelector(selector);\n\n        if (host && host.length) {\n          selector = [...extendHostSelector(host, hostSelector), ...rest];\n        } else {\n          selector = [hostSelector, ...rest];\n        }\n      }\n\n      producer.render(properties, { selector });\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction extractHostSelector(\n    selector: StypSelector.Normalized,\n): [StypSelector.Normalized, StypSelector.Normalized?] {\n  if (typeof selector[0] !== 'string') {\n\n    const [{ ns, e, i, c, u, s, $ }, ...restParts] = selector;\n\n    if (!ns && !e && !i && !c && !s && u) {\n\n      const [[prefix, name, ...params]] = u;\n\n      if (prefix === ':' && name === 'host') {\n\n        let host: StypSelector.Mutable;\n\n        if (params.length) {\n          host = Array.from(params[0] as StypSubSelector.NormalizedParameter);\n          (host[0] as any).$ = $;\n        } else {\n          host = $ ? [{ $ }] : [];\n        }\n\n        return [restParts, host];\n      }\n    }\n  }\n  return [selector];\n}\n\n/**\n * @internal\n */\nfunction extendHostSelector(\n    selector: StypSelector.Normalized,\n    {\n      ns,\n      e,\n      i,\n      c,\n      u,\n      s,\n    }: StypPureSelector.NormalizedPart,\n): StypSelector.Normalized {\n\n  const [first, ...rest] = selector as [StypSelector.NormalizedPart, ...StypSelector.Normalized];\n\n  return [\n    {\n      ns: first.e || first.ns ? first.ns : ns,\n      e: first.e || first.ns ? first.e : e,\n      i: first.i || i,\n      c: first.c ? (c ? [...first.c, ...c] : first.c) as typeof c : c,\n      u: first.u ? (u ? [...first.u, ...u] : first.u) as typeof u : u,\n      s: ((first.s || '') + (s || '')) || undefined,\n      $: first.$,\n    },\n    ...rest,\n  ];\n}\n\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { stypDomFormat, StypDomFormatConfig, StypFormat } from '@proc7ts/style-producer';\nimport {\n  BootstrapWindow,\n  ComponentContext,\n  DefaultNamespaceAliaser,\n  ElementRenderScheduler,\n  RenderDef,\n} from '@wesib/wesib';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * Component's DOM style production format.\n *\n * Renders CSS styles as text.\n *\n * This format is generally slower than {@link ComponentStypObjectFormat}, but allows to render styles before element\n * is connected to document.\n */\nexport class ComponentStypDomFormat extends ComponentStypFormat {\n\n  /**\n   * When to start component style rendering.\n   *\n   * One of:\n   * `settled` (the default) - to start rendering when component is settled.\n   * `connected` - to start rendering when component's element is connected to document.\n   */\n  readonly when: 'settled' | 'connected';\n\n  /**\n   * Constructs DOM style production format.\n   *\n   * @param context  Target component context.\n   * @param when  When to start style rendering. `settled` by default.\n   */\n  constructor(\n      readonly context: ComponentContext,\n      {\n        when = 'settled',\n      }: {\n        readonly when?: 'settled' | 'connected';\n      } = {},\n  ) {\n    super();\n    this.when = when;\n  }\n\n  format(config?: ComponentStypFormatConfig & StypDomFormatConfig): StypFormat {\n    return stypDomFormat(this.config(config));\n  }\n\n  /**\n   * Builds configuration of DOM style production format.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config  Original component style production format configuration.\n   *\n   * @returns Configuration of DOM style production format.\n   */\n  config(\n      config?: ComponentStypFormatConfig & StypDomFormatConfig,\n  ): StypDomFormatConfig {\n    return componentStypDomFormatConfig(this, config, { when: this.when });\n  }\n\n}\n\n/**\n * Builds configuration of DOM style production format.\n *\n * Schedules style rendering in `ElementRenderScheduler` by default.\n *\n * Utilizes `DefaultNamespaceAliaser` by default.\n *\n * @param format  Target component style production format.\n * @param config  Original component style production format configuration.\n * @param render  Element render definition to apply to style render schedule, unless render scheduler specified\n * explicitly in `config`.\n *\n * @returns Configuration of DOM style production format.\n */\nexport function componentStypDomFormatConfig(\n    format: ComponentStypFormat,\n    config: ComponentStypFormatConfig & StypDomFormatConfig = {},\n    render?: RenderDef,\n): StypDomFormatConfig {\n\n  const { context } = format;\n\n  return {\n    ...config,\n    document: config.document || context.get(BootstrapWindow).document,\n    parent: config.parent || context.contentRoot,\n    rootSelector: [],\n    scheduler: config.scheduler || defaultStypRenderScheduler(context, render),\n    nsAlias: config.nsAlias || context.get(DefaultNamespaceAliaser),\n    renderer: format.renderer(config),\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultStypRenderScheduler(\n    context: ComponentContext,\n    render: RenderDef = {},\n): ElementRenderScheduler {\n\n  const scheduler = context.get(ElementRenderScheduler);\n\n  return (opts = {}) => scheduler({ ...opts, ...render });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { StypFormat, stypObjectFormat, StypObjectFormatConfig } from '@proc7ts/style-producer';\nimport { ComponentContext } from '@wesib/wesib';\nimport { componentStypDomFormatConfig } from './component-styp-dom.format';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * Component's CSS object model production format.\n *\n * Renders CSS when component's element connected to document.\n *\n * This format is used by default.\n */\nexport class ComponentStypObjectFormat extends ComponentStypFormat {\n\n  /**\n   * Constructs CSS object model production format.\n   *\n   * @param context  Target component context.\n   */\n  constructor(readonly context: ComponentContext) {\n    super();\n  }\n\n  format(config?: ComponentStypFormatConfig & StypObjectFormatConfig): StypFormat {\n    return stypObjectFormat(this.config(config));\n  }\n\n  /**\n   * Builds configuration of CSS object model production format.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config  Original component style production format configuration.\n   *\n   * @returns Configuration of CSS object model production format.\n   */\n  config(config?: ComponentStypFormatConfig & StypObjectFormatConfig): StypObjectFormatConfig {\n    return componentStypDomFormatConfig(this, config, { when: 'connected' });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { produceBasicStyle } from '@proc7ts/style-producer';\nimport { FeatureDef, FeatureDef__symbol, StateSupport } from '@wesib/wesib';\nimport { ComponentStyleProducer } from './component-style-producer';\nimport { ComponentStypFormat } from './component-styp-format';\nimport { ComponentStypObjectFormat } from './component-styp-object.format';\n\n/**\n * @internal\n */\nconst BasicStyleProducerSupport__feature: FeatureDef = {\n  needs: StateSupport,\n  setup(setup) {\n    setup.provide({ a: ComponentStyleProducer, is: produceBasicStyle });\n    setup.perComponent({\n      a: ComponentStypFormat,\n      as: ComponentStypObjectFormat,\n    });\n  },\n};\n\n/**\n * Basic style producer support feature.\n *\n * Depends on [style-producer].\n *\n * Unlike [[StyleProducerSupport]] feature this one does not enable default CSS renderers.\n *\n * It is enabled automatically by {@link ProduceStyle @ProduceStyle} decorator.\n *\n * [style-producer]: https://www.npmjs.com/package/style-producer\n */\nexport class BasicStyleProducerSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return BasicStyleProducerSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { StypRule, StypRules } from '@proc7ts/style-producer';\nimport { ComponentClass, ComponentProperty, ComponentPropertyDecorator } from '@wesib/wesib';\nimport { BasicStyleProducerSupport } from './basic-style-producer-support.feature';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * A decorator of component property returning CSS rules to produce.\n *\n * Decorated property value should either contain a CSS rules source of type `StypRules.Source` or be a method\n * returning it.\n *\n * This decorator automatically enables [[BasicStyleProducerSupport]] feature.\n *\n * Produces CSS using {@link ComponentStypFormat component style production format}.\n *\n * @typeparam T  A type of decorated component class.\n * @param config  Non-mandatory component style production format config.\n *\n * @returns Component property decorator.\n */\nexport function ProduceStyle<T extends ComponentClass>(\n    config?: ComponentStypFormatConfig,\n): ComponentPropertyDecorator<\n    | StypRules.Source\n    | (() => StypRule | StypRules | Promise<StypRule | StypRules>),\n    T> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      feature: {\n        needs: BasicStyleProducerSupport,\n      },\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(({ component }) => {\n\n            const value = get(component);\n            const source: StypRules.Source = typeof value === 'function' ? value.bind(component) : value;\n            const format = context.get(ComponentStypFormat);\n\n            format.produce(source, config);\n          });\n        });\n      },\n    },\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { produceStyle } from '@proc7ts/style-producer';\nimport { FeatureDef, FeatureDef__symbol, StateSupport } from '@wesib/wesib';\nimport { BasicStyleProducerSupport } from './basic-style-producer-support.feature';\nimport { ComponentStyleProducer } from './component-style-producer';\nimport { ComponentStypFormat } from './component-styp-format';\nimport { ComponentStypObjectFormat } from './component-styp-object.format';\n\n/**\n * @internal\n */\nconst StyleProducerSupport__feature: FeatureDef = {\n  has: BasicStyleProducerSupport,\n  needs: StateSupport,\n  setup(setup) {\n    setup.provide({ a: ComponentStyleProducer, is: produceStyle });\n    setup.perComponent({\n      a: ComponentStypFormat,\n      as: ComponentStypObjectFormat,\n    });\n  },\n};\n\n/**\n * Style producer support feature.\n *\n * Depends on [style-producer].\n *\n * This is an implementation of [[BasicStyleProducerSupport]] feature that enables default CSS renderers.\n *\n * It is _not_ enabled automatically by {@link ProduceStyle @ProduceStyle} decorator.\n *\n * [style-producer]: https://www.npmjs.com/package/style-producer\n */\nexport class StyleProducerSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StyleProducerSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { RefStypRule, StypProperties, StypRule, StypRuleRef, StypRules } from '@proc7ts/style-producer';\nimport { ThemeStyle } from './theme-style';\n\n/**\n * @internal\n */\nconst Theme__key = new SingleContextKey<Theme>('theme');\n\n/**\n * A hierarchy of CSS rules within single root.\n *\n * A component may use it to extract styling information.\n *\n * Current theme is available in bootstrap, definition, or component context. By default, only one theme is declared\n * per bootstrap. But this can be overridden.\n */\nexport abstract class Theme {\n\n  /**\n   * A key of bootstrap, definition, or component context value containing current theme instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<Theme> {\n    return Theme__key;\n  }\n\n  /**\n   * Root CSS rule.\n   *\n   * All theme styling is represented as rules within this root.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * Obtains CSS rule reference by its `referrer`.\n   *\n   * This is a helper method that resolves the given `referrer` against the `root` CSS rule of this theme.\n   *\n   * @param referrer  Target CSS rule referrer.\n   *\n   * @returns CSS rule reference.\n   */\n  ref<T extends StypProperties<T>>(referrer: RefStypRule<T>): StypRuleRef<T> {\n    return referrer(this.root);\n  }\n\n  /**\n   * Obtains a styling for the given theme styles.\n   *\n   * This method requests the registered {@link ThemeStyle theme styles} for CSS rules they provide.\n   * If some of the styles are not registered then uses the given style as provider.\n   *\n   * @param styles  The styles to obtain styling information for.\n   *\n   * @returns Dynamically updated CSS rule set containing the requested styling.\n   */\n  abstract style(...styles: ThemeStyle.Provider[]): StypRules;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { Theme } from './theme';\n\n/**\n * @internal\n */\nconst ThemeFactory__key = new SingleContextKey<ThemeFactory>('theme-factory');\n\nexport abstract class ThemeFactory {\n\n  static get [ContextKey__symbol](): ContextKey<ThemeFactory> {\n    return ThemeFactory__key;\n  }\n\n  abstract newTheme(): Theme;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { ContextRef, ContextValueOpts, ContextValues, IterativeContextKey } from '@proc7ts/context-values';\nimport { stypRules, StypRules } from '@proc7ts/style-producer';\nimport { Theme } from './theme';\n\n/**\n * Theme style provides part of the theme styling information.\n *\n * Theme style(s) can be provided in bootstrap context. They are applied to the theme at most once, when requested\n * by calling [[Theme.style]] method.\n *\n * Theme style is either a function, or an extension of another theme style.\n */\nexport type ThemeStyle = ThemeStyle.Provider | ThemeStyle.Extension;\n\nexport namespace ThemeStyle {\n\n  /**\n   * Theme style provider function.\n   *\n   * This function is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n   *\n   * This function is used as an identifier of particular style and can be extended using [[ThemeStyle.Extension]].\n   *\n   * It is not absolutely necessary to register style provider. It will be applied on request anyway.\n   *\n   * @param theme  A theme to apply styling to.\n   *\n   * @returns Dynamically updated CSS rule set containing the applied styling.\n   */\n  export type Provider = (this: void, theme: Theme) => StypRules;\n\n  /**\n   * Theme style extension.\n   *\n   * An extension should be registered in bootstrap context in order to be applied.\n   */\n  export interface Extension {\n\n    /**\n     * A theme style provider to extend.\n     */\n    readonly style: ThemeStyle.Provider;\n\n    /**\n     * Extends the theme style.\n     *\n     * This method is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n     *\n     * It will be called after the style provider it extends.\n     *\n     * @param theme  A theme to apply styling to.\n     *\n     * @returns Dynamically updated CSS rule set containing the applied styling.\n     */\n    provide(theme: Theme): StypRules;\n\n  }\n\n  /**\n   * A function obtaining combined style provider. I.e. the one that applies the style along with all extensions.\n   *\n   * @param A  provider of theme style to apply.\n   *\n   * @returns A combined theme style provider.\n   */\n  export type ById = (this: void, style: ThemeStyle.Provider) => ThemeStyle.Provider;\n\n}\n\n/**\n * @internal\n */\nclass ThemeStyleKey extends IterativeContextKey<ThemeStyle.ById, ThemeStyle> {\n\n  constructor() {\n    super('theme-style');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, ThemeStyle.ById, ThemeStyle, Iterable<ThemeStyle>>,\n  ): ThemeStyle.ById | null | undefined {\n\n    const providers = new Map<ThemeStyle.Provider, [ThemeStyle.Provider, boolean]>();\n\n    for (const style of opts.seed) {\n\n      let key: ThemeStyle.Provider;\n      let provider: ThemeStyle.Provider;\n      let isId: boolean;\n\n      if (typeof style === 'function') {\n        key = provider = style;\n        isId = true;\n      } else {\n        key = style.style;\n        provider = style.provide.bind(style);\n        isId = false;\n      }\n\n      const prev = providers.get(key);\n\n      if (!prev) {\n        providers.set(key, [provider, isId]);\n      } else {\n\n        const [prevProvider, hasId] = prev;\n\n        providers.set(\n            key,\n            [\n              isId ? combineStyles(provider, prevProvider) : combineStyles(prevProvider, provider),\n              isId || hasId,\n            ],\n        );\n      }\n    }\n\n    return providers.size ? byId : opts.byDefault(() => byId);\n\n    function byId(id: ThemeStyle.Provider): ThemeStyle.Provider {\n\n      const existing = providers.get(id);\n\n      if (!existing) {\n        return id;\n      }\n\n      const [provider, hasId] = existing;\n\n      return hasId ? provider : combineStyles(id, provider);\n    }\n  }\n\n}\n\n/**\n * A key of bootstrap context value containing theme styles.\n */\nexport const ThemeStyle: ContextRef<ThemeStyle.ById, ThemeStyle> = new ThemeStyleKey();\n\n/**\n * @internal\n */\nfunction combineStyles(first: ThemeStyle.Provider, second: ThemeStyle.Provider): ThemeStyle.Provider {\n  return theme => stypRules(first(theme), second(theme));\n}\n","import { lazyStypRules, stypRoot, StypRule, StypRules } from '@proc7ts/style-producer';\nimport { Theme as Theme_ } from './theme';\nimport { ThemeStyle } from './theme-style';\n\n/**\n * @internal\n */\nexport class Theme extends Theme_ {\n\n  readonly root: StypRule = stypRoot();\n  private readonly _rules = new Map<ThemeStyle.Provider, StypRules>();\n\n  constructor(private readonly _styles: ThemeStyle.ById) {\n    super();\n  }\n\n  style(...styles: ThemeStyle.Provider[]): StypRules {\n\n    const theme = this;\n\n    return lazyStypRules(...styles.reduce<StypRules[]>(addStyleRules, []));\n\n    function addStyleRules(target: StypRules[], style: ThemeStyle.Provider): StypRules[] {\n\n      const existing = theme._rules.get(style);\n\n      if (existing) {\n        target.push(existing);\n      } else {\n\n        const constructed = theme._styles(style)(theme);\n\n        theme._rules.set(style, constructed);\n        target.push(constructed);\n      }\n\n      return target;\n    }\n  }\n\n}\n","import { ThemeFactory as ThemeFactory_ } from './theme-factory';\nimport { ThemeStyle } from './theme-style';\nimport { Theme } from './theme.impl';\n\n/**\n * @internal\n */\nexport class ThemeFactory extends ThemeFactory_ {\n\n  constructor(private readonly _styles: ThemeStyle.ById) {\n    super();\n  }\n\n  newTheme(): Theme {\n    return new Theme(this._styles);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { BasicStyleProducerSupport } from '../styp';\nimport { Theme } from './theme';\nimport { ThemeFactory } from './theme-factory';\nimport { ThemeFactory as ThemeFactory_ } from './theme-factory.impl';\nimport { ThemeStyle } from './theme-style';\n\n/**\n * @internal\n */\nconst ThemeSupport__feature: FeatureDef = {\n  needs: BasicStyleProducerSupport,\n  setup(setup) {\n    setup.provide({ a: ThemeFactory, as: ThemeFactory_, with: [ThemeStyle] });\n    setup.provide({\n      a: Theme,\n      by(factory: ThemeFactory) {\n        return factory.newTheme();\n      },\n      with: [ThemeFactory],\n    });\n  },\n};\n\n/**\n * Theme support feature.\n *\n * This needs to be enabled in order [[Theme]] and [[ThemeFactory]] to be available.\n */\nexport class ThemeSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ThemeSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/delta-set\n */\n/**\n * A `Set` implementation that keeps a delta of changes made to it.\n *\n * @typeparam T  A type of elements of delta set.\n */\nexport class DeltaSet<T> extends Set<T> {\n\n  /** @internal */\n  private readonly _added: Set<T>;\n\n  /** @internal */\n  private readonly _removed: Set<T>;\n\n  /**\n   * Constructs new delta set.\n   *\n   * @param values  An iterable of elements be add to constructed delta set. Or `null` to add nothing.\n   */\n  constructor(values?: Iterable<T> | null) {\n    super();\n    this._added = new Set<T>(values);\n    this._removed = new Set<T>();\n    this._added.forEach(value => this.add(value));\n  }\n\n  /**\n   * Appends a new element with a specified value to the end of this delta set. Unless the set contains this element\n   * already.\n   *\n   * Records element addition and forgets its removal unless the set contains it already.\n   *\n   * @param value  The value of the element to add.\n   *\n   * @returns `this` delta set.\n   */\n  add(value: T): this {\n    if (!this.has(value)) {\n      this._added.add(value);\n      this._removed.delete(value);\n      super.add(value);\n    }\n    return this;\n  }\n\n  /**\n   * Removes the specified element from this delta set.\n   *\n   * Records element removal and forgets its addition if removal succeed.\n   *\n   * @param value  The value of the element to remove.\n   *\n   * @returns `true` if element removed successfully; or `false` if this set did not contain the element.\n   */\n  delete(value: T): boolean {\n    if (super.delete(value)) {\n      this._added.delete(value);\n      this._removed.add(value);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all elements from this delta set.\n   *\n   * Records all elements removal and forgets all elements additions.\n   */\n  clear(): void {\n    this._added.clear();\n    this.forEach(value => this._removed.add(value));\n    super.clear();\n  }\n\n  /**\n   * Applies changes to this delta set.\n   *\n   * First removes elements to `remove`. Then appends elements to `add`.\n   *\n   * Records all changes made.\n   *\n   * @param add  An iterable of elements to add.\n   * @param remove  An iterable of elements to remove.\n   *\n   * @returns `this` delta set.\n   */\n  delta(add: Iterable<T>, remove: Iterable<T> = []): this {\n    deltaSetDeltaReceiver(this)(add, remove);\n    return this;\n  }\n\n  /**\n   * Replays changes made to this set in target receiver.\n   *\n   * @param receiver  A receiver of changes delta. E.g. another `Set`.\n   *\n   * @returns `this` delta set.\n   */\n  redelta(receiver: DeltaSet.DeltaReceiver<T>): this {\n\n    const receive = typeof receiver === 'function' ? receiver : deltaSetDeltaReceiver(receiver);\n\n    receive(Array.from(this._added), Array.from(this._removed));\n\n    return this;\n  }\n\n  /**\n   * Forgets all changes made to this set.\n   *\n   * Does not alter the set contents.\n   *\n   * @returns `this` delta set.\n   */\n  undelta(): this {\n    this._added.clear();\n    this._removed.clear();\n    return this;\n  }\n\n}\n\nexport namespace DeltaSet {\n\n  /**\n   * A delta set changes receiver.\n   *\n   * This can be either an {@link DeltaReceiverObject object}, or a {@link DeltaReceiverFunction function}.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export type DeltaReceiver<T> =\n      | DeltaReceiverFunction<T>\n      | DeltaReceiverObject<T>;\n\n  /**\n   * A delta set changes receiver function.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export type DeltaReceiverFunction<T> =\n  /**\n   * @param added  An array of added elements.\n   * @param removed  An array of removed elements.\n   */\n      (this: void, added: T[], remove: T[]) => void;\n\n  /**\n   * A delta set changes receiver object.\n   *\n   * A `Set` class implements this interface.\n   *\n   * @typeparam T  A type of elements of delta set.\n   */\n  export interface DeltaReceiverObject<T> {\n\n    /**\n     * Receives an element that has been added to delta set.\n     *\n     * @param value  The value of the added element.\n     */\n    add(value: T): void;\n\n    /**\n     * Receives an element that has been remove from delta set.\n     *\n     * @param value  The value of the removed element.\n     */\n    delete(value: T): void;\n\n  }\n\n}\n\n/**\n * @internal\n */\nfunction deltaSetDeltaReceiver<T>(\n    receiver: DeltaSet.DeltaReceiverObject<T>,\n): (this: void, add: Iterable<T>, remove: Iterable<T>) => void {\n  return (add, remove) => {\n    for (const removed of remove) {\n      receiver.delete(removed);\n    }\n    for (const added of add) {\n      receiver.add(added);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeparam Instance  Aspect instance type.\n * @typeparam Kind  Aspect application kind.\n */\nexport interface InAspect<Instance, Kind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeparam Value  Input value type.\n   * @param control  Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, Instance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   */\n  export interface Key<Instance, Kind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<Instance, Kind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeparam Value  Input value type.\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam ConvertedInstance  A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<Value, Instance, ConvertedInstance extends Instance = Instance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: Instance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by [[InControl.convert]] method.\n     *\n     * @typeparam To  Converted input value type.\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<To>(target: InControl<To>): Applied<To, ConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of [[convertTo]] when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target  Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<Value>): Applied<Value, Instance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Result<OfInstance, OfValue, OfKind extends Kind> =\n        Applied<OfValue, Instance<OfInstance, OfValue, OfKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     * @typeparam OfKind  Aspect application kind.\n     */\n    export type Instance<OfInstance, OfValue, OfKind extends Kind> =\n        ReturnType<Map<OfInstance, OfValue>[OfKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeparam OfInstance  Aspect instance type.\n     * @typeparam OfValue  Input value type.\n     */\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): OfInstance;\n\n    }\n\n  }\n\n}\n","import { noop, valueProvider } from '@proc7ts/call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nexport const inAspectNull: InAspect.Applied<any, any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * @internal\n */\nexport function inAspectSameOrBuild<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance, Kind>,\n    build: <V>(this: void, control: InControl<V>, origin?: InControl<any>) => Instance,\n    instance?: Instance,\n    origin?: InControl<any>,\n): InAspect.Applied<Value, Instance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n  return {\n    instance,\n    convertTo<To>(target: InControl<To>): InAspect.Applied<To, Instance> {\n      return inAspectSameOrBuild<To, Instance, Kind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<Value>): InAspect.Applied<Value, Instance> | undefined {\n      return inAspectSameOrBuild(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as Instance | undefined) || build(target),\n      );\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function inAspectSameOrNull<Value, Instance, Kind extends InAspect.Application.Kind>(\n    control: InControl<Value>,\n    aspectKey: InAspect.Key<Instance | null, Kind>,\n    instance: Instance | null = null,\n): InAspect.Applied<Value, Instance | null> {\n  return inAspectSameOrBuild(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * @internal\n */\nexport function inAspectValue<Instance>(instance: Instance): InAspect.Applied<any, Instance> {\n  return {\n    instance,\n    convertTo() {\n      return this;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from '@proc7ts/namespace-aliaser';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * [[InNamespaceAliaser.to]] converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return inAspectValue(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @param nsAlias  Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? inAspectValue(nsAlias) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { newRenderSchedule, RenderScheduler } from '@proc7ts/render-scheduler';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by [[InRenderScheduler.to]] converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return inAspectValue(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @param scheduler  Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(scheduler: InRenderScheduler): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? inAspectValue(scheduler) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { filterIt, flatMapIt, itsReduction, mapIt } from '@proc7ts/a-iterable';\nimport { isPresent, noop, valueProvider } from '@proc7ts/call-thru';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n */\nexport type InConverter<From, To> =\n    | InConverter.Conversion<From, To>\n    | InConverter.Factory<From, To>;\n\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<From, To>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Conversion<From, To> =\n      | InConverter.Value.Conversion<From, To>\n      | InConverter.Aspect.Conversion<To>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Value<From, To> =\n      | InConverter.Value.Factory<From, To>\n      | InConverter.Value.Conversion<From, To>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Aspect<From, To = From> =\n      | InConverter.Aspect.Conversion<To>\n      | InConverter.Aspect.Factory<From, To>;\n\n}\n\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To> =\n  /**\n   * @param from  Original input control.\n   * @param to  Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<From>,\n          to: InControl<To>,\n      ) => Conversion<From, To>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export interface Conversion<From, To> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value  Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: From): To;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value  A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: To): From;\n\n  }\n\n}\n\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by [[InControl.convert]] to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeparam From  Original input value type.\n   * @typeparam To  Converted input value type.\n   */\n  export type Factory<From, To = From> = (\n      this: void,\n      from: InControl<From>,\n      to: InControl<To>,\n  ) => Conversion<To>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Conversion<Value> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeparam Instance  Aspect instance type.\n     * @typeparam Kind  Aspect application kind.\n     * @param aspect  An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ): InAspect.Application.Result<Instance, Value, Kind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeparam Value  Input value type.\n * @param converters  Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<Value>(\n    ...converters: InConverter.Aspect<Value, Value>[]\n): InConverter.Aspect.Factory<Value, Value>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter: InConverter.Value<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Value.Factory<From, To>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeparam From  Original input value type.\n * @typeparam To  Converted input value type.\n * @param converter  Input control converter.\n * @param converters  Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<From, To>(\n    converter?: InConverter<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To>;\n\nexport function intoConvertedBy<From, To>(\n    valueOrAspectConverter?: InConverter<From, To> | InConverter.Aspect<From, To>,\n    ...converters: InConverter.Aspect<From, To>[]\n): InConverter.Factory<From, To> {\n\n  type AspectApplicator = <Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = mapIt<InConverter.Aspect<From, To>, InConverter.Aspect.Factory<From, To>>(\n      converters,\n      inConverter,\n  );\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<From, To> => {\n\n    const conversion = converter(from, to);\n    const conversions = flatMapIt<InConverter.Conversion<From, To>>([\n        [conversion],\n        filterIt<InConverter.Aspect.Conversion<To> | undefined, InConverter.Aspect.Conversion<To>>(\n            mapIt(\n                aspectConverters,\n                acf => acf(from, to),\n            ),\n            isPresent,\n        ),\n    ]);\n\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev: AspectApplicator, cv: InConverter.Conversion<From, To>) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeparam Value  Input value type.\n * @param aspects  Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<Value>(\n    aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[],\n): InConverter.Aspect.Factory<Value> {\n  return aspects\n      ? ((/*#__INLINE__*/ isArray(aspects)) ? intoConvertedBy(...aspects) : intoConvertedBy(aspects))\n      : intoConvertedBy<Value>();\n}\n\nfunction isArray<T>(value: T | readonly T[] | undefined): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nconst noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nfunction noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion  Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<From, To>(\n    conversion: InConverter.Conversion<From, To>,\n): conversion is InConverter.Aspect.Conversion<To> {\n  return !(conversion as any).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Value<From, To>,\n): InConverter.Value.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter.Aspect<From, To>,\n): InConverter.Aspect.Factory<From, To>;\n\n/**\n * @internal\n */\nfunction inConverter<From, To>(\n    converter: InConverter<From, To>,\n): InConverter.Factory<From, To>;\n\nfunction inConverter<From, To>(\n    converter: InConverter<From, To> | InConverter.Aspect<From, To>,\n): InConverter.Factory<From, To> | InConverter.Aspect.Factory<From, To> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { asis, noop } from '@proc7ts/call-thru';\nimport {\n  EventEmitter,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InConverter, intoConvertedBy, isInAspectConversion } from './converter';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InControl<Value> extends ValueTracker<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspects = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  /**\n   * Input value.\n   */\n  abstract it: Value;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get [EventSupply__symbol](): EventSupply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n  ): InAspect.Application.Instance<Instance, Value, Kind> {\n    return this._aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup  A function that accepts this control as its only parameter to configure it.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param aspectKey  A key of aspect to set up.\n   * @param setup  A function that accepts the aspect and this control as parameters to configure them.\n   *\n   * @returns `this` control instance.\n   */\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<Instance, Kind>,\n      setup?: (this: void, aspect: InAspect.Application.Instance<Instance, Value, Kind>, control: this) => void,\n  ): this;\n\n  setup<Instance, Kind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<Instance, Kind> | ((this: void, control: this) => void),\n      aspectSetup: (\n          this: void,\n          aspect: InAspect.Application.Instance<Instance, Value, Kind>,\n          control: this,\n      ) => void = noop,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<Value, Value>[]\n  ): InControl<Value>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeparam To  Converted input value type.\n   * @param by  Input control converter.\n   * @param and  Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<To>(\n      by: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<To>;\n\n  convert<To>(\n      by?: InConverter<Value, To>,\n      ...and: InConverter.Aspect<Value, To>[]\n  ): InControl<Value> | InControl<To> {\n    return new InConverted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * @internal\n   */\n  _aspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> {\n\n    const existing = this._aspects.get(aspect);\n\n    if (existing) {\n      return existing as InAspect.Application.Result<Instance, Value, Kind>;\n    }\n\n    const applied = this._applyAspect(aspect) || aspect.applyTo(this);\n\n    this._aspects.set(aspect, applied);\n\n    return applied as InAspect.Application.Result<Instance, Value, Kind>;\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeparam Instance  Aspect instance type.\n   * @typeparam Kind  Aspect application kind.\n   * @param _aspect  An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      _aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isAspectKey<Instance, Kind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<Instance, Kind> {\n  return InAspect__symbol in value;\n}\n\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeparam Control  Input control type.\n   */\n  export type ValueType<Control extends InControl<any>> = Control extends InControl<infer Value> ? Value : never;\n\n}\n\n/**\n * @internal\n */\nclass InConverted<From, To> extends InControl<To> {\n\n  private readonly _supply: EventSupply;\n  private readonly _on = new EventEmitter<[To, To]>();\n  private readonly _it: ValueTracker<[To, number]>;\n  protected readonly _applyAspect: <Instance, Kind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<Instance, Kind>,\n  ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n  constructor(src: InControl<From>, by: InConverter.Factory<From, To>) {\n    super();\n    this._supply = eventSupply().needs(src);\n\n    let lastRev = 0;\n    let backward: From | undefined;\n\n    const conversion = by(src, this);\n    let set: (value: From) => To;\n    let get: (value: To) => From;\n    let convertAspect: <Instance, Kind extends InAspect.Application.Kind>(\n        aspect: InAspect<Instance, Kind>,\n    ) => InAspect.Application.Result<Instance, To, Kind> | undefined;\n\n    if (isInAspectConversion(conversion)) {\n      set = asis as (value: From) => To;\n      get = asis as (value: To) => From;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <Instance, Kind extends InAspect.Application.Kind>(aspect: InAspect<Instance, Kind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src._aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    eventSupplyOf(this._it).needs(this._supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        this._on.send(newValue, oldValue);\n      }\n    }).cuts(this._on);\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).cuts(this);\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply;\n  }\n\n  get it(): To {\n    return this._it.it[0];\n  }\n\n  set it(value: To) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  on(): OnEvent<[To, To]>;\n  on(receiver: EventReceiver<[To, To]>): EventSupply;\n  on(receiver?: EventReceiver<[To, To]>): OnEvent<[To, To]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { EventReceiver, EventSupply, eventSupply, EventSupply__symbol, OnEvent } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\n\n/**\n * @internal\n */\nclass InSameValueControl<Value> extends InControl<Value> {\n\n  private _supply?: EventSupply;\n\n  constructor(private readonly _control: InControl<Value>) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return this._supply || (this._supply = eventSupply().needs(this._control));\n  }\n\n  get it(): Value {\n    return this._control.it;\n  }\n\n  set it(value: Value) {\n    this._control.it = value;\n  }\n\n  on(): OnEvent<[Value, Value]>;\n  on(receiver: EventReceiver<[Value, Value]>): EventSupply;\n  on(receiver?: EventReceiver<[Value, Value]>): OnEvent<[Value, Value]> | EventSupply {\n    return (this.on = this._control.on().F)(receiver);\n  }\n\n}\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @param control  Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<Value>(control: InControl<Value>): InControl<Value> {\n  return new InSameValueControl(control);\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InAspect } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter, intoConvertedAspects } from '../converter';\nimport { inValueOf } from './value-of.control';\n\n/**\n * Abstract input control implementation.\n *\n * Allows to define default input aspects.\n *\n * @category Control\n */\nexport abstract class AbstractInControl<Value> extends InControl<Value> {\n\n  /**\n   * @internal\n   */\n  private readonly _aspectConversion: InConverter.Aspect.Conversion<Value>;\n\n  /**\n   * Constructs input control.\n   *\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   */\n  protected constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n      },\n  ) {\n    super();\n    this._aspectConversion = intoConvertedAspects(aspects)(inValueOf(this), this);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return this._aspectConversion.applyAspect(aspect) || super._applyAspect(aspect);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { AbstractInControl } from '../controls';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n */\nexport abstract class InContainer<Value> extends AbstractInControl<Value> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inAspectSameOrNull(this, InContainer, this) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   *\n   * @typeparam L  Input container layout interface.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * Builds an `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Container updates sender.\n   */\n  abstract on(): OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  /**\n   * Starts sending container updates to the given receiver.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * @param receiver  Target container updates receiver.\n   *\n   * @returns Container updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InContainer.Entry[], InContainer.Entry[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Container contents snapshot keeper.\n   */\n  abstract read(): AfterEvent<[InContainer.Snapshot]>;\n\n  /**\n   * Starts sending container contents and updates to the given `receiver`\n   *\n   * @param receiver  Target receiver of container snapshot updates.\n   *\n   * @returns Container contents supply.\n   */\n  abstract read(receiver: EventReceiver<[InContainer.Snapshot]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read();\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectValue } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return inAspectValue(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of parent updates.\n   */\n  abstract on(): OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  /**\n   * Starts sending parent updates to the given `receiver`.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * @param receiver  Target parent updates receiver.\n   *\n   * @returns Parent updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InParents.Entry[], InParents.Entry[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of control parents.\n   */\n  abstract read(): AfterEvent<[InParents.All]>;\n\n  /**\n   * Starts sending control parents and updates to the given `receiver`\n   *\n   * @param receiver  Target control parents receiver.\n   *\n   * @returns Control parents supply.\n   */\n  abstract read(receiver: EventReceiver<[InParents.All]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read();\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry  Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): EventSupply;\n\n}\n\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  private readonly _map = new Map<InParents.Entry, EventSupply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    eventSupplyOf(this._on).needs(this._control);\n  }\n\n  add(entry: InParents.Entry): EventSupply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = eventSupply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n  on(): OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n  on(receiver: EventReceiver<[InParents.Entry[], InParents.Entry[]]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[InParents.Entry[], InParents.Entry[]]>,\n  ): OnEvent<[InParents.Entry[], InParents.Entry[]]> | EventSupply {\n    return (this.on = this._on.on().F)(receiver);\n  }\n\n  read(): AfterEvent<[InParents.All]>;\n  read(receiver: EventReceiver<[InParents.All]>): EventSupply;\n  read(receiver?: EventReceiver<[InParents.All]>): AfterEvent<[InParents.All]> | EventSupply {\n\n    const allParents = (): IterableIterator<InParents.Entry> => this._map.keys();\n\n    return (this.read = afterSent<[InParents.All]>(\n        this.on().thru(allParents),\n        () => [allParents()],\n    ).F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { AfterEvent, EventReceiver, EventSupply } from '@proc7ts/fun-events';\nimport { DomEventDispatcher } from '@proc7ts/fun-events/dom';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { inAspectSameOrNull } from './aspect.impl';\nimport { AbstractInControl } from './controls';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport abstract class InElement<Value, Elt = HTMLElement> extends AbstractInControl<Value> {\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: Elt;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of user input.\n   *\n   * @returns `AfterEvent` keeper of user input.\n   */\n  abstract input(): AfterEvent<[InElement.Input<Value>]>;\n\n  /**\n   * Starts sending user input and updates to the given `receiver`.\n   *\n   * @param receiver  Target user input receiver.\n   *\n   * @returns User input supply.\n   */\n  abstract input(receiver: EventReceiver<[InElement.Input<Value>]>): EventSupply;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<Instance, Kind>,\n  ): InAspect.Application.Result<Instance, Value, Kind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inAspectSameOrNull(\n            this,\n            InElement,\n            this as InElement<Value, any>,\n        ) as InAspect.Application.Result<Instance, Value, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Input<Value> {\n\n    /**\n     * The value user entered.\n     */\n    value: Value;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<OfValue> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { flatMapIt } from '@proc7ts/a-iterable';\nimport { nextArgs, NextCall, nextSkip, valuesProvider } from '@proc7ts/call-thru';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InMode> {\n    return inAspectSameOrBuild(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * Creates an `OnEvent` sender of input mode updates.\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of input mode updates.\n   */\n  abstract on(): OnEvent<[InMode.Value, InMode.Value]>;\n\n  /**\n   * Starts sending input mode updates to the given `receiver`\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * @param receiver  Target input mode updates receiver.\n   *\n   * @returns Input mode updates supply.\n   */\n  abstract on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of input mode.\n   */\n  abstract read(): AfterEvent<[InMode.Value]>;\n\n  /**\n   * Starts sending input mode and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of input mode.\n   *\n   * @returns Input mode supply.\n   */\n  abstract read(receiver: EventReceiver<[InMode.Value]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read();\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode  Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source  A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): EventSupply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason  Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.done(reason);\n    return this;\n  }\n\n}\n\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._tracker);\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n    case 'off':\n    case 'ro':\n    case '-on':\n    case '-ro':\n      break;\n    default:\n      value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  on(): OnEvent<[InMode.Value, InMode.Value]>;\n  on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n  on(receiver?: EventReceiver<[InMode.Value, InMode.Value]>): OnEvent<[InMode.Value, InMode.Value]> | EventSupply {\n    return (this.on = this._tracker.on().F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterSent(\n        this._on.on().thru(() => this._all),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.keepThru(\n        (set: Set<AfterEvent<[InMode.Value]>>) => nextAfterEvent(afterEach(...set)),\n        mergeInModes,\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): EventSupply {\n\n    const supply = eventSupply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    eventSupplyOf(this.own).needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read().keepThru_(parentsInMode));\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n  }\n\n  read(): AfterEvent<[InMode.Value]>;\n  read(receiver: EventReceiver<[InMode.Value]>): EventSupply;\n  read(receiver?: EventReceiver<[InMode.Value]>): AfterEvent<[InMode.Value]> | EventSupply {\n\n    let last: InMode.Value = 'on';\n\n    return (this.read = afterSent<[InMode.Value]>(\n            afterAll({\n              derived: this._derived.read,\n              own: this.own,\n            }).thru(\n                ({\n                  derived: [derived],\n                  own: [own],\n                }) => {\n\n                  let next: InMode.Value;\n\n                  if (own === 'off' || derived === 'off') {\n                    next = 'off';\n                  } else {\n\n                    let off = false;\n\n                    if (own[0] === '-') {\n                      off = true;\n                      own = own.substring(1) as InMode.Value;\n                    }\n                    if (derived[0] === '-') {\n                      off = true;\n                      derived = derived.substring(1) as InMode.Value;\n                    }\n                    next = derived === 'ro' ? 'ro' : own;\n                    if (off) {\n                      next = '-' + next as InMode.Value;\n                    }\n                  }\n\n                  return last === next ? nextSkip() : nextArgs(last = next);\n                },\n            ),\n            valuesProvider<[InMode.Value]>(last),\n        ).F\n    )(receiver);\n  }\n\n  on(): OnEvent<[InMode.Value, InMode.Value]>;\n  on(receiver: EventReceiver<[InMode.Value, InMode.Value]>): EventSupply;\n  on(receiver?: EventReceiver<[InMode.Value, InMode.Value]>): OnEvent<[InMode.Value, InMode.Value]> | EventSupply {\n    let lastUpdate: InMode.Value = 'on';\n\n    return (this.on = this.read().thru(value => {\n\n      const old = lastUpdate;\n\n      return old === value ? nextSkip() : nextArgs(lastUpdate = value, old);\n    }).F)(receiver);\n  }\n\n  derive(source: InMode.Source): EventSupply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control))\n            .tillOff(this._control),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off' : (\n          element.getAttribute('readonly') != null ? 'ro' : 'on'\n      );\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n  case 'off':\n    element.setAttribute('disabled', '');\n    break;\n  case 'ro':\n  case '-ro':\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    element.setAttribute('readonly', '');\n    break;\n  default:\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('readonly', '');\n    element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): NextCall<OnEventCallChain, [InMode.Value]> {\n\n  const parentList = Array.from(parents);\n\n  if (!parentList.length) {\n    return nextArgs('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return nextAfterEvent(afterEach(...parentModes).keepThru_(mergeInModes));\n}\n\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...flatMapIt<InMode.Value>(modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes  Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n    case 'off':\n      return 'off';\n    case 'ro':\n      ro = true;\n      break;\n    case '-on':\n      off = true;\n      break;\n    case '-ro':\n      off = true;\n      ro = true;\n      break;\n    case 'on':\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport { afterAll, AfterEvent } from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport type InData<Value> = AfterEvent<[InData.DataType<Value>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return inAspectSameOrBuild(control, InData, <V>(ctrl: InControl<V>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).keepThru(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? nextArgs(value as any)\n            : nextArgs(),\n    ));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<Value>(control: InControl<Value>): Applied<Value>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<Value> extends InAspect.Applied<Value, InData<Value>, InData<any>> {\n\n  convertTo<To>(target: InControl<To>): Applied<To> | undefined;\n\n}\n\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeparam Value  Input value type.\n   */\n  export type DataType<Value> =\n      | (Value extends object ? { [K in keyof Value]?: DataType<Value[K]> } : Value)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { itsEach, itsIterable, mapIt, overEntries } from '@proc7ts/a-iterable';\nimport { nextArg, nextArgs, NextCall, noop } from '@proc7ts/call-thru';\nimport {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  EventEmitter,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  nextAfterEvent,\n  noEventSupply,\n  OnEvent,\n  OnEvent__symbol,\n  OnEventCallChain,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrNull } from '../aspect.impl';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inAspectSameOrNull(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroup<Model extends object> extends InContainer<Model> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<Model>;\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    return aspect === InGroup__aspect\n        ? inAspectSameOrNull(this, InGroup, this) as InAspect.Application.Result<Instance, Model, Kind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Controls<Model> = {\n    readonly [K in keyof Model]?: InControl<Model[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export type Entry<Model, K extends keyof Model = any> = readonly [K, InControl<Model[K]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeparam Model  Group model type, i.e. its value type.\n   */\n  export interface Snapshot<Model> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<Model>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key  Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<Model>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>, EventKeeper<[InGroup.Snapshot<Model>]> {\n\n  abstract on(): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  abstract on(receiver: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>): EventSupply;\n\n  abstract read(): AfterEvent<[InGroup.Snapshot<Model>]>;\n  abstract read(receiver: EventReceiver<[InGroup.Snapshot<Model>]>): EventSupply;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @param key  A key of input control to set. I.e. corresponding model property key.\n   * @param control  Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<K extends keyof Model>(key: K, control: InControl<Model[K]> | undefined): EventSupply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls  A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<Model>): EventSupply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key  A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof Model): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<Model> {\n\n  [OnEvent__symbol](): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InGroup.Snapshot<Model>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, EventSupply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<Model> implements InGroup.Snapshot<Model> {\n\n  constructor(private readonly _map: Map<keyof Model, InGroupEntry>) {\n  }\n\n  get<K extends keyof Model>(key: K): InGroup.Controls<Model>[K] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<Model>[K];\n  }\n\n  [Symbol.iterator](): IterableIterator<InControl<any>> {\n    return itsIterable(mapIt(this._map.values(), ([control]) => control));\n  }\n\n  entries(): IterableIterator<InGroup.Entry<Model>> {\n    return itsIterable(mapIt(this._map.entries(), ([key, [control]]) => [key, control]));\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<Model extends object> {\n\n  readonly _supply = eventSupply();\n  private _map = new Map<keyof Model, InGroupEntry>();\n  private _shot?: InGroupSnapshot<Model>;\n\n  constructor(private readonly _controls: InGroupControlControls<Model>) {\n  }\n\n  set<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]> | undefined,\n      added: [keyof Model, InGroupEntry][],\n      removed: [keyof Model, InGroupEntry][],\n  ): EventSupply {\n\n    const replaced = this._map.get(key);\n    let supply: EventSupply;\n\n    if (control) {\n      supply = eventSupply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = noEventSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<K extends keyof Model>(\n      key: K,\n      control: InControl<Model[K]>,\n      supply: EventSupply,\n  ): InGroupEntry {\n    return [\n      control,\n      eventSupply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof Model, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof Model, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<Model> {\n    return this._shot || (this._shot = new InGroupSnapshot<Model>(this._map));\n  }\n\n  clear(): [keyof Model, InGroupEntry][] {\n\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<Model extends object> extends InGroupControls<Model> {\n\n  private readonly _map: InGroupMap<Model>;\n  private readonly _updates = new EventEmitter<[[keyof Model, InGroupEntry][], [keyof Model, InGroupEntry][]]>();\n\n  constructor(private readonly _group: InGroupControl<Model>) {\n    super();\n\n    const applyModelToControls = (model: Model): void => {\n      this.read().once(snapshot => {\n\n        const withValues = new Set<keyof Model>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    };\n\n    this._map = new InGroupMap<Model>(this);\n    this._map._supply.needs(_group.read(applyModelToControls));\n  }\n\n  on(): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>;\n  on(receiver: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]>,\n  ): OnEvent<[InGroup.Entry<Model>[], InGroup.Entry<Model>[]]> | EventSupply {\n    return (this.on = this._updates.on().thru(\n        (added, removed) => nextArgs(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    ).F)(receiver);\n  }\n\n  read(): AfterEvent<[InGroup.Snapshot<Model>]>;\n  read(receiver: EventReceiver<[InGroup.Snapshot<Model>]>): EventSupply;\n  read(receiver?: EventReceiver<[InGroup.Snapshot<Model>]>): AfterEvent<[InGroup.Snapshot<Model>]> | EventSupply {\n    return (this.read = afterSent<[InGroup.Snapshot<Model>]>(\n        this._updates.on().thru(\n            () => this._map.snapshot(),\n        ),\n        () => [this._map.snapshot()],\n    ).F)(receiver);\n  }\n\n  set<K extends keyof Model>(\n      keyOrControls: K | InGroup.Controls<Model>,\n      newControl?: InControl<Model[K]> | undefined,\n  ): EventSupply {\n\n    const group = this._group;\n    const added: [keyof Model, InGroupEntry][] = [];\n    const removed: [keyof Model, InGroupEntry][] = [];\n    let supply: EventSupply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = eventSupply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: Model | undefined;\n\n      added.forEach(([key, [control, supply]]) => {\n        control.aspect(InParents)\n            .add({ parent: group })\n            .needs(supply)\n            .cuts(supply);\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(([key, [control, supply]]) => {\n        control.read().tillOff(supply).to(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).cuts(supply);\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<Model extends object>(\n    [key, [control]]: [keyof Model, InGroupEntry],\n): InGroup.Entry<Model> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<Model extends object> extends InGroup<Model> {\n\n  private readonly _model: ValueTracker<Model>;\n  readonly controls: InGroupControlControls<Model>;\n\n  constructor(\n      model: Model,\n      opts: {\n        readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    eventSupplyOf(this).whenOff(() => this.controls.clear());\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._model);\n  }\n\n  get it(): Model {\n    return this._model.it;\n  }\n\n  set it(value: Model) {\n    this._model.it = value;\n  }\n\n  on(): OnEvent<[Model, Model]>;\n  on(receiver: EventReceiver<[Model, Model]>): EventSupply;\n  on(receiver?: EventReceiver<[Model, Model]>): OnEvent<[Model, Model]> | EventSupply {\n    return (this.on = this._model.on().F)(receiver);\n  }\n\n  protected _applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<Instance, Model, Kind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<Model extends object>(group: InGroup<Model>): InData<Model> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).keepThru_(\n      readInGroupData,\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<Model extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<Model>];\n      model: [Model];\n      mode: [InMode.Value];\n    },\n): NextCall<OnEventCallChain, [InData.DataType<Model>?]> {\n  if (!InMode.hasData(mode)) {\n    return nextArgs();\n  }\n\n  const csData: { [key in keyof Model]: InData<any> } = {} as any;\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof Model] = control.aspect(InData);\n  });\n\n  return nextAfterEvent(afterAll(csData).keepThru(controlsData => {\n\n    const data: Partial<Model> = { ...model };\n\n    itsEach(overEntries(controlsData), ([key, [controlData]]) => {\n      data[key] = controlData;\n    });\n\n    return nextArg(data as InData.DataType<Model>);\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeparam Model  Group model type, i.e. its value type.\n * @param model  Initial model of the group.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<Model extends object>(\n    model: Model,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<Model> | readonly InConverter.Aspect<Model>[];\n    } = {},\n): InGroup<Model> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<OfValue extends object ? OfValue : never> | null;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { AfterEvent, afterThe } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nconst _requireNothing = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return _requireNothing;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { CallChain, nextArgs, NextCall, valueProvider } from '@proc7ts/call-thru';\nimport { AfterEvent, afterSupplied, EventKeeper, isEventKeeper } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n */\nexport type InValidator<Value> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<Value>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<Value>;\n\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeparam Value  Input value type.\n   */\n  export interface Simple<Value> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control  Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<Value>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeparam Value  Input value type.\n * @param validator  Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<Value>(\n    validator: InValidator<Value>,\n): (this: void, control: InControl<Value>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n  return control => control.read().keepThru(simpleInValidator(control, validator));\n}\n\n/**\n * @internal\n */\nfunction simpleInValidator<Value>(\n    control: InControl<Value>,\n    validator: InValidator.Simple<Value>,\n): (value: Value) => NextCall<CallChain, InValidation.Message[]> {\n  return () => {\n\n    const messages = validator.validate(control);\n\n    return messages == null\n        ? nextArgs()\n        : Array.isArray(messages)\n            ? nextArgs(...messages)\n            : nextArgs(messages);\n  };\n}\n","import { flatMapIt, itsEach } from '@proc7ts/a-iterable';\nimport { asis, noop, valuesProvider } from '@proc7ts/call-thru';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  EventSupply,\n  eventSupply,\n} from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<Value> implements EventKeeper<InValidation.Message[]> {\n\n  readonly _messages: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<Value>) => EventSupply;\n\n  constructor(control: InControl<Value>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, EventSupply>();\n    const validatorMessages = new Map<InValidator<Value>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => void = noop;\n\n    this._messages = afterEventBy(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider()).to(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: EventSupply) => {\n\n        const supply = validator.to(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).share().tillOff(control);\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = eventSupply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values(), asis);\n    }\n  }\n\n  [AfterEvent__symbol](): AfterEvent<InValidation.Message[]> {\n    return this._messages;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { flatMapIt, itsEach, mapIt, overEntries } from '@proc7ts/a-iterable';\nimport { nextArgs, NextCall } from '@proc7ts/call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  nextAfterEvent,\n  OnEventCallChain,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { inAspectSameOrBuild } from '../aspect.impl';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<Value>(control: InControl<Value>) {\n    return inAspectSameOrBuild<Value, InValidation<Value>, 'validation'>(\n        control,\n        InValidation,\n        <V>(ctrl: InControl<V>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<V>(ctrl);\n\n          if (origin) {\n\n            const from = origin.aspect(InValidation);\n\n            validation.by(from.read().keepThru(result => nextArgs(...result.messages())));\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeparam Value  Input value type.\n */\nexport abstract class InValidation<Value> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @return `AfterEvent` keeper of validation result keeper.\n   */\n  abstract read(): AfterEvent<[InValidation.Result]>;\n\n  /**\n   * Starts sending validation result and updates to the given `receiver`\n   *\n   * @param receiver  Target validation result receiver.\n   *\n   * @returns Validation results supply.\n   */\n  abstract read(receiver: EventReceiver<[InValidation.Result]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read();\n  }\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators  Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<Value>[]): EventSupply;\n\n}\n\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code  Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code  Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes  Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator]() {\n    return [][Symbol.iterator]();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    itsEach(\n        messages,\n        message => {\n\n          let nonEmpty = false;\n\n          itsEach(overEntries(message), ([code, codePresent]) => {\n            if (codePresent) {\n              nonEmpty = true;\n\n              const prev = this._byCode.get(code);\n\n              if (prev) {\n                prev.push(message);\n              } else {\n                this._byCode.set(code, [message]);\n              }\n            }\n          });\n\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          if (nonEmpty) {\n            this._all.push(message);\n          }\n        },\n    );\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): IterableIterator<InValidation.Message> {\n    return this._all[Symbol.iterator]();\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages  Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<Value> extends InValidation<Value> {\n\n  readonly _messages: InValidationMessages<Value>;\n\n  constructor(control: InControl<Value>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    const container = control.aspect(InContainer);\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n\n  }\n\n  by(...validators: InValidator<Value>[]): EventSupply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n  read(): AfterEvent<[InValidation.Result]>;\n  read(receiver: EventReceiver<[InValidation.Result]>): EventSupply;\n  read(receiver?: EventReceiver<[InValidation.Result]>): AfterEvent<[InValidation.Result]> | EventSupply {\n    return (this.read = afterSupplied(this._messages).keepThru(inValidationResult).F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read().keepThru(\n      nestedInValidations,\n      combineInValidationResults,\n  );\n}\n\n/**\n * @internal\n */\nfunction nestedInValidations(\n    controls: InContainer.Snapshot,\n): NextCall<OnEventCallChain, [InValidation.Result][]> {\n  return nextAfterEvent(afterEach(...mapIt(controls, control => control.aspect(InValidation))));\n}\n\n/**\n * @internal\n */\nfunction combineInValidationResults(\n    ...results: [InValidation.Result][]\n): NextCall<OnEventCallChain, InValidation.Message[]> {\n  return nextArgs<InValidation.Message[]>(\n      ...flatMapIt(mapIt(results, result => result[0])),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<OfInstance, OfValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<OfValue>;\n\n    }\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @param validators  Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<Value>(...validators: InValidator<Value>[]): InValidator<Value> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<Value>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport { EventKeeper } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control\n      ? control.read().keepThru(value => value ? nextArgs() : { missing: 'missing' })\n      : requirePresent;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { asis, nextArgs, nextSkip } from '@proc7ts/call-thru';\nimport {\n  AfterEvent,\n  afterSent,\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n} from '@proc7ts/fun-events';\nimport { DomEventDispatcher } from '@proc7ts/fun-events/dom';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeparam Value  Input value type.\n * @typeparam Elt  A type of input HTML element.\n */\nexport class AbstractInElement<Value, Elt extends HTMLElement> extends InElement<Value, Elt> {\n\n  readonly events: DomEventDispatcher;\n  private readonly _get: (this: AbstractInElement<Value, Elt>) => Value;\n  private readonly _set: (this: AbstractInElement<Value, Elt>, value: Value) => void;\n  private readonly _input: EventEmitter<[InElement.Input<Value>, Value]> = new EventEmitter();\n  private _value: Value;\n  private _update: (value: Value, oldValue: Value) => void;\n\n  /**\n   * Constructs HTML input element control.\n   *\n   * @param element  HTML input element the constructed control is based on.\n   * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   * @param get  Input value getter.\n   * @param set  Input value setter.\n   */\n  constructor(\n      readonly element: Elt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<Value> | readonly InConverter.Aspect<Value>[];\n        readonly get: (this: AbstractInElement<Value, Elt>) => Value;\n        readonly set: (this: AbstractInElement<Value, Elt>, value: Value) => void;\n      },\n  ) {\n    super({ aspects });\n\n    const self = this;\n\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const doUpdate = this._update = (value: Value, oldValue: Value): void => update({ value }, oldValue);\n\n    this.events = new DomEventDispatcher(element);\n    eventSupplyOf(this.events).needs(this);\n    this.listenForInput(input => update(input, this._value));\n\n    function update(input: InElement.Input<Value>, oldValue: Value): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<Value>, Value] | undefined;\n\n        // Record corrections\n        self._update = (newValue: Value, old: Value) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = doUpdate;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._input);\n  }\n\n  get it(): Value {\n    return this._get();\n  }\n\n  set it(value: Value) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  input(): AfterEvent<[InElement.Input<Value>]>;\n  input(receiver: EventReceiver<[InElement.Input<Value>]>): EventSupply;\n  input(receiver?: EventReceiver<[InElement.Input<Value>]>): AfterEvent<[InElement.Input<Value>]> | EventSupply {\n    return (this.input = afterSent<[InElement.Input<Value>]>(\n        this._input.on().thru(asis), // remove the second parameter\n        () => [{ value: this.it }],\n    ).F)(receiver);\n  }\n\n  on(): OnEvent<[Value, Value]>;\n  on(receiver: EventReceiver<[Value, Value]>): EventSupply;\n  on(receiver?: EventReceiver<[Value, Value]>): OnEvent<[Value, Value]> | EventSupply {\n    return (this.on = this._input.on().thru(\n        ({ value: newValue }, oldValue) => newValue === oldValue ? nextSkip() : nextArgs(newValue, oldValue),\n    ).F)(receiver);\n  }\n\n  /**\n   * Enables reaction to input input.\n   *\n   * By default listens for `input` and `change` events.\n   *\n   * @param update  Updates current value by user input and sends update event. This function is to be called by\n   * input event listeners.\n   */\n  protected listenForInput(update: (input: InElement.Input<Value>) => void): void {\n\n    const onInput = (event: Event): void => update({ value: this.it, event });\n\n    this.events.on('input').to(onInput);\n    this.events.on('change').to(onInput);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { AbstractInElement } from './abstract-element.control';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element  Target text input element.\n * @param aspects  Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new AbstractInElement(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { noop } from '@proc7ts/call-thru';\nimport {\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InFocus | null> {\n    return inAspectSameOrBuild(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when [[InElement]] aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot | null = element.getRootNode\n        ? element.getRootNode() as any\n        : element.ownerDocument;\n\n    this._it = trackValue(!!owner && owner.activeElement === element);\n    eventSupplyOf(this).needs(inElement);\n\n    events.on('focus').to(() => this._it.it = true);\n    events.on('blur').to(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._it);\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n  on(): OnEvent<[boolean, boolean]>;\n  on(receiver: EventReceiver<[boolean, boolean]>): EventSupply;\n  on(receiver?: EventReceiver<[boolean, boolean]>): OnEvent<[boolean, boolean]> | EventSupply {\n    return (this.on = this._it.on().F)(receiver);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { itsEach, mapIt } from '@proc7ts/a-iterable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  eventSupplyOf,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectSameOrBuild } from '../../aspect.impl';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<Value>(control: InControl<Value>): InAspect.Applied<Value, InStatus> {\n    return inAspectSameOrBuild(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * Builds `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of input status flags.\n   */\n  abstract read(): AfterEvent<[InStatus.Flags]>;\n\n  /**\n   * Starts sending input status flags and updates to the given `receiver`\n   *\n   * @param receiver  Target receiver of input status flags.\n   *\n   * @returns Input status flags supply.\n   */\n  abstract read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read();\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched  Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited  Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  constructor(control: InControl<any>) {\n    super();\n    eventSupplyOf(this._flags).needs(control);\n    this._flags.by(elementInStatusFlags(this._flags, control));\n  }\n\n  read(): AfterEvent<[InStatus.Flags]>;\n  read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InStatus.Flags]>): AfterEvent<[InStatus.Flags]> | EventSupply {\n    return (this.read = this._flags.read().F)(receiver);\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input().keepThru(({ event }) => !!event) : afterThe(false),\n  }).keepThru(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  );\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n  }\n\n  read(): AfterEvent<[InStatus.Flags]>;\n  read(receiver: EventReceiver<[InStatus.Flags]>): EventSupply;\n  read(receiver?: EventReceiver<[InStatus.Flags]>): AfterEvent<[InStatus.Flags]> | EventSupply {\n    return (this.read = containerInStatusFlags(this._container).F)(receiver);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read().once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markEdited(edited),\n        ),\n    );\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read().once(\n        snapshot => itsEach(\n            snapshot,\n            control => control.aspect(InStatus).markTouched(touched),\n        ),\n    );\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read().tillOff(container).keepThru_(\n      (snapshot: InContainer.Snapshot) => nextAfterEvent(afterEach(...inControlStatuses(snapshot))),\n      combineInStatusFlags,\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { inAspectNull, inAspectValue } from '../../aspect.impl';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? inAspectValue(element.element) : inAspectNull;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @param element  A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<Value>(element: InStyledElement | null = null): InConverter.Aspect<any, Value> {\n    return {\n      applyAspect<Instance, Kind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<Instance, Value, Kind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? inAspectValue(element) as InAspect.Application.Result<Instance, Value, Kind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/a-iterable';\nimport { noop } from '@proc7ts/call-thru';\nimport { DeltaSet } from '@proc7ts/delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventKeeper,\n  EventNotifier,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  eventSupplyOf,\n  isEventKeeper,\n  nextAfterEvent,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { css__naming, isQualifiedName, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { RenderSchedule } from '@proc7ts/render-scheduler';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` keeper of CSS classes map.\n   */\n  abstract read(): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Starts sending CSS classes for styled element and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of CSS classes map.\n   *\n   * @returns CSS classes supply.\n   */\n  abstract read(receiver: EventReceiver<[InCssClasses.Map]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   *\n   * @returns `AfterEvent` keeper of added and removed classes.\n   */\n  abstract track(): AfterEvent<[readonly string[], readonly string[]]>;\n\n  /**\n   * Starts sending current, added and removed CSS classes to the given `receiver`\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   *\n   * @param receiver  Target receiver of added and removed CSS classes.\n   *\n   * @returns CSS classes supply.\n   */\n  abstract track(receiver: EventReceiver<[readonly string[], readonly string[]]>): EventSupply;\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source  A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): EventSupply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source  A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element  Target element to apply CSS classes to.\n   * @param schedule  DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): EventSupply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason  An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by [[InNamespaceAliaser]] aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  private readonly _sources: ValueTracker<[Map<AfterEvent<[InCssClasses.Map]>, EventSupply>]> = trackValue([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n\n    eventSupplyOf(_control).whenOff(reason => this.done(reason));\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  read(): AfterEvent<[InCssClasses.Map]>;\n  read(receiver: EventReceiver<[InCssClasses.Map]>): EventSupply;\n  read(receiver?: EventReceiver<[InCssClasses.Map]>): AfterEvent<[InCssClasses.Map]> | EventSupply {\n    return (this.read = this._sources.read().tillOff(this._control).keepThru_(\n        ([sources]) => nextAfterEvent(afterEach(...sources.keys())),\n        (...classes) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        },\n    ).F)(receiver);\n  }\n\n  track(): AfterEvent<[readonly string[], readonly string[]]>;\n  track(receiver: EventReceiver<[readonly string[], readonly string[]]>): EventSupply;\n  track(\n      receiver?: EventReceiver<[readonly string[], readonly string[]]>,\n  ): AfterEvent<[readonly string[], readonly string[]]> | EventSupply {\n    return (this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n      receiver.supply.needs(this._control);\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    }).F)(receiver);\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).keepThru(\n        (...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        },\n    );\n  }\n\n  add(source: InCssClasses.Source): EventSupply {\n\n    const inSupply = eventSupplyOf(this._control);\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = eventSupply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source).to({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).share();\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): EventSupply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.done(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark  Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input\n * aspects namespace} is used by default.\n * @param when  {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  let marks: InCssClasses.Spec[];\n\n  if (!mark) {\n    marks = defaultInCssErrorMarks;\n  } else if (Array.isArray(mark)) {\n    marks = mark.length ? mark : defaultInCssErrorMarks;\n  } else {\n    marks = [mark];\n  }\n\n  return control => control.aspect(InValidation).read().keepThru(\n      errors => hasError(errors) ? nextArgs(...marks) : nextArgs(),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @proc7ts/input-aspects\n */\nimport { nextArgs } from '@proc7ts/call-thru';\nimport { afterAll } from '@proc7ts/fun-events';\nimport { NamespaceDef, QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InValidation } from '../../validation';\nimport { InStatus } from '../focus';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `hasFocus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns  A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).keepThru(\n        ({ md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          return nextArgs(...names);\n        },\n    );\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { ContextValueOpts, ContextValues } from '@proc7ts/context-values';\nimport { ContextSupply, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, EventKeeper } from '@proc7ts/fun-events';\nimport { InConverter, InNamespaceAliaser, InRenderScheduler, intoConvertedBy } from '@proc7ts/input-aspects';\nimport { DefaultNamespaceAliaser, ElementRenderScheduler } from '@wesib/wesib';\n\n/**\n * Default input aspects.\n *\n * This is an `AfterEvent` keeper of aspect converter meant to be applied to controls.\n *\n * As a bare minimum it assigns the following aspects to converted controls:\n * - `InRenderScheduler` set to `ElementRenderScheduler`,\n * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n *\n * More input aspect converters may be registered in context. They may override the default ones.\n */\nexport type DefaultInAspects = AfterEvent<[InConverter.Aspect<any, any>]>;\n\n/**\n * @internal\n */\nclass DefaultInAspectsKey\n    extends ContextUpKey<AfterEvent<[InConverter.Aspect<any, any>]>, InConverter.Aspect<any, any>> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor() {\n    super('default-in-aspects');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[InConverter.Aspect<any, any>]>,\n          EventKeeper<InConverter.Aspect<any, any>[]> | InConverter.Aspect<any, any>,\n          AfterEvent<InConverter.Aspect<any, any>[]>>,\n  ): AfterEvent<[InConverter.Aspect.Factory<any, any>]> {\n\n    const nsAlias = opts.context.get(DefaultNamespaceAliaser);\n    const scheduler = opts.context.get(ElementRenderScheduler);\n\n    return opts.seed.keepThru(\n        (...fns) => intoConvertedBy(\n            ...fns,\n            InRenderScheduler.to(scheduler),\n            InNamespaceAliaser.to(nsAlias),\n        ),\n    ).tillOff(opts.context.get(ContextSupply));\n  }\n\n}\n\n/**\n * A key of component context containing default input aspects.\n */\nexport const DefaultInAspects: ContextUpRef<DefaultInAspects, InConverter.Aspect<any, any>> = (\n    /*#__PURE__*/ new DefaultInAspectsKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { SingleContextUpKey, SingleContextUpRef } from '@proc7ts/context-values/updatable';\nimport { eventSupply, EventSupply } from '@proc7ts/fun-events';\nimport { InControl } from '@proc7ts/input-aspects';\nimport { ComponentContext } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\n\n/**\n * A user input originated from control.\n *\n * It is meant to be present in root {@link HierarchyContext hierarchy context}. Nested components may access it from\n * their hierarchy contexts to participate in user input.\n *\n * An [[inputFromControl]] function can be used to initiate user input.\n *\n * @typeparam Value  Input value type.\n */\nexport interface InputFromControl<Value = any> {\n\n  /**\n   * Root component context the input is initiated for.\n   */\n  readonly root: ComponentContext;\n\n  /**\n   * User input control.\n   */\n  readonly control: InControl<Value>;\n\n}\n\n/**\n * No user input originated from control.\n */\nexport interface NoInputFromControl {\n  control?: undefined;\n}\n\n/**\n * A key of hierarchy context value containing a user input originated from control. Potentially\n * {@link NoInputFromControl absent}.\n */\nexport const InputFromControl: SingleContextUpRef<InputFromControl | NoInputFromControl> = (\n    /*#__PURE__*/ new SingleContextUpKey<InputFromControl | NoInputFromControl>(\n        'input-from-control',\n        {\n          byDefault: () => ({}),\n        },\n    )\n);\n\n/**\n * Initiates user input from the given control for the given root component.\n *\n * Constructs an [[InputFromControl]] instance and makes it available in `root` component's hierarchy.\n *\n * @typeparam Value  Input value type.\n * @param root  Root component context to initiate user input for.\n * @param control  User input control.\n *\n * @returns User input supply. The user input would be stopped once this supply is cut off.\n */\nexport function inputFromControl<Value>(\n    root: ComponentContext,\n    control: InControl<Value>,\n): EventSupply {\n\n  const off = root.get(HierarchyContext).provide({\n    a: InputFromControl,\n    by: () => ({\n      root,\n      control,\n    }),\n  });\n\n  return eventSupply(off)\n      .needs(root)\n      .needs(control);\n}\n","import { NamespaceDef } from '@proc7ts/namespace-aliaser';\n\nexport const Examples__NS = new NamespaceDef(\n    'https://wesib.github.io/examples',\n    'bex',\n    'wesib-examples',\n);\n","import { RefStypRule, StypColor, StypLength, StypLengthPt, StypProperties, StypRGB } from '@proc7ts/style-producer';\n\nexport interface ThemeSettings {\n  $color: StypColor;\n  $bgColor: StypColor;\n  $fontFace: string;\n  $fontSize: StypLengthPt;\n  $lineHeight: number;\n  $fontWeight: string;\n  $linkFontWeight: string;\n  $layoutBreakpoint: StypLength;\n}\n\nexport const ThemeSettings: RefStypRule<ThemeSettings> = RefStypRule.by(\n    { $: 'settings' },\n    {\n      $color: new StypRGB({ r: 161, g: 185, b: 142 }),\n      $bgColor: new StypRGB({ r: 40, g: 43, b: 36 }),\n      $fontFace: `'Exo 2', sans-serif`,\n      $fontSize: StypLengthPt.of(1, 'em'),\n      $lineHeight: 1.2,\n      $fontWeight: '400',\n      $linkFontWeight: '600',\n      $layoutBreakpoint: StypLength.of(576, 'px'),\n    },\n);\n\nexport function mediaStyle({ $layoutBreakpoint }: ThemeSettings): StypProperties {\n  return {\n    '@media:sm': `(max-width: ${$layoutBreakpoint})`,\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@proc7ts/style-producer';\nimport { Theme } from '@wesib/generic/styp';\nimport { ThemeSettings } from './theme-settings';\n\nexport function LinkStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read();\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add({ e: 'a' }, settings.keepThru(linkStyle)),\n      rules.add({ e: 'a', s: ':visited' }, settings.keepThru(linkStyle)),\n      rules.add({ e: 'a', s: ':hover' }, { textDecoration: 'underline' }),\n      rules.add({ e: 'a', s: ':active' }, { textDecoration: 'underline dotted' }),\n      rules.add({ e: 'a', s: ':focus' }, { textDecoration: 'underline dotted' }),\n  );\n}\n\nfunction linkStyle(\n    {\n      $color,\n      $linkFontWeight,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    fontWeight: $linkFontWeight,\n    textDecoration: 'none',\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@proc7ts/style-producer';\nimport { Theme } from '@wesib/generic/styp';\nimport { LinkStyle } from './link.style';\nimport { mediaStyle, ThemeSettings } from './theme-settings';\n\nexport function DefaultStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read();\n\n  return stypRules(\n      theme.root\n          .add(settings.keepThru(defaultStyle))\n          .add(settings.keepThru(mediaStyle)),\n      theme.style(LinkStyle),\n  );\n}\n\nfunction defaultStyle(\n    {\n      $color,\n      $fontFace,\n      $fontSize,\n      $lineHeight,\n      $fontWeight,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    font: `normal ${$fontWeight} ${$fontSize}/${$lineHeight} ${$fontFace}`,\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@proc7ts/style-producer';\nimport { Theme } from '@wesib/generic/styp';\nimport { DefaultStyle } from './default.style';\nimport { ThemeSettings } from './theme-settings';\n\nexport function BodyStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read();\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add(\n          { e: 'html' },\n          {\n            height: '100%',\n            margin: 0,\n            padding: 0,\n          },\n      ),\n      rules.add(\n          { e: 'body' },\n          settings.keepThru(bodyStyle),\n      ),\n      theme.style(DefaultStyle),\n  );\n}\n\nfunction bodyStyle(\n    {\n      $bgColor,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    backgroundColor: $bgColor,\n    height: '100%',\n    margin: 0,\n    padding: 0,\n  };\n}\n","import { RefStypRule, StypColor, StypLength, StypLengthPt, StypMapper, StypRuleRefs } from '@proc7ts/style-producer';\nimport { ThemeSettings } from '../theme';\n\nexport interface FormThemeSettings {\n  $color: StypColor;\n  $bgColor: StypColor;\n  $roBgColor: StypColor;\n  $fontFace: string;\n  $fontSize: StypLengthPt;\n  $errorFontSize: StypLengthPt;\n  $lineHeight: number;\n  $fontWeight: string;\n  $borderColor: StypColor;\n  $marginV: StypLengthPt;\n  $marginH: StypLengthPt;\n  $paddingV: StypLengthPt;\n  $paddingH: StypLengthPt;\n  $borderW: StypLength;\n}\n\nexport const FormThemeSettings: RefStypRule<FormThemeSettings> = RefStypRule.by(\n    { $: 'settings:form' },\n    root => StypRuleRefs.by<{ global: ThemeSettings }>(\n        {\n          global: ThemeSettings,\n        },\n        root,\n    ).read().keepThru(formMappings),\n);\n\nfunction formMappings(\n    {\n      global: {\n        $color,\n        $bgColor,\n        $fontFace,\n        $fontSize,\n        $lineHeight,\n        $fontWeight,\n      },\n    }: {\n      global: ThemeSettings;\n    },\n): StypMapper.Mappings<FormThemeSettings> {\n  return {\n    $color,\n    $bgColor: $bgColor.hsl.set(({ l }) => ({ l: l * 0.8 })),\n    $roBgColor: $bgColor.hsl.set(({ l }) => ({ l: l * 0.94 })),\n    $fontFace,\n    $fontSize,\n    $errorFontSize: $fontSize.mul(0.8),\n    $lineHeight,\n    $fontWeight,\n    $borderColor: $bgColor,\n    $marginV: $fontSize.div(4),\n    $marginH: $fontSize.div(4),\n    $paddingV: $fontSize.div(2),\n    $paddingH: $fontSize,\n    $borderW: StypLength.of(1, 'px'),\n  };\n}\n","import { AfterEvent } from '@proc7ts/fun-events';\nimport { InCssClasses, inCssError, inCssInfo, InputAspects__NS, InStyledElement } from '@proc7ts/input-aspects';\nimport { QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { StypLengthPt, stypRules, StypRules } from '@proc7ts/style-producer';\nimport { ConvertInput } from '@wesib/generic/input';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { Attributes, Component, ComponentContext, trackAttribute } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { FormThemeSettings } from './form.theme-settings';\n\n@Component(\n    ['in-error', Examples__NS],\n    Attributes('code'),\n    ConvertInput(\n        ({ control: { control }, aspects, context }) => {\n\n          const codes: AfterEvent<[string[]]> = trackAttribute(context, 'code')\n              .read()\n              .keepThru_(\n                  code => code ? code.trim().split(/\\s+/) : [],\n              );\n\n          return codes.keepThru(\n              when => control.convert(\n                  InStyledElement.to(context.element),\n                  aspects,\n              ).setup(\n                  InCssClasses,\n                  cssClasses => {\n                    cssClasses.add(inCssInfo());\n                    cssClasses.add(inCssError({ when }));\n                  },\n              ),\n          );\n        },\n    ),\n)\nexport class InErrorComponent {\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  @ProduceStyle()\n  style(): StypRules {\n    return this._context.get(Theme).style(InErrorStyle);\n  }\n\n}\n\nconst InError__qualifier = 'bex:in-error';\nconst hasError__cssClass: QualifiedName = ['has-error', InputAspects__NS];\n\nfunction InErrorStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(FormThemeSettings).read();\n  const { root: { rules } } = theme;\n  const borderW = StypLengthPt.of(4, 'px');\n\n  return stypRules(\n      rules.add(\n          { u: [':', 'host'], $: InError__qualifier },\n          settings.keepThru(({ $color, $errorFontSize }) => ({\n            display: 'none',\n            fontSize: $errorFontSize,\n            padding: $errorFontSize.div(2),\n            borderLeft: `${borderW} dotted ${$color}`,\n            paddingLeft: $errorFontSize.sub(borderW),\n          })),\n      ),\n      rules.add(\n          {\n            u: [\n              ':',\n              'host',\n              {\n                c: [hasError__cssClass, ['touched', InputAspects__NS]],\n                u: [':', 'not', { c: ['has-focus', InputAspects__NS] }],\n              },\n            ],\n            $: InError__qualifier,\n          },\n          {\n            display: 'block',\n          },\n      ),\n      rules.add(\n          {\n            u: [\n              ':',\n              'host',\n              {\n                c: hasError__cssClass,\n                u: [\n                  [':', 'not', { u: ['code', '~=', 'missing'] }],\n                  [':', 'not', { u: ['code', '~=', 'incomplete'] }],\n                ],\n              },\n            ],\n            $: InError__qualifier,\n          },\n          {\n            display: 'block',\n          },\n      ),\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { nextArg, nextArgs, NextCall } from '@proc7ts/call-thru';\nimport {\n  afterAll,\n  EventKeeper,\n  EventSupply,\n  eventSupplyOf,\n  nextAfterEvent,\n  OnEventCallChain,\n} from '@proc7ts/fun-events';\nimport { InControl, InConverter } from '@proc7ts/input-aspects';\nimport { Class, Component, ComponentClass, ComponentContext, ComponentDecorator, StateSupport } from '@wesib/wesib';\nimport { HierarchyContext } from '../hierarchy';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputFromControl, InputFromControl, NoInputFromControl } from './input-from-control';\n\n/**\n * Constructs component decorator that converts input control from {@link HierarchyContext.up enclosing component}\n * and uses it as an {@link InputFromControl origin of user input} in decorated component.\n *\n * Enables `StateSupport` feature.\n *\n * @param convert  Input control converter definition.\n *\n * @returns New component decorator.\n */\nexport function ConvertInput<T extends ComponentClass = Class>(\n    convert: ConvertInputDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n  return Component({\n    feature: {\n      needs: StateSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const { up } = context.get(HierarchyContext);\n\n        afterAll({\n          parent: up().keepThru_(\n              upper => upper ? nextAfterEvent(upper.get(InputFromControl)) : nextArg<NoInputFromControl>({}),\n          ),\n          aspects: context.get(DefaultInAspects),\n        }).keepThru_(\n            ({\n              parent: [control],\n              aspects: [aspects],\n            }): NextCall<OnEventCallChain, [InControl<any>?, EventSupply?]> => {\n              if (control.control) {\n\n                const converted = convert({ control, context, aspects });\n\n                if (converted) {\n                  return converted instanceof InControl\n                      ? nextArgs(converted)\n                      : nextAfterEvent(converted);\n                }\n              }\n\n              return nextArgs();\n            },\n        ).consume(\n            (control?: InControl<any> | null, supply?: EventSupply) => {\n              if (!control) {\n                return;\n              }\n\n              const usageSupply = inputFromControl(context, control);\n\n              (supply || eventSupplyOf(control)).needs(usageSupply);\n\n              return usageSupply;\n            },\n        );\n      });\n    },\n  });\n}\n\n/**\n * Converter definition of enclosing component's user input control.\n *\n * The returned converted control keeper may send an event supply as a second parameter. This supply will be cut off\n * once the input from converted control is no longer needed. Otherwise the control's input supply will be cut off\n * instead, and control would become unusable after that.\n *\n * Configures {@link ConvertInput @ConvertInput} component decorator.\n */\nexport type ConvertInputDef<T extends object = any> =\n/**\n * @param control  Enclosing component's user input to convert.\n * @param context  Decorated component context.\n * @param aspects  Default input aspect converter. This is a value of [[DefaultInAspects]].\n *\n * @returns Either input control, its keeper, or nothing.\n */\n    (\n        this: void,\n        {\n          control,\n          context,\n          aspects,\n        }: {\n          control: InputFromControl;\n          context: ComponentContext<T>;\n          aspects: InConverter.Aspect<any, any>;\n        },\n    ) => InControl<any> | EventKeeper<[InControl<any>?, EventSupply?]> | null | undefined;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { StatePath } from '@proc7ts/fun-events';\nimport { Class } from '../../common';\nimport { Component, ComponentDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\nimport { AttributesSupport } from './attributes-support.feature';\nimport { property2attributeName } from './property2attribute-name';\n\n/**\n * Creates a component decorator declaring supported custom element's attributes.\n *\n * This decorator automatically enables [[AttributesSupport]] feature.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param items  Attributes definition options.\n *\n * @return New component decorator.\n */\nexport function Attributes<T extends ComponentClass = Class>(\n    ...items: readonly Attributes.Item<InstanceType<T>>[]\n): ComponentDecorator<T> {\n  return Component({\n    feature: { needs: AttributesSupport },\n    setup(setup) {\n      for (const item of items) {\n        if (typeof item === 'string') {\n\n          const name = property2attributeName(item);\n\n          setup.perDefinition({\n            a: AttributeDescriptor,\n            is: {\n              name,\n              change: attributeStateUpdate(name),\n            },\n          });\n        } else {\n          for (const [key, updateState] of Object.entries(item)) {\n\n            const name = property2attributeName(key);\n\n            setup.perDefinition({\n              a: AttributeDescriptor,\n              is: {\n                name,\n                change: attributeStateUpdate(name, updateState),\n              },\n            });\n          }\n        }\n      }\n    },\n  });\n}\n\nexport namespace Attributes {\n\n  /**\n   * Attribute definition item.\n   *\n   * This is either an attribute name (_camelCase_ or _dash-style_), or a per-attribute options map.\n   *\n   * @typeparam T  A type of component.\n   */\n  export type Item<T extends object> = Map<T> | string;\n\n  /**\n   * Per-attribute definition options.\n   *\n   * This is a map with attribute names as keys (either _camelCase_ or _dash-style_), and their state update\n   * instructions as values.\n   *\n   * The state update instruction can be one of:\n   * - `false` to not update the component state,\n   * - `true` to update the component state with changed attribute key,\n   * - a state value key to update, or\n   * - an attribute update receiver function with custom state update logic.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Map<T extends object> {\n    readonly [name: string]: boolean | StatePath | AttributeUpdateReceiver<T>;\n  }\n\n}\n","import { ComponentTreeSupport } from '@wesib/generic';\nimport { ThemeSupport } from '@wesib/generic/styp';\nimport { Feature } from '@wesib/wesib';\nimport { InErrorComponent } from './in-error.component';\n\n@Feature({\n  needs: [\n    ComponentTreeSupport,\n    InErrorComponent,\n    ThemeSupport,\n  ],\n})\nexport class InputSupport {\n}\n","import { StypProperties } from '@proc7ts/style-producer';\nimport { IncludePage } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { ThemeSettings } from '../theme';\n\n@Component(\n    ['main', Examples__NS],\n    IncludePage({\n      onResponse({ response, range }) {\n        if (!response.ok) {\n          range.deleteContents();\n          if (response.ok == null) {\n            range.insertNode(document.createTextNode('Loading...'));\n          } else {\n            range.insertNode(document.createTextNode(`Error. ${response.error}`));\n          }\n        }\n      },\n    }),\n)\nexport class MainComponent {\n}\n\nexport function mainStyle(\n    {\n      $fontSize,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    flex: '1 1 auto',\n    padding: 0,\n    margin: `0 0 0 ${$fontSize.div(2)}`,\n  };\n}\n","import { StypColor, StypLengthPt, StypProperties, stypRules, StypRules } from '@proc7ts/style-producer';\nimport { ActivateNavLink, HandleNavLinks } from '@wesib/generic';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { Component, ComponentContext, Wesib__NS } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { ThemeSettings } from '../theme';\n\n@Component(\n    ['nav', Examples__NS],\n    HandleNavLinks(),\n    ActivateNavLink(),\n)\nexport class NavComponent {\n\n  private readonly _theme: Theme;\n\n  constructor(context: ComponentContext) {\n    this._theme = context.get(Theme);\n  }\n\n  @ProduceStyle()\n  style(): StypRules {\n    return this._theme.style(NavStyle);\n  }\n\n}\n\nconst Nav__qualifier = 'bex:nav';\n\nfunction NavStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read();\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add(\n          { u: [':', 'host'], $: Nav__qualifier },\n          settings.keepThru(navStyle),\n      ),\n      rules.add(\n          { u: [':', 'host'], $: Nav__qualifier },\n          settings.keepThru(sts => ({\n            flex: '0 1 200px',\n            height: '100%',\n            background: navLinkBackground(sts),\n          })),\n      ),\n      rules.add(\n          { u: [':', 'host'], $: [Nav__qualifier, '@media:sm'] },\n          {\n            flex: '0 1 100%',\n          },\n      ),\n      rules.add(\n          [{ u: [':', 'host'], $: Nav__qualifier }, { e: 'a', $: Nav__qualifier }],\n          settings.keepThru(navLinkStyle),\n      ),\n      rules.add(\n          [{ u: [':', 'host'], $: Nav__qualifier }, { e: 'a', c: ['active', Wesib__NS], $: Nav__qualifier }],\n          settings.keepThru(activeNavLinkStyle),\n      ),\n  );\n}\n\nfunction navStyle(\n    {\n      $fontSize,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    padding: 0,\n    margin: `0 ${$fontSize.div(2)} 0 0`,\n  };\n}\n\nexport function navLinkBackground({ $bgColor }: ThemeSettings): StypColor {\n  return $bgColor.hsl.set(({ l }) => ({ l: l * 0.8 }));\n}\n\nfunction navLinkStyle(\n    settings: ThemeSettings,\n): StypProperties {\n\n  const { $fontSize } = settings;\n\n  return {\n    display: 'block',\n    margin: 0,\n    padding: `${$fontSize.div(2)} ${$fontSize}`,\n    border: 0,\n    outline: 0,\n    background: navLinkBackground(settings),\n  };\n}\n\nfunction activeNavLinkStyle(\n    {\n      $fontSize,\n      $color,\n      $bgColor,\n    }: ThemeSettings,\n): StypProperties {\n\n  const borderW = StypLengthPt.of(4, 'px');\n\n  return {\n    background: $bgColor,\n    borderLeft: `${borderW} solid ${$color}`,\n    paddingLeft: $fontSize.sub(borderW),\n  };\n}\n","import { QualifiedName } from '@proc7ts/namespace-aliaser';\nimport { stypRules, StypRules } from '@proc7ts/style-producer';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { BootstrapContext, Component, ComponentContext } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { mediaStyle, ThemeSettings } from '../theme';\nimport { MainComponent, mainStyle } from './main.component';\nimport { NavComponent } from './nav.component';\n\n@Component({\n  name: ['container', Examples__NS],\n  feature: {\n    needs: [\n      MainComponent,\n      NavComponent,\n    ],\n  },\n})\nexport class ContainerComponent {\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  @ProduceStyle()\n  async style(): Promise<StypRules> {\n\n    const { elementDef: { name: mainName } } = await this._context.get(BootstrapContext).whenDefined(MainComponent);\n\n    return this._context.get(Theme).style(ContainerStyle(mainName!));\n  }\n\n}\n\nconst Container__qualifier = 'bex:container';\n\nfunction ContainerStyle(mainName: QualifiedName): (theme: Theme) => StypRules {\n  return theme => {\n\n    const settings = theme.ref(ThemeSettings).read();\n    const { root: { rules } } = theme;\n\n    return stypRules(\n        rules.add(\n            { u: [':', 'host'], $: Container__qualifier },\n            {\n              height: '100%',\n              display: 'flex',\n              flexFlow: 'row wrap',\n              alignItems: 'stretch',\n              alignContent: 'flex-start',\n            },\n        ).add(\n            settings.keepThru(mediaStyle),\n        ),\n        rules.add(\n            { u: [':', 'host'], $: [Container__qualifier, '@media:sm'] },\n            {\n              height: 'auto',\n            },\n        ),\n        rules.add(\n            [{ u: [':', 'host'], $: Container__qualifier }, { e: mainName, $: Container__qualifier }],\n            settings.keepThru(mainStyle),\n        ),\n    );\n  };\n}\n","import { ComponentTreeSupport, PageLoadSupport } from '@wesib/generic';\nimport { StyleProducerSupport, ThemeSupport } from '@wesib/generic/styp';\nimport { Feature } from '@wesib/wesib';\nimport { ContainerComponent } from './container.component';\n\n@Feature({\n  needs: [\n    ContainerComponent,\n    ComponentTreeSupport,\n    PageLoadSupport,\n    StyleProducerSupport,\n    ThemeSupport,\n  ],\n})\nexport class LayoutSupportFeature {\n}\n","import { produceBasicStyle, stypDomFormat } from '@proc7ts/style-producer';\nimport { ComponentStypDomFormat, ComponentStypFormat, Theme, ThemeSupport } from '@wesib/generic/styp';\nimport { Feature } from '@wesib/wesib';\nimport { BodyStyle } from './body.style';\n\n@Feature({\n  needs: ThemeSupport,\n  setup(setup) {\n    setup.perComponent({ a: ComponentStypFormat, as: ComponentStypDomFormat });\n  },\n  init(context) {\n    context.whenReady(() => {\n      produceBasicStyle(context.get(Theme).style(BodyStyle), stypDomFormat());\n    });\n  },\n})\nexport class BodyStyleSupport {}\n\n","import { Feature } from '@wesib/wesib';\nimport { InputSupport } from './input/input-support.feature';\nimport { LayoutSupportFeature } from './layout';\nimport { BodyStyleSupport } from './theme/body-style-support.feature';\n\n@Feature({\n  needs: [\n    BodyStyleSupport,\n    InputSupport,\n    LayoutSupportFeature,\n  ],\n})\nexport class AppFeature {}\n","import { InputAspects__NS } from '@proc7ts/input-aspects';\nimport { mixStypColors, StypProperties, stypRules, StypRules } from '@proc7ts/style-producer';\nimport { Theme } from '@wesib/generic/styp';\nimport { FormThemeSettings } from './form.theme-settings';\n\nexport function InputStyle(theme: Theme): StypRules {\n\n  const formSettings = theme.ref(FormThemeSettings).read();\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add({ e: 'input' }, formSettings.thru(inStyle)),\n      rules.add({ e: 'input', s: '[readonly]' }, formSettings.thru(readonlyInStyle)),\n      rules.add({ e: 'input', s: '[disabled]' }, formSettings.thru(readonlyInStyle)),\n      rules.add({ e: 'input', s: ':focus' }, formSettings.thru(focusedInStyle)),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['invalid', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          formSettings.keepThru(invalidInStyle),\n      ),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['missing', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          {\n            outlineStyle: 'dotted',\n          },\n      ),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['incomplete', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          {\n            outlineStyle: 'dotted',\n          },\n      ),\n  );\n}\n\nexport function inStyle(\n    {\n      $color,\n      $fontFace,\n      $fontSize,\n      $lineHeight,\n      $fontWeight,\n      $marginV,\n      $marginH,\n      $paddingV,\n      $paddingH,\n      $bgColor,\n      $borderColor,\n      $borderW,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    font: `normal ${$fontWeight} ${$fontSize}/${$lineHeight} ${$fontFace}`,\n    padding: `${$paddingV} ${$paddingH}`,\n    margin: `${$marginV} ${$marginH}`,\n    backgroundColor: $bgColor,\n    border: '0 none',\n    outline: `${$borderW} solid ${$borderColor}`,\n    boxShadow: 'inset 1px 1px 2px -2px black',\n    boxSizing: 'border-box',\n    width: '100%',\n  };\n}\n\nexport function readonlyInStyle(\n    {\n      $roBgColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    backgroundColor: $roBgColor,\n  };\n}\n\nfunction focusedInStyle(\n    {\n      $color,\n      $borderColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    outlineColor: mixStypColors($borderColor, $color, 0.5),\n  };\n}\n\nfunction invalidInStyle(\n    {\n      $color,\n      $borderW,\n      $borderColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    outline: `${$borderW.mul(2)} dashed ${mixStypColors($borderColor, $color, 0.25)}`,\n  };\n}\n","import { bootstrapComponents } from '@wesib/wesib';\nimport { AppFeature } from './app.feature';\n\nexport * from './app.feature';\nexport * from './examples.ns';\nexport * from './input';\nexport * from './theme';\n\nexport const examplesContext = bootstrapComponents(AppFeature);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs, nextSkip } from '@proc7ts/call-thru';\nimport { AfterEvent, afterEventBy, EventReceiver, EventSupply, OnEvent, trackValue } from '@proc7ts/fun-events';\nimport { newNamespaceAliaser } from '@proc7ts/namespace-aliaser';\nimport { Class } from '../../common';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { FeatureDef, FeatureRef, FeatureStatus } from '../../feature';\nimport { FeatureKey, FeatureLoader, FeatureRequester } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapContextRegistry } from '../impl';\nimport { whenDefined } from '../impl/when-defined.impl';\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features  Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapContextRegistry = BootstrapContextRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.get(FeatureRequester).request(feature);\n  bootstrapContext.get(FeatureKey.of(feature)).to(loader => {\n    loader!.init().then(complete).catch(console.error);\n  });\n\n  return bootstrapContext;\n}\n\n/**\n * @internal\n */\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\n/**\n * @internal\n */\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n\n/**\n * @internal\n */\nfunction initBootstrap(\n    bootstrapContextRegistry: BootstrapContextRegistry,\n): {\n  bootstrapContext: BootstrapContext;\n  complete(): void;\n} {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const values = bootstrapContextRegistry.values;\n\n  class BootstrapContext$ extends BootstrapContext {\n\n    readonly get = values.get;\n\n    constructor() {\n      super();\n      bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    whenDefined<C extends object>(componentType: ComponentClass<C>): OnEvent<[DefinitionContext<C>]> {\n      return whenDefined(this, componentType);\n    }\n\n    whenReady(): OnEvent<[BootstrapContext]>;\n    whenReady(receiver: EventReceiver<[BootstrapContext]>): EventSupply;\n    whenReady(receiver?: EventReceiver<[BootstrapContext]>): OnEvent<[BootstrapContext]> | EventSupply {\n      return (this.whenReady = stage.read().thru(\n          s => s ? nextArgs(this) : nextSkip(),\n      ).once().F)(receiver);\n    }\n\n    load(feature: Class<any>): FeatureRef {\n\n      interface FeatureInfo {\n        status: FeatureStatus;\n        down?: Promise<void>;\n      }\n\n      const status = afterEventBy<[FeatureInfo]>(receiver => {\n\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const request = bootstrapContext.get(FeatureRequester).request(feature);\n        const info = trackValue<FeatureInfo>({\n          status: {\n            feature,\n            ready: false,\n          },\n        });\n\n        this.get(FeatureKey.of(feature)).to({\n          supply: receiver.supply,\n          receive(_ctx, ldr) {\n\n            // Present until `request` revoked\n            // But that happens only when supply is cut off.\n            const loader = ldr as FeatureLoader;\n\n            info.it = {\n              status: {\n                feature: loader.request.feature,\n                ready: loader.ready,\n              },\n              down: loader.down,\n            };\n            if (!loader.ready) {\n              loader.init().then(() => {\n                info.it = {\n                  status: {\n                    feature: loader.request.feature,\n                    ready: true,\n                  },\n                  down: loader.down,\n                };\n              }).catch(console.error);\n            }\n          },\n        }).whenOff(() => {\n          request.unuse(); // Apply this callback _after_ registration complete,\n                           // to prevent receiver call.\n        });\n\n        info.read(receiver);\n      }).share();\n\n      let whenDown: Promise<void>;\n      const supply = status.to(({ down }) => {\n        whenDown = down!;\n      });\n\n      class Ref extends FeatureRef {\n\n        get down(): Promise<void> {\n          return whenDown;\n        }\n\n        read(): AfterEvent<[FeatureStatus]>;\n        read(receiver: EventReceiver<[FeatureStatus]>): EventSupply;\n        read(receiver?: EventReceiver<[FeatureStatus]>): AfterEvent<[FeatureStatus]> | EventSupply {\n          return (this.read = status.tillOff(supply).keepThru(\n              info => info.status,\n          ).F)(receiver);\n        }\n\n        dismiss(reason?: any): Promise<void> {\n          supply.off(reason);\n          return whenDown;\n        }\n\n      }\n\n      return new Ref();\n    }\n\n  }\n\n  const bootstrapContext = new BootstrapContext$();\n\n  return {\n    bootstrapContext,\n    complete(): void {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n"],"names":["asis","value","noop","isPresent","valueProvider","lazyValue","provider","get","valuesProvider","values","NextCall__symbol","Symbol","nextCall","callNext","result","chain","fn","nextArg","arg","pass","nextArgs","args","call","nextSkip","skip","itsIterator","iterable","iterator","itsIterable","makeIt","iterate","reverse","[object Object]","reversible","itsEach","action","element","itsEmpty","next","done","itsFirst","itsReduction","reducer","initialValue","reduced","filterIt","source","test","flatMapIt","convert","mapIt","overArray","array","i","length","reverseArray","noneIterable","this","overKeys","target","Reflect","ownKeys","overEntries","keys","mapToEntries","_keys","key","ContextKey__symbol","ContextKey","name","ContextSeedKey","super","seedKey","opts","seeder","seed","isEmpty","byDefault","ContextKeyError","Error","message","contextValueSpec","spec","byProvider","withDeps","a","by","with","deps","context","map","dep","isConstant","is","viaAlias","via","ctx","asInstance","selfInstance","Object","as","toAsInstance","Type","DepType","TypeError","JSON","stringify","ContextValues","ContextRegistry","initial","Map","_initial","_seeding","provide","found","_seeds","seeding","set","factory","cache","newValues","bind","_nonCachedValues","registry","Values","cached","constructed","defaultUsed","findSeed","valueOpts","or","defaultProvider","defaultValue","grow","growValue","other","combine","IterativeContextSeeder","_providers","push","indexOf","splice","overNone","iterativeSeed","first","second","IterativeSeedKey","IterativeContextKey","providers","undefined","MultiContextKey","Array","from","defaultSources","SimpleContextSeeder","unshift","lastIndexOf","makeSeed","seeds","combineSimpleSeeds","SimpleSeedKey","SimpleContextKey","SingleContextKey","AfterEvent__symbol","isEventKeeper","EventSupply__symbol","EventSupply","off","_off","reason","_whenOff","callback","prev","isOff","another","eventSupplyOf","needs","whenOff","peer","eventSupply","eventReceiver","receiver","generic","supply","_context","event","receive","receiveByEach","receivers","send","sendNonRecurrent","actualReceivers","received","recurrent","processEvent","shift","recurrentReceivers","idx","recurrentReceiver","recurrentEvent","EventNotifier","rcs","_rcs","Set","clear","size","add","delete","OnEvent__symbol","isEventSender","NoSupply","noSupply","noEventSupply","sendEventsTo","once","onSource","to","share","shared","sharedSupply","initialEvents","_ctx","on","dispatch","forEach","thru","passes","chains","index","chainSupply","lastPass","existing","prevSupply","entry","handleResult","sender","callResult","parentSupply","nextChain","firstChain","tillOff","required","dependentSupply","cuts","neverReceive","OnEvent","_on","F","onEvent","onCutOff","Promise","resolve","reject","e","then","onEventBy","consume","consumerSupply","thru_","register","noEvent","AfterEvent","_or","dest","reported","_last","_rcn","afterEventBy","keepThru_","fallback","afterSent","afterSupplied","supplier","afterAll","sources","afterEach","afterThe","nextAfterEvent","keeper","EventEmitter","onNever","onSupplied","onAny","suppliers","remained","removeSupplier","onAsync","sourceSupply","numInProcess","numSent","numReceived","lastIndex","promise","onAnyAsync","toSend","onPromise","alwaysReceiveValue","catch","statePath","path","isArray","PathEntry","_drop","emitter","newValue","oldValue","nested","_nested","slice","_dropIfEmpty","dontCreateMissing","created","_remove","Trackers","_entry","_root","nest","SubStateTracker","_trackers","_path","update","_tracker","onUpdate","StateTracker","subTracker","track","ValueTracker","read","valueReceiver","onRecurrent","recurrentValue","it","extract","acceptValuesFrom","byNone","container","_by","TrackedValue","_it","trackValue","ValueSync","old","third","syncWithTracker","tracker","syncTrackers","extractTracker","tracker1","tracker2","supply1","supply2","Naming","nsAlias","local","ns","DefaultNaming","alias","default__naming","html__naming","XmlNaming","id__naming","CssNaming","css__naming","NamespaceDef","url","aliases","naming","applyAlias","isQualifiedName","isNameAndNamespace","compareNames","compareStrings","firstName","firstUrl","newNamespaceAliaser","aliasesByNs","nsNumPerAlias","mostPreferred","nsNumRegistered","preferred","ids","generated","OnDomEvent","listener","onDomEventBy","capture","instead","preventDefault","just","stopPropagation","last","stopImmediatePropagation","passive","domEventContext","DomEventDispatcher","_target","type","domListener","addEventListener","removeEventListener","dispatchEvent","contextDestroyed","ContextSupplyKey","ContextSupply","ContextUpSeeder","concat","providersTracker","keepThru","prov","toUpSrcKeeper","flatUpSources","upSrcKeepers","src","isUpSrcKeeper","ContextSeedUpKey","upKey","ContextUpKeyUpKey","_key","ContextUpKey","FnContextKey","createUpKey","fns","delegated","SingleContextUpKey","backup","RenderScheduleConfig","options","win","node","window","ownerDocument","defaultView","messages","error","console","RenderQ__symbol","RenderQ","q","ref","schedule","doSchedule","queue","shot","config","postponed","execution","reset","suspend","exec","postpone","post","resume","pull","scheduled","customRenderScheduler","scheduleOptions","queueRef","newQueue","enqueued","lastQueue","executed","nextQueue","activeQueue","nextEnqueued","RenderQueue","replace","shots","animationRenderQueues","WeakMap","immediateRenderScheduler","execute","pop","defaultRenderScheduler","task","requestAnimationFrame","replacement","newRenderSchedule","BootstrapContext__key","BootstrapContext","bootstrapDefault","bootstrapContext","ArraySet","items","addAll","item","superClassOf","satisfying","prototype","getPrototypeOf","superType","constructor","decoratePropertyAccessor","propertyKey","desc","updateDescriptor","isField","updatedDesc","writable","isPropertyAccessorDescriptor","value__symbol","accessorDesc","toPropertyAccessorDescriptor","fieldKey","String","configurable","enumerable","fieldAccessorDescriptor","defineProperty","mergeFunctions","merge","_f","s","apply","isElement","nodeType","Node","ELEMENT_NODE","MetaAccessor","symbol","hasOwnProperty","ownDef","own","superDef","of","prevMeta","updates","meta","newMeta","PromiseResolver","_resolve","_reject","FeatureDef__symbol","FeatureMeta","defs","def","has","setup","init","featureMeta","noFeatureDef","FeatureDef","featureType","for","all","define","Feature","FeatureContext__key","FeatureContext","componentType","whenDefined","feature","load","FeatureNeedsError","reduce","need","FeatureRef","ComponentDef__symbol","ComponentMeta","componentMeta","noComponentDef","ComponentDef","Component","decorator","ComponentContext__key","ComponentEventDispatcher__key","dispatcher","ContentRoot","StateUpdaterKey","combined","StateUpdater","ComponentContext__symbol","ComponentContext","updateState","contentRoot","ComponentEvent","Event","AnonymousComponentProperty__symbol","ComponentProperty","decorateWith","readable","component","componentDef","By","proto","descriptor","getValue","setValue","notReadableAccessor","notWritableAccessor","updated","With","access","As","Bind","binder","accessor__symbol","accessor","BootstrapContextRegistry__key","BootstrapContextRegistry","ComponentContextRegistry__key","ComponentContextRegistry","DefinitionContextRegistry__key","DefinitionContextRegistry","PostDefSetup__symbol","postDefSetup","superPostDefSetup","BootstrapWindow","BootstrapRoot","document","body","DefaultNamespaceAliaser","DefaultRenderSchedulerKey","toDefaultRenderScheduler","scheduler","DefaultRenderScheduler","ElementAdapterKey","adapters","adapter","defaultElementAdapter","ElementAdapter","ElementObserver","bsContext","DefaultElementObserver","MutationObserver","mutations","mutation","removedNodes","mount","mountOf","checkConnected","addedNodes","observe","childList","DefinitionContext__symbol","definitionContextOf","CustomElements__key","customElements","CustomElements","componentTypeOrName","elementType","defContext","extend","elementDef","extends","componentResolver","ComponentResolver__symbol","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","mountTo","connect","ComponentContext$","_definitionContext","_newComponentRegistry","_component","settled","_status","connected","whenReady","status","whenSettled","whenConnected","componentDestroyed","parentNode","removeChild","removeElement","whenComponent","_whenComponent","lastRev","readNotifier","notifier","_","_elementBuilder","components","prevContext","newComponent","bubbles","ComponentMount$","_connect","el","doc","contains","destroy","MountComponentContext$","definitionContext","CustomComponentContext$","WhenComponent","currentRev","onCreated","receiverRev","eventContext","componentContext","notifiedRev","recurrentContext","rev","DefinitionContext$","_bsContext","_ready","_whenReady","ready","_def","definitionContextRegistry","seedIn","_perTypeRegistry","whenReady$","whenComponent$","definitionSetup","perDefinition","perComponent","_elementType","_createComponent","_created","settle","append","definitions","CustomElement$","connectedCallback","disconnectedCallback","customElementType","ElementBuilder","_define","doNotAdd","ComponentRegistry","_definitionQueue","definition","buildElement","FeatureContext$","_loader","unloads","adder","unload","newUnloader","_componentRegistry","request","st","state","bs","onDefinition","_unloader","onComponent","unloader","onPostDefSetup","FeatureKey__symbol","FeatureKey","preferredFeatureClause","origin","stageId","clause","loadFeatureDeps","loader","stage","ownLoader","FeatureLoader","ownSource","rcv","lastLoader","preventDuplicateLoader","clauses","presentFeatureDeps","down","_down","_stage","SetupFeatureStage","after","lastStage","id","prevStage","stop","FeatureStage","_stop","perDep","InitFeatureStage","ActiveFeatureStage","FeatureRequest","_requester","_revoke","featureDef","requester","isClause","_revokeBy","unuse","_uses","revoke","FeatureRequester__key","FeatureRequester","_map","reuse","WhenDefined__symbol","AttributeDescriptor","AttributePath__root","attributePathTo","attributeStateUpdate","updateAttributeState","property2attributeName","c","substring","toLowerCase","AttributeRegistry__key","AttributeRegistry","attrs","_attrs","change","observedAttributes","attributeChangedCallback","attributeFilter","records","record","attributeName","getAttribute","attributes","attributeOldValue","alreadyObserved","prevCallback","attrChanged","AttributesSupport__feature","AttributesSupport","Attribute","parseAttributeDescriptor","setAttribute","removeAttribute","ComponentState__key","ComponentState","StateSupport__feature","StateSupport","AttributeTracker","_name","DomPropertyPath__root","RenderPath__root","RenderDef","recipe","valueByRecipe","base","defaults","trigger","ElementRenderCtl$","renderer","fulfill","when","scheduleRenderer","immediateSchedule","_renders","renderNow","renderElement","newRenderer","render","ElementRenderCtl","ElementRenderScheduler","renderCtl","recentShot","renderBy","Render","ShadowContentRoot","ShadowDomEvent","shadowRoot","ShadowRootBuilder","ShadowDomSupport__feature","attachShadow","ShadowDomSupport","shadowRootOf","defaultShadowContentDef","mode","AttachShadow","Wesib__NS","hthvItem","$","n","t","v","x","p","pl","addParam","param","nextInItem","input","d","delimiterOf","datePattern","parseDateTime","out","parseNone","itemParser","named","tagged","extra","parseQuotedString","unquoted","quotedStringParser","parseAngleBrackets","angleBracketsParser","parseExtra","tag","extraItem","nextInComment","spacesParser","start","paramParser","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParserOpts","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter","FetchAgentKey","agents","fetch","agentIdx","agentRequest","agent","nextRequest","combineFetchAgents","defaultFetchAgent","HttpFetchAgent","HttpFetchAborted","HttpFetch","Request","responseEmitter","abortController","AbortController","signal","abort","response","customSignal","aborted","HierarchyRoot","root","HierarchyUpdates","issue","HierarchyUpdates__key","hierarchyRoot","parent","findParentContext","immediate","HierarchyContext__key","HierarchyContext$","HierarchyContext","_parent","_registry","up","isContextSeedUpKey","upper","parentHierarchy","rootSupply","updateParent","parentCtx","newParent","enclosing","ComponentNode","ElementNodeList","WATCH_DEEP","subtree","elementNodeList","selectorOrType","nodeOf","deep","selector","overNodes","overNodeSubtree","selected","refresh","added","ElementNodeList$","observer","firstReceiver","disconnect","initialEmitter","list","sel","querySelectorAll","children","matches","select","removed","removeNode","addNode","nodes","childNodes","AttributesObserver","_bs","_observer","Observer","_update","self","_emitter","_emitters","reconnect","takeRecords","_updates","observeSupply","NodeAttributes","PropertyTracker","_element","NodeProperties","_props","prop","ElementNode__symbol","ElementNode$","_bind","elementNodeOf","optional","selectNodes","ComponentTreeSupport__feature","ComponentTreeSupport","getHashURL","URL","hash","PageParam__symbol","PageParam","_page","NavigationAgentKey","navigate","agentTo","nextURL","title","nextTitle","data","nextData","baseURI","visited","current","put","defaultNavigationAgent","_when","_from","NavigationAgent","Navigation__key","Navigation","go","PageParamContext","NavHistory__key","NavHistory","extractNavData","_document","_location","location","_history","history","_uid","btoa","Math","random","newEntry","href","_entries","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","page","pushState","_enter","fromEntry","_forget","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","wesib:navigation:data","_params","handle","newHandle","_newContext","_init","create","entries","transferred","at","stay","EnterPageEvent","cancelable","LeavePageEvent","StayOnPageEvent","createNavigation","navHistory","nav","nextEntry","hashChange","onEnter","onLeave","onStay","delta","toURL","withParam","applyParams","open","targetOrCallback","navTarget","navTargetOf","applyAgent","whenLeave","doNavigate","prepared","leavePage","prepare","navigated","NavigationSupport__feature","NavigationSupport","defaultNavLinkWeight","calcNavLinkWeight","linkURL","pageURL","linkDir","navLinkPath2dir","pageDir","searchParamWeight","navLinkSearchParamsWeight","pathname","startsWith","endsWith","searchParams","linkParams","pageParams","weight","_value","isIgnoredSearchParam","pageValues","getAll","every","linkValue","NavLinkRenderSchedule__symbol","defaultActiveNavLinkClass","defaultNavLinkHref","importNode","beforeOrImport","importContent","importNodeContent","before","elementClone","createElement","tagName","getAttributeNames","attr","insertBefore","nodeClone","cachingPageLoader","pageUrl","sup","tracked","onLoad","trackSupply","resp","num","requested","PageLoadAbortError","PageLoadRequestsParam","requests","PageLoadRequests","_navigation","fragments","fragment","pageSupply","loadSupply","_add","_transfer","responseReceiver","ok","getElementsByTagName","getElementById","onFragment","req","PageLoadAgent","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","header","requestPageFragments","text","batch","nextEach","elements","parsePageDocument","parseFromString","head","querySelector","newBase","appendChild","PageLoadParam$","PageLoadParam","PageCacheBuster__key","PageCacheBuster","appRev","navigation","urlModifier","newRev","reload","pageScriptsAgent","allScripts","externalScripts","scripts","script","pageStyleAgent","newStyles","oldStyles","oldStylesByHref","firstOldStyle","link","newStyle","oldStyle","nextSibling","style","pageTitleAgent","textContent","PageLoadSupport__feature","buster","PageLoadSupport","defaultPageContentKey","cssescId","cssesc","isIdentifier","isReadonlyArray","isNotEmptyArray","StypValueStruct","priority","prioritize","stypValuesEqual","StypColorStruct","StypRGB","coords","r","intCoord","g","b","coord","rgb","hsl","max","min","l","round","StypHSL","h","StypColor","hueAsFraction","hueToRgb","newT","mixStypColors","color1","color2","w","rgba1","rgba2","aDiff","w1","w2","StypNumericStruct","dim","toFormula","StypMapper","mappings","mapped","mappedValue","mapping","mappingBy","mapper","stypSplitPriority","trim","StypDimension","val","unit","thisDim","pt","noPt","addendum","stypDimension","stypAddSub","subtrahend","multiplier","divisor","zero","StypCalcBase","left","op","right","usual","stypMul","stypDiv","toString","StypAddSub","toDim","negate","StypMulDiv","Zero","_byPriority","important","ZeroByPriority","unitlessZeroDimensionKind","dimension","StypDimension_","isStypNumeric","StypLength","StypLengthPt","StypURL","noStypProperties","noStypPropertiesSpec","stypPropertiesBySpec","rule","preventDuplicates","propertiesKeeper","senderOrProperties","propertiesMap","properties","stored","propertyEntries","sentry","propertiesEqual","passNonDuplicate","$$css","mergeStypProperties","baseProperties","addendumProperties","k","priorityOf","addValue","addValues","isCombinator","normalizeStypSelector","normalizeKey","normalized","combinator","prevCombinator","part","normalizeStypSelectorPart","classes","filter","sort","normalizeClasses","u","subs","isSubSelectorsArray","normalizeSubSelector","normalizeSubSelectors","isPseudoSubSelector","normalizeQualifiers","sub","prefix","params","qualifiers","exposeQualifier","noQualifiers","qualifier","eqIdx","exposed","lastExposed","split","noKeyAndTail","stypRuleKeyAndTail","rootSelector","classesMatch","query","qClass","find","mClass","namesEqual","stypSelector","ruleKeyTextOpts","qualify","stypRuleKeyText","formatStypSelector","defaultFormat","format","hasProperties","className","subFormat","attrName","attrOp","attrVal","attrFlag","quotes","wrap","formatSubSelector","xmlNs","qualifyElement","formatItem","AtRulesRenderer","_rule","outer","onlyAtProperties","producer","writer","isGroup","sheet","extracted","atSelectors","rest","extractPartAtSelectors","extractAtSelectors","restSelector","atSelector","buildAtSelector","addStyle","addGroup","names","customQuery","addQuery","namedQuery","stypRenderAtRules","order","isAtEntry","restQualifies","addAtSelector","colonIdx","prevQuery","stypRenderGlobals","FIRST_RENDER_ORDER","rootRule","importIndex","nsIndex","importDelta","renderImport","renderDefaultNamespace","renderNamespacePrefix","css","addGlobal","stypRenderProperties","notCustomProperty","hyphenateStyleName","stypRenderText","stypRenderXmlNs","xmlNsDefs","declareNs","rendererFactory","isRendererFactory","rendererSpec","compareRenderers","firstOrder","secondOrder","stypRenderScheduler","removeStyleElement","defaultPrettyPrint","indent","compactStypTextFormatter","nv","eol","pre","StypTextFormatter$","_config","StypStyleTextWriter","f","nf","substr","afterBody","AbstractStypGroupTextWriter","StypGroupTextWriter","StypSheetTextWriter","stypDomFormat","textFormat","pretty","onSheet","formatter","idSeq","addSheet","stypTextFormat","StypStyleObjectWriter","setProperty","cssText","StypGroupObjectWriter","ruleText","cssRules","insertRule","StypSheetObjectWriter","deleteRule","produceBasicStyle","rules","selectorFormat","factories","addRenderers","renderers","addRenderer","stypRenderFactories","renderSupply","renderRule","trackRules","styleProducer","production","_selector","stypSelectorText","reader","specs","renderAt","nextIndex","nextRenderer","nextProducer","rendererForRule","ruleSelector","lastSheet","remove","defaultStypRenderers","produceStyle","StypRule","StypRuleList","StypRuleHierarchy","Rules","_list","ruleMatches","_buildList","_filterArray","_ruleSet","grabRules","stypQuery","stypSelectorMatches","AllRules","_added","Self","selfRuleList","iterateAllRules","extendRule","targetSelector","sendUpdate","tail","_spec","oldSpec","empty","extendSpec","keyText","newNested","StypRule$","_get","propertiesSupply","allRules","NestedRules","_all","_byKey","_outer","outerSelector","stypOuterSelector","builder","StypRuleRef","StypRuleRef$","ms","ps","watch","_mappings","_properties","RefStypRule","mappingsKeeper","StypRuleRefs","refs","referrers","fromAll","flattenProperties","noStypRules","stypRules","rulesByList","rulesFromSource","_rules","rulesByValue","evalRules","lazyStypRules","lazyRulesFromSource","ruleSet","reportExistingRules","lazyRules","resolution","asyncRules","ComponentStyleProducer","ComponentStypRenderer","ElementIdClass__NS","ElementIdClass","contextValues","aliaser","uniqueClassSeq","qualified","classList","ComponentStypFormat__symbol","ComponentStypFormat","newProducer","componentSupply","hostSelector","host","extractHostSelector","extendHostSelector","shadowRenderer","noShadowRenderer","restParts","ComponentStypDomFormat","componentStypDomFormatConfig","defaultStypRenderScheduler","ComponentStypObjectFormat","createTextNode","stypObjectFormat","BasicStyleProducerSupport__feature","BasicStyleProducerSupport","ProduceStyle","produce","StyleProducerSupport__feature","Theme__key","Theme","referrer","ThemeFactory__key","ThemeFactory","ThemeStyle","isId","prevProvider","hasId","combineStyles","byId","theme","Theme_","_styles","StypRule_","styles","ThemeFactory_","ThemeSupport__feature","newTheme","ThemeSupport","DeltaSet","_removed","deltaSetDeltaReceiver","InAspect__symbol","inAspectNull","instance","convertTo","inAspectSameOrBuild","control","aspectKey","build","attachTo","aspect","inAspectSameOrNull","inAspectValue","InputAspects__NS","InNamespaceAliaser__aspect","applyTo","InNamespaceAliaser","applyAspect","InRenderScheduler__aspect","InRenderScheduler","intoConvertedBy","valueOrAspectConverter","converters","noopInConverter","converter","inConverter","aspectConverters","conversion","acf","cv","isInAspectConversion","intoConvertedAspects","aspects","noopInConversion","InControl","_aspect","aspectKeyOrSetup","aspectSetup","and","InConverted","_aspects","applied","_applyAspect","_supply","backward","convertAspect","prevValue","prevRev","InSameValueControl","_control","AbstractInControl","_aspectConversion","InContainer__aspect","InContainer","InContainerControls","InParents__aspect","InControlParents","InParents","existingSupply","allParents","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","OwnModeTracker","initialInMode","DerivedInModes","mergeInModes","derive","InParentsAspect","parentsInMode","applyInMode","derived","_derived","lastUpdate","parents","parentList","modes","ro","inModeValue","InData__aspect","InData","hasData","InGroup__aspect","InGroup","InGroupControls","inControlReplacedReason","InGroupSnapshot","InGroupMap","_controls","replaced","modify","_shot","InGroupControlControls","_group","model","snapshot","withValues","controlEntryToGroupEntry","keyOrControls","newControl","group","newModel","applyControlsToModel","InGroupControl","_model","controls","cs","readInGroupData","csData","controlsData","controlData","inGroup","_requireNothing","requireNothing","inValidator","validator","validate","simpleInValidator","dontRemove","InValidationMessages","validators","validatorMessages","_messages","resultSupply","validatorSupply","InValidation__aspect","InValidation","validation","InControlValidation","noInValidationErrors","hasBut","InValidationErrors","nonEmpty","code","codePresent","_byCode","codes","some","inValidationResult","nestedInValidations","combineInValidationResults","nestedInValidationMessages","numValidators","requireAll","results","requirePresent","missing","AbstractInElement","_set","doUpdate","correction","_input","events","listenForInput","onInput","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","getRootNode","activeElement","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","_flags","flags","updateInStatusFlags","elementInStatusFlags","_container","inControlStatuses","combineInStatusFlags","markEdited","markTouched","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","_schedule","controlSchedule","_sources","mergeInCssClassesMap","classesSent","flag","redelta","undelta","inSupply","classesSupply","updateClasses","defaultInCssErrorMarks","defaultInCssHasError","errors","inCssInfo","cls","md","vl","valid","DefaultInAspectsKey","DefaultInAspects","InputFromControl","inputFromControl","Examples__NS","ThemeSettings","$color","$bgColor","$fontFace","$fontSize","$lineHeight","$fontWeight","$linkFontWeight","$layoutBreakpoint","mediaStyle","@media:sm","LinkStyle","settings","linkStyle","textDecoration","color","fontWeight","DefaultStyle","defaultStyle","font","BodyStyle","height","margin","padding","bodyStyle","backgroundColor","FormThemeSettings","global","formMappings","$roBgColor","$errorFontSize","mul","$borderColor","$marginV","div","$marginH","$paddingV","$paddingH","$borderW","InErrorComponent","InErrorStyle","__decorate","Attributes","trackAttribute","cssClasses","mark","hasError","marks","inCssError","converted","usageSupply","hasError__cssClass","borderW","display","fontSize","borderLeft","paddingLeft","InputSupport","MainComponent","mainStyle","flex","onResponse","contentKey","detectFragment","lastPageURL","range","createRange","selectNodeContents","newPageURL","deleteContents","createDocumentFragment","insertNode","handleResponse","IncludePage","NavComponent","_theme","NavStyle","getHref","defaultHandleNavLinks","eventType","HandleNavLinks","pick","activate","active","activeClass","makeActive","assignClass","lastSupply","activateNavLink","weigh","navLinkWeight","componentNode","weights","maxWeight","selectActiveNavLinks","newActive","activeLink","ActivateNavLink","navStyle","sts","background","navLinkBackground","navLinkStyle","activeNavLinkStyle","border","outline","ContainerComponent","mainName","flexFlow","alignItems","alignContent","ContainerStyle","LayoutSupportFeature","BodyStyleSupport","AppFeature","InputStyle","formSettings","inStyle","readonlyInStyle","focusedInStyle","invalidInStyle","outlineStyle","boxShadow","boxSizing","width","outlineColor","examplesContext","features","bootstrapContextRegistry","complete","info","ldr","whenDown","initBootstrap","bootstrapComponents"],"mappings":"6DAWgBA,EAAQC,GACtB,OAAOA,WCHOC,cCEAC,EAAaF,GAC3B,OAAgB,MAATA,WCDOG,EAAiBH,GAC/B,MAAO,IAASA,WAYFI,EAAaC,GAE3B,IAAIC,EAAM,KAAUA,EAAMH,EAAcE,QAExC,MAAO,IAAMC,aAYCC,KAA4CC,GAC1D,MAAO,IAASA,QChCLC,EAAkCC,OAAO,sBAmDtCC,EACZC,GAOF,MAAMC,MAAgBA,EAItB,OAFAA,EAAOJ,GAAoB,CAACK,EAAOC,IAAOH,EAASE,EAAOC,GAEnDF,WCvDOG,EAAiBC,GAC/B,OAAON,EAAS,CAACG,EAAOI,IAASJ,EAAMI,KAAKA,EAAMD,aCHpCE,KACTC,GAEL,OAAOT,EAAS,CAACG,EAAOC,IAAOD,EAAMO,KAAKN,EAAIK,UCCnCE,EAAoCX,EAASG,GAASA,EAAMS,iBCJzDC,EAAeC,GAC7B,OAAOA,EAASf,OAAOgB,qBAUTC,EAAeF,GAC7B,OAAO,kBAAsBA,EAAtB,YA0BOG,EACZC,EACAC,GAGF,MAAML,EAAwB,CAC5BM,CAACrB,OAAOgB,UAAWG,GAGrB,IAAKC,EACH,OAAOL,EAGT,MAAMO,EAAaP,EAInB,OAFAO,EAAWF,QAAUA,EAEdE,WCtDOC,EAAWR,EAAuBS,GAChD,IAAK,MAAMC,KAAWV,EACpBS,EAAOC,YAWKC,EAASX,GACvB,QAASD,EAAYC,GAAUY,OAAOC,cAmDxBC,EAAYd,GAC1B,OAAOD,EAAYC,GAAUY,OAAOrC,eA4CtBwC,EACZf,EACAgB,EACAC,GAGF,IAAIC,EAAUD,EAEd,IAAK,MAAMP,KAAWV,EACpBkB,EAAUF,EAAQE,EAASR,GAG7B,OAAOQ,WClGOC,EAAYC,EAAqBC,GAC/C,OAAOlB,GAAO,YACZ,IAAK,MAAMO,KAAWU,EAChBC,EAAKX,WACDA,eA+BEY,EACZF,EACAG,EAAmDjD,GAErD,OAAO6B,GAAO,YACZ,IAAK,MAAMO,KAAWU,QACbG,EAAQb,eAcLc,EAAYJ,EAAqBG,GAC/C,OAAOpB,GAAO,YACZ,IAAK,MAAMO,KAAWU,QACdG,EAAQb,eCnFJe,EAAaC,GAC3B,OAAOvB,GACH,YAEE,IAAK,IAAIwB,EAAI,EAAGA,EAAID,EAAME,SAAUD,QAC5BD,EAAMC,KAGhB,aCiB0BD,GAC9B,OAAOvB,GACH,YAIE,IAAK,IAAIwB,EAFGD,EAAME,OAEC,EAAGD,GAAK,IAAKA,QACxBD,EAAMC,MDxBVE,CAAaH,IAOzB,MAAMI,EAAwC,CAE5CxB,EAAErB,OAAOgB,cAETK,UAAY,OAAOyB,gBElBLC,EAA2BC,GACzC,OAAOR,EAAUS,QAAQC,QAAQF,aAenBG,EAA8BH,GAE5C,MAAMI,EAAOL,EAASC,GAEtB,SAASK,EAAaC,GACpB,OAAOf,EAAMe,EAAOC,GAAO,CAACA,EAAKP,EAAOO,KAG1C,OAAOrC,EAAO,IAAMJ,EAAYuC,EAAaD,IAAQ,IAAMC,EAAaD,EAAKhC,kBC7BlEoC,EAAmCxD,OAAO,qBAcjCyD,EAqBpBpC,YAAsBqC,GACpBZ,KAAKY,KAAOA,EAQdF,IAAKA,KACH,OAAOV,KAaTzB,WACE,MAAO,cAAcyB,KAAKY,eA2ERC,UAAkCF,EAOtDpC,YAAYkC,GACVK,MAASL,EAAIG,KAAP,SAMRG,cACE,OAAOf,KAYTzB,KAAgCyC,GAE9B,MAAMC,OAAEA,EAAMC,KAAEA,GAASF,EAEzB,OAAOC,EAAOE,QAAQD,GAAQF,EAAKI,UAAU,IAAMF,GAAQA,SCvKlDG,UAAwBC,MAanC/C,YAAYkC,EAAgCc,EAAU,8BAA8Bd,GAClFK,MAAMS,GACNvB,KAAKS,IAAMA,YCiOCe,EACZC,GAEF,GAkEF,SACIA,GAEF,MAAO,OAAQA,EArEXC,CAAWD,GAAO,CACpB,IAAKE,EAA+BF,GAClC,OAAOA,EAGT,MAAMG,EAAEA,EAACC,GAAEA,EAAIC,KAAMC,GAASN,EAE9B,MAAO,CACLG,EAAAA,EACAC,GAAeG,GACNH,KAAME,EAAKE,IAAIC,GAAOF,EAAQlF,IAAIoF,MAI/C,GA2FF,SACIT,GAEF,MAAO,OAAQA,EA9FXU,CAAsBV,GAAO,CAE/B,MAAMG,EAAEA,EAAGQ,GAAI5F,GAAUiF,EAEzB,MAAO,CACLG,EAAAA,EACAC,GAAIlF,EAAcH,IAGtB,GA2FF,SACIiF,GAEF,MAAO,QAASA,EA9FZY,CAASZ,GAAO,CAElB,MAAMG,EAAEA,EAACU,IAAEA,GAAQb,EAEnB,MAAO,CACLG,EAAAA,EACAC,GAAGU,GACMA,EAAIzF,IAAIwF,IAIrB,GAyCF,SACIb,GAEF,MAAO,OAAQA,EA5CXe,CAAiCf,GAAO,CAI1C,GA8CJ,SACIA,GAEF,QAAS,MAAOA,GApDVgB,CAAmChB,KACrCA,EAyDN,SACIA,GAEF,OAAOiB,+BACFjB,IACHG,EAAGH,EAAKkB,KA9DCC,CAAanB,KAEjBE,EAA+BF,GAAO,CAEzC,MAAQkB,GAAIE,GAASpB,EAErB,MAAO,CACLG,EAAGH,EAAKG,EACRC,GAAGU,GACM,IAAIM,EAAKN,IAKtB,MAAQI,GAAIG,EAAShB,KAAMC,GAASN,EAEpC,MAAO,CACLG,EAAGH,EAAKG,EACRC,GAAeG,GACN,IAAIc,KAAWf,EAAKE,IAAIC,GAAOF,EAAQlF,IAAIoF,MAKxD,MAAM,IAAIa,UAAU,sCAAsCC,KAAKC,UAAUxB,IA6E3E,SAASE,EACLF,GAEF,MAAO,SAAUA,QC7XGyB,SCgBTC,EAmBX5E,YAAY6E,GAbKpD,YAAS,IAAIqD,IAe1BrD,KAAKsD,SADQ,MAAXF,EACc3G,EACY,mBAAZ2G,EACAA,EAEArC,GAAWqC,EAAQtG,IAAIiE,GAc3CxC,QAAuCkD,GAErC,MAAQG,GAAKrD,CAACmC,IAAqBK,QAAEA,IAAWc,GAAEA,GAAOL,EAAiBC,IACnER,GAAUjB,KAAKuD,SAAoBxC,GAE1C,OAAOE,EAAOuC,QAAQ3B,GAMhBtD,SAAoBwC,GAE1B,MAAM0C,EAA6CzD,KAAK0D,OAAO5G,IAAIiE,GAEnE,GAAI0C,EACF,OAAOA,EAGT,MAAMxC,EAAwCF,EAAQE,SAEhD0C,EAAmC,CAAC1C,EADFe,GAAWf,EAAOC,KAAKc,EAAShC,KAAKsD,SAASvC,EAASiB,KAK/F,OAFAhC,KAAK0D,OAAOE,IAAI7C,EAAS4C,GAElBA,EAWTpF,KAAgByD,EAAcvB,GAE5B,OAASoD,GAAW7D,KAAKuD,SAAS9C,GAElC,OAAOoD,EAAQ7B,GAWjBzD,OAAOyD,EAAc8B,GACnB,OAAO9D,KAAK+D,UAAUD,GAAOhH,IAAIkH,KAAKhC,GAUxCzD,UAAUuF,GAAQ,GAChB,IAAKA,GAAS9D,KAAKiE,iBACjB,OAAOjE,KAAKiE,iBAGd,MAAMjH,EAAS,IAAIqG,IACba,EAAWlE,KAEjB,MAAMmE,UAAejB,EAEnB3E,KAEMA,CAACmC,GAAqBD,GACxBO,GAGF,MACMoD,EAA4BpH,EAAOF,IAAI2D,GAE7C,GAAc,MAAV2D,EACF,OAAOA,EAGT,MAAOC,EAAaC,GAiBxB,SACItC,EACAvB,EACAO,GAGF,MAAOC,EAAQC,GAoCjB,SACIc,EACAvB,GAGF,MAAMM,QAAEA,GAAYN,GACbQ,EAAQ4C,GAAWK,EAASX,SAASxC,GAE5C,GAAIA,IAAYN,EAGd,MAAO,CAACQ,EAAQe,EAAQlF,IAAIiE,IAG9B,MAAO,CAACE,EAAQ4C,EAAQ7B,IAlDDuC,CAAoBvC,EAASvB,GACpD,IAAI6D,GAAc,EAElB,MAAME,EAEF,CACFxC,QAAAA,EACAf,OAAAA,EACAC,KAAAA,EACAE,UAAYJ,GAAQ,OAAQA,EACtB,KACAsD,GAAc,EACPtD,EAAKyD,IAEZC,IAEA,MAAMC,EAAeD,IAErB,GAAoB,MAAhBC,EACF,MAAM,IAAItD,EAAgBZ,GAG5B,OAAOkE,IAIX3D,GAAQ,OAAQA,IAClBwD,EAAUC,GAAKzD,EAAKyD,IAGtB,MAAO,CACLhE,EAAImE,KAAKJ,GACTF,GAvDmCO,CAPnB7E,KAOsCS,EAAKO,GAM3D,OAJI8C,IAAUQ,GACZtH,EAAO4G,IAAInD,EAAK4D,GAGXA,GAKX,OAAKP,EAIE,IAAIK,EAHFnE,KAAKiE,iBAAmB,IAAIE,EAwEvC5F,OAAOuG,GACL,OAAO,IAAI3B,EAAgB,CAAY1C,EAAgCuB,KAErE,MAAOf,EAAQ4C,GAAW7D,KAAKuD,SAAS9C,GAExC,OAAOQ,EAAO8D,QAAQlB,EAAQ7B,GAAU8C,EAAM5D,KAAKc,EAASvB,GAAMuB,MClOxE,MAAMgD,EAANzG,cAEmByB,gBAA+C,GAEhEzB,QAAQ1B,GAEN,OADAmD,KAAKiF,WAAWC,KAAKrI,GACd,KAEL,MAAM4G,EAAQzD,KAAKiF,WAAWE,QAAQtI,GAElC4G,GAAS,GACXzD,KAAKiF,WAAWG,OAAO3B,EAAO,IAKpClF,KAAKyD,EAAcoB,aRgBnB,OAAOrD,EQhBqCsF,IAC1C,OAAO9F,EAAU,CACf6D,EACAkC,EAActD,EAAShC,KAAKiF,cAIhC1G,QAAQ2C,GACN,OAAOtC,EAASsC,GAGlB3C,QAAQgH,EAAsBC,GAC5B,OAAOjG,EAAU,CAACgG,EAAOC,KAQ7B,MAAMC,UAA8B5E,EAElCtC,SACE,OAAO,IAAIyG,SAeOU,UAAgD/E,EAUpEpC,YAAYqC,EAAcG,GACxBD,MAAMF,GACNZ,KAAKe,QAAUA,GAAW,IAAI0E,EAAiBzF,OAQnD,SAASsF,EACLtD,EACA2D,GAEF,OAAOvG,EACHK,EACIkG,EAAU1D,IAAIpF,GAAYD,EAAUC,EAASmH,UAAK4B,EAAW5D,KAC7DnF,GAAYA,KAEhBH,SCrEOmJ,UACDH,EAeVnH,YACIqC,GACAG,QACEA,EAAOK,UACPA,EAAYrE,KAIV,IAEN+D,MAAMF,EAAMG,GACZf,KAAKoB,UAAYA,EAGnB7C,KACIyC,GAGF,MAAM3D,EAASyI,MAAMC,KAAK/E,EAAKE,MAE/B,OAAI7D,EAAOwC,OACFxC,EAGF2D,EAAKI,UAAU,KAEpB,MAAM4E,EAAiBhG,KAAKoB,UAAUJ,EAAKgB,QAAShC,MAEpD,GAAIgG,EACF,OAAOF,MAAMC,KAAKC,MC5D1B,MAAMC,EAAN1H,cAGmByB,gBAA+C,GAEhEzB,QAAQ1B,GAEN,OADAmD,KAAKiF,WAAWiB,QAAQrJ,GACjB,KAEL,MAAM4G,EAAQzD,KAAKiF,WAAWkB,YAAYtJ,GAEtC4G,GAAS,GACXzD,KAAKiF,WAAWG,OAAO3B,EAAO,IAKpClF,KAAKyD,EAAcoB,GAEjB,MAAMvD,OAAEA,GAAWG,KAAKiF,WAExB,IAAKpF,EACH,OAAOuD,GAAW3G,EAGpB,MAAM2J,EAAYvJ,GAAyED,EACvFC,EAASmH,UAAK4B,EAAW5D,IAG7B,IAAKoB,GAAsB,IAAXvD,EACd,OAAOuG,EAASpG,KAAKiF,WAAW,IAGlC,MAAMoB,EAAsCrG,KAAKiF,WAAWhD,IAAImE,GAMhE,OAJIhD,GACFiD,EAAMnB,KAAK9B,GAGNkD,EAAmBD,GAG5B9H,QAAQ2C,GACN,OAAiB,MAAVA,IAGT3C,QACIgH,EACAC,GAEF,OAAID,IAAU9I,EACL+I,EAELA,IAAW/I,EACN8I,EAEFe,EAAmB,CAACd,EAAQD,KAQvC,SAASe,EACLD,GAEF,OAAOzJ,EAAU,KACf,IAAK,MAAMsE,KAAQmF,EAAO,CAExB,MAAM7J,EAAQ0E,IAEd,GAAa,MAAT1E,EACF,OAAOA,KAUf,MAAM+J,UAA2B1F,EAE/BtC,SACE,OAAO,IAAI0H,SAeOO,UAA6C7F,EAUjEpC,YAAYqC,EAAcG,GACxBD,MAAMF,GACNZ,KAAKe,QAAUA,GAAW,IAAIwF,EAAcvG,aCtGnCyG,UACDD,EAgBVjI,YACIqC,GACAG,QACEA,EAAOK,UACPA,EAAY3E,GAIV,IAENqE,MAAMF,EAAMG,GACZf,KAAKoB,UAAYA,EAGnB7C,KACIyC,GAGF,MAAMxE,EAAQwE,EAAKE,OAEnB,OAAa,MAAT1E,EACKA,EAGFwE,EAAKI,UAAU,IAAMpB,KAAKoB,UAAUJ,EAAKgB,QAAShC,cCtDhD0G,EAAoCxJ,OAAO,wBA0CxCyJ,EAA+BnK,GAC7C,OAAOkK,KAAsBlK,QC3ClBoK,EAAqC1J,OAAO,uBAW5C2J,EAYXtI,YAAYuI,EAA0CrK,GACpDuD,KAAK+G,KAAOC,IACVhH,KAAKiH,SAAWC,GAAYA,EAASF,GACrChH,KAAK+G,KAAOtK,EACZqK,EAAIE,IAENhH,KAAKiH,SAAWC,IAEd,MAAMC,EAAOnH,KAAK+G,KAElB/G,KAAK+G,KAAOC,IACVG,EAAKH,GACLE,EAASF,KAUfI,YACE,OAAOpH,KAAK+G,OAAStK,EAMvBmK,IAAKA,KACH,OAAO5G,KAaTzB,IAAIyI,GAEF,OADAhH,KAAK+G,KAAKC,GACHhH,KAYTzB,QAAQ2I,GAEN,OADAlH,KAAKiH,SAASC,GACPlH,KAcTzB,KAAK8I,GAEH,OADAC,EAAcD,GAASE,MAAMvH,MACtBA,KAYTzB,MAAM8I,GAEJ,OADAC,EAAcD,GAASG,QAAQR,GAAUhH,KAAK+G,KAAKC,IAC5ChH,eA+BKsH,EAAcG,GAC5B,OAAOA,EAAKb,YAUEc,EAAYZ,GAC1B,OAAO,IAAID,EAAYC,YC1CTa,EAA+BC,GAE7C,IAAIC,EA6BJ,OAvBEA,EADsB,mBAAbD,EACC,CACRE,OAAQJ,IACRnJ,QAAQwJ,KAAaC,GACnBJ,KAAYI,KAIN,CACRF,OAAQF,EAASE,QAAUJ,IAC3BnJ,QAAQyD,KAAYgG,GACbhI,KAAK8H,OAAOV,OAGfQ,EAASK,QAAQjG,KAAYgG,KAQrCH,EAAQC,OAAON,QAAQ,IAAMK,EAAQI,QAAUxL,GAExCoL,WCjJOK,EACZC,GAGF,IAAIC,EAIJ,SAASC,EAAiBL,GAExB,IAAIM,EAAkBH,EACtB,MAAMI,EAAgB,GAEtBH,EAAQI,GAAiBD,EAASrD,KAAKsD,GAEvC,IACE,OAAU,CACRF,EAAkBG,GAAaH,EAAiBN,GAEhD,MAAMQ,EAAYD,EAASG,QAE3B,IAAKF,EACH,MAGFR,EAAQQ,WAGVJ,EAAOC,IAtBX,MAAO,IAAIL,IAAUI,EAAKJ,GA2B5B,SAASS,GACLN,EACAH,GAGF,MAAMW,EAAiD,GAEvD,IAAK,MAAMf,KAAYO,EAAW,CAEhC,MAAMS,EAAMD,EAAmB9I,OAE/B8I,EAAmBzD,KAAK0C,GAExB,MAAM5F,EAAoC,CACxCzD,YAAYsK,GACVF,EAAmBC,GAAOjB,EAAc,CACtCG,OAAQF,EAASE,OACjBvJ,QAAQwJ,KAAae,GACnBD,KAAqBC,QAM7BlB,EAASK,QAAQjG,KAAYgG,GAG/B,OAAOW,QCnDII,GAgBXxK,cAEE,MAAMyK,EAAMhJ,KAAKiJ,KAAO,IAAIC,IAE5BlJ,KAAKoI,KAAOF,EAAcc,GAC1BhJ,KAAK4G,GAAuBc,EAAY,KACtCsB,EAAIG,eACGnJ,KAAKiJ,OAOhBG,WACE,OAAOpJ,KAAKiJ,KAAOjJ,KAAKiJ,KAAKG,KAAO,EActC7K,GAAGqJ,GAED,MAAMC,EAAUF,EAAcC,GACxBE,EAASD,EAAQC,OAAOP,MAAMvH,OAC9BiJ,KAAEA,GAASjJ,KAOjB,OALIiJ,IAASnB,EAAOV,QAClB6B,EAAKI,IAAIxB,GACTC,EAAON,QAAQ,IAAMyB,EAAKK,OAAOzB,KAG5BC,EAaTvJ,KAAKyI,GAEH,OADAM,EAActH,MAAM8G,IAAIE,GACjBhH,YC/EEuJ,GAAiCrM,OAAO,qBAyCrCsM,GAA+BhN,GAC7C,OAAO+M,MAAmB/M,EC5C5B,MAAMiN,WAAiB5C,EAErBO,YACE,OAAO,EAGT7I,MACE,OAAOyB,KAGTzB,QAAQ2I,GAEN,OADAA,IACOlH,KAGTzB,KAAK8I,GAEH,OADAC,EAAcD,GAASP,MAChB9G,KAGTzB,QACE,OAAOyB,MAQX,MAAM0J,OAA8BD,YASpBE,KACd,OAAOD,YC9BOE,GAA8BhC,GAE5C,MAAMC,EAAUF,EAAcC,GAC9B,IAAIQ,EAA8BF,EAAc,CAACL,IAIjD,OAFAA,EAAQC,OAAON,QAAQ,IAAMY,EAAO3L,GAE7B,IAAIuL,IAAUI,KAAQJ,YCnBf6B,GACZC,GAEF,OAAOlC,GAAYkC,EAASC,GAAG,CAC7BjC,OAAQF,EAASE,OACjBG,QAAS,CAACjG,KAAYgG,KACpBJ,EAASK,QAAQjG,KAAYgG,GAC7BJ,EAASE,OAAOhB,kBCPNkD,GACZF,GAGF,MAAMG,EAAS,IAAIlB,GACnB,IAAImB,EACAC,EAEJ,OAAOvC,IA+BL,GA9BKqC,EAAOb,OACVe,EAAgB,GAChBD,EAAexC,EAAY,IAAMyC,OAAgBvE,GAEjDkE,EAASC,GAAG,CACVjC,OAAQoC,EACR3L,QAAQ6L,KAASpC,GACXmC,IACEF,EAAOb,KAGTe,OAAgBvE,EAIhBuE,EAAcjF,KAAK8C,IAGvBiC,EAAO7B,QAAQJ,OAKrBJ,EAASE,OAAOP,MAAM2C,GACtBD,EAAOI,GAAGzC,GAAUJ,QAASR,IACtBiD,EAAOb,MACVc,EAAapD,IAAIE,KAIjBmD,EAAe,CAGjB,MAAMG,EAAWV,GAAahC,GAE9BuC,EAAcI,QAAQvC,GAASsC,KAAYtC,eC1CjCwC,GACZV,EACAW,GAQF,OAAQ7C,IAEN,MAAM8C,EAAuB,GAE7BZ,EAASC,GAAG,CACVjC,OAAQF,EAASE,OACjBvJ,QAAQyD,KAAYgG,GAElB,MAAM1K,EAAQ,CAACqN,EAAeC,KAE5B,MAAMC,EAAWF,GAASF,EAAO5K,SAE/B8K,EAEF,MAAMG,EAAWJ,EAAOC,GAExB,GAAIG,EAAU,CAEZ,MAAMC,EAAaD,EAAShD,OAI5B,OAFAgD,EAAShD,OAAS8C,EAEX,CAACE,EAASxN,MAAOyN,GAG1B,MAAMrN,EAAOiN,EAAQF,EAAO5K,OAAS4K,EAAOE,GAASlO,EAE/CuO,EAAoB,CACxB1N,MAAO,CACLiB,KAAsBhB,EAAyBK,GAC7CqN,EAAa1N,KAAMK,GAAOA,IAE5BW,KAAQhB,EAAqBE,GAC3BwN,EAAa1N,EAAGE,GAAM,CAACA,KAEzBc,OACEyM,EAAMlD,OAAOhB,OAEfvI,QACIb,EACAwN,GAGF,MAAMpD,EAASJ,IAAcH,MAAMyD,EAAMlD,QAEzCoD,EAAO3B,MAAmBQ,GAAG,CAC3BjC,OAAAA,EACAvJ,QAAQwJ,KAAaC,GACnBiD,EAAavN,KAAQsK,GAAQA,EAAOF,QAK5CA,OAAQ8C,GAKV,OAFAF,EAAOC,GAASK,EAET,CAACA,EAAM1N,MAAOqM,MAErB,SAASsB,EACLE,EACAvN,EACAwN,EAAeJ,EAAMlD,QAGvB,MAAOuD,EAAWN,GAAczN,EAAMqN,EAAOjD,IAAcH,MAAM6D,IAEjE,I7BEe,mBAFvBlL,E6BCyBiL,I7BCYlO,KAAoBiD,E6BA7CiL,EAAWlO,GAAkBoO,EAAW3N,GAC/BmN,EACTjD,EAASK,QAAQjG,KAAYpE,GAE7ByN,EAAU3N,KAAKA,EAAMyN,WAGvBJ,EAAWjE,U7BTrB5G,K6BcWoL,EAAYP,GAAczN,EAAM,EAAGoK,IAAcH,MAAMK,EAASE,SAEvE,IACEwD,EAAWzN,KAAK4M,EAAO,GAAIzC,WAE3B+C,EAAWjE,oBCnGLyE,GACZzB,EACA0B,EACAC,GAEF,OAAO7D,IACD6D,EACF3B,EAASC,GAAG,CACVjC,OAAQJ,IAAcH,MAAMiE,GAAUE,KAAKD,GAC3CxD,QAAUL,EAASK,QAAqBjE,KAAK4D,MAG/CA,EAASE,OAAOP,MAAMiE,GACtB1B,EAASC,GAAGnC,cCPF+D,IAAa7D,OAAEA,IAC7BA,EAAOhB,YCkBI8E,GAcXrN,YAAY8L,GACVrK,KAAK6L,IAAMxB,EAQbyB,QACE,OAAO9L,KAAK+J,GAAG/F,KAAKhE,MAGtBzB,CAACgL,MACC,OAAOvJ,KA6BTzB,GAAGqJ,GACD,IAAKA,EACH,OAAO5H,KAGT,MAAM6H,EAAUF,EAAcC,IACxBE,OAAEA,GAAWD,EAMnB,OAJKC,EAAOV,OACVpH,KAAK6L,IAAIhE,GAGJC,EAcTvJ,KACIwN,EACAC,GAEF,gBCjHAlC,EACAiC,EACAC,GAEF,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAC3BtC,GAAKC,EAALD,CAAe,CACb/B,OACMJ,EADEsE,EACUhF,IACZ,IACEkF,EAAQF,EAAShF,IACjB,MAAOoF,GACPD,EAAOC,KAGGD,GAClBlE,QAAS8D,EACH,CAAC3B,KAASpC,KACV,IACEkE,EAAQH,KAAW/D,IACnB,MAAOoE,GACPD,EAAOC,MAGPhC,EAAgCpC,IAAgBkE,EAAQlE,OD0F3DqE,CAAKrM,KAAM+L,EAASC,GAoB7BzN,KAAKqJ,GACH,OAAQ5H,KAAK6J,KAAOyC,GAAUzC,GAAK7J,OAAO8L,GAAGlE,GAc/CrJ,QAAQiN,EAA2BC,GACjC,OAAOa,GAAUf,GAAQvL,KAAMwL,EAAUC,IAW3ClN,QAAQgO,GAEN,IAAIC,EAAiB7C,KAGrB,MAAM7B,EAASJ,EAAYV,GAAUwF,EAAe1F,IAAIE,IAkBxD,OAhBAhH,KAAK+J,GAAG,CACNjC,OAAAA,EACAvJ,QAAQ6L,KAASpC,GAEf,MAAM+C,EAAayB,EAEnB,IACEA,EAAiBlF,EAAciF,KAAWvE,IAAU2B,cAEhD6C,IAAmBzB,GACrBA,EAAWjE,UAMZgB,EAYTvJ,QACE,OAAO+N,GAAUtC,GAAMhK,OAsPzBzB,QAAQkM,GACN,OAAQzK,KAAayM,SAAShC,GAAQT,QAuPxCzL,SAASkM,GACP,OAAO6B,GAAU9B,GAAKxK,KAAMyK,cAmEhB6B,GACZI,GAEF,OAAO,IAAId,GAAQc,GE1uBrB,SAASC,KACP,MAAM,IAAIrL,MAAM,2BAcLsL,WAAoChB,GA2B/CrN,YACI8L,EACA5F,EAAwBkI,IAE1B7L,MAAMuJ,GArBArK,UAAO,EAsBbA,KAAK6M,IAAMpI,EAQbqH,QACE,OAAO9L,KAAK+J,GAAG/F,KAAKhE,MAGtBzB,CAACmI,KACC,OAAO1G,KA6BTzB,GAAGqJ,GACD,IAAKA,EACH,OAAO5H,KAGT,IAAI8M,EAAiErQ,EACrE,MAAMoL,EAAUF,EAAcC,GAE9B,GAAIC,EAAQC,OAAOV,MACjB,OAAOS,EAAQC,OAGjB,MAAMA,EAASJ,IAAcH,MAAMM,EAAQC,QAC3C,IAAIiF,GAAW,EA+Bf,OA7BA/M,KAAK6L,IAAI,CACP/D,OAAAA,EACAG,QAAS,CAACjG,KAAYgG,KACpB+E,GAAW,EACX/M,KAAKgN,MAAQhF,EACb8E,EAAK9K,KAAYgG,QAGnBhI,KAAKiN,KAEFnF,EAAOV,QAAS2F,IACnBlF,EAAQI,QACJ,CACE1J,YAAYiK,GACVsE,EAAO,CAAC/E,KAAaC,IAAUQ,KAAaR,QAG5ChI,KAAKgN,QAAUhN,KAAKgN,MAAQhN,KAAK6M,QAEzCC,EAAO,CAAC9K,KAAYgG,IAAUH,EAAQI,QAAQjG,KAAYgG,IAG5DF,EAAON,QAAQR,MACNhH,KAAKiN,OACVjN,KAAKgN,WAAQpH,GAEfiC,EAAQC,OAAOhB,IAAIE,KAGdc,EAoBTvJ,KAAKqJ,GACH,OAAQ5H,KAAK6J,KAAOqD,GAAarD,GAAK7J,OAAO8L,GAAGlE,GAclDrJ,QAAQiN,EAA2BC,GACjC,OAAOyB,GAAa3B,GAAQvL,KAAMwL,EAAUC,IAY9ClN,QACE,OAAO2O,GAAalD,GAAMhK,OA0P5BzB,YAAYkM,GACV,OAAQzK,KAAamN,aAAa1C,GAAQT,QAuP5CzL,aAAakM,GACX,OAAOyC,GAAa1C,GAAKxK,KAAMyK,cAuEnByC,GACZR,EACAU,GAEF,OAAO,IAAIR,GAAWF,EAAUU,YCnvBlBC,GACZnC,EACAkC,GAEF,OAAOF,GAAatF,GAAYsD,EAAO3B,MAAmBQ,GAAGnC,GAAWwF,YCa1DE,GACZC,EACAH,GAEF,OAAOzG,EAAc4G,GAAYA,EAAS7G,KAAwB2G,GAAUE,EAAUH,YCvBxEI,GACZC,GAGF,MAAMnN,EAAOoC,OAAOpC,KAAKmN,GAEzB,OAAOP,IAEP,SACItF,GAGF,MAAME,OAAEA,GAAWF,EACb0C,EAAWV,GAAahC,GAC9B,IAAIQ,EAAmB3L,EACvB,MAAMY,EAAsD,GAE5DiD,EAAKiK,QAAS9J,IACZqH,EAAOP,MAAMkG,EAAQhN,GAAKiG,KAAsBqD,GAAG,IAAI/B,KACrD3K,EAAOoD,GAAOuH,EACdI,MACCb,MAAMO,MAGNA,EAAOV,QACVgB,EAAO,IAAMkC,EAASjN,OAI1B,WAEE,MAAMA,EAAsD,GAQ5D,OANAiD,EAAKiK,QACD9J,GAAO6M,GAAcG,EAAQhN,IAAMoJ,KAC/B,IAAI7B,IAAU3K,EAAOoD,GAAkBuH,IAIxC,CAAC3K,MAjCyC2M,iBCNrC0D,MAA8BD,GAE5C,OAAOP,IAEP,SAA0BtF,GAExB,MAAME,OAAEA,GAAWF,EACb0C,EAAWV,GAAahC,GAC9B,IAAIQ,EAAmB3L,EACvB,MAAMY,EAAc,GAEpBoQ,EAAQlD,QAAQ,CAAClL,EAAQsL,KACvB7C,EAAOP,MAAMlI,EAAOqH,KAAsBqD,GAAG,IAAI/B,KAC/C3K,EAAOsN,GAAS3C,EAChBI,MACCb,MAAMO,MAGNA,EAAOV,QACVgB,EAAO,IAAMkC,KAAYjN,OAI7B,WAEE,MAAMA,EAAc,GAQpB,OANAoQ,EAAQlD,QACJlL,GAAUiO,GAAcjO,GAAQwK,KAC5B,IAAI7B,IAAU3K,EAAO6H,KAAK8C,KAI3B3K,KA/B0C2M,iBCNrC2D,MAA6B3F,GAC3C,OAAOkF,GAAazQ,EAAME,EAAcqL,aCQ1B4F,GACZC,GAEF,OAAO1Q,EAAS,CAACG,EAAOI,IAASJ,EAAMyO,QAAQrO,EAAM4P,GAAcO,WCZxDC,WAAsC/E,GAOjDxK,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKiC,GAAa1E,GAAY9G,MAAMuJ,GAAGzC,IAAWkE,GAAGlE,GAGpErJ,CAACgL,MACC,OAAOvJ,KAAKqK,YCfH0D,GAAuCzB,GAAUX,aCI9CqC,GAA4BT,GAC1C,OAAO/D,GAAc+D,GAAYA,EAAShE,MAAqBgE,EAAS7G,cCG1DuH,MAA0BC,GACxC,OAAKA,EAAUrO,OAIRyM,GAAa1E,IAElB,MAAME,OAAEA,GAAWF,EACnB,IAAIuG,EAAWD,EAAUrO,OACzB,MAAMuO,EAAkBpH,MACfmH,GACLrG,EAAOhB,IAAIE,IAGTiB,EAAU,CAACjG,KAAsCgG,KACrDJ,EAASK,QAAQjG,KAAYgG,IAG/BkG,EAAU3D,QACNgD,GAAYS,GAAWT,GAAUxD,GAAG,CAClCjC,OAAQJ,EAAY0G,GAAgB7G,MAAMO,GAC1CG,QAAAA,OAGL+B,QAtBM+D,YCIKM,GAAWtI,GACzB,OAAOuG,GAAU1E,IAEf,MAAME,OAAEA,GAAWF,EACb0C,EAAWV,GAAahC,GAExB0G,EAAe5G,IACrB,IAAI6G,EAAe,EACnB,MAAMlP,EAAS2O,GAAWjI,GACrBwF,QAAQzD,EAAQwG,GAChB7B,MAAMzE,MACHuG,EACK/Q,EAAQwK,KAErB,IAAIO,EAAgB,GAChBiG,EAAU,EACVC,EAAc,EAElBH,EAAa9G,QAAQR,IACduH,GACHzG,EAAOhB,IAAIE,cCvBWjB,GAC5B,OAAOuG,GAAU1E,IAEf,MAAME,OAAEA,GAAWF,EACb0C,EAAWV,GAAahC,GAE9B,IAAI8G,EAAY,EAEhB3I,EAAKwD,MAAmBQ,GAAG,CACzBjC,OAAAA,EACAvJ,QAAQ6L,EAAMuE,GAEZ,MAAMhE,IAAU+D,EAEhBzC,QAAQC,UACHG,KAAK,IAAMsC,GACXtC,KACGrE,GAASsC,EAAStC,EAAO2C,GACzB3D,GAAUc,EAAOhB,IAAIE,SDSjC4H,CAAWvP,GAAQ0K,GAAG,CACpBjC,OAAAA,EACAvJ,QAAQ6L,EAAMpC,EAAO2C,GAEnB,MAAM/K,EAAI+K,EAAQ6D,EAIlB,GAFAjG,EAAS3I,GAAKoI,IACZyG,EACEA,EAAc7O,EAAG,CAEnB,IAAIiP,EAEAJ,IAAgBlG,EAAS1I,QAE3BgP,EAAStG,EACTA,EAAW,IAGXsG,EAAStG,EAASnD,OAAO,EAAGxF,EAAI,GAElC4O,GAAWK,EAAOhP,OAClB4O,GAAeI,EAAOhP,OACtB0O,GAAgBM,EAAOhP,OAEvByK,KAAauE,IACRN,GAAgBD,EAAalH,OAChCQ,EAASE,OAAOP,MAAM+G,kBEvDlBQ,GAAaH,GAE3B,IAAI1G,EAAWL,IACb+G,EAAQtC,KAAK,IAAMpE,EAAQL,GAAW,IAAMK,EAAQL,KAStD,OANA+G,EAAQtC,KAAK7P,IACXyL,WCtBkCzL,GACpC,OAAOoL,IACL,IACEgC,GAAahC,EAAbgC,CAAuBpN,GACvBoL,EAASE,OAAOhB,MAChB,MAAOsF,GACPxE,EAASE,OAAOhB,IAAIsF,KDgBZ2C,CAAmBvS,KAC5BwS,MAAM5C,QhBxByBpF,EAAAA,EgByBFoF,EAA9BnE,EhBxBK,EAAGH,OAAAA,KAAaA,EAAOhB,IAAIE,KgB2B3BsF,GAAU1E,GAAYK,EAAQL,aEcvBqH,GAAUC,GACxB,OAAOpJ,MAAMqJ,QAAQD,GAAQA,EAAO,CAACA,GCpCvC,MAAME,GAKJ7Q,YAA6B8Q,GAAArP,WAAAqP,EAHpBrP,aAAU,IAAI8N,GACN9N,aAAU,IAAIqD,IAG7BrD,KAAKsP,QAAQjF,GAAG,CAAC6E,EAAMK,EAAUC,KAE/B,MAAM/O,EAAMyO,EAAK,GACXO,EAASzP,KAAK0P,QAAQ5S,IAAI2D,GAE5BgP,GACFA,EAAOH,QAAQlH,KAAK8G,EAAKS,MAAM,GAAIJ,EAAUC,KAKnDjR,GAAGqJ,GAED,MAAME,EAAS9H,KAAKsP,QAAQjF,GAAGzC,GAE/B,OAAOF,EAAYV,IACjBc,EAAOhB,IAAIE,GACXhH,KAAK4P,iBACJrI,MAAMO,GASXvJ,KAAKkC,EAAkBoP,GAErB,MAAMpM,EAAQzD,KAAK0P,QAAQ5S,IAAI2D,GAE/B,GAAIgD,GAASoM,EACX,OAAOpM,EAGT,MAAMqM,EAAU,IAAIV,GAAU,IAAMpP,KAAK+P,QAAQtP,IAIjD,OAFAT,KAAK0P,QAAQ9L,IAAInD,EAAKqP,GAEfA,EAGTvR,KAAKyI,GACH,IAAK,MAAMyI,KAAUzP,KAAK0P,QAAQ1S,SAChCyS,EAAO3Q,KAAKkI,GAEdhH,KAAKsP,QAAQxQ,KAAKkI,GAGZzI,QAAQkC,GACdT,KAAK0P,QAAQpG,OAAO7I,GACpBT,KAAK4P,eAGCrR,gBACDyB,KAAK0P,QAAQtG,MAAQpJ,KAAKsP,QAAQlG,MAAQ,GAC7CpJ,KAAKqP,SAMX,MAAMW,GAANzR,cAEmByB,WAAQ,IAAIoP,GAAU3S,GAEvC8B,GAAG2Q,EAA4BtH,GAC7B,OAAO5H,KAAKiQ,OAAOf,GAAM7E,GAAGzC,GAG9BrJ,KAAQ2Q,EAA4BK,EAAaC,GAC/CxP,KAAKkQ,MAAMZ,QAAQlH,KAAK8G,EAAMK,EAAUC,GAG1CjR,KAAK2Q,EAA4BlI,GAE/B,MAAMgE,EAAQhL,KAAKiQ,OAAOf,GAAM,GAE5BlE,GACFA,EAAMlM,KAAKkI,GAQPzI,OAAO2Q,EAA4BW,GAEzC,IAAI7E,EAAQhL,KAAKkQ,MAEjB,IAAK,MAAMzP,KAAOyO,EAAM,CAEtB,MAAMO,EAASzE,EAAMmF,KAAK1P,EAAKoP,GAE/B,IAAKJ,EACH,OAGFzE,EAAQyE,EAGV,OAAOzE,GAKX,MAAMoF,GASJ7R,YAA6B8R,EAAsCC,GAAtCtQ,eAAAqQ,EAAsCrQ,WAAAsQ,EACjEtQ,KAAKuQ,OAAS,CAAIrB,EAAiBK,EAAaC,KAC9CxP,KAAKqQ,UAAUjI,KAAK,IAAIpI,KAAKsQ,SAAUrB,GAAUC,IAAQK,EAAUC,IAIvEgB,eACE,OAAOxQ,KAKTzB,SAASqJ,GACP,OAAQ5H,KAAKyQ,SAAWnE,GACpB1E,GAAY5H,KAAKqQ,UAAUhG,GAAGrK,KAAKsQ,MAAO1I,IAC5CkE,GAAuBlE,GAG3BrJ,CAACgL,MACC,OAAOvJ,KAAKyQ,WAGdlS,MAAM2Q,GAEJ,OADAA,EAAOD,GAAUC,IACPrP,OAGH,IAAIuQ,GAAgBpQ,KAAKqQ,UAAW,IAAIrQ,KAAKsQ,SAAUpB,IAFrDlP,KAKXzB,KAAKyI,GACHhH,KAAKqQ,UAAUvR,KAAKkB,KAAKsQ,MAAOtJ,UAevB0J,GAAbnS,cAKWyB,cAA4B,IAAIoQ,GAAgB,IAAIJ,GAAY,IAsBzEzR,SAASqJ,GACP,OAAQ5H,KAAKyQ,SAAWzQ,KAAKwQ,SAASC,WAAW3E,GAAGlE,GAGtDrJ,CAACgL,MACC,OAAOvJ,KAAKyQ,WAcdF,aAME,OAAOvQ,KAAKwQ,SAASD,OAUvBhS,MAAM2Q,GAEJ,MAAMyB,EAAa3Q,KAAKwQ,SAASI,MAAM1B,GAEvC,OAAOyB,IAAe3Q,KAAKwQ,SAAWxQ,KAAO2Q,EAU/CpS,KAAKyI,GACHhH,KAAKwQ,SAAS1R,KAAKkI,UChOD6J,GAAtBtS,cAKUyB,SAAM2J,KAwCdpL,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAO5D,GAChBtF,IAAY5H,OAAAA,KAAKqK,GAsIhB,CACLvC,QAHAiJ,EApIwCnJ,GAuIlBE,OACtBvJ,QAAQyD,EAASuN,GACfwB,EAAc9I,QACV,CACE1J,YAAYsK,GACV7G,EAAQgP,YAAYC,GAAkBpI,EAAkBoI,MAG5D1B,MAZV,IACIwB,GAnII,IAAM,CAAC/Q,KAAKkR,KACdpF,GAAGlE,GAGPrJ,CAACgL,MACC,OAAOvJ,KAAKqK,KAGd9L,CAACmI,KACC,OAAO1G,KAAK8Q,OAiDdvS,GACIgP,EACA4D,GAGF,MAAMC,EAAoBlG,IAERvE,EAAcuE,GAAUA,EAAOxE,KAAwBwE,EAAO3B,OAE/DQ,GAAGvN,GAASwD,KAAKkR,GAAK1U,GAIvC,GADAwD,KAAKqR,SACAF,EAKE,CAEL,MAAMG,EAAY/D,EAElBvN,KAAKuR,IAAMvD,GAAWsD,GAAW/E,QAAQ,IAAIvE,KAE3C,MAAMkD,EAASiG,KAAWnJ,GAE1B,GAAIkD,EACF,OAAOkG,EAAiBlG,SAdhB,CAEZ,MAAMA,EAASqC,EAEfvN,KAAKuR,IAAMH,EAAiBlG,GAmB9B,OAFAlL,KAAKuR,IAAI/J,QAAQ,IAAMxH,KAAKuR,IAAM5H,MAE3B3J,KAYTzB,OAAOyI,GAEL,OADAhH,KAAKuR,IAAIzK,IAAIE,GACNhH,KAYTzB,KAAKyI,GAEH,OADAM,EAActH,MAAM8G,IAAIE,GACjBhH,MC/LX,MAAMwR,WAAwBX,GAI5BtS,YAAoBkT,GAClB3Q,QADkBd,SAAAyR,EAFHzR,SAAM,IAAI8N,GAM3BlH,IAAKA,KACH,OAAOU,EAActH,KAAK6L,KAK5BtN,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAK6L,IAAIxB,KAAKyB,GAAGlE,GAGrCsJ,SACE,OAAOlR,KAAKyR,IAGdP,OAAO1U,GAEL,MAAMgT,EAAWxP,KAAKyR,IAElBjC,IAAahT,IACfwD,KAAKyR,IAAMjV,EACXwD,KAAK6L,IAAIzD,KAAK5L,EAAOgT,cAyBXkC,GAActO,GAC5B,OAAO,IAAIoO,GAAgBpO,SCvChBuO,WAAqBd,GAYhCtS,YAAY6E,GACVtC,QARed,SAAM,IAAI8N,GASzB9N,KAAKyR,IAAMrO,EAKb7E,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAK6L,IAAIxB,KAAKyB,GAAGlE,GAGrChB,IAAKA,KACH,OAAOU,EAActH,KAAK6L,KAG5BqF,SACE,OAAOlR,KAAKyR,IAGdP,OAAO1U,GAEL,MAAMoV,EAAM5R,KAAKkR,GAEbU,IAAQpV,IACVwD,KAAKyR,IAAMjV,EACXwD,KAAK6L,IAAIzD,KAAK5L,EAAOoV,IAgEzBrT,KACIgH,EACAC,EAIAqM,GAGF,IACIxS,EACA8R,EAFAW,EAAmBC,GAA0CC,EAAahS,KAAM+R,GAI/D,iBAAVxM,GACK,OAAVA,IACFuM,EAAkBC,GAAWC,EAAaD,EAAS/R,OAErDX,EAASmG,EACT2L,EAAUU,IAEVxS,EAASkG,EACT4L,EAAU3L,GAGZ,MAAMyM,EAAiBd,EAEvB,IAAKc,EACH,OAAOH,EAAgBzS,GAGzB,MAAMkO,EAAWlO,EAEjB,OAAQsH,EAAc4G,GAAYD,GAAcC,GAAYS,GAAWT,IAAWhB,QAAQ,IAAIvE,KAE5F,MAAM+J,EAAUE,KAAkBjK,GAElC,OAAO+J,GAAWD,EAAgBC,KAGpC,SAASC,EAAaE,EAA2BC,GAE/C,MAAMC,EAAUF,EAASpB,KAAKtU,IAC5B2V,EAASjB,GAAK1U,IAEV6V,EAAUF,EAAS9H,GAAG7N,IAC1B0V,EAAShB,GAAK1U,IAGhB,OAAOkL,EAAYV,IACjBqL,EAAQvL,IAAIE,GACZoL,EAAQtL,IAAIE,KACXO,MAAM6K,GAAS7K,MAAM8K,WCvKRC,GAmBpB/T,KAAKqC,EAAqB2R,GACxB,GAAoB,iBAAT3R,EACT,OAAOA,EAGT,MAAO4R,EAAOC,GAAM7R,EAEpB,OAAO6R,EAAG7R,KAAK2R,EAAQE,GAAKD,EAAOxS,OC7BvC,MAAM0S,WAAsBJ,GAE1B/T,WAAWqC,EAAc+R,GACvB,MAAO,GAAGA,KAAS/R,WAYVgS,OAA6CF,GAS7CG,OAA0CH,GAKvD,MAAMI,WAAkBR,GAEtB/T,WAAWqC,EAAc+R,GACvB,MAAO,GAAGA,KAAS/R,WAqBVmS,OAAwCD,GAKrD,MAAME,WAAkBV,GAEtB/T,WAAWqC,EAAc+R,GACvB,MAAO,GAAG/R,KAAQ+R,WAYTM,OAAyCD,SCtEzCE,GA6BX3U,YAAY4U,KAAgBC,GAC1BpT,KAAKmT,IAAMA,EACXnT,KAAKoT,QAAUA,EAdjBT,YACE,OAAO3S,KAAKoT,QAAQ,IAAM,KA2B5B7U,KAAKoU,EAAe/R,EAAcyS,EAAiBT,IACjD,OAAOS,EAAOC,WAAW1S,EAAM+R,EAAO3S,gBCX1BuT,GAAgB/W,GAC9B,MAAwB,iBAAVA,YAjBmBA,GACjC,OAAOsJ,MAAMqJ,QAAQ3S,IACG,IAAjBA,EAAMqD,QACc,iBAAbrD,EAAM,IACbA,EAAM,aAAc0W,GAaSM,CAAmBhX,YA2DzCiX,GAAalO,EAAsBC,GACjD,GAAqB,iBAAVD,EACT,MAAsB,iBAAXC,EACFkO,GAAenO,EAAOC,GAE1BA,EAAO,GAAG2N,KAGP,EAFCO,GAAenO,EAAOC,EAAO,IAKxC,MAAOmO,GAAaR,IAAKS,IAAcrO,EAEvC,MAAsB,iBAAXC,EACJoO,EAGE,EAFEF,GAAeC,EAAWnO,GAK9BkO,GAAeE,EAAUpO,EAAO,GAAG2N,MAAQO,GAAeC,EAAWnO,EAAO,IAMrF,SAASkO,GAAenO,EAAeC,GACrC,OAAOD,EAAQC,GAAU,EAAID,EAAQC,EAAS,EAAI,WC3GpCqO,KAEd,MAAMC,EAAc,IAAIzQ,IAClB0Q,EAAgB,IAAI1Q,IAE1B,OAAO,SAAiBoP,GAEtB,MAAMhP,EAAQqQ,EAAYhX,IAAI2V,EAAGU,KAEjC,GAAI1P,EACF,OAAOA,EAGT,MAAMuQ,EAAgBvB,EAAGE,MACzB,IAAIsB,EAAkB,EAEtB,IAAK,MAAMC,IAAa,CAACF,KAAkBvB,EAAGW,SAAU,CAEtD,MAAMe,EAAMJ,EAAcjX,IAAIoX,GAE9B,IAAKC,EAGH,OAFAL,EAAYlQ,IAAI6O,EAAGU,IAAKe,GACxBH,EAAcnQ,IAAIsQ,EAAW,GACtBA,EAEJD,IAEHA,EAAkBE,GAItB,MAAMC,EAAYJ,KAAmBC,EAKrC,OAHAH,EAAYlQ,IAAI6O,EAAGU,IAAKiB,GACxBL,EAAcnQ,IAAIoQ,EAAeC,GAE1BG,SCvCEC,WAAoCzI,GAO/CE,QACE,OAAO9L,KAAK+J,GAAG/F,KAAKhE,MA+BtBzB,GAAG+V,EAAgCtT,GACjC,IAAKsT,EACH,OAAOtU,KAGT,MAAM4H,EAAWD,EAAc2M,IACzBxM,OAAEA,GAAWF,EAUnB,OARKE,EAAOV,OACTpH,KAAK6L,IAIKjE,EAAU5G,GAGhB8G,EAqBTvJ,KAAK+V,EAAgCtT,GACnC,OAAQhB,KAAK6J,KAAO0K,GAAa1K,GAAK7J,OAAO8L,GAAGwI,EAAUtT,GAc5DzC,QAAQiN,EAA2BC,GACjC,OAAO8I,GAAahJ,GAAQvL,KAAMwL,EAAUC,IA0B9ClN,QAAQ+V,EAAgCtT,GACtC,OAAQhB,KAAKwU,QAAUD,GAAa,CAChCD,EACAtT,IAEU,MAARA,EACKhB,KAAK+J,GAAGuK,GAAU,GAEP,iBAATtT,GAAqC,MAAhBA,EAAKwT,QAC5BxU,KAAK+J,GAAGuK,iCAAetT,IAAMwT,SAAS,KAExCxU,KAAK+J,GAAGuK,EAAUtT,IACxB8K,GAAGwI,EAAUtT,GAyBlBzC,QAAQ+V,EAAgCtT,GACtC,OAAQhB,KAAKyU,QAAUF,GAAa,CAChCD,EACAtT,KAGF,MAAM4G,EAAWD,EAAc2M,GAE/B,OAAOtU,KAAK+J,GACR,CACEjC,OAAQF,EAASE,OACjBvJ,QAAQyD,EAASgG,GACfA,EAAM0M,iBACN9M,EAASK,QAAQjG,EAASgG,KAG9BhH,KAEH8K,GAAGwI,EAAUtT,GA0BlBzC,KAAK+V,EAAgCtT,GACnC,OAAQhB,KAAK2U,KAAOJ,GAAa,CAC7BD,EACAtT,KAGF,MAAM4G,EAAWD,EAAc2M,GAE/B,OAAOtU,KAAK+J,GACR,CACEjC,OAAQF,EAASE,OACjBvJ,QAAQyD,EAASgG,GACfA,EAAM4M,kBACNhN,EAASK,QAAQjG,EAASgG,KAG9BhH,KAEH8K,GAAGwI,EAAUtT,GAwBlBzC,KAAK+V,EAAgCtT,GACnC,OAAQhB,KAAK6U,KAAON,GAAa,CAC7BD,EACAtT,KAGF,MAAM4G,EAAWD,EAAc2M,GAE/B,OAAOtU,KAAK+J,GACR,CACEjC,OAAQF,EAASE,OACjBvJ,QAAQyD,EAASgG,GACfA,EAAM8M,2BACNlN,EAASK,QAAQjG,EAASgG,KAG9BhH,KAEH8K,GAAGwI,EAAUtT,GAyBlBzC,QAAQ+V,EAAgCtT,GACtC,OAAQhB,KAAK+U,QAAUR,GAAa,CAChCD,EACAtT,IAEU,MAARA,EACKhB,KAAK+J,GAAGuK,EAAU,CAAES,SAAS,IAElB,kBAAT/T,EACFhB,KAAK+J,GAAGuK,EAAU,CAAEE,QAASxT,EAAM+T,SAAS,IAEjC,MAAhB/T,EAAK+T,QACA/U,KAAK+J,GAAGuK,iCAAetT,IAAM+T,SAAS,KAExC/U,KAAK+J,GAAGuK,EAAUtT,IACxB8K,GAAGwI,EAAUtT,aAsEJuT,GACZ7H,GAMF,OAAO,IAAI2H,GAAW3H,UCxYxB,MAAMsI,GAA8C,CAClDhE,YAAavU,SAQFwY,GAcX1W,YAAY2B,GAZHF,SAAqC0H,IAa5C1H,KAAKkV,QAAUhV,EAiBjB3B,GAAoB4W,GAClB,OAAOZ,GAAgB,CAACD,EAAUtT,KAEhC,MAAM8G,OAAEA,GAAWwM,EAInB,GAFAxM,EAAOP,MAAMD,EAActH,QAEtB8H,EAAOV,MAAO,CAGjB,MAAMgO,EAA6BpN,GAASsM,EAASrM,QAAQ+M,GAAiBhN,GAE9EhI,KAAKkV,QAAQG,iBAAiBF,EAAMC,EAAapU,GACjDsT,EAASxM,OAAON,QAAQ,IAAMxH,KAAKkV,QAAQI,oBAAoBH,EAAMC,OAe3E7W,SAASyJ,GACP,OAAQV,EAActH,MAAMoH,OAASpH,KAAKkV,QAAQK,cAAcvN,GAUlEzJ,KAAKyI,GAEH,OADAM,EAActH,MAAM8G,IAAIE,GACjBhH,eC/EKwV,GAAiBxO,GAC/B,MAAO,KACL,MAAMA,MAAAA,EAAAA,EAAU,IAAIjE,UAAU,yBDMtB6D,EEIZ,MAAM6O,WAAyBjP,EAE7BjI,cACEuC,MAAM,kBAGRvC,KACIyC,GAEF,OAAOA,EAAKE,QACLF,EAAKyD,IACJzD,EAAKgB,QAAqC4E,IAC3C5F,EAAKI,UAAU3E,UAYbiZ,OAA8DD,GCpB3E,MAAME,GAANpX,cAGmByB,gBAAkF0R,GAAW,IAE9GnT,QAAQ1B,GAEN,OADAmD,KAAKiF,WAAWiM,GAAK,IAAIlR,KAAKiF,WAAWiM,GAAIrU,GACtC,KAEL,MAAM8I,EAAY3F,KAAKiF,WAAWiM,GAC5BzN,EAAQkC,EAAUR,QAAQtI,GAE5B4G,GAAS,IACXzD,KAAKiF,WAAWiM,GAAKvL,EAAUgK,MAAM,EAAGlM,GAAOmS,OAAOjQ,EAAUgK,MAAMlM,EAAQ,MAKpFlF,KAAKyD,EAAcoB,EAA6BuK,MAC9C,OAAO3N,KAAK+E,QAAQ3B,EAqBxB,SACIpB,EACA6T,GAEF,OAAOA,EAAiB/E,OAAOgF,SAC3BnQ,GAAcA,EAAU9F,OAElB+N,GACEF,MACOjO,EACCA,EACIC,EAAUiG,GACVoQ,GAAQA,EAAK/T,IAEjBgU,MARVrY,IAYNsY,IAvC2BC,CAAalU,EAAShC,KAAKiF,aAG1D1G,UACE,OAAO,EAGTA,QAAQgH,EAA0BC,GAChC,OAAOkI,GACHnI,EACAC,GACFsQ,SACEG,KAkCR,SAASD,GAAmBG,GAC1B,OAAc,MAAPA,EAAcxI,KAMvB,SAA4BwI,GAC1B,OAAuB,iBAARA,GAAmC,mBAARA,IAAuBxP,EAAcwP,GAP7CC,CAAcD,GAAO7I,GAAc6I,GAAOxI,GAASwI,GAavF,SAASF,MAAsBxI,GAC7B,OAAO9P,KAAmB4B,EAAekO,IAM3C,MAAM4I,WACMxV,EAGVyV,YACE,OAAOtW,KAGTzB,SACE,OAAO,IAAIoX,IAoBf,MAAMY,WACM5V,EAUVpC,YACqBiY,EACjB5R,GAIF9D,MAAM0V,EAAK5V,KAAO,OALCZ,UAAAwW,EAMnBxW,KAAK4E,KAAO5D,IAEV,MAAMxE,EAAQoI,EAAK5D,GACb8G,EAAS9G,EAAKgB,QAAQlF,IAAI4Y,GAAe,CAAEjR,GAAI,OAErD,OAAOqD,EAAStL,EAAM+O,QAAQzD,GAAoCtL,GAhBtEuE,cACE,OAAOf,KAAKwW,KAAKzV,eA+BC0V,WACV9V,EAoBVpC,YAAYqC,EAAcG,GACxBD,MAAMF,GACNZ,KAAKe,QAAUA,GAAW,IAAIsV,GAAsBrW,MAU5CzB,YACNqG,GAIF,OAAO,IAAI2R,GAAkBvW,KAAM4E,UCvL1B8R,WACDD,GAmBVlY,YACIqC,GACAG,QACEA,EAAOK,UACPA,EAAY3E,GAIV,IAENqE,MAAMF,EAAMG,GACZf,KAAKoB,UAAY,CAACY,EAASvB,IAAQW,EAAUY,EAASvB,UAAiB,MAAM,IAAIY,EAAgBrB,QACjGA,KAAKsW,MAAQtW,KAAK2W,YACd3V,GAAQA,EAAKE,KAAK4U,SACd,IAAIc,KACF,GAAIA,EAAI/W,OACN,OAAO+W,EAAIA,EAAI/W,OAAS,GAG1B,MAAM6E,EAAkB,IAAwDiJ,GAAS3N,KAAKoB,UAC1FJ,EAAKgB,QACLhC,OAGJ,OAAO4N,GAAe5M,EAAKI,UAAUsD,IAAoBA,QAMrEnG,KACIyC,GAOF,IAAI6V,EAWJ,OATA7V,EAAKgB,QAAQlF,IACTkD,KAAKsW,MACL,OAAQtV,EAAO,CAAEyD,GAAe,MAAXzD,EAAKyD,GAAakJ,GAAS3M,EAAKyD,IAAMzD,EAAKyD,SAAOmB,GACxEmE,GACCxM,GAAMsZ,EAAYtZ,GACpBiK,QACER,GAAU6P,EAAYrB,GAAiBxO,IAGpC,IAAIpJ,IAASiZ,KAAajZ,UC3ExBkZ,WACDL,GAoBVlY,YACIqC,GACAG,QACEA,EAAOK,UACPA,EAAY3E,GAIV,IAENqE,MAAMF,EAAMG,GACZf,KAAKoB,UAAYA,EAvBnBkV,YACE,OAAOtW,KAyBTzB,KACIyC,GAGF,MAAMxE,EAAQwE,EAAKE,KAAK4U,SAAS,IAAIrI,KACnC,GAAIA,EAAQ5N,OAEV,OAAOrC,EAAQiQ,EAAQA,EAAQ5N,OAAS,IAI1C,MAAMkX,EAAS/V,EAAKI,UAAU,KAE5B,MAAMuD,EAAe3E,KAAKoB,UAAUJ,EAAKgB,QAAShC,MAElD,OAAO2E,GAAgBgJ,GAAShJ,KAGlC,OACSiJ,GADK,MAAVmJ,EACoBA,EAIF7J,GAAsB,KAC1C,MAAM,IAAI7L,EAAgBrB,WAIxB8H,EAAS9G,EAAKgB,QAAQlF,IAAI4Y,GAAe,CAAEjR,GAAI,OAErD,OAAOqD,EAAStL,EAAM+O,QAAQzD,GAAUtL,SCF/Bwa,GAAuB,CAOlCzY,GAAe0Y,EAAiC,IAE9C,IAAIC,EAEJ,MAAO,CACLC,WACE,OAAOF,EAAQE,MAEjBC,aACE,OAAOF,IAAQA,EAAMD,EAAQG,QAAWH,EAAQE,QAqB7BA,EArBgDF,EAAQE,MAuB3DE,eAAiBF,GAEvBG,aAzB2EF,YAqBlED,GAnBrB5Y,SAASgZ,GACHN,GAAWA,EAAQO,MACrBP,EAAQO,SAASD,GAEjBE,QAAQD,SAASD,OCjF3B,MAAMG,GAAkBxa,OAAO,YAK/B,MAAMya,GAWJpZ,YAAqCqZ,EAAgBC,GAAhB7X,OAAA4X,EACnC5X,KAAK8X,SAAW9X,KAAK+X,WACrB/X,KAAK6X,IAAMA,GAAO,CAAC7X,KAAMA,MAP3BzB,UAAUyZ,EAAoBH,GAC5B,OAAQG,EAAcN,MACbM,EAAcN,IAAmB,IAAIC,GAAQK,EAAOH,IAQ/DtZ,IAAI0Z,GACFjY,KAAK4X,EAAEvO,IAAI4O,GAGL1Z,WAAW2Z,GACjBlY,KAAK8X,SAAW,OAEhB,MAAMK,EAA0B,GAC1BC,EAA6B,CACjCF,aACE,OAAOA,GAET3Z,SAAS0Z,GACPE,EAAUjS,QAAQ+R,KAItBjY,KAAK4X,EAAEE,SAAS,KAEd,MAAMjZ,EAAOmB,KAAKqY,QAElBxZ,EAAKyZ,UACLtY,KAAKuY,KAAKH,GAEVpY,KAAK6X,IAAI,GAAK7X,KAAK6X,IAAI,GAEvBM,EAAU5N,QAAQ0N,GAAQjY,KAAK4X,EAAEvO,IAAI4O,IAErCG,EAAUI,SAAWP,GAAQjY,KAAK4X,EAAEa,KAAKR,GACzCjY,KAAKuY,KAAKH,GACVvZ,EAAK6Z,WAIDna,KAAK6Z,GACX,OAAU,CAER,MAAMH,EAAOjY,KAAK4X,EAAEe,OAEpB,IAAKV,EACH,MAEFA,EAAKG,IAID7Z,QAEN,OAAOyB,KAAK6X,IAAI,GAAKF,GAAQ9V,GAAG7B,KAAK4X,EAAES,QAASrY,KAAK6X,KAG/CtZ,UACNyB,KAAK8X,SAAWI,IACdlY,KAAK4Y,UAAYV,EACjBlY,KAAK8X,SAAW,QAIZvZ,SACFyB,KAAK4Y,UACP5Y,KAAK+X,WAAW/X,KAAK4Y,WAErB5Y,KAAK8X,SAAW9X,KAAK+X,qBAaXc,GACZ5B,GAEF,OAAO6B,IAEL,MAAMZ,EAASlB,GAAqBnV,GAAGiX,GACjCC,EAAwCpB,GAAQ9V,GAAGoV,EAAQ+B,SAASd,IAASL,IACnF,IAAIoB,EAA8C,GAElD,OAAOhB,IAEL,MAAOiB,GAAYC,GAAYF,GACxBG,EAAWC,GAAeN,EACjC,IAAIf,EAAQkB,GAAaG,EAEzB,GAAIH,IAAcG,IAAgBF,GAAYD,IAAcE,EAC1DH,EAAS,GAAKhB,MACT,CAIL,MAAMqB,EAA6CL,EAAW,CAC5DjB,EAAQmB,EAAWC,EAAYC,EAC/BpB,GAGFD,EAAM3O,IAAK+O,IACTkB,EAAa,IAAK,EAClB,IACEA,EAAa,GAAG,CACdpB,aACE,OAAOA,GAET3Z,SAAS4Z,GACPC,EAAUI,SAASL,MAGvB,MAAO/L,GACP8L,EAAOV,MAAMpL,MAKnB4L,EAAMF,SAASI,WCzHRqB,GAAc,CAYzBhb,IAEIuZ,SACEA,EAAQ0B,QACRA,EAAU,WAOd,MAAMC,EAAsB,GAE5B,MAAO,CACL3B,SAAAA,EACAvZ,IAAI0Z,GACFwB,EAAMvU,KAAK+S,IAEb1Z,KAAK0Z,GACHwB,EAAMvT,QAAQ+R,IAEhBU,KAAI,IACKc,EAAM/Q,QAEfnK,QAEE,MAAMM,EAAO0a,GAAY1X,GAAG,CAAEiW,SAAAA,EAAU0B,QAAAA,IAIxC,OAFAA,EAAQ3a,GAEDA,MCnFT6a,OAA2CC,QCFpCC,GAA6C3C,IAExD,MAAMiB,EAASlB,GAAqBnV,GAAGoV,GAEvC,OAAQgB,IAEN,MAAME,EAA0B,GAC1BC,EAA6B,CACjCF,aACE,OAAOA,GAET3Z,SAAS0Z,GACPE,EAAUjT,KAAK+S,KAKnB,IADA4B,EAAQ5B,KACE,CAER,MAAMpD,EAAOsD,EAAU2B,MAEvB,IAAKjF,EACH,MAGFgF,EAAQhF,GAGV,SAASgF,EAAQ5B,GACf,IACEA,EAAKG,GACL,MAAOhM,GACP8L,EAAOV,MAAMpL,OCPrB,IAAI2N,GFVoElB,GAAsB,CAC5Fta,UAAS6Y,OAAEA,IAET,MAAMtM,EAAW4O,GAAsB5c,IAAIsa,GAE3C,GAAItM,EACF,OAAOA,EAGT,MAAMkO,EAAWO,GAAY1X,GAAG,CAC9BiW,SAAUkC,GAAQ5C,EAAO6C,sBAAsBD,GAC/CR,QAASU,GAAeR,GAAsB9V,IAAIwT,EAAQ8C,KAK5D,OAFAR,GAAsB9V,IAAIwT,EAAQ4B,GAE3BA,cEmBKmB,GAAkBlD,GAChC,OAAO8C,GAAuB9C,GCtDzB,MAAMmD,OAA2C3T,EAAmC,2BCerE4T,WAAyBnX,EAK7CxC,WAAYA,KACV,OAAO0Z,aCXKE,GACZ9W,GAEF,MAAO,CAACxB,EAASvB,KAEf,MAAM8Z,EAAmBvY,EAAQlF,IAAIud,IAErC,OAAOrY,IAAYuY,EAAmB/W,EAAQ+W,EAAkB9Z,GAAO8Z,EAAiBzd,IAAI2D,aCbhF0O,GAAW3S,GACzB,OAAOsJ,MAAMqJ,QAAQ3S,SCDVge,GAIXjc,YAAY/B,GACVwD,KAAKya,MAAiB,MAATje,EAAgB,IAAI0M,IAAQiG,GAAQ3S,GAAS,IAAI0M,IAAI1M,GAAS,IAAI0M,IAAI,CAAC1M,IAGtFA,YACE,OAAOwD,KAAKya,MAAMrR,KAAO,EAAIrK,EAASiB,KAAKya,OAAS3U,MAAMC,KAAK/F,KAAKya,OAGtElc,CAACrB,OAAOgB,YACN,OAAO8B,KAAKya,MAAMvd,OAAOgB,YAG3BK,OAAOkc,GACL,OAAOza,KAAK0a,OAAOD,GAGrBlc,OAAOkc,GAEL,OADAhc,EAAQgc,EAAOE,GAAQ3a,KAAKya,MAAMpR,IAAIsR,IAC/B3a,KAGToJ,WACE,OAAOpJ,KAAKya,MAAMrR,KAGpB7K,MAAMkc,GAMJ,OALItL,GAAQsL,GACVza,KAAK0a,OAAOD,GACM,MAATA,GACTza,KAAKya,MAAMpR,IAAIoR,GAEVza,eCfK4a,GAAazF,EAAa0F,EAAuC,MAAM,IAErF,MAAMC,EAAYpY,OAAOqY,eAAe5F,EAAK2F,WAE7C,GAAiB,MAAbA,EACF,OAGF,MAAME,EAAYF,EAAUG,YAE5B,OAAIJ,EAAWG,GACNA,EAGFJ,GAAaI,EAAWH,YCLjBK,GACZhb,EACAib,EACAC,EACAC,GAGF,MAAMC,GAAWF,EAIXG,EAAcF,EAHgCD,WCsDlDA,GAEF,YAlBEA,GAEF,YAAsBxV,IAAfwV,EAAK5e,YAAyCoJ,IAAlBwV,EAAKI,SAgBpCC,CAA6BL,GAC/B,OAAOA,EAGT,MAAMM,EAAgBxe,OAAO,SACvBkG,EAAUgY,EAAK5e,MAEfmf,iCACDP,IACHI,cAAU5V,EACVpJ,WAAOoJ,EACPrH,MACE,OAAOmd,KAAiB1b,KAAOA,KAAK0b,GAAiBtY,KAazD,OATIgY,EAAKI,WACPG,EAAa/X,IAAM,SAAqB2L,GACtCvP,KAAK0b,GAAiBnM,WAInBoM,EAAaH,gBACbG,EAAanf,MAEbmf,EDhFDC,CAA6BR,YCPjClb,EACA2b,GAGF,MAAMH,EAAgBxe,OAAU4e,OAAOD,GAAV,UACvBzY,EAAgBlD,EAAO2b,GAE7B,MAAO,CACLE,cAAc,EACdC,YAAY,EACZzd,MACE,OAAOmd,KAAiB1b,KAAOA,KAAK0b,GAAiBtY,GAEvD7E,IAAegR,GACbvP,KAAK0b,GAAiBnM,IDNpB0M,CAAwB/b,EAAQib,IAGtC,IAAIG,IAAWC,EAKf,OAAOA,EAJL7Y,OAAOwZ,eAAehc,EAAQib,EAAaI,YEd/BY,GACZ5W,EACAC,EACA4W,EAAoC,EAACC,EAAIC,IAAMA,IAEjD,OAAK/W,EAGAC,EAGE,YAAsB5H,GAC3B,OAAOwe,EACH7W,EAAMgX,MAAMvc,KAAMpC,GAClB4H,EAAO+W,MAAMvc,KAAMpC,KALhB2H,EAHAC,WCjCKgX,GAAUrF,GACxB,OAAOA,EAAKsF,WAAaC,KAAKC,mBCHVC,GAIpBre,YAAsBse,GACpB7c,KAAK6c,OAASA,EAGhBte,IAAI4W,GAEF,OAAOA,EAAK2H,eAAe9c,KAAK6c,QAAW1H,EAAanV,KAAK6c,aAAUjX,EAGzErH,GAAG4W,GAED,MAAM4H,EAAwB/c,KAAKgd,IAAI7H,GACjC6F,EAAYJ,GAAazF,GACzB8H,EAAWjC,GAAahb,KAAKkd,GAAGlC,GAEtC,OAAO+B,EAAUE,EAAWjd,KAAKoc,MAAM,CAACa,EAAUF,IAAWA,EAAUE,EAGzE1e,OAAwB4W,EAAS1H,GAE/B,MAAM0P,EAAWnd,KAAKgd,IAAI7H,GACpBiI,EAAU3d,EAAMgO,EAASpO,GAAUW,KAAKqd,KAAKhe,EAAQ8V,IACrDmI,EAAatd,KAAKoc,MAAMe,EAAW5d,EAAU,CAAC,CAAC4d,GAAWC,IAAYA,GAW5E,OATA1a,OAAOwZ,eACH/G,EACAnV,KAAK6c,OACL,CACEd,cAAc,EACdvf,MAAO8gB,IAINnI,SCxCEoI,GAMXhf,cACEyB,KAAK2O,QAAU,IAAI1C,QAAQ,CAACC,EAASC,KACnCnM,KAAKwd,SAAWtR,EAChBlM,KAAKyd,QAAUtR,IAInB5N,QAAQ/B,GACNwD,KAAKwd,SAAShhB,GAGhB+B,OAAOiZ,GACLxX,KAAKyd,QAAQjG,UCXJkG,GAAoCxgB,OAAO,eAyFxD,MAAMygB,WAAoBf,GAExBre,cACEuC,MAAM4c,IAGRnf,MAAMqf,GACJ,OAAO5e,EACH4e,EACA,CAACzW,EAAM0W,MACLtW,MAAO,IAAIiT,GAASrT,EAAKI,OAAO6U,MAAMyB,EAAItW,OAAO/K,MACjDshB,IAAK,IAAItD,GAASrT,EAAK2W,KAAK1B,MAAMyB,EAAIC,KAAKthB,MAC3CuhB,MAAO5B,GAA8ChV,EAAK4W,MAAOF,EAAIE,OACrEC,KAAM7B,GAA8ChV,EAAK6W,KAAMH,EAAIG,QAErE,IAINzf,KAAKc,EAAoB8V,GAEvB,MAAM0I,EAAMxe,EAAOqe,IAEnB,OAAc,MAAPG,EACDxe,EACAW,KAAKqd,KACY,mBAARQ,EAAsBxe,EAA8Bqe,IAAoBvI,GAAQ0I,EACvF1I,IASZ,MAAM8I,OAAiCN,GAKjCO,GAAmC,CACvC3f,CAACmf,IAAmB,KACX,KAOES,GAAa,CAUxBjB,GAAekB,GACNH,GAAYf,GAAGkB,IAAgB,GAWxCC,IAAG,CAAaD,EAAoBP,IAC3BI,GAAYZ,KAAKQ,EAAKO,GAU/BhC,MAAK,IAAgBwB,IACZK,GAAY7B,MAAMwB,GAU3BU,IAAG,IAAgBV,IACV5e,EACH4e,EACA,CAACzW,EAAM0W,MACLtf,CAACmf,IAAoBU,GACZD,GAAW/B,MACd+B,GAAWE,IAAID,EAAajX,GAC5BgX,GAAWE,IAAID,EAAaP,MAIpCK,IAeNK,OAAM,CAA8BH,KAAmBR,IAC9CK,GAAYM,OAAOH,EAAaR,aCpM3BY,MAAkCZ,GAChD,OAAQzI,GAAYgJ,GAAWI,OAAOpJ,KAASyI,GCdjD,MAAMa,OAAyChY,EAAiC,yBAO1DiY,WAAuBrE,GAK3C3Z,WAAYA,KACV,OAAO+d,GAmHTlgB,YAA8BogB,GAC5B,OAAO3e,KAAKlD,IAAIud,IAAkBuE,YAAYD,GAGhDpgB,KAAKsgB,GACH,OAAO7e,KAAKlD,IAAIud,IAAkByE,KAAKD,UC7H9BE,WAA0Bzd,MAYrC/C,YAAYgJ,GACVzG,MACI,2BAA6ByG,EAAMyX,OACnC,CACI7X,GACC0X,EAAS7X,EAAQiY,MAChB9X,GAAc0X,EAAQje,MAAQ,IAAIoG,KAAUiY,EAAKre,OACvD,KAGJZ,KAAKuH,MAAQA,SC7BK2X,GA2BpB3gB,CAACmI,KACC,OAAO1G,KAAK8Q,cC7BHqO,GAAsCjiB,OAAO,iBAiH1D,MAAMkiB,WAAsBxC,GAE1Bre,cACEuC,MAAMqe,IAGR5gB,MAAwBqf,GACtB,OAAO5e,EACH4e,EACA,CAACzW,EAAM0W,iDACF1W,GACA0W,IACHE,MAAO5B,GAAehV,EAAK4W,MAAOF,EAAIE,OACtCQ,OAAQpC,GAAehV,EAAKoX,OAAQV,EAAIU,QACxCM,QAAS1X,EAAK0X,QACRhB,EAAIgB,QAAUV,GAAW/B,MAAMjV,EAAK0X,QAAShB,EAAIgB,SAAW1X,EAAK0X,QACjEhB,EAAIgB,UAEZ,IAINtgB,KAAuBc,EAAyBsf,GAE9C,MAAMd,EAAOxe,EAAe8f,IAE5B,OAAW,MAAPtB,EACK7d,KAAKqd,KACO,mBAARQ,EAAsBxe,EAAmC8f,IAAsBR,GAAiBd,EACvGc,GAGqC,MAAtCtf,EAAeqe,IACX,CACLmB,QAASV,GAAWE,IAAIM,EAAetf,IAGvCkU,GAAgBlU,GACX,CAAEuB,KAAMvB,GAGVA,GAQX,MAAMggB,OAAmCD,GAKnCE,GAAuC,CAC3C/gB,CAAC4gB,IAAqB,KACb,KAOEI,GAAe,CAU1BrC,GAAiCyB,GACxBU,GAAcnC,GAAGyB,IAA6C,GAWvEN,IAAG,CAECM,EACAtf,IAEKggB,GAAchC,KAAKhe,EAAQsf,GAWpCvC,MAAK,IAAkCwB,IAC9ByB,GAAcjD,MAAMwB,GAW7BU,IAAG,IAAkCV,IAC5B5e,EACH4e,EACA,CAACzW,EAAM0W,MACLtf,CAAC4gB,IAAsBR,GACdY,GAAanD,MAChBmD,GAAalB,IAAIM,EAAexX,GAChCoY,GAAalB,IAAIM,EAAed,MAIxCyB,IAkBNf,OAAM,CAEFI,KACGf,IAEEyB,GAAcd,OAAOI,EAAef,aCtO/B4B,MACT5B,GAGL,MAAM6B,EAActK,GAAYoK,GAAahB,OAAOpJ,KAASyI,GAK7D,OAJY6B,EAERN,IAAwB,IAAMI,GAAajB,OAAOV,GAE/C6B,EChDF,MAAMC,OAA2CjZ,EAAmC,qBCG9EkZ,OAAmDlZ,EAC5D,6BACA,CACElI,UAAUvB,GAER,MAAMgF,EAAUhF,EAAOF,IAAI4iB,IACrBE,EAAa,IAAI3K,GAAmBjT,EAAQrD,SAIlD,OAFA2I,EAAcsY,GAAYrY,MAAMvF,GAEzB,CACLsI,SAAStC,GACA4X,EAAWtV,SAAStC,GAE7BqC,GAAoB8K,GACXyK,EAAWvV,GAAG8K,OCHpB0K,OAAgEpZ,EACzE,eACA,CACErF,UAAUmB,GACDA,EAAIzF,IAAI4iB,IAAuB/gB,UCoB9C,MAAMmhB,WAAwBrJ,GAI5BlY,cACEuC,MAAM,iBACNd,KAAKsW,MAAQtW,KAAK2W,YACd3V,GAAQA,EAAKE,KAAK4U,SACd,IAAIc,KACF,GAAIA,EAAI/W,OAAQ,CAEd,MAAMkgB,EAAoCnJ,EAAIoI,OAC1C,CAAC7X,EAAM5J,IAAO4e,GAAe5e,EAAI4J,GACjC1K,GAGJ,MAAO,CAACyS,EAAMK,EAAUC,IAAauQ,EAAS9Q,GAAUC,GAAOK,EAAUC,GAG3E,MAAM9K,EAAkB/H,EAAcgR,GAASlR,IAE/C,OAAOmR,GAAe5M,EAAKI,UAAUsD,IAAoBA,QAMrEnG,KACIyC,GAOF,IAAI6V,EAWJ,OATA7V,EAAKgB,QAAQlF,IACTkD,KAAKsW,MACL,OAAQtV,EAAO,CAAEyD,GAAe,MAAXzD,EAAKyD,GAAakJ,GAAS3M,EAAKyD,IAAMzD,EAAKyD,SAAOmB,GACxEmE,GACCxM,GAAMsZ,EAAYtZ,GACpBiK,QACE,IAAMqP,EAAYpa,GAGf,CAACyS,EAAMK,EAAUC,IAAaqH,EAAU3H,EAAMK,EAAUC,UAmBtDwQ,OAAuFF,GCpFvFG,GAA0C/iB,OAAO,2BAaxCgjB,WAAiDhd,EAoGrE3E,cACEuC,QACAd,KAAKmgB,YAAc,CAAI1f,EAAgB8O,EAAaC,KAClDxP,KAAKlD,IAAIkjB,GAAThgB,CAAuBS,EAAK8O,EAAUC,IAlG1C9O,WAAYA,KACV,OAAOgf,GAmFTnhB,UAA4BI,GAE1B,MAAMqD,EAAUrD,EAAQshB,IAExB,IAAKje,EACH,MAAMe,UAAU,iCAAiCpE,GAGnD,OAAOqD,EAeToe,kBACE,OAAOpgB,KAAKlD,IAAI+iB,IAsGlBthB,GAAoB4W,GAClB,OAAOnV,KAAKlD,IAAI6iB,IAA+BtV,GAAG8K,GAUpD5W,cAAcyJ,GACZhI,KAAKlD,IAAI6iB,IAA+BrV,SAAStC,UChPxCqY,WAAuBC,MAKlCte,cACE,OAAOke,GAAiBhD,GAAGld,KAAKE,eC6UvBqgB,GAAoDrjB,OAAO,yCAexDsjB,GACZjC,GAGF,MA+CMkC,EAAe,EACf3jB,IAAAA,EAAK8G,IAAAA,GACPnD,EAAuB8f,GACvB/E,IACwBgE,GAAU,CACpCjhB,CAAC4gB,IAAsBhK,GAErB,MAAM0I,EAAMU,EAAO,CACjBpJ,KAAAA,EACA1U,IAAAA,EACAigB,UAAU,EACVlF,SAAAA,EACAQ,YAAY,EACZD,cAAc,EACdjf,IAAK6jB,GAAa7jB,EAAI6jB,EAAWlgB,GACjCmD,IAAK,CAAC+c,EAAWnkB,IAAUoH,EAAI+c,EAAWnkB,EAAOiE,KAGnD,OAAQod,GAAOA,EAAI+C,cAAiB,MAGlCC,EAAK,CACPhkB,EACA4D,IACwBggB,EACxB,CACE3jB,IAAG,CAAC6jB,EAAWlgB,IACN5D,EAAS8jB,EAAWlgB,IAG/BA,GACA,GAGEpD,EAjFY,CACdyjB,EACA3F,EACA4F,IACa7F,GACb4F,EACA3F,EACA4F,EACA3F,IAEE,MAAQte,IAAKkkB,EAAUpd,IAAKqd,GAAa7F,EACnCjG,EAAO2L,EAAM7F,aACbne,IAAEA,EAAG8G,IAAEA,EAAGmY,aAAEA,EAAYC,WAAEA,EAAU4E,aAAEA,EAAe,IAAOrC,EAAO,CACvEpJ,KAAAA,EACA1U,IAAK0a,EACLuF,WAAYtF,EAAKte,IACjB0e,WAAYJ,EAAKxX,IACjBoY,aAAcZ,EAAKY,WACnBD,eAAgBX,EAAKW,aACrBjf,IAAKkkB,EACGL,GAA+BK,EAASnjB,KAAK8iB,GAC/CO,GAAoB/F,GAC1BvX,IAAKqd,GACGN,EAAWnkB,IAAUykB,EAASpjB,KAAK8iB,EAAWnkB,GAChD2kB,GAAoBhG,MACtB,GAENoE,GAAahB,OAAOpJ,EAAMyL,GAE1B,MAAMQ,iCACDhG,IACHW,aAAcA,MAAAA,EAAAA,EAAgBX,EAAKW,aACnCC,WAAYA,MAAAA,EAAAA,EAAcZ,EAAKY,aAYjC,OATIlf,GAAO8G,KACTwd,EAAQtkB,IAAMA,GAAO,WACnB,OAAOA,EAAIkD,KAAMmb,IAEnBiG,EAAQxd,IAAMA,GAAO,SAAiCpH,GACpDoH,EAAI5D,KAAMxD,EAAO2e,KAIdiG,IA8Eb,OAvCA/jB,EAAOgkB,KAAO,CAACC,EAAQ7gB,IAAQggB,EAAaa,EAAQ7gB,GAAK,GACzDpD,EAAOwjB,GAAKA,EACZxjB,EAAOkkB,GAAK,CAAC/kB,EAAOiE,IAASogB,EAAGlkB,EAAcH,GAAQiE,GACtDpD,EAAOmkB,KAAO,CAACC,EAAQhhB,EAAM8f,MAE3B,MAAMmB,EAAmBxkB,OAAU4e,OAAOrb,GAAV,aAC1BkhB,EAAYhB,IAKhB,MAAM7V,EAAW6V,EAAUe,GAE3B,GAAI5W,EACF,OAAOA,EAGT,MAAM6W,EAAWF,EAAOd,EAAWlgB,GAEnC,OAAOkgB,EAAUe,GAAoB,CACnC5kB,IAAK6kB,EAAS7kB,IAAM6kB,EAAS7kB,IAAIkH,KAAK2d,GAAYT,GAAoBzgB,GACtEmD,IAAK+d,EAAS/d,IAAM+d,EAAS/d,IAAII,KAAK2d,GAAYR,GAAoB1gB,KAI1E,OAAOggB,EACH,CACE3jB,IAAI6jB,GACKgB,EAAShB,GAAW7jB,MAE7B8G,IAAG,CAAC+c,EAAWnkB,IACNmlB,EAAShB,GAAW/c,IAAIpH,IAGnCiE,GACA,IAICpD,EAMT,SAAS6jB,GAAoB/F,GAC3B,MAAO,KAAQ,MAAM,IAAIpY,UAAU,IAAI+Y,OAAOX,wBAMhD,SAASgG,GAAoBhG,GAC3B,MAAO,KAAQ,MAAM,IAAIpY,UAAU,IAAI+Y,OAAOX,wBC/fhD,MAAMyG,OACgBnb,EAA2C,oCAMpDob,WAAiC1e,EAY5C5E,cACEuC,QACAd,KAAKwD,QAAQ,CAAE5B,EAAGigB,GAA0Bzf,GAAIpC,OAChDA,KAAKhD,OAASgD,KAAK+D,YAbrBrD,WAAYA,KACV,OAAOkhB,GAKTrjB,gBACE,OAAO,IAAIsjB,ICrBf,MAAMC,OAAmDrb,EACrD,6BACA,CACErF,UAAWkZ,GAAiB,IAAM,IAAIyH,YAO/BA,WAAiC5e,EAE5CzC,WAAYA,KACV,OAAOohB,ICbX,MAAME,OAAoDvb,EACtD,8BACA,CACErF,UAAWkZ,GAAiBtY,GAAW,IAAIigB,GAA0BjgB,YAO9DigB,WAAkC9e,EAE7CzC,WAAYA,KACV,OAAOshB,ICuCX,MAAME,GAAsChlB,OAAO,2BAKnCilB,GAA+BxD,GAE7C,GAAIA,EAAc7B,eAAeoF,IAC/B,OAAQvD,EAAsBuD,IAGhC,MAAMnQ,EAAUL,KACVpC,EAAU,IAAIxB,GAEdzD,EAAK4D,GADoC8D,EAAQjB,OAAOtG,KAAKuT,GAASA,EAAQpgB,EAASogB,GAASjgB,KAC5EwR,GACpB0L,EAAYJ,GAAa+D,EAAexJ,GAAQgK,MAAwBhK,GAE9E,GAAI6F,EAAW,CAEb,MAAMoH,EAAoBD,GAAanH,GAEvC3Q,EAAGN,GAAGgU,GAASqE,EAAkBha,KAAK2V,IAGxC,MAAM1gB,EAA0B,CAC9BgN,GAAAA,EACA9L,KAAKwf,GACHzO,EAAQlH,KAAK2V,IAEfxf,MAAMwf,GACJhM,EAAQb,GAAK6M,IAMjB,OAFArb,OAAOwZ,eAAeyC,EAAeuD,GAAsB,CAAE1lB,MAAOa,IAE7DA,QCxEIglB,OAAwE5b,EACjF,SACA,CACErF,UAAS,IACAgW,SCHFkL,OAAoE7b,EAC7E,iBACA,CACErF,UAAUmB,GACDA,EAAIzF,IAAIulB,IAAiBE,SAASC,OCJpCC,OACShc,EAA0C,6BCLhE,MAAMic,WAAkCjM,GAItClY,cACEuC,MAAM,4BACNd,KAAKsW,MAAQtW,KAAK2W,YACd3V,GAAQA,EAAKE,KAAK4U,SACd,IAAIc,KACF,GAAIA,EAAI/W,OACN,OAAO8iB,GAAyB3hB,EAAKgB,QAAS4U,EAAIA,EAAI/W,OAAS,IAGjE,MAAM6E,EAAkB,IAA4CiJ,GAChEgV,GAAyB3hB,EAAKgB,QAASmY,KAG3C,OAAOvM,GAAe5M,EAAKI,UAAUsD,IAAoBA,QAMrEnG,KACIyC,GAOF,IAAI6V,EAWJ,OATA7V,EAAKgB,QAAQlF,IACTkD,KAAKsW,MACL,OAAQtV,EAAO,CAAEyD,GAAe,MAAXzD,EAAKyD,GAAakJ,GAAS3M,EAAKyD,IAAMzD,EAAKyD,SAAOmB,GACxEmE,GACC6Y,GAAa/L,EAAY8L,GAAyB3hB,EAAKgB,QAAS4gB,IAClEpb,QACER,GAAU6P,EAAYrB,GAAiBxO,IAGpC,IAAIpJ,IAASiZ,KAAajZ,IAKrC,SAAS+kB,GACL3gB,EACA4gB,GAEF,MAAO,CAAC3L,EAAU,KAAO2L,iCACpB3L,IACHG,OAAQH,EAAQG,QAAUpV,EAAQlF,IAAIulB,aAW7BQ,OACSH,GCrDtB,MAAMI,WAA0BrM,GAI9BlY,cACEuC,MAAM,mBACNd,KAAKsW,MAAQtW,KAAK2W,YACd3V,GAAQA,EAAKE,KAAK4U,SAAS,IAAIiN,KAE7B,MAAMhD,EAA2BgD,EAAS/D,OACtC,CAAC7X,EAAM6b,IAAYrkB,GAAWwI,EAAKxI,IAAYqkB,EAAQrkB,GACvDskB,IAGEve,EAAkB,IAAoCiJ,GAASsV,IAErE,OAAOlD,IAAakD,GACdlD,EACAnS,GAAe5M,EAAKI,UAAUsD,IAAoBA,QAKhEnG,KACIyC,GAOF,IAAI6V,EAWJ,OATA7V,EAAKgB,QAAQlF,IACTkD,KAAKsW,MACL,OAAQtV,EAAO,CAAEyD,GAAe,MAAXzD,EAAKyD,GAAakJ,GAAS3M,EAAKyD,IAAMzD,EAAKyD,SAAOmB,GACxEmE,GACCiZ,GAAWnM,EAAYmM,GACzBxb,QACER,GAAU6P,EAAYrB,GAAiBxO,IAGpCrI,GAAWkY,EAAUlY,IAQhC,SAASskB,GAAsBtkB,GAC7B,OAAOA,EAAQshB,UAQJiD,OAAkFJ,GC5ClFK,OAAwFzM,GACjG,mBACA,CACEtV,UAAWkZ,GAAiB8I,IAE1B,MAAMJ,EAAUI,EAAUtmB,IAAIomB,IAC9B,MAAMG,UAA+BC,iBAEnC/kB,YAAY2I,GACVpG,MAAMyiB,IACJA,EAAUhZ,QAAQiZ,IAChB/kB,EACIiB,EAAU8jB,EAASC,cACnBtM,2BA4CpB,SAAiBA,SACf,iBAAOA,EAAK8I,0BAA2ByD,MA7CbC,CAAQxM,yBAAOyM,mBAE3BnlB,EACIW,EACIM,EAAU8jB,EAASK,YACnBrH,IAEJ7d,uCAAWqkB,EAAQrkB,yBAAU+kB,4BAAOE,qBAG1C1c,EAASqc,EAAWvjB,QAIxBzB,QAAQ2B,EAAc+W,GACpBnW,MAAMgjB,QAAQ5jB,iCAAa+W,IAAS8M,WAAW,MAKnD,OAAO7c,GAAY,IAAImc,EAAuBnc,OCxE/C,MAAM8c,GAA2C9mB,OAAO,+BAK/C+mB,GAAsCtF,GAEpD,IAAKA,EAAc7B,eAAekH,IAChC,MAAM,IAAIjhB,UAAU,6BAA6B4b,GAEnD,OAAQA,EAAsBqF,ICAhC,MAAME,OAAyCzd,EAC3C,kBACA,CACErF,UAAWkZ,IAqDjB,SAA8B8I,GAE5B,MAAMe,EAAwCf,EAAUtmB,IAAIulB,IAAiB8B,eACvE5R,EAAU6Q,EAAUtmB,IAAI2lB,IA+C9B,OAAO,IA7CP,cAA8B2B,GAE5B7lB,OAAO8lB,EAA8CC,GACnD,GAAI/Q,GAAgB8Q,GAElB,YADAF,EAAe5F,OAAO1L,GAAajS,KAAKyjB,EAAqB9R,GAAU+R,GAIzE,MAAMC,EAAaN,GAAoBI,IACjCzjB,KAAEA,EAAI4jB,OAAEA,GAAWD,EAAWE,WAE/B7jB,EAID4jB,GAAUA,EAAO5jB,KACnBujB,EAAe5F,OACX1L,GAAajS,KAAKA,EAAM2R,GACxB+R,EACA,CACEI,QAASF,EAAO5jB,OAItBujB,EAAe5F,OAAO1L,GAAajS,KAAKA,EAAM2R,GAAU+R,GAZxDK,GAAkBN,GAAqBnY,aAAQtG,GAgBnDrH,YAAY8lB,GACV,GAAI9Q,GAAgB8Q,GAClB,OAAOF,EAAevF,YAAY/L,GAAajS,KAAKyjB,EAAqB9R,IAG3E,MAAMgS,EAAaN,GAAoBI,IACjCzjB,KAAEA,GAAS2jB,EAAWE,WAE5B,OAAK7jB,EAIEujB,EAAevF,YAAY/L,GAAajS,KAAKA,EAAM2R,IAHjDoS,GAAkBN,GAAqB1V,qBAlFhCyV,GAQpB1jB,WAAYA,KACV,OAAOwjB,IAuFX,MAAMU,GAA2C1nB,OAAO,sBAKxD,SAASynB,GAAkBhG,GAEzB,OAAIA,EAAc7B,eAAe8H,IACxBjG,EAAciG,IAEhBjG,EAAciG,IAA6B,IAAIrH,GCnIjD,MAAMsH,OAA4Cpe,EAAoC,sBCoChFqe,OAA8Dre,EACvE,cACA,CACElI,UAAUvB,GAER,MAAM2hB,EAAgB3hB,EAAOF,IAAI+nB,IAAwBlG,eACnD/d,KAAEA,EAAI4jB,OAAEA,GAAWjF,GAAarC,GAAGyB,GAEnCoG,EAAmC,CACvC5P,WACE,OAAOqP,GAAUA,EAAOrP,MAAQnY,EAAOF,IAAIulB,IAAiB2C,aAE9DpkB,WACE,OAAO4jB,GAAUA,EAAO5jB,OAI5B,MAAO,CACLA,WACE,OAAOA,GAET4jB,aACE,OAAOO,aCzCGE,WAAkD/hB,EAKtExC,WAAYA,KACV,OAAOmkB,GAoBTJ,iBACE,OAAOzkB,KAAKlD,IAAIgoB,IA4DlBvmB,UAAUI,GAER,MAAM+kB,EAAQ1jB,KAAKklB,QAAQvmB,GAI3B,OAFA+kB,EAAMyB,UAECzB,SC3FW0B,WAA4ClF,GAKhE3hB,YACa8mB,EACA1mB,GAEXmC,QAHWd,wBAAAqlB,EACArlB,aAAArB,EAJLqB,aAAU0R,MAQhB,MAAMxN,EAAWmhB,EAAmBC,wBAEpCphB,EAASV,QAAQ,CAAE5B,EAAGse,GAAkB9d,GAAIpC,OAC5CA,KAAKlD,IAAMoH,EAASH,YAAYjH,IAGlC6hB,oBACE,OAAO3e,KAAKqlB,mBAAmB1G,cAGjCgC,gBACE,OAAO3gB,KAAKulB,aAGdC,cACE,OAAOxlB,KAAKylB,QAAQvU,QAAkC5J,EAActH,MAAMoH,MAG5Ese,gBACE,OAAO1lB,KAAKylB,QAAQvU,QAAoC5J,EAActH,MAAMoH,MAG9ER,IAAKA,KACH,OAAOU,EAActH,KAAKylB,SAG5BlnB,aACE,MAAM,IAAIwE,UAAU,8EAKtBxE,UAAUqJ,GACR,OAAQ5H,KAAK2lB,UAAY3lB,KAAKylB,QAAQ3U,OAAOrE,MACzCmZ,GAAUA,EAASjoB,EAASqC,MAAQlC,KACtC+L,OAAOiC,GAAGlE,GAGdrJ,aACMyB,KAAKylB,QAAQvU,KAEflR,KAAKylB,QAAQvU,MAMjB3S,YAAYqJ,GACV,OAAQ5H,KAAK6lB,YAAc7lB,KAAKylB,QAAQ3U,OAAOrE,MAC3CmZ,GAAUA,KAAoCpoB,EAAQwC,MAAQlC,KAChE+L,OAAOiC,GAAGlE,GAKdrJ,cAAcqJ,GACZ,OAAQ5H,KAAK8lB,cAAgB9lB,KAAKylB,QAAQ3U,OAAOrE,MAC7CmZ,GAAUA,KAAsCpoB,EAAQwC,MAAQlC,KAClE+L,OAAOiC,GAAGlE,GAGdrJ,QAAQyI,GACN,IACEhH,KAAKylB,QAAQ3mB,KAAKkI,kBAEVhH,KAAK2gB,UAAkBV,WACxBjgB,KAAKrB,QAAQshB,IACpBjgB,KAAKulB,WAAaQ,GAiExB,SAAuBpnB,GAErB,MAAMqnB,WAAEA,GAAernB,EAEnBqnB,GACFA,EAAWC,YAAYtnB,GArErBunB,CAAclmB,KAAKrB,UAIvBJ,mBAEE,MAAM4nB,EAAgBnmB,KAAKqlB,mBAAmBe,eAE9C,IAAIC,EAAU,EAEdrmB,KAAKrB,QAAQshB,IAA4BjgB,KACzCmmB,EAAcG,aAAazc,KAAK0c,GAAYF,EAAUE,EAASvmB,KAAMqmB,IACrErmB,KAAK8lB,cAAc,KACjBK,EAAcG,aAAavc,GAAG,CAC5BjC,OAAQJ,IAAcH,MAAMvH,MAC5BiI,QAAS,CAACue,EAAGD,KACXF,EAAUE,EAASvmB,KAAMqmB,QAI/BrmB,KAAKqlB,mBAAmBoB,gBAAgBC,WAAWte,KAAKpI,MAExD,MAAM2gB,EAuBV,SAAwC3e,GAEtC,MAAMmT,EAAOnT,EAAQ2c,cACfmC,EAAQ3L,EAAK2F,UACb6L,EAAc7F,EAAMb,IAE1Ba,EAAMb,IAA4Bje,EAClC,IAEE,MAAM2e,EAAY,IAAIxL,EAAKnT,GAI3B,OAFC2e,EAAkBV,IAA4Bje,EAExC2e,UAEPG,EAAMb,IAA4B0G,GAtChBC,CAAa5mB,MAK/B,OAHAA,KAAKulB,WAAa5oB,EAAcgkB,GAChC3gB,KAAKylB,QAAQvU,KAENlR,KAGTzB,WACEyB,KAAKylB,QAAQvU,KAGf3S,WACMyB,KAAKylB,QAAQvU,OACflR,KAAKylB,QAAQvU,MAEflR,KAAK8lB,cACD,IAAM9lB,KAAKuV,cAAc,IAAI8K,GAAe,kBAAmB,CAAEwG,SAAS,OAkClF,SAASd,KACP,MAAM,IAAIhjB,UAAU,+BC9KtB,MAAM+jB,iBCgCJnG,gBACE,OAAO3gB,KAAKgC,QAAQ2e,UAMtBhiB,cACE,OAAOqB,KAAKgC,QAAQrD,UDtCtBJ,YAAqByD,GACnBlB,QADmBd,aAAAgC,EAIrB0jB,gBACE,OAAO1lB,KAAKgC,QAAQ0jB,UAGtBnnB,UACEyB,KAAKgC,QAAQ+kB,WAGfxoB,iBAEE,MAAMyoB,EAAchnB,KAAKgC,QAAQrD,QAC3BsoB,EAAMD,EAAG3P,cACTqO,EAAmB,MAAPuB,GAAeA,EAAIC,SAASF,GAU9C,OARItB,IAAc1lB,KAAK0lB,YACjBA,EACF1lB,KAAKmlB,UAELnlB,KAAKgC,QAAQmlB,WAIVzB,SAQE0B,WAAiDhC,GAI5D7mB,YAAY8oB,EAA0C1oB,GACpDmC,MAAMumB,EAAmB1oB,GACzBqB,KAAK0jB,MAAQ1jB,KAAK0jB,MAAQ,IAAIoD,GAAmB9mB,OExCrD,MAAMsnB,WAAkDlC,GAEtD1B,oBCLW6D,GAKXhpB,cAEE,MAAMipB,EAAa9V,GAAW,GACxB5B,EAAU,IAAIhC,GAEpB9N,KAAKynB,UAAYnb,GAAU1E,IAEzB,MAAM8f,EAAcF,EAAWtW,GAAK,EAEpCpB,EAAQzF,GAAG,CACTvC,OAAQF,EAASE,OACjBG,QAAS,CAAC0f,EAAcC,EAAkBC,KACpCA,EAAcH,GAEhB9f,EAASK,QACL,CACE1J,YAAYsK,GACV8e,EAAa3W,YAAY8W,GAAoBjf,EAAkBif,MAGnEF,QAMRJ,EAAWtW,KAEflR,KAAKsmB,aAAekB,EAAW1W,OAAO3D,UAClC4a,GAAO,CAAC/lB,EAAS6lB,KACf/X,EAAQ1H,KAAKpG,EAAS6lB,GACfE,WCpBJC,WAA6C/C,GASxD1mB,YACa0pB,EACAxB,EACA9H,WAEX7d,QAJWd,gBAAAioB,EACAjoB,qBAAAymB,EACAzmB,mBAAA2e,EARJ3e,oBAAiB,IAAIunB,GAW5BvnB,KAAKkoB,OAASxW,IAAW,GACzB1R,KAAKmoB,WAAanoB,KAAKkoB,OAAOpX,OAAOtG,KAAK4d,GAASA,EAAQzqB,IAAaG,KACxEkC,KAAKqoB,KAAO9I,GAAarC,GAAGyB,GAE5B,MAAM2J,EAA4B,IAAIrG,GAClCgG,EAAWnrB,IAAImlB,IAA2BsG,OAAOvoB,OAGrDsoB,EAA0B9kB,QAAQ,CAAE5B,EAAGqjB,GAAmB7iB,GAAIpC,OAC9DA,KAAKlD,IAAMwrB,EAA0BvkB,YAAYjH,IACjDkD,KAAKwoB,iBAAmB,IAAIzG,GAAyBuG,EAA0BC,OAAOvoB,OAEtF,MAAMyoB,EAAazoB,KAAK2lB,YAAY7Z,EAC9B4c,EAAiB1oB,KAAKmmB,gBAAgBra,EAEtC6c,EAAsC,CAC1ChK,oBACE,OAAOA,GAETgH,gBACE,OAAO8C,GAETtC,oBACE,OAAOuC,GAETE,cAAennB,GAAQ6mB,EAA0B9kB,QAAQ/B,GACzDonB,aAAcpnB,GAAQzB,KAAKwoB,iBAAiBhlB,QAAQ/B,iBAGtDzB,KAAKqoB,MAAKtK,6BAAQ4K,GAClBxG,GAAaxD,GAAeZ,MAAM4K,GAGpCrE,kBACE,OAAOtkB,KAAK8oB,eAKdvqB,UAAUqJ,GACR,OAAQ5H,KAAK2lB,UAAa3lB,KAAKmoB,WAAW1b,MAAM9P,EAAcqD,OAAO6J,OAA2BiC,GAAGlE,GAGrGrJ,QAAQI,GACN,GAAIA,EAAQshB,IACV,MAAM,IAAI3e,MAAM,WAAW3C,gCAG7B,MAAMqD,EAAU,IAAIolB,GAAuBpnB,KAAMrB,GAEjDqD,EAAQ+mB,mBAER,MAAMrF,MAAEA,GAAU1hB,EAMlB,OAJA0hB,EAAME,iBACN5hB,EAAQgnB,WACRhnB,EAAQinB,SAEDvF,EAKTnlB,cAAcqJ,GACZ,OAAQ5H,KAAKmmB,cAAgBnmB,KAAKomB,eAAeqB,UAAU3b,GAAGlE,GAGhErJ,aACIkD,GAEF,OAAOzB,KAAKwoB,iBAAiBhlB,QAAQ/B,GAGvClD,wBACE,OAAOyB,KAAKioB,WAAWnrB,IAAIilB,IAA0BmH,OAAOlpB,KAAKwoB,kBAGnEjqB,eACE,MAAM,IAAI+C,MAAM,yFAGlB/C,+BACEyB,KAAKqoB,MAAK9J,8BAASve,MACnBA,KAAKymB,gBAAgB0C,YAAY/gB,KAAKpI,MACtCA,KAAK8oB,aAAensB,WFpGpB0qB,GAGF,MAAM5C,EAAa4C,EAAkBvqB,IAAIgoB,IAEzC,MAAMsE,UAAuB3E,EAAWD,OAAOrP,KAK7C5W,cACEuC,QAEA,MAAMkB,EAAU,IAAIslB,GAAwBD,EAAmBrnB,MAE/DgC,EAAQ+mB,mBACR/mB,EAAQgnB,WAGVzqB,oCACEuC,MAAMuoB,6CACNrpB,KAAKigB,IAA0B8G,WAGjCxoB,6BACEyB,KAAKigB,IAA0BkH,oBAC/BrmB,MAAMwoB,iDAKV,OAAOF,EEqE6BG,CAAkBvpB,OACnDA,KAAK2e,cAAsBqF,IAA6BhkB,KACzDA,KAAKkoB,OAAOhX,IAAK,GCpGd,MAAMsY,OAAsE/iB,EAC/E,kBACA,CACErF,UAAWkZ,IAIjB,SAA2B8I,GACzB,MAAO,CACL+F,YAAa,IAAIrb,GACjB4Y,WAAY,IAAI5Y,GAChBvP,aAA+BogB,GAE7B,MAAM0I,EAAoB,IAAIW,GAAmB5E,EAAWpjB,KAAM2e,GAIlE,OAFA0I,EAAkBoC,UAEXpC,SCzBb,MAAMqC,GAAW/sB,EAAcF,SCLlBktB,GAIXprB,YAA6BwJ,GAAA/H,cAAA+H,EAFrB/H,sBAAmC,GAGzC+H,EAAS4d,UAAU,KACjB3lB,KAAK4pB,iBAAiBrf,QAAQsf,GAAcA,YACrC7pB,KAAK4pB,mBAIhBzF,qBACE,OAAOnkB,KAAK+H,SAASjL,IAAIsnB,IAG3B7lB,OAAyBogB,GACvB3e,KAAK4pB,iBAAiB1kB,KAAK,KAEzB,MACMqf,EADiBvkB,KAAK+H,SAASjL,IAAI0sB,IACPM,aAAanL,GAE/C3e,KAAKmkB,eAAe5F,OAAOI,EAAe4F,EAAWD,sBCN9CyF,WAAwBrL,GAMnCngB,YACqB0pB,EACA+B,GAEnBlpB,QAHmBd,gBAAAioB,EACAjoB,aAAAgqB,EANZhqB,0BFLT,MAAMiqB,EAA0B,GAChC,IAAI5gB,EAAO6gB,IAET,MAAMC,EAASD,IAIf,OAFAD,EAAQ/kB,KAAKilB,GAENA,GAWT,MAAO,CACLriB,OAVaJ,EAAY,KACzB2B,EAAMqgB,GACNjrB,EACIiB,EAAUuqB,GAAS3rB,UACnB6rB,GAAUA,KAEdF,EAAQpqB,OAAS,IAKjBwJ,IAAI6gB,GACK7gB,EAAI6gB,IEhBME,GAUnB,MAAMlmB,EAAW,IAAIf,EAAgC8kB,GAErD/jB,EAASV,QAAQ,CAAE5B,EAAG8c,GAAgBtc,GAAIpC,OAC1CA,KAAKlD,IAAMoH,EAASH,YAAYjH,IAChCkD,KAAKqqB,mBAAqB,IAAIV,GAAkB3pB,MAGlD6e,cACE,OAAO7e,KAAKgqB,QAAQM,QAAQzL,QAK9BtgB,UAAUqJ,GACR,OAAQ5H,KAAK2lB,UAAYnY,GAAS,CAChC+c,GAAIvqB,KAAKgqB,QAAQQ,MACjBC,GAAI/Y,KAA+B7P,GAAG7B,KAAKioB,WAAWtC,eACrDnb,KACC,EACE+f,IAAKnC,GACLqC,IAAKA,MACDA,GAAMrC,EAAQ5qB,EAAQwC,MAAQlC,KACtC+L,OAAOiC,GAAGlE,GAKdrJ,aAAaqJ,GACX,OAAQ5H,KAAK0qB,aAAe1qB,KAAKioB,WAAWnrB,IAAI0sB,IAAgBL,YAAY9e,KACvEkB,QAAQvL,KAAK2qB,UAAU7iB,QAAQgE,GAAGlE,GAKzCrJ,YAAYqJ,GACV,OAAQ5H,KAAK4qB,YAAc5qB,KAAKioB,WAAWnrB,IAAI0sB,IAAgB9C,WAAWrc,KACrEkB,QAAQvL,KAAK2qB,UAAU7iB,QAAQgE,GAAGlE,GAGzCrJ,QACIkD,GAEF,OAAOzB,KAAK2qB,UAAUthB,IAAI,IAAMrJ,KAAKioB,WAAWnrB,IAAI+kB,IAA0Bre,QAAQ/B,IAGxFlD,cACIkD,GAEF,OAAOzB,KAAK2qB,UAAUthB,IAAI,IAAMrJ,KAAKioB,WAAWnrB,IAAImlB,IAA2Bze,QAAQ/B,IAGzFlD,aACIkD,GAEF,OAAOzB,KAAK2qB,UAAUthB,IAAI,IAAMrJ,KAAKioB,WAAWnrB,IAAIilB,IAA0Bve,QAAQ/B,IAGxFlD,gBAAkCogB,GAChC,gBrBjFAA,EACAkM,GAGF,MAAMxgB,GAAEA,GAAO8X,GAAaxD,GAE5B,OAAOrS,GAAU1E,IACfyC,EAAGN,GAAG,CACJjC,OAAQF,EAASE,OAAOP,MAAMsjB,EAAS/iB,QACvCvJ,QAAQgE,EAAKwb,GAEX,MAAM4H,EAAY5H,EAAM4H,YAAYpa,QAAQsf,EAAS/iB,QAAQgE,EACvDqa,EAAgBpI,EAAMoI,gBAAgB5a,QAAQsf,EAAS/iB,QAAQgE,EAErElE,EAASK,QAAQ1F,EAAK,CACpBoc,oBACE,OAAOZ,EAAMY,eAEfgH,gBACE,OAAOA,GAETQ,oBACE,OAAOA,GAETyC,cAAcnnB,GACLopB,EAASxhB,IAAI,IAAM0U,EAAM6K,cAAcnnB,IAEhDonB,aAAapnB,GACJopB,EAASxhB,IAAI,IAAM0U,EAAM8K,aAAapnB,WqBqD9CqpB,CAAenM,EAAe3e,KAAK2qB,WAG5CpsB,OAAyBogB,GACvB3e,KAAKqqB,mBAAmB9L,OAAOI,IC3EnC,MAAMoM,GAAoC7tB,OAAO,qBAKpC8tB,WAAmBvU,GAE9BlY,UAAUsgB,GAER,OAAOA,EAAQ/B,eAAeiO,IACvBlM,EAAgBkM,IACflM,EAAgBkM,IAAsB,IAAIC,GAAWnM,GAG/DvI,YACE,OAAOtW,KAGTzB,YAAoBsgB,GAClB/d,MAAM,WAAW+d,EAAQje,MAG3BrC,KACIyC,GAMF,OAiCAoiB,EAhCIpiB,EAAKgB,QAAQlF,IAAIud,IAiCrBtU,EAhCI/E,EAAKE,KAAK4U,SAASmV,IAkClB/d,GAA+BtF,IAEpC,IAAIsjB,EACA7rB,EAAuCsO,KACvCwd,EAAmClf,QAAQC,QAAQ,QAEvD,OAAOsB,GAAS,CACd4d,OAAQrlB,EACRhE,KAAMspB,GAAgBjI,EAAWrd,KAChCoH,UAAU,EAAGie,QAASA,GAASrpB,KAAAA,MAChC,IAAKqpB,EACH,OAAOztB,IAGT,MAAO2sB,GAAWpqB,GAAUkrB,EAE5B,GAAId,EAAQzL,UAAYqM,EACtB,OAAOtd,GAAevO,GAKxB,GAFA6rB,EAASZ,EAAQzL,QAEb3e,IAAWgrB,EAEb,OAAOtd,GAAevO,EAAS+jB,EAAUtmB,IAAIkuB,GAAW9N,GAAGgO,IAAS/d,UAChEme,IACEA,EAAQvhB,GAAGohB,GACXA,EAAUG,EAAQC,MACXD,KAMf,MAAME,EAAY,IAAIC,GAAcrI,EAAWkH,EAASvoB,GAAMgI,GAAGohB,GAC3DO,EAAY/d,GAAS6d,GAE3B,OAAO5d,GAAevO,EAAS6N,GAC3Bye,GAAOD,EAAU3hB,GAAG4hB,GAAKnkB,QAAQ,KAC/B2jB,EAAUK,EAAUrB,YAExBngB,WACDD,GAAGnC,KACLkO,SAKL,WAKE,IAAI8V,EAA+C,KAEnD,OAAQN,GACFM,IAAeN,EACVxtB,KAET8tB,EAAaN,EAERA,EAIE3tB,EAA2B2tB,GAHzB3tB,KAlBPkuB,IAhDN,IACIzI,EACArd,GA1BJ,SAASklB,MAA0Ba,GAEjC,IACI5X,EADA1I,GAAW,EAGf,IAAK,MAAM4f,KAAUU,EACnB,OAAQV,EAAO,IACf,IAAK,KACH5f,GAAW,EACN0I,IACHA,EAAYkX,GAEd,MACF,IAAK,MACHlX,EAAYkX,EACZ,MACF,IAAK,QACH5f,GAAW,EAIf,OAAOA,EAAW0I,OAAYtO,EA4EhC,SAASylB,GACLjI,EACArd,GAEF,OAAOA,EAAKoH,UAAUie,IACpB,IAAKA,EACH,OAAOztB,IAGT,OAAOkgB,IAAEA,IAASuN,EACZ7jB,EAAQ,IAAIiT,GAASqD,EAAItW,OAE/B,OAAKA,EAAM6B,KAIJwE,GACHF,MACOjO,EACC8H,EACArF,GAAOkhB,EAAUtmB,IAAIkuB,GAAW9N,GAAGhb,MAEzCiL,UAAU4e,KATPpuB,MAcb,SAASouB,MAAsBhqB,GAC7B,OAAOpE,KACAyB,EACCK,EAAMsC,EAAMG,GAAOA,EAAI,IACvBxF,UAQG+uB,GAOXltB,YACa6kB,EACAkH,EACAvoB,GAFA/B,eAAAojB,EACApjB,aAAAsqB,EACAtqB,UAAA+B,EALJ/B,WAAQ0R,IAAW,GAO1B1R,KAAKgsB,KAAO,IAAI/f,QAAQC,GAAWlM,KAAKisB,MAAQ/f,GAChDlM,KAAKksB,OAASjgB,QAAQC,QAAQ,IAAIigB,GAAkBnsB,OAGtDurB,YACE,OAAOvrB,KAAKksB,OAAO7f,KAAKkf,GAASA,EAAMa,OAGzChE,YACE,OAAOpoB,KAAKwqB,MAAMtZ,GAGpB3S,GAAG4sB,GAED,MAAMkB,EAAYrsB,KAAKksB,OAIvB,OAFAlsB,KAAKksB,OAASf,EAAQ9e,KAAKigB,GAAMD,EAAUhgB,KAAKkf,GAASA,EAAMe,OAExDtsB,KAGTzB,oBACSyB,KAAKksB,OAASlsB,KAAKksB,OAAO7f,KAAKkf,GAASA,EAAMxN,UAGvDxf,mBACSyB,KAAKksB,OAASlsB,KAAKksB,OAAO7f,KAAKkf,GAASA,EAAMvN,SAGvDzf,eAEE,MAAMguB,EAAYvsB,KAAKksB,cAEhBlsB,KAAKksB,OAEZ,MAAMX,QAAcgB,EACdpB,QAAgBI,EAAMiB,OAI5B,OAFAxsB,KAAKisB,QAEEd,GAQX,MAAesB,GAIbluB,YACa+sB,EACQoB,EAA0B,KAAMzgB,QAAQC,YADhDlM,YAAAsrB,EACQtrB,WAAA0sB,EAGrBnuB,OACE,OAAO0N,QAAQC,QAAQlM,MAOzBzB,OACE,OAAOyB,KAAK0sB,QAAQrgB,KAAK,IAAMrM,KAAKosB,OAG5B7tB,OAAOG,GAEf,MAAMqD,KAAEA,GAAS/B,KAAKsrB,OAEtB,OAAOrf,QAAQqS,IAAIvc,EAAKE,IAAIC,GAAOxD,EAAOwD,MAK9C,MAAMiqB,WAA0BM,GAE9BL,YACE,MAAO,OAGT7tB,0BACQyB,KAAK2sB,OAAOrB,GAAUA,EAAOvN,SAEnC,MAAMqF,UAAEA,EAAWkH,SAASzM,IAAEA,IAAU7d,KAAKsrB,OACvCtpB,EAAU,IAAI+nB,GAAgB3G,EAAWpjB,KAAKsrB,QAC9CxjB,EAAS9F,EAAQ2oB,UAAU7iB,OAIjC,iBAFA+V,EAAIE,2BAAJF,EAAY7b,GAEL,IAAI4qB,GACP5sB,KAAKsrB,OACLtpB,EACA,IAAMiK,QAAQC,QAAQpE,EAAOhB,QAInCvI,OACE,OAAOyB,KAAK+d,QAAQ1R,KAAKkf,GAASA,EAAMvN,SAK5C,MAAM4O,WAAyBH,GAM7BluB,YACIisB,EACiBziB,EACjBykB,GAEF1rB,MAAM0pB,EAAOgC,GAHMxsB,cAAA+H,EANrBqkB,YACE,MAAO,QAWT7tB,QACE,OAAO0N,QAAQC,QAAQlM,MAGzBzB,yBACQyB,KAAK2sB,OAAOrB,GAAUA,EAAOtN,QAEnC,MAAQsM,SAASzM,IAAEA,IAAU7d,KAAKsrB,OAIlC,iBAFAzN,EAAIG,0BAAJH,EAAW7d,KAAK+H,UAET,IAAI8kB,GAAmB7sB,OAKlC,MAAM6sB,WAA2BJ,GAE/BL,YACE,MAAO,OAGT7tB,YAAY4I,GACVrG,MAAMqG,EAAKmkB,OAAQ,IAAMnkB,EAAKqlB,QAC9BrlB,EAAKmkB,OAAOd,MAAMtZ,IAAK,EAGzB3S,QACE,OAAO0N,QAAQC,QAAQlM,MAGzBzB,OACE,OAAO0N,QAAQC,QAAQlM,aClVd8sB,GAKXvuB,YACqBwuB,EACRlO,EACDmO,GAFShtB,gBAAA+sB,EACR/sB,aAAA6e,EACD7e,aAAAgtB,EALJhtB,WAAQ,EAOdA,KAAK6d,IA+DT,SAAoBO,GAElB,IAAIP,EAAMM,GAAWjB,GAAGkB,GAExB,GAAIe,MAAwBf,EAAa,CACvCP,EAAMM,GAAW/B,MACbyB,EACA,CACEtf,KAAKyD,GACHA,EAAQuc,OAAOH,MAKvB,MAAMS,QAAEA,GAAYU,GAAarC,GAAGkB,GAEhCS,IACFhB,EAAMM,GAAW/B,MAAMyB,EAAKgB,IAKhC,OAAOhB,EArFMoP,CAAWpO,GAGxBtgB,QAAQutB,GAEN,MAAMoB,EAAYltB,KAAK+sB,YACjB7oB,SAAEA,GAAagpB,EACfC,EAA0B,CAACntB,KAAM,KAAMA,KAAK6e,SAElD7e,KAAKotB,UAAUlpB,EAASV,QAAQ,CAC9B5B,EAAGopB,GAAW9N,GAAGld,KAAK6e,SACtBzc,GAAI+qB,KAGN,IAAK,MAAMtO,KAAW,IAAIrE,GAASxa,KAAK6d,IAAIC,KAAM,CAEhD,MAAMsN,EAA4B,CAACprB,KAAM,MAAO6e,GAEhD7e,KAAKotB,UAAUlpB,EAASV,QAAQ,CAAE5B,EAAGopB,GAAW9N,GAAG2B,GAAUzc,GAAIgpB,KAGjE,MAAMd,EAAU4C,EAAU5C,QAAQzL,EAAS,IAAIiN,EAASV,IAExDprB,KAAKotB,UAAU,IAAM9C,EAAQ+C,SAG/B,IAAK,MAAMxO,KAAW,IAAIrE,GAASxa,KAAK6d,IAAItW,OAAQ,CAElD,MAAM6jB,EAA4B,CAACprB,KAAM,QAAS6e,GAE5CyL,EAAU4C,EAAU5C,QAAQzL,EAAS,IAAIiN,EAASV,IAExDprB,KAAKotB,UAAU,IAAM9C,EAAQ+C,SAC7BrtB,KAAKotB,UAAUlpB,EAASV,QAAQ,CAAE5B,EAAGopB,GAAW9N,GAAG2B,GAAUzc,GAAIgpB,KAKnE,OAFAprB,KAAKstB,MAAQ,EAENttB,KAGTzB,MAAMutB,GACJ,IAAK9rB,KAAKstB,MACR,MAAM,IAAIvO,GAAkB+M,EAAQ7pB,IAAI,GAAI4c,QAAAA,GAAW7X,EAAQiY,KAAU,CAACJ,EAAS7X,EAAQiY,KAK7F,QAFEjf,KAAKstB,MAEAttB,KAGTzB,UACSyB,KAAKstB,OACVttB,KAAKgtB,UAIDzuB,UAAUgvB,GAChBvtB,KAAKgtB,QAAU7Q,GAAeoR,EAAQvtB,KAAKgtB,UClF/C,MAAMQ,OAA2C/mB,EAC7C,oBACA,CACErF,UAAWkZ,GAAiBtY,GAAW,IAAIyrB,GAAiBzrB,YAOrDyrB,GASXlvB,YAAYyD,GAFKhC,UAAO,IAAIqD,IAG1BrD,KAAKkE,SAAWlC,EAAQlF,IAAI+kB,IAR9BnhB,WAAYA,KACV,OAAO8sB,GAUTjvB,QAAQsgB,EAAgBiN,EAAwC,IAE9D,MAAMhhB,EAAW9K,KAAK0tB,KAAK5wB,IAAI+hB,GAE/B,GAAI/T,EACF,OAAOA,EAAS6iB,MAAM7B,GAGxB,MAAMxB,EAAU,IAAIwC,GAAe9sB,KAAM6e,EAAS,IAAM7e,KAAK0tB,KAAKpkB,OAAOuV,IAIzE,OAFA7e,KAAK0tB,KAAK9pB,IAAIib,EAASyL,GAEhBA,EAAQA,QAAQwB,ICjCpB,MAAM8B,GAAqC1wB,OAAO,sBC0C5C2wB,OACShoB,EAAqC,wBCxC9CioB,GAAqC5wB,OAAO,sBAiBzC6wB,GAAgBntB,GAC9B,MAAO,CAACktB,GAAqBltB,YCffotB,GACZptB,EACAuf,GAAgE,GAElE,IAAoB,IAAhBA,EACF,OAAO1jB,EAET,IAAoB,IAAhB0jB,GAA+C,mBAAhBA,EAA4B,CAE7D,MAAMjR,EAAO6e,GAAgBntB,GACvB2P,GAAqD,IAAhB4P,EAAuB8N,GAAuB9N,EAEzF,MAAO,CAACQ,EAAcpR,EAAUC,IAAae,EAAOoQ,EAAWzR,EAAMK,EAAUC,GAGjF,MAAO,CAACmR,EAAcpR,EAAUC,IAAaye,GAAqBtN,EAAWR,EAAa5Q,EAAUC,GAGtG,SAASye,GACLtN,EACAzR,EACAK,EACAC,GAEF0Q,GAAiBhD,GAAGyD,GAAWR,YAAYjR,EAAMK,EAAUC,YCvB7C0e,GAAuBttB,GAErC,IAAIvD,EAEJ,IAAK,IAAIuC,EAAI,EAAGA,EAAIgB,EAAKf,SAAUD,EAAG,CAEpC,MAAMuuB,EAAIvtB,EAAKhB,GAEXuuB,GAAK,KAAOA,GAAK,KACd9wB,IAEHA,EAASuD,EAAKwtB,UAAU,EAAGxuB,IAE7BvC,GAAU,IAAM8wB,EAAEE,eACThxB,IACTA,GAAU8wB,GAId,OAAO9wB,GAAUuD,EC1BnB,MAAM0tB,OAA4C7nB,EAAoC,4BAKzE8nB,GAQXhwB,YAA6BwJ,GAAA/H,cAAA+H,EAN7BrH,WAAYA,KACV,OAAO4tB,GAQTE,YACE,GAAIxuB,KAAKyuB,OACP,OAAOzuB,KAAKyuB,OAGd,MAAMD,EAAQ,IAAInrB,IASlB,OAPArD,KAAK+H,SAASjL,IAAI+wB,IAAqBtjB,QAAQ6Q,IAE7C,MAAMxa,KAAEA,EAAI8tB,OAAEA,GAAWtT,EAEzBoT,EAAM5qB,IAAIhD,EAAMub,GAAeqS,EAAM1xB,IAAI8D,GAAO8tB,MAG3C1uB,KAAKyuB,OAASD,EAGvBjwB,OAAO+lB,GAEL,MAAMkK,EAAQxuB,KAAKwuB,MAEdA,EAAMplB,OAIX1G,OAAOwZ,eAAeoI,EAAa,qBAAsB,CACvDvI,cAAc,EACdC,YAAY,EACZxf,MAAOmyB,GAAmBrK,EAAakK,EAAMluB,UAE/CoC,OAAOwZ,eAAeoI,EAAYxJ,UAAW,2BAA4B,CACvEiB,cAAc,EACdC,YAAY,EACZxf,MAAOoyB,GAAyBtK,EAAakK,MAIjDjwB,MAAMmlB,GAEJ,MAAM/kB,EAAU+kB,EAAM/kB,QAChB6vB,EAAQxuB,KAAKwuB,MACbK,EAAkB/oB,MAAMC,KAAKyoB,EAAMluB,QAEpCuuB,EAAgBhvB,QAKJ,IAAIyjB,EADItjB,KAAK+H,SAASjL,IAAIulB,IAAiBiB,kBAExDwL,GAAWA,EAAQvkB,QACfwkB,IAEE,MAAMC,EAAgBD,EAAOC,cAE7B,OAAOR,EAAM1xB,IAAIkyB,EAAVR,CACHtO,GAAiBhD,GAAMve,GAASgiB,UAChChiB,EAAQswB,aAAaD,GACrBD,EAAOvf,aAMZsU,QAAQnlB,EAAS,CACxBuwB,YAAY,EACZL,gBAAAA,EACAM,mBAAmB,KAmBzB,SAASR,GACLrK,EACAkK,GAGF,MAAMY,EAAkD9K,EAAoBqK,mBAE5E,OAAO7oB,MAAMC,KACToJ,GAAgBigB,GACV,IAAI5U,GAAS4U,GAAiB1U,OAAO8T,GAAO/T,MAC5C+T,GAOZ,SAASI,GACLtK,EACAkK,GAGF,MAAMa,EAAoD/K,EAAYxJ,UAAU8T,yBAEhF,OAAKS,EAME,SAAqBzuB,EAAM4O,EAAUD,GAE1C,MAAM+f,EAAcd,EAAM1xB,IAAI8D,GAE1B0uB,EACFA,EAAYpP,GAAiBhD,GAAMld,MAAM2gB,UAAWpR,EAAUC,GAE9D6f,EAAaxxB,KAAKmC,KAAMY,EAAM4O,EAAUD,IAZnC,SAAqB3O,EAAM4O,EAAUD,GAC1Cif,EAAM1xB,IAAI8D,EAAV4tB,CAAiBtO,GAAiBhD,GAAMld,MAAM2gB,UAAWpR,EAAUC,IC7HzE,MAAM+f,GAAyC,CAC7ChxB,MAAMwf,GACJA,EAAM6K,cAAc,CAAEjmB,GAAI4rB,KAC1BxQ,EAAM2M,aAAarD,IAEjBA,EAAkB1B,UACd,EAAGrB,YAAAA,KAAkB+C,EAAkBvqB,IAAIyxB,IAAmBhQ,OAAO+F,MAG3EvG,EAAM6M,YAAYhD,IAEhB,MAAMlE,EAAQkE,EAAiBlE,MAE3BA,GAEFkE,EAAiB9qB,IAAIyxB,IAAmB7K,MAAMA,aAczC8L,GAEX9R,WAAYA,MACV,OAAO6R,aCjBKE,GACZ5R,GAEF,OAAO2C,GAAkB,EAAGrL,KAAAA,EAAM1U,IAAAA,MAEhC,MAAMsgB,WCpBN7gB,EACAib,EACAna,GAGF,IAAIJ,EACA8tB,EAEJ,GAAoB,iBAAT1tB,EACTJ,EAAOstB,GAAuBltB,GAC9B0tB,EAASV,GAAqBptB,OACzB,CACL,GAAII,GAAQA,EAAKJ,KACfA,EAAOstB,GAAuBltB,EAAKJ,UAC9B,CAAA,GAA2B,iBAAhBua,EAChB,MAAM,IAAIpY,UAEJ,+DAAG7C,EAAO+a,YAAYra,kBAAkBkb,OAAOX,MAGrDva,EAAOstB,GAAuB/S,GAGhCuT,EAASV,GAAqBptB,EAAMI,GAAQA,EAAKmf,aAGnD,MAAO,CAAEvf,KAAAA,EAAM8tB,OAAAA,GDNMgB,CAAyBva,EAAK2F,UAAWra,EAAKod,IAC3Djd,KAAEA,GAASmgB,EAEjB,MAAO,CACLH,aAAc,CACZ/B,QAAS,CACPtX,MAAOioB,IAETjxB,MAAMwf,GACJA,EAAM6K,cAAc,CAAEhnB,EAAGisB,GAAqBzrB,GAAI2e,MAGtDjkB,IAAI6jB,GACKT,GAAiBhD,GAAGyD,GAAWhiB,QAAQswB,aAAaruB,GAE7DrC,IAAIoiB,EAA4BpR,GAE9B,MAAM5Q,QAAEA,GAAkCuhB,GAAiBhD,GAAGyD,GAE9C,MAAZpR,EACF5Q,EAAQgxB,aAAa/uB,EAAM2O,GAE3B5Q,EAAQixB,gBAAgBhvB,OE1ClC,MAAMivB,OAAyCppB,EAAiC,yBAOnEqpB,WAAuBpf,GAElChQ,WAAYA,KACV,OAAOmvB,ICRX,MAAME,GAAoC,CACxCxxB,MAAMwf,GACJA,EAAM8K,aAAa,CACjBjnB,EAAGkuB,GACHvxB,GAAGyD,GAED,MAAMwoB,EAAQ,IAAIsF,GAIlB,OAFAxoB,EAActF,GAASwF,QAAQR,GAAUwjB,EAAM1rB,KAAKkI,IAE7CwjB,KAGXzM,EAAM8K,aAAa,CACjBjnB,EAAGoe,GACHne,GAAG2oB,GACMA,EAAMja,OAEfzO,KAAM,CAACguB,cAkBAE,GAEXtS,WAAYA,MACV,OAAOqS,WChCX,MAAME,WAAyBpf,GAI7BtS,YACqBwJ,EACAmoB,EACA5f,GAEnBxP,QAJmBd,cAAA+H,EACA/H,WAAAkwB,EACAlwB,WAAAsQ,EALZtQ,SAAwB0H,IAUjCwJ,SACE,OAAOlR,KAAK+H,SAASpJ,QAAQswB,aAAajvB,KAAKkwB,OAGjDhf,OAAO1U,GACA8K,EAActH,MAAMoH,QACV,MAAT5K,EACFwD,KAAK+H,SAASpJ,QAAQixB,gBAAgB5vB,KAAKkwB,OAE3ClwB,KAAK+H,SAASpJ,QAAQgxB,aAAa3vB,KAAKkwB,MAAO1zB,IAOrD+B,GACIqJ,GAEF,OAAQ5H,KAAKqK,GAAKrK,KAAK+H,SAASjL,IAAIgzB,IAAgBlf,MAAM5Q,KAAKsQ,OAAOG,WAAWjG,KAC7E,CAAC8F,EAAOf,EAAUC,IAAa7R,EAAS4R,EAAUC,IACpDjE,QAAQvL,MAAM8L,GAAGlE,OA/BXhB,QCVCupB,GAAuCjzB,OAAO,sBCkF9CkzB,GAAkClzB,OAAO,UAKzCmzB,GAAY,CAUvB5uB,KAAI,CAEAO,EACA6b,aCtDFyS,KACG1yB,GAEL,MAjBwB,mBAiBiB0yB,EAAWA,KAAU1yB,GAAQ0yB,EDqD7DC,CAAc1S,EAAK7b,GAW5BzD,QAAoBiyB,EAAsBC,EAA2B,IAEnE,MAAMpmB,GAAEA,EAAKomB,EAASpmB,GAAEmN,MAAEA,GAAUgZ,EAEpC,MAAO,CACLnmB,GAAAA,EACAmN,MAAOA,EAAQA,EAAMxT,KAAKwsB,GAAQC,EAASjZ,OAASiZ,EAASjZ,MAAMxT,KAAKysB,KAY5ElyB,QAEIyD,EACAP,EAAuB,IAGzB,MAAM4I,GAAEA,EAAK,IAAO5I,EAEpB,GAAkB,iBAAP4I,GAAmBb,GAAca,GAC1C,OAAO2D,GAAW3D,GAAIkB,QAAQvJ,GAGhC,MAAM0uB,EAAU1uB,EACXlF,IAAIgzB,IACJlf,MAAMvG,GACNoG,WACAlF,QAAQvJ,GAEb,OAAI8D,MAAMqJ,QAAQ9E,KAAQA,EAAGxK,OACpB6wB,EAAQjkB,MACVyC,GAA+BA,EAAK,KAAOkhB,GAAmBtyB,EAAWH,KAIzE+yB,UEhJEC,GAIXpyB,YAA6BwJ,GAAA/H,cAAA+H,EAFZ/H,cAAW,IAAIkJ,IAKhC3K,SACIqyB,EACA/S,EAAiB,IAGnB,MAAMpc,EAAO4uB,GAAU5uB,KAAKzB,KAAK+H,SAAU8V,GACrC6S,EAAUL,GAAUK,QAAQ1wB,KAAK+H,SAAUtG,GAC3CqW,EAAW9X,KAAK+H,SAASjL,IAAI+lB,GAAlB7iB,gCACZqwB,GAAUQ,QAAQpvB,KACrB0V,KAAMnX,KAAK+H,SAASpJ,WAEhBmnB,EAA8B,cAAdrkB,EAAKqvB,KAC3B,IAAIlL,IACJ,MACMnV,EAAWqV,EACX,IAAM9lB,KAAK+H,SAAS2d,WAAaqL,IACjC,IAAM/wB,KAAK+H,SAASyd,SAAWuL,IAC/BjpB,EAAS4oB,EACV3mB,GAAG0G,GACHlJ,MAAMvH,KAAK+H,UACXP,SAmBL,eACMoe,GACF9N,EAASrb,GAEXmpB,SArBDE,EAAgB9lB,KAAK+H,SAAS+d,gBAAkB9lB,KAAK+H,SAAS8d,eAAe9b,GATvD,IAAgB6b,GAA6CmL,KAWpF,MAAMC,EAAoBpX,KAI1B,OAFA5Z,KAAKixB,SAAS5nB,IAAI6nB,GAEXppB,EAAON,QAAQ,IAAMxH,KAAKixB,SAAS3nB,OAAO4nB,IAEjD,SAASH,IACPnL,IACA9N,EAASqZ,GAGX,SAASD,IACPF,EAAkBG,GAUpB,SAASA,EAAc/Y,GACrB,GAAIwN,IAEF,IADAA,MACU,CAER,MAAMwL,EAAcR,EAASxY,GAE7B,GAAIgZ,IAAgBR,GAAmC,mBAAhBQ,EACrC,MAGFR,EAAWQ,IAMnB7yB,YACEyB,KAAKixB,SAAS1mB,QAAQ8mB,GAAUA,YCxCvBC,OACS7qB,EACd,qBACA,CACErF,UAAUpE,GACD,IAAI2zB,GAAkB3zB,EAAOF,IAAIojB,aC4BvCqR,OACS9qB,EACd,2BACA,CACErF,UA5BV,SAAmCY,GAEjC,MAAMwvB,EAAYxvB,EAAQlF,IAAIw0B,IAE9B,MAAO,CAACtwB,EAAO,MAEb,MAAMywB,EAAa/f,GAAuBjV,GAO1C,OAFA+0B,EAAUE,SAJwBtZ,IAChCqZ,EAAWvgB,GAAGkH,IAGaiY,GAAUQ,QAAQ,CAAExmB,GAAIonB,EAAWpnB,MAAQrJ,IAEhEiX,IACNwZ,EAAWvgB,GAAKkH,GAAaH,EAAKG,iBC7CxBuZ,GACZ9T,GAEF,OAAO2C,GAAkB,EAAG1jB,IAAAA,OAC1B8jB,aAAc,CACZ/B,QAAS,CACPtX,MAAOyoB,IAETzxB,OAAOgmB,GACLA,EAAW4B,cAAcnkB,IACvBA,EAAQ2jB,UAAU,KAEhB,MAAMhF,UAAEA,GAAc3e,EAChB4uB,EAAW9zB,EAAI6jB,GAAW3c,KAAK2c,GAErC3e,EAAQlF,IAAIw0B,IAAkBI,SAASd,EAAU/S,kBC1BhD+T,OACSnrB,EAAoC,6BCN7CorB,WAAuBvR,MAKlCwR,iBACE,OAAQ9xB,KAAKE,OAAmB4xB,kBCavBC,OACSrb,GACd,uBCxBFsb,GAAwC,CAC5CzzB,MAAMwf,GACJA,EAAMva,QAAQ,CAAE5B,EAAGmwB,GAAmB3vB,GAAI6vB,aAWjCC,GAEXxU,WAAYA,MACV,OAAOsU,IAQX,SAASC,GAAajwB,EAA2Bgc,GAE/C,MACM8T,EAgBR,SAAsBnzB,EAAkBqf,GAEtC,MAAMlT,EAAWnM,EAAQmzB,WAEzB,GAAIhnB,EAEF,OAAOA,EAET,GAAI,iBAAkBnM,EACpB,OAAOA,EAAQszB,aAAajU,GAG9B,OA5BmBmU,CADHnwB,EAAQrD,QACiBqf,GAUzC,OARI8T,IACDA,EAAmB7R,IAA4Bje,EAChDA,EAAQ8jB,cAAc,IAAM9jB,EAAQuT,cAAc,IAAIsc,GAClD,uBACA,CAAEhL,SAAS,OAIViL,ECnCT,MAAMM,GAA4C,CAAEC,KAAM,iBAuB1CC,GACZzU,EAAwBuU,IAE1B,OAAO5S,GAAU,CACfjhB,MAAMwf,GACJA,EAAM8K,aACF,CACEjnB,EAAGgwB,GACH/vB,GAAGU,GACMA,EAAIzF,IAAIi1B,GAARxvB,CAA2BA,EAAKsb,KAI/CE,EAAM8K,aAAa,CACjBjnB,EAAGie,GACHhe,GAAGG,GACMA,EAAQlF,IAAI80B,GAAmB,CAAEntB,GAAI,UAIlDoa,QAAS,CAAEtX,MAAO2qB,YC9CTK,OAA6Crf,GACtD,6BACA,IACA,kBCIYsf,IACZC,EACEA,EAACC,EACDA,EAACC,EACDA,EAACC,EACDA,EAACC,EACDA,EAAI,GAAEC,EACNA,EAAI,GAAEC,GACNA,EAAK,KAGT,MAAO,CACLN,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,EAAAA,EACAC,GAAAA,YC/BYC,IACZF,EACEA,EAACC,GACDA,GAEFE,GAGF,MAAMxyB,EAAMwyB,EAAMP,GAAKO,EAAML,EACvBzrB,EAAO2rB,EAAEryB,KAGV0G,IAASA,EAAKurB,GAAKO,EAAMP,KAC5BI,EAAEryB,GAAOwyB,GAEXF,EAAG7tB,KAAK+tB,YCdMC,GAAWhb,GACzB,OAAOib,IAEL,MAAMhF,EAAIgF,EAAM7W,EAAE6W,EAAMvzB,GAIxB,OAFAuzB,EAAMC,EAAIlb,EAAOmb,YAAYlF,GAEtBA,GCXX,MAAMmF,GAAc,8HAKJC,GAAcJ,EAAoBK,GAGhD,OAFAL,EAAM7W,EAAI6W,EAAM7W,EAAE8R,UAAU+E,EAAMvzB,GAClCuzB,EAAMvzB,EAAI,IACN0zB,GAAYh0B,KAAK6zB,EAAM7W,KACzBkX,EAAIL,EAAM7W,EAAE8R,UAAU+E,EAAMvzB,EAAGuzB,EAAMvzB,GAAK,MACnC,GCTJ,MAAM6zB,GAAY,KAAa,WCqBtBC,GACZxb,GACAyb,MACEA,GAAQ,EAAIC,OACZA,GAAS,EAAIC,MACbA,GAAQ,EAAIh1B,KACZA,EAAOq0B,GAAWhb,IACA,IAGtB,MAAM4b,WC1BJ5b,GAEF,MAAO,CAACib,EAAOK,KAEb,IAAIO,EAAW,GAGf,MADEZ,EAAMvzB,EACDuzB,EAAMvzB,EAAIuzB,EAAM7W,EAAEzc,SAAUszB,EAAMvzB,EAAG,CAE1C,MAAMuuB,EAAIgF,EAAM7W,EAAE6W,EAAMvzB,GAExB,GAAU,OAANuuB,EAAY,CAEd,MAAMtvB,EAAOs0B,EAAM7W,IAAI6W,EAAMvzB,GAG3Bm0B,GADEl1B,GAGUsvB,MAET,CAAA,SAAIjW,EAAOmb,YAAYlF,GAG5B,QAFEgF,EAAMvzB,OACR4zB,EAAIO,GAGJA,GAAY5F,GAIhBqF,EAAIO,IDHoBC,CAAmB9b,GACvC+b,WE3BJ/b,GAEF,MAAO,CAACib,EAAOK,KACZ,YAAMtb,EAAOmb,YAAYF,EAAM7W,EAAE6W,EAAMvzB,KACrC,OAAO,EAGT,IAAIvC,EAAS,GAGb,MADE81B,EAAMvzB,EACDuzB,EAAMvzB,EAAIuzB,EAAM7W,EAAEzc,QAAQ,CAE/B,MAAMsuB,EAAIgF,EAAM7W,EAAE6W,EAAMvzB,KAExB,UAAIsY,EAAOmb,YAAYlF,GACrB,MAEF9wB,GAAU8wB,EAKZ,OAFAqF,EAAIn2B,IAEG,GFKiB62B,CAAoBhc,GACzCic,EAAaN,EAAQH,GAAWxb,EAAQ,CAAErZ,KAAAA,EAAM+0B,QAAQ,EAAOD,OAAO,EAAOE,OAAO,IAAWJ,GAErG,MAAO,CAACN,EAAOK,KAEb,IAEIY,EACA53B,EAgFAme,EAnFA/Z,EAAO,GACPuU,EAAqB,MAIzB,KAAOge,EAAMvzB,EAAIuzB,EAAM7W,EAAEzc,QAAQ,CAE/B,MAAMsuB,EAAItvB,EAAKs0B,GAEf,GAAIA,EAAMC,EAAG,CACX,MAAID,EAAMC,EACR,MAEF,GAAa,MAAT52B,EAAe,CACjB,MAAI22B,EAAMC,EAA8B,CACtC52B,EAAQoE,EAAO,GAAKutB,IAClBgF,EAAMvzB,EACR,SAEF,SAAIuzB,EAAMC,EAAyB,EAC7BQ,GAAWhzB,GACbkzB,EAAkBX,EAAOP,IACnBhyB,GACFuU,EAAO,gBACPif,EAAMxzB,GAENuU,EAAO,gBAETvU,EAAO,GACPpE,EAAQo2B,IAGZ,MAEF,IAAKhyB,GAAQqzB,EAAmBd,EAAOP,IACrCzd,EAAO,yBACP3Y,EAAQo2B,IAER,MAEFp2B,EAAQoE,EACRA,EAAO,OACF,CAAA,SAAIuyB,EAAMC,EAAyB,EACpCQ,GAAWp3B,GACbs3B,EAAkBX,EAAOP,IACnBp2B,GACF2Y,EAAO,gBACPif,EAAM53B,GAEN2Y,EAAO,gBAET3Y,EAAQo2B,IAGZ,MACK,IAAKp2B,GAASy3B,EAAmBd,EAAOP,IAC7Czd,EAAO,yBACP3Y,EAAQo2B,IAER,OAIJ,GAAa,MAATp2B,EAAe,CACjB,IAAKoE,GAAQ2yB,GAAcJ,EAAOP,GAAKp2B,EAAQo2B,GAAI,CACjDzd,EAAO,YACP,MAEEwe,EACF/yB,GAAQutB,EAER3xB,EAAQ2xB,MAEL,CAAA,IAAK3xB,GAAS+2B,GAAcJ,EAAOP,GAAKp2B,EAAQo2B,GAAI,CACzDzd,EAAO,YACP,MAEA3Y,GAAS2xB,IAGTgF,EAAMvzB,EAKV,GAAa,MAATpD,EAAe,CACjB,IAAKoE,EACH,OAAO,EAET+Z,EAAO6X,GAAS,CAAEC,EAAGtd,EAAMyd,EAAGhyB,SAE9B+Z,EAAO6X,GAAS,CAAEC,EAAGtd,EAAMud,EAAG9xB,QAAQgF,EAAW+sB,EAAGyB,EAAKxB,EAAGp2B,IAI9D,KAAO23B,EAAWhB,EAAOkB,GAAa1Z,EAAKkY,EAAE3tB,KAAKmvB,MAIlD,OAFAb,EAAI7Y,IAEG,YGpIK2Z,GAAcpc,GAC5B,OAAOib,IAEL,IAAIhF,EAAIgF,EAAM7W,EAAE6W,EAAMvzB,GAEtB,MAAU,OAANuuB,GACFgF,EAAMC,EAAIlb,EAAOmb,YAAYlF,GACtBA,MAGPgF,EAAMvzB,EACJuzB,EAAMvzB,EAAIuzB,EAAM7W,EAAEzc,QACpBsuB,EAAIgF,EAAM7W,EAAE6W,EAAMvzB,GAClBuzB,EAAMC,EAAIlb,EAAOmb,YAAYlF,QAE7BgF,EAAMC,IAGDjF,aClBKoG,GAAarc,GAC3B,OAAOib,IAEL,MAAMqB,EAAQrB,EAAMvzB,EAEpB,EAAG,CAED,MAAMuuB,EAAIgF,EAAM7W,EAAE6W,EAAMvzB,GAExB,OAAMsY,EAAOmb,YAAYlF,IACvB,MAEFgF,EAAMvzB,UACCuzB,EAAMvzB,EAAIuzB,EAAM7W,EAAEzc,QAE3B,OAAOszB,EAAMvzB,IAAM40B,YCZPC,GACZvc,EACAlX,EAAuB,IAGzB,MAAM0zB,EAAaH,GAAarc,GAC1Byc,EAAYjB,GAAWxb,iCAAalX,IAAM4yB,QAAQ,KAExD,MAAO,CAACT,EAAOK,SACPtb,EAAOmb,YAAYF,EAAM7W,EAAE6W,EAAMvzB,SAIrCuzB,EAAMvzB,EACR80B,EAAWvB,GAEJwB,EAAUxB,EAAOK,ICRrB,MAAMoB,GAAgC,CAC3CC,IAAK,EACLC,KAAM,EACNC,IAAK,EACLC,IAAK,EACLC,IAAK,MACLC,KAAM,GACNC,IAAK,OACLC,IAAK,OACLC,IAAK,GACLC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,MACAC,gBAMcC,IACZC,QACEA,GAGE,IAGN,MAAMC,EAA+BD,iCAAerB,IAAmBqB,GAAYrB,GAEnF,MAAO,CACLvB,YAAYlF,GACH+H,EAAc/H,KACbA,GAAK,MAAYA,GAAK,KAAa,SAANA,QAQpC,MAAMgI,GAAqCH,KAKrCI,GAAqCJ,GAAkB,CAClEC,QAAS,CACPR,IAAK,GACLH,IAAK,OACLC,IAAK,GACLV,IAAK,EACLC,KAAM,EACNO,MACAN,kBCIYsB,GAAcne,GAE5B,MAAMoe,EAAepe,EAAS8d,GAAkB9d,GAAUie,GACpDI,WC5E0Bre,GAEhC,MAAMwc,EAAaH,GAAarc,GAEhC,OAAOib,QACDjb,EAAOmb,YAAYF,EAAM7W,EAAE6W,EAAMvzB,OACnCuzB,EAAMvzB,IACN80B,EAAWvB,IACJ,GDoEcqD,CAAkBF,GACrCG,EAAahC,GAAY6B,GACzB3B,EAAYjB,GAAW4C,GACvBI,GAAexe,MAAAA,SAAAA,EAAQye,mBEzEDze,GAE5B,MAAMwc,EAAaH,GAAarc,GAC1B0e,EAAoC,CACxC/3B,KAAMy1B,GAAcpc,IAEhByc,EAAYjB,GAAWxb,EAAQ0e,GAC/BH,EAAahC,GAAYvc,EAAQ0e,GAEvC,MAAO,CAACzD,EAAOK,KACb,YAAMtb,EAAOmb,YAAYF,EAAM7W,EAAE6W,EAAMvzB,KACrC,OAAO,EAKT,IAAIvC,EAGJ,MALE81B,EAAMvzB,EAMJ80B,EAAWvB,IACRsD,EACCtD,EACAF,IACO51B,IACHA,EAASm1B,GAAS,CAAEC,EAAG,MAAOG,EAAG,MAEnCI,GAAS31B,EAAQ41B,MAGpB0B,EAAUxB,EAAOxY,GAAQtd,EAASsd,KAMzC,QAHEwY,EAAMvzB,EACR4zB,EAAIn2B,GAAUm1B,GAAS,CAAEC,EAAG,MAAOG,EAAG,OAE/B,GFqC+BiE,CAAcT,IAAuB3C,GAE7E,OAAOqD,IAEL,MAAMz5B,EAAqB,GACrB81B,EAAqB,CAAEvzB,EAAG,EAAG0c,EAAGwa,GAGtC,KAKS3D,EAAMvzB,EAAIuzB,EAAM7W,EAAEzc,SACrB02B,EAAiBpD,IACdsD,EACCtD,EACAF,IACO51B,EAAOwC,QACVxC,EAAO6H,KAAKstB,GAAS,CAAEC,EAAG,MAAOG,EAAG,MAEtCI,GAAS31B,EAAOA,EAAOwC,OAAS,GAAIozB,MAGvCyD,EAAavD,EAAOxY,GAAQtd,EAAO6H,KAAKyV,KACxCga,EAAUxB,EAAOxY,GAAQtd,EAAO6H,KAAKyV,OAf9C,OAAOtd,SGxEE05B,GAAuCV,cCRpCW,GAAUC,GACxB,IAAKA,EACH,MAAO,KAGT,IAAIC,EACAC,GAAQ,EAEZ,IAAK,IAAIv3B,EAAI,EAAGA,EAAIq3B,EAAOp3B,SAAUD,EAAG,CAEtC,MAAMuuB,EAAI8I,EAAOr3B,GACXw3B,EAAYjB,GAAoB9C,YAAYlF,GAE9CiJ,MACEA,IACGF,IACHA,EAAUD,EAAO7I,UAAU,EAAGxuB,IAEhCs3B,GAAW,KAAO/I,GAEpBgJ,GAAQ,GACCD,IACTA,GAAW/I,GAIf,OAAOgJ,EAAQ,IAAID,GAAWD,KAAYA,QCT/BI,WACD5gB,GAKVlY,YAAYqC,GACVE,MAAMF,GACNZ,KAAKsW,MAAQtW,KAAK2W,YACd3V,GAAQA,EAAKE,KAAK4U,SACd,IAAIwhB,KACF,GAAIA,EAAOz3B,OACT,OAAOrC,WAgD+B85B,GACpD,MAAO,CAACz4B,EAAMyrB,KAEZ,MAAMiN,EAAmE,CAACC,EAAUC,KAElF,MAAMC,EAAQJ,EAAOE,GAErB,OAAKE,EAIE1pB,GACH0pB,EACI,CAACC,EAAcF,IAAiBF,EAAMC,EAAW,EAAGG,GACpDF,IANC54B,EAAK44B,IAWhB,OAAOF,EAAM,EAAGjN,IAnEWsN,CAAmBN,IAGpC,MAAM5yB,EAAkB,IAA6CiJ,GAASkqB,IAE9E,OAAOjqB,GAAe5M,EAAKI,UAAUsD,IAAoBA,QAMrEnG,KACIyC,GAOF,IAAI6V,EAWJ,OATA7V,EAAKgB,QAAQlF,IACTkD,KAAKsW,MACL,OAAQtV,EAAO,CAAEyD,GAAe,MAAXzD,EAAKyD,GAAakJ,GAAS3M,EAAKyD,IAAMzD,EAAKyD,SAAOmB,GACxEmE,GACC2tB,GAAS7gB,EAAY6gB,GACvBlwB,QACER,GAAU6P,EAAYrB,GAAiBxO,IAGpC,CAACnI,EAAMyrB,IAAYzT,EAAUhY,EAAMyrB,IAQ9C,SAASuN,GACLh5B,EACAyrB,GAEF,OAAOzrB,EAAKyrB,SC9BDwN,OACST,GAA0B,oBCrD1CU,GAAmB,SC8BZC,OACSthB,GACd,aACA,CACEtV,UAAWkZ,aD7BQtY,GAE3B,MAAMoV,EAASpV,EAAQlF,IAAIulB,IACrBqV,EAAQ11B,EAAQlF,IAAIg7B,IAE1B,MAAO,CAAC3E,EAAOnV,IAAS0Z,EAAMH,EAAO,IAAIU,QAAQ9E,EAAOnV,IAExD,SAASuZ,EAAMjN,GACb,OAAOhe,GAAU1E,IAEf,MAAMswB,EAAkB,IAAIpqB,GAC5B,IAAIhG,EAEJ,GAAI,oBAAqBsP,EAAQ,CAE/B,MAAM+gB,EAAkB,IAAK/gB,EAAeghB,iBACtCC,OAAEA,GAAWF,EAEnBrwB,EAASJ,EAAYV,IACfA,IAAW+wB,IACbI,EAAgBG,UAGpB1wB,EAASE,OAAON,QAAQ,IAAMM,EAAOhB,IAAIixB,KAAmBxwB,MAAMO,GAClEowB,EAAgB7tB,GAAG,CACjBvC,OAAAA,EACAvJ,QAAQgE,EAAKg2B,GACX3wB,EAASK,QAAQ1F,EAAKg2B,MAI1B,MAAMC,EAAelO,EAAQ+N,OAEzBG,IACF,IAAIvjB,GAAmBujB,GAAcnuB,GAAG,SAASR,KAAK,IAAMsuB,EAAgBG,SACxEE,EAAaC,SACfN,EAAgBG,SAIpBhO,EAAU,IAAI2N,QAAQ3N,EAAS,CAAE+N,OAAAA,SAEjCvwB,EAASowB,EAAgB7tB,GAAGzC,GAG9BwP,EAAOmgB,MAAMjN,GACRje,KAAKksB,IACJL,EAAgB9vB,KAAKmwB,GACrBzwB,EAAOhB,QAERkI,MAAMhI,GAAUc,EAAOhB,IAAIE,YE1C/B,MAAM0xB,OAAmCjyB,EAC5C,iBACA,CACErF,UAAWgiB,IAET,MAAMuV,EAAgBvV,EAAUtmB,IAAIwlB,IAMpC,OAJA,IAAIrN,GAAmB0jB,GAAMtuB,GAAmB,mBAAmBN,GAC/D,EAAG/H,QAAAA,KAA8BA,EAAQlF,IAAI87B,IAAkBC,SAG5DnnB,QAKTonB,OAA2CryB,EAC7C,oBACA,CACErF,UAAWY,GAAW,IAAI42B,GAAiB52B,EAAQlF,IAAIojB,aAOhD0Y,GAUXr6B,YAAYyD,GAEV,MAAMob,EAAU,IAAItP,GACdirB,EAAgB/2B,EAAQlF,IAAIud,IAAkBvd,IAAI47B,IAExD14B,KAAKqK,GAAK+S,EAAQ/S,KAClBrK,KAAKoI,KAAO,IAAMgV,EAAQhV,KAAKpG,GAC/BhC,KAAK64B,MAAQ,KAEX,MAAMG,EAASC,GAAkBj3B,GAE7Bg3B,EACFA,EAAO,GAAGl8B,IAAI87B,IAAkBxwB,OAEhC2wB,EAAc7nB,GAAKlP,GAtBzBtB,WAAYA,KACV,OAAOo4B,aA+BKG,GAAkB/b,GAEhC,MAAMyb,EAAOzb,EAAGpgB,IAAIud,IAAkBvd,IAAIwlB,IAC1C,IAAI3jB,EAAgBue,EAAGve,QACnBu6B,GAAY,EAEhB,GAAIv6B,IAAYg6B,EAGhB,OAAS,CAEP,MAAMK,EAASr6B,EAAQqnB,WAEvB,IAAKgT,EACH,OAGF,MAAMz2B,EAAyBy2B,EAAe/Y,IAE9C,GAAI1d,EACF,MAAO,CAACA,EAAK22B,GAEf,GAAIF,IAAWL,EACb,OAGFO,GAAY,EACZv6B,EAAUq6B,GC1Ed,MAAMG,OAA2C1yB,EAC7C,oBACA,CACErF,UAAWY,GAAW,IAAIo3B,GAAkBp3B,EAAQlF,IAAIojB,aAaxCmZ,WAAiDn2B,EAKrExC,WAAYA,KACV,OAAOy4B,GAQTvyB,IAAKA,KACH,OAAOU,EAActH,KAAKgC,UAsD9B,MAAMo3B,WAA4CC,GAMhD96B,YAAqByD,GACnBlB,QADmBd,aAAAgC,EAGnB,MAAMg3B,EAASh5B,KAAKs5B,QAAU5nB,KAE9B1P,EAAQ8jB,cAAcrpB,GAAMiP,KAAKstB,GAEjC,MAAM90B,EAAWlE,KAAKu5B,WCxHtBC,EDwH0Dx5B,KAAKw5B,KCtH1D,IAAIr2B,EACK1C,GAWlB,SACIA,GAEF,MAAO,UAAWA,EAdiCg5B,CAAmBh5B,GAC5D+4B,EAAG1jB,SACD4jB,GAASA,EAAQ9rB,GAAe8rB,EAAM58B,IAAI2D,IAAQ9C,UAEpDiI,QAPR4zB,ED0HAx5B,KAAKlD,IAAMoH,EAASH,YAAYjH,IAGlCyB,QACIkD,GAGF,MAAMqF,EAAM9G,KAAKu5B,UAAU/1B,QAAQ/B,GAInC,OAFA6F,EAActH,MAAMwH,QAAQV,GAErBA,EAKTvI,GAAGqJ,GACD,OAAQ5H,KAAKw5B,GAAKtsB,GACdtF,IAEE,MAAME,OAAEA,GAAWF,EAEnBE,EAAOP,MAAMvH,MAEb,MAAM25B,EAAkBjoB,KAExBioB,EAAgB93B,GAAG7B,KAAKs5B,SACxBxxB,EAAO4D,KAAKiuB,GAEZ,MAAMC,EAAalyB,IAAcH,MAAMO,GACjCsD,EAAe1D,IAAcH,MAAMO,GACnC+xB,EAAe,KAEnB,MAAMb,EAASC,GAAkBj5B,KAAKgC,SAEtC,GAAIg3B,EAAQ,CAEV,MAAOc,EAAWZ,GAAaF,EAE/BW,EAAgBzoB,GAAK4oB,EAAUh9B,IAAIu8B,IACnCO,EAAW9yB,MACPoyB,GACF9tB,EAAatE,WAGf6yB,EAAgBzoB,QAAKtL,GAIzB5F,KAAKgC,QAAQlF,IAAIud,IAAkBvd,IAAI47B,IAAe5nB,KAAK,CACzDhJ,OAAQ8xB,EACR3xB,QAAS,IAAMjI,KAAKgC,QAAQ0jB,WAAamU,MAE3CF,EAAgB7oB,OAAOvF,QAAQH,GAAcmB,QACzCwtB,GAAaA,GAAaA,EAAU/3B,QAAQlF,IAAI87B,IAAkBvuB,GAAGN,GAAG8vB,IAE5EF,EAAgB7oB,KAAKlJ,GACrB5H,KAAKgC,QAAQ8jB,cAAc,CACzBhe,OAAQJ,IAAcH,MAAMO,GAC5BG,QAAS4xB,MAGf7vB,QAAQ8B,GAAGlE,GAGfrJ,OAAOy7B,GAEL,OADAh6B,KAAKs5B,QAAQpoB,GAAK8oB,GAAaA,EAAUl9B,IAAIu8B,IACtCr5B,YE5EEi6B,OACSxzB,EAAgC,wBCnGhCyzB,GAuBpB37B,CAACgL,MACC,OAAOvJ,KAAKyQ,WAqBdlS,CAACmI,KACC,OAAO1G,KAAK8Q,QC3ChB,MAAMqpB,GAAkC,CAAEC,SAAS,YAKnCC,GACZjX,EACAuV,EACA2B,EACAC,GACAC,KAAEA,EAAIlc,IAAEA,IAGV,MAAMlB,EAAU,IAAItP,GACdkQ,EAAOwc,EAAOL,QAAav0B,EACjC,IACI3H,EACAw8B,EAFA32B,EAAQ,IAAIoF,IAGhB,MAAMwxB,EAAiDF,EAAOG,GAAkBj7B,EAElD,iBAAnB46B,EACTG,EAAWH,EAEXlX,EAAUxE,YAAY0b,GAAgBjuB,KAAK,EAAGoY,YAAc7jB,KAAAA,OAE1D,GADA3C,OAAW2H,EACPhF,IACF65B,EAAW5nB,GAAajS,KAAKA,EAAMwiB,EAAUtmB,IAAI2lB,KAC7CrF,EAAQhU,MAAM,CAIhB,MAAMwxB,EAAWC,IAEjB,GAAID,EAASxxB,KAAM,CAEjB,MAAM0xB,EAAQh1B,MAAMC,KAChB3G,EACIK,EAAMm7B,EAAUzjB,GAAQojB,EAAOpjB,IAC/Bza,IAKJo+B,EAAMj7B,QACRud,EAAQhV,KAAK0yB,EAAO,QAK3B9rB,MAAMyI,QAAQD,OAGd8G,GACHqa,EAAKtjB,iBAAiB,kBAAmBrN,IAEvC,MAAMrJ,EAAUqJ,EAAM9H,OAEtB,GAAI4D,EAAMga,IAAInf,GAAU,CAEtB,MAAMwY,EAAOojB,EAAO57B,GAEpBye,EAAQhV,KAAK,CAAC+O,GAAO,OAK3B,MAAM4jB,UAAyBb,GAI7B37B,SAASqJ,GAEP,MAAMozB,EAAW5X,EAAUtmB,IAAIqmB,GAAdC,CAA+B7S,GAEhD,OAAQvQ,KAAKyQ,SAAWnE,GAAsB1E,IAE5C,MAAMqzB,GAAiB7d,EAAQhU,KACzBtB,EAASsV,EAAQ/S,GAAGzC,GAO1B,OALIqzB,IACFJ,IACAG,EAASlX,QAAQ6U,EAAM3a,IAGlBlW,EAAON,QAAQ,KACf4V,EAAQhU,OACX4xB,EAASE,aA8DjBj9B,OAAW2H,EACX9B,EAAMqF,aA3DD2C,GAAGlE,GAKRrJ,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAOzD,GAChBrN,KAAKyQ,WAAWjG,KAAK,IAAMxK,MAC3BjD,EAAeiD,OACjB8L,GAAGlE,GAKPrJ,MACIqJ,GAGF,MAAM6I,EAAkDzQ,KAAKyQ,WAE7D,OAAQzQ,KAAK4Q,MAAQ1D,GAA2CtF,IAE9D,MAAMuzB,EAAiB,IAAIrtB,GAE3BqtB,EAAe9wB,GAAGzC,GAClBuzB,EAAe/yB,KAAKtC,MAAMC,KAAK/F,MAAO,IAEtCyQ,EAAS1G,GAAGnC,KACXkE,GAAGlE,GAKRrJ,MAAMqJ,GACJ,OAAQ5H,KAAKuF,MAAQ+H,GAActN,KAAK8Q,QAAQgF,SAC5CslB,GAAQ59B,EAAuBuB,EAASq8B,KAC1CtvB,GAAGlE,GAGPrJ,CAACrB,OAAOgB,YACN,OAAOF,EAAYC,IAAaA,EAAWmB,EACvCK,EAaC2d,EAAQhU,KAAOtF,EAAQ+2B,IAXpBl8B,GAAW47B,EAAO57B,IAEtBjC,MAMR,OAAO,IAAIq+B,EAWX,SAASF,IACP58B,OAAW2H,EAEX,MAAMw1B,EASR,WAEE,MAAMC,EAAMZ,EAEZ,IAAKY,EACH,OAAO,IAAInyB,IAEb,GAAIsxB,EACF,OAAO,IAAItxB,IAAIxJ,EAAUi5B,EAAK2C,iBAAiBD,KAEjD,OAAO,IAAInyB,IACP9J,EACIM,EAAUi5B,EAAK4C,UACf5gB,GAAQA,EAAK6gB,QAAQH,KAtBhBI,GAMb,OAJIre,EAAQhU,OACVtF,EAAQs3B,GAGHA,EAqBT,SAAS7qB,EAAOgT,GAEd,MAAMuX,EAAa,GACbY,EAAe,GAErBnY,EAAUhZ,QAAQiZ,IAChB/kB,EACIW,EACIK,EAAMi7B,EAAUlX,EAASC,cAAekY,GACxCj/B,GAEJya,GAAQukB,EAAQx2B,KAAKiS,IAEzB1Y,EACIW,EACIK,EAAMi7B,EAAUlX,EAASK,YAAa+X,GACtCl/B,GAEJya,GAAQ2jB,EAAM51B,KAAKiS,OAGrB2jB,EAAMj7B,QAAU67B,EAAQ77B,SAC1Bud,EAAQhV,KAAK0yB,EAAOY,GAIxB,SAASE,EAAQzkB,GACf,GAAKqF,GAAUrF,GAGf,OAAIsjB,GAAYtjB,EAAKqkB,QAAQf,KAAc32B,EAAMga,IAAI3G,IACnDrT,EAAMuF,IAAI8N,GACHojB,EAAOpjB,SAFhB,EAOF,SAASwkB,EAAWxkB,GAClB,GAAKqF,GAAUrF,IAGVrT,EAAMwF,OAAO6N,GAGlB,OAAOojB,EAAOpjB,GAAM,IAKxB,SAASwjB,GAAgBkB,GACvB,OAAOt8B,EACHG,EAAUm8B,GACV1kB,GAAQ,CAACA,KAASwjB,GAAgBxjB,EAAK2kB,cCpP7C,MAAMC,GAKJx9B,YAA6By9B,EAAgCr9B,GAAhCqB,SAAAg8B,EAAgCh8B,aAAArB,EAH5CqB,eAAY,IAAIqD,IAMjC23B,eACE,GAAIh7B,KAAKi8B,UACP,OAAOj8B,KAAKi8B,UAGd,MAAMC,EAAqCl8B,KAAKg8B,IAAIl/B,IAAIulB,IAAyBiB,iBAEjF,OAAOtjB,KAAKi8B,UAAY,IAAIC,EAAS3Y,GAAavjB,KAAKm8B,QAAQ5Y,IAGjEhlB,QAAQqC,EAAcgH,GAEpB,MAAMw0B,EAAOp8B,KACPg7B,EAAWh7B,KAAKg7B,SAChB1rB,EAAUtP,KAAKq8B,SAASz7B,GACxB+qB,EAAMhkB,EAAcC,GACpBE,EAASwH,EAAQjF,GAAG,CACxBvC,OAAQJ,EAAY,KAClB1H,KAAKs8B,UAAUhzB,OAAO1I,GACtBo6B,EAASE,aACLl7B,KAAKs8B,UAAUlzB,KACjBmzB,IAEAv8B,KAAKi8B,eAAYr2B,IAElB2B,MAAMokB,EAAI7jB,QACbG,QAAS,CAAC1F,EAAKgN,EAAUC,IAAamc,EAAI1jB,QAAQ1F,EAAKgN,EAAUC,KAMnE,OAHAwrB,EAASE,aACTqB,IAEOz0B,EAEP,SAASy0B,IACPH,EAAKD,QAAQnB,EAASwB,eACtBxB,EAASlX,QAAQsY,EAAKz9B,QAAS,CAC7BuwB,YAAY,EACZC,mBAAmB,EACnBN,gBAAiB/oB,MAAMC,KAAKq2B,EAAKE,UAAUh8B,WAKzC/B,QAAQglB,GACdA,EAAUhZ,QAAQiZ,IAEhB,MAAMwL,EAAgBxL,EAASwL,cACzB1f,EAAUtP,KAAKs8B,UAAUx/B,IAAIkyB,GAE/B1f,GACFA,EAAQlH,KAAKpI,KAAKrB,QAAQswB,aAAaD,GAA0BxL,EAAShU,YAKxEjR,SAASqC,GAEf,MAAM0O,EAAU,IAAIxB,GAIpB,OAFA9N,KAAKs8B,UAAU14B,IAAIhD,EAAM0O,GAElBA,GAQX,MAAM2gB,WAAyBpf,GAI7BtS,YACqB09B,EACA/L,GAEnBpvB,QAHmBd,eAAAi8B,EACAj8B,WAAAkwB,EAJJlwB,cAAW,IAAI8N,GAShClH,IAAKA,KACH,OAAOU,EAActH,KAAKy8B,UAG5BvrB,SACE,OAAOlR,KAAKi8B,UAAUt9B,QAAQswB,aAAajvB,KAAKkwB,OAGlDhf,OAAO1U,GACQ,MAATA,EACFwD,KAAKi8B,UAAUt9B,QAAQgxB,aAAa3vB,KAAKkwB,MAAO1zB,GAEhDwD,KAAKi8B,UAAUt9B,QAAQixB,gBAAgB5vB,KAAKkwB,OAMhD3xB,GAAGqJ,GAED,IAAI80B,EAAgB/yB,KAEpB,OAAQ3J,KAAKqK,GAAKiC,GAAU1E,IACrB5H,KAAKy8B,SAASrzB,OACjBszB,EAAgB18B,KAAKi8B,UAAUnY,QAC3B9jB,KAAKkwB,MACL,CAAC3gB,EAAUC,IAAaxP,KAAKy8B,SAASr0B,KAAKmH,EAAUC,KAG3D5H,EAASE,OAAOP,MAAMm1B,GACtB18B,KAAKy8B,SAASpyB,GAAGzC,GAAUJ,QAAQR,IAC5BhH,KAAKy8B,SAASrzB,MACjBszB,EAAc51B,IAAIE,OAGrB8E,GAAGlE,UAQG+0B,GAKXp+B,YAAYksB,EAAsB9rB,GAHjBqB,YAAS,IAAIqD,IAI5BrD,KAAKi8B,UAAY,IAAIF,GAAmBtR,EAAI9rB,GAG9CJ,IAAIqC,GAEF,MAAMkK,EAAW9K,KAAKyuB,OAAO3xB,IAAI8D,GAEjC,GAAIkK,EACF,OAAOA,EAGT,MAAMgF,EAAU,IAAImgB,GAAiBjwB,KAAKi8B,UAAWr7B,GAIrD,OAFAZ,KAAKyuB,OAAO7qB,IAAIhD,EAAMkP,GAEfA,GC7JX,MAAM8sB,WAA2B/rB,GAI/BtS,YACqBs+B,EACArmB,GAEnB1V,QAHmBd,cAAA68B,EACA78B,UAAAwW,EAJJxW,cAAW,IAAI8N,GAShClH,IAAKA,KACH,OAAOU,EAActH,KAAKy8B,UAG5BvrB,SACE,OAAOlR,KAAK68B,SAAS78B,KAAKwW,MAG5BtF,OAAO1U,GACLwD,KAAK68B,SAAS78B,KAAKwW,MAAQha,EAK7B+B,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAKy8B,SAASpyB,KAAKyB,GAAGlE,GAG1CrJ,KAAKyD,OzCfgEvB,EyCiB7CuB,EAAQlF,IAAIgzB,IAAgBlf,OzCjBiBnQ,EyCiBOT,KAAKwW,KzChB1E,CAAC2Z,GAAuB1vB,KyCkBfgQ,WAAW1G,GAAG,CAC1BjC,OAAQR,EAActH,MACtBiI,QAAS,CAACmC,EAAMkG,EAAOf,EAAeC,IAAkBxP,KAAKy8B,SAASr0B,KAAKmH,EAAUC,YAS9EstB,GAKXv+B,YAA6Bs+B,GAAA78B,cAAA68B,EAHZ78B,YAAS,IAAIqD,IAM9B9E,KAAKyD,GACHhC,KAAK+H,SAAW/F,EAChBhC,KAAK+8B,OAAOxyB,QAAQyyB,GAAQA,EAAKh5B,KAAKhC,IAGxCzD,IAAOkC,GAEL,MAAMqK,EAAW9K,KAAK+8B,OAAOjgC,IAAI2D,GAEjC,GAAIqK,EACF,OAAOA,EAGT,MAAMgF,EAAU,IAAI8sB,GAAqB58B,KAAK68B,SAAUp8B,GAOxD,OALIT,KAAK+H,UACP+H,EAAQ9L,KAAKhE,KAAK+H,UAEpB/H,KAAK+8B,OAAOn5B,IAAInD,EAAKqP,GAEdA,GCpEX,MAAMmtB,GAAqC//B,OAAO,gBAKlD,MAAMggC,GAKJ3+B,YAA6By9B,EAAgCr9B,GAAhCqB,SAAAg8B,EAAgCh8B,aAAArB,EAC3DqB,KAAKyuB,OAAS,IAAIkO,GAAeX,EAAKr9B,GACtCqB,KAAK+8B,OAAS,IAAID,GAAen+B,GAChCA,EAAgBs+B,IAAuBj9B,KAExC,MAAMgC,EAAWrD,EAAgBshB,IAE7Bje,EACFhC,KAAKm9B,MAAMn7B,GAEXrD,EAAQ0W,iBAAiB,kBAAmBrN,GAAShI,KAAKm9B,MAAOn1B,EAAyBhG,UAI9FA,cACE,OAAQhC,KAAKrB,QAAgBshB,IAG/B+Y,aAEE,MAAMA,EAASh5B,KAAKrB,QAAQqnB,WAE5B,OAAOgT,GAAUoE,GAAcp9B,KAAKg8B,IAAKhD,GAG3Cz6B,OAAOk8B,EAAwCpI,GAC7C,OA8BJ,SACIjP,EACAuV,EACA8B,EACApI,EAAwB,IAE1B,GAAIA,EAAK/T,IACP,OAAO+b,GACHjX,EACAuV,EACA8B,EACA,CAAC97B,EAAS0+B,IAAaD,GAAcha,EAAWzkB,EAAS0+B,GACzDhL,GAIN,MAAMrP,EAAUI,EAAUtmB,IAAIomB,IAE9B,OAAOmX,GACHjX,EACAuV,EACA8B,EACA,CAAC97B,EAAS0+B,IAAara,EAAQrkB,IAAYy+B,GAAcha,EAAWzkB,EAAS0+B,GAC7EhL,GArDKiL,CAAYt9B,KAAKg8B,IAAKh8B,KAAKrB,QAAS87B,EAAUpI,GAGvD9zB,UAAUqC,GACR,OAAOZ,KAAKyuB,OAAO3xB,IAAI8D,GAGzBrC,SAAYkC,GACV,OAAOT,KAAK+8B,OAAOjgC,IAAI2D,GAGjBlC,MAAMyD,GACZhC,KAAK+8B,OAAO/4B,KAAKhC,aAQLo7B,GAAcha,EAA6BzkB,EAAkB0+B,GAE3E,MAAMvyB,EAAyBnM,EAAgBs+B,IAE/C,OAAQnyB,GAAYuyB,EAAYvyB,EAAW,IAAIoyB,GAAa9Z,EAAWzkB,GCnEzE,MAAM4+B,GAA4C,CAChDh2B,MAAOyoB,GACPzxB,MAAMwf,GACJA,EAAM8K,aAAa,CACjBjnB,EAAGq4B,GACHp4B,GAAGG,GACMo7B,GAAcp7B,EAAQlF,IAAIud,IAAmBrY,EAAQrD,mBAWvD6+B,GAEX9f,WAAYA,MACV,OAAO6f,aChBKE,GAAWtqB,GACzB,OAAO,IAAIuqB,IAAIvqB,EAAIwqB,KAAKvP,UAAU,GAAIjb,EAAI+X,cCN/B0S,GAAmC1gC,OAAO,oBAWjC2gC,GAEpBD,IAAKA,MACH,OAAO59B,KA+BTzB,UAAUu/B,EAAa/1B,KCbzB,MAAMg2B,WACMtnB,GAKVlY,YAAYqC,GACVE,MAAMF,GACNZ,KAAKsW,MAAQtW,KAAK2W,YACd3V,IAEE,MAAMuhB,SAAEA,GAAavhB,EAAKgB,QAAQlF,IAAIulB,IAEtC,OAAOrhB,EAAKE,KAAK4U,SACb,IAAIwhB,KACF,GAAIA,EAAOz3B,OACT,OAAOrC,GAOT,SACIqB,EACAiyB,EACA/qB,EACAgE,GAGF,OAEA,SAASi0B,EAASxG,EAAkByG,GAElC,MAAMvG,EAAQJ,EAAOE,GAErB,IAAKE,EACH,OAAO74B,EAAKo/B,GAGdvG,EACI,EAEMvkB,IAAK+qB,EAAUD,EAAQ9qB,IACvBgrB,MAAOC,EAAYH,EAAQE,MAC3BE,KAAMC,EAAWL,EAAQI,MACJJ,IACtBD,EACDxG,EAAW,EACX,CACErkB,IAAK,IAAIuqB,IAAI5hB,OAAOoiB,GAAU3b,EAASgc,SACvCJ,MAAOC,EACPC,KAAMC,EACNE,cACE,OAAOP,EAAQO,SAEjBC,cACE,OAAOR,EAAQQ,SAEjB3hC,IAAO+a,GACEomB,EAAQnhC,IAAI+a,GAErBtZ,IAAIsZ,EAAKsb,GACP8K,EAAQS,IAAI7mB,EAAKsb,MAIzBrC,EACA/qB,EACAk4B,GAvCCD,CAAS,EAAGj0B,MAXrB,MAAMrF,EAAkB,IAA8CiJ,GAASgxB,IAE/E,OAAO/wB,GAAe5M,EAAKI,UAAUsD,IAAoBA,SA0DvEnG,KACIyC,GAOF,IAAI6V,EAWJ,OATA7V,EAAKgB,QAAQlF,IACTkD,KAAKsW,MACL,OAAQtV,EAAO,CAAEyD,GAAe,MAAXzD,EAAKyD,GAAakJ,GAAS3M,EAAKyD,IAAMzD,EAAKyD,SAAOmB,GACxEmE,GACC2tB,GAAS7gB,EAAY6gB,GACvBlwB,QACER,GAAU6P,EAAYrB,GAAiBxO,IAGpC,CAACnI,EAAMiyB,EAAM/qB,EAAMgE,IAAO8M,EAAUhY,EAAMiyB,EAAM/qB,EAAMgE,IAQjE,SAAS40B,GACL9/B,EACA+/B,EACAC,EACA90B,GAEFlL,EAAKkL,SAkCM+0B,OACSf,GAAmB,oBCtKnCgB,OAAqCt4B,EAA6B,oBAkBlDu4B,GAEpBt+B,WAAYA,KACV,OAAOq+B,GAsFTxgC,CAACgL,MACC,OAAOvJ,KAAKqK,KAqBd9L,CAACmI,KACC,OAAO1G,KAAK8Q,OAQdvS,OACEyB,KAAKi/B,IAAI,GAQX1gC,UACEyB,KAAKi/B,GAAG,GAoBV1gC,SACEyB,KAAKi/B,YCrLaC,WAAyBh8B,GCD/C,MAAMi8B,OAAqC14B,EACvC,cACA,CACErF,UAAWkZ,GAAiB/X,GAAO,IAAI68B,GAAW78B,MAiCxD,SAAS88B,GAAe7U,GACtB,OAAgB,MAATA,GAAkC,iBAAVA,EAAqB,CAAE6T,KAAM7T,GAAUA,EA3B5C,+BAiCf4U,GAaX7gC,YAA6BwJ,GAAA/H,cAAA+H,EAJZ/H,cAAW,IAAIqD,IAExBrD,aAAU,EAGhB,MAAMoX,EAASrP,EAASjL,IAAIulB,IAE5BriB,KAAKs/B,UAAYloB,EAAOmL,SACxBviB,KAAKu/B,UAAYnoB,EAAOooB,SACxBx/B,KAAKy/B,SAAWroB,EAAOsoB,QACvB1/B,KAAK2/B,KAAOC,KAAK9jB,OAAO+jB,KAAKC,WAjB/Bp/B,WAAYA,KACV,OAAOy+B,GAmBT5gC,OAEE,MAAM8/B,KAAEA,GAASgB,GAAer/B,KAAKy/B,SAASjV,OACxCxf,EAAQhL,KAAK+/B,SAAS,CAC1B5sB,IAAK,IAAIuqB,IAAI19B,KAAKu/B,UAAUS,MAC5B3B,KAAAA,EACAF,MAAOn+B,KAAKs/B,UAAUnB,QASxB,OANAn+B,KAAKigC,SAASr8B,IAAIoH,EAAMshB,GAAIthB,GAC5BA,EAAM8M,SAAS,KACb9M,EAAMk1B,MAAM,QACZlgC,KAAKy/B,SAASU,aAAangC,KAAKogC,cAAcp1B,GAAQ,MAGjDA,EAGTzM,SAAS2B,GACP,OAAO,IAAImgC,GAAUrgC,KAAK+H,WAAY/H,KAAKsgC,QAASpgC,GAGtD3B,KACIgiC,EACAxuB,GAGF,MAAQyuB,MAAMrC,MAAEA,EAAQ,GAAEhrB,IAAEA,IAAUotB,EAEtCvgC,KAAKy/B,SAASgB,UACVzgC,KAAKogC,cAAcG,GACnBpC,EACAhrB,EAAI6sB,MAGRhgC,KAAK0gC,OAAO,OAAQH,EAASxuB,GAGvBxT,OACJuyB,EACAyP,EACAxuB,GAGF,MAAM4uB,EAAY5uB,EAAQb,GAE1BlR,KAAKigC,SAASr8B,IAAI28B,EAAQjU,GAAIiU,GAE9B,IAEE,IAAK,IAAIn0B,EAAIu0B,EAAU9hC,KAAMuN,EAAGA,EAAIA,EAAEvN,KACpCmB,KAAK4gC,QAAQx0B,WAGfm0B,EAAQp5B,KAAOw5B,EACfA,EAAU9hC,KAAO0hC,EACjBA,EAAQzoB,SAAS,KACf,IACE6oB,EAAUE,gBAEVN,EAAQL,MAAMpP,MAGlB/e,EAAQb,GAAKqvB,GAIjBhiC,QACIgiC,EACAxuB,GAGF,MAAM4uB,EAAY5uB,EAAQb,IAClBsvB,MAAMrC,MAAEA,EAAQ,GAAEhrB,IAAEA,IAAUotB,EAEtCvgC,KAAKy/B,SAASU,aACVngC,KAAKogC,cAAcG,GACnBpC,EACAhrB,EAAI6sB,MAGRhgC,KAAKigC,SAASr8B,IAAI28B,EAAQjU,GAAIiU,GAE9B,MAAMp5B,EAAOw5B,EAAUx5B,KAEnBA,IACFo5B,EAAQp5B,KAAOA,EACfA,EAAKtI,KAAO0hC,GAGdA,EAAQzoB,SAAS,KACf,IACE6oB,EAAUE,gBAEV,IACE7gC,KAAK4gC,QAAQD,WAEbJ,EAAQL,MAAM,eAIpBnuB,EAAQb,GAAKqvB,EAGfhiC,SACIuiC,EACA/uB,GAGF,MAAMyY,MAAEA,GAAUsW,EAElB,GAAa,MAATtW,EAEF,OAA2B,MAAvBxqB,KAAKy/B,SAASjV,MAETxqB,KAAK+gC,YAAYhvB,QAE1B,EAGF,MAAM4uB,EAAY5uB,EAAQb,IACpB8vB,IAAEA,EAAG3C,KAAEA,EAAM/R,GAAI2U,GAAW5B,GAAe7U,GACjD,IAAI+V,EAEJ,MAAMW,EAAgBF,IAAQhhC,KAAK2/B,MAAkB,MAAVsB,EAAiBjhC,KAAKigC,SAASnjC,IAAImkC,QAAUr7B,EA0BxF,OAxBIs7B,EACFX,EAAUW,GAGVX,EAAUvgC,KAAK+/B,SAAS,CACtB5sB,IAAK,IAAIuqB,IAAI19B,KAAKu/B,UAAUS,MAC5B3B,KAAAA,EACAF,MAAOn+B,KAAKs/B,UAAUnB,QAExBwC,EAAUQ,SAASZ,EAAS,UAC5BvgC,KAAKigC,SAASr8B,IAAI28B,EAAQjU,GAAIiU,GAC9BvgC,KAAKy/B,SAASU,aAAangC,KAAKogC,cAAcG,GAAU,KAG1DA,EAAQzoB,SAAS,KACf,IACE6oB,EAAUE,gBAEVN,EAAQL,MAAM,aAIlBnuB,EAAQb,GAAKqvB,EAENA,EAGFhiC,WAAWwT,GAChB,GAA2B,MAAvB/R,KAAKy/B,SAASjV,MAEhB,OAAOxqB,KAAK+gC,YAAYhvB,GAMrBxT,OAAOwT,EAAkCoB,GAE9C,MAAMiuB,EAAWrvB,EAAQb,GACnB6uB,EAAW,IAAIM,GAAUrgC,KAAK+H,WAAY/H,KAAKsgC,uCAAcc,EAASZ,OAAMrtB,IAAAA,IAAOiuB,GAMzF,OAJAphC,KAAKigC,SAASr8B,IAAIm8B,EAASzT,GAAIyT,GAC/B//B,KAAKy/B,SAASU,aAAangC,KAAKogC,cAAcL,GAAW,GAAI5sB,EAAI6sB,MACjEhgC,KAAKigC,SAAS32B,OAAO83B,EAAS9U,IAEvBva,EAAQb,GAAK6uB,EAGdxhC,YAAYwT,GAElB,MAAM4uB,EAAY5uB,EAAQb,GACpBqvB,EAAUvgC,KAAK+/B,SAAS,CAC5B5sB,IAAK,IAAIuqB,IAAI19B,KAAKu/B,UAAUS,MAC5B3B,KAAM,KACNF,MAAOn+B,KAAKs/B,UAAUnB,QAGxB,IACEwC,EAAUQ,SAASZ,EAAS,iBAE5BvgC,KAAKy/B,SAASU,aAAangC,KAAKogC,cAAcG,GAAU,IACxDvgC,KAAK0gC,OAAO,QAASH,EAASxuB,GAGhC,OAAOwuB,EAGDhiC,QAAQyM,GACdhL,KAAKigC,SAAS32B,OAAO0B,EAAMshB,IAC3BthB,EAAMq2B,SAGA9iC,eAAc+tB,GAAEA,EAAIkU,MAAMnC,KAAEA,KAClC,MAAO,CACLiD,wBAAgB,CACdN,IAAKhhC,KAAK2/B,KACVrT,GAAAA,EACA+R,KAAAA,WAgBKgC,GASX9hC,YACqB0pB,EACRqE,EACTpsB,EACA4gB,GAHiB9gB,gBAAAioB,EACRjoB,QAAAssB,EAPLtsB,eAGAA,aAAsBvD,EAQ5BuD,KAAKuhC,QAAUzgB,EAAQA,EAAMygB,QAAU,IAAIl+B,IAE3C,MAAM2H,EAAQhL,KAEdA,KAAKwgC,KAAO,CACVrtB,UACE,OAAOjT,EAAOiT,KAEhBgrB,YACE,OAAOj+B,EAAOi+B,OAEhBE,WACE,OAAOn+B,EAAOm+B,MAEhBG,cACE,QAASxzB,EAAMya,SAEjBgZ,cACE,WAAOzzB,EAAMya,SAEf3oB,IAAO+a,GACE7M,EAAMlO,IAAI+a,GAEnBtZ,IAAIsZ,EAAKsb,GACPnoB,EAAM0zB,IAAI7mB,EAAKsb,KAKrB50B,IAAOsZ,GAEL,MAAMob,EAAQpb,EAAI+lB,IACZ4D,EAAmDxhC,KAAKuhC,QAAQzkC,IAAIm2B,GAE1E,GAAIuO,EACF,OAAOA,EAAO1kC,MAGhB,MAAM2kC,EAAYxO,EAAM7xB,UAAUpB,KAAKwgC,KAAMxgC,KAAK0hC,eAElD,OAAOD,GAAazhC,KAAK2hC,MAAM1O,EAAOwO,GAGxCljC,IAAUsZ,EAA0Bsb,GAElC,MAAMF,EAAQpb,EAAI+lB,IACZ4D,EAA6CxhC,KAAKuhC,QAAQzkC,IAAIm2B,GAEpE,OAAIuO,GACFA,EAAO9C,IAAIvL,GACJqO,EAAO1kC,OAGTkD,KAAK2hC,MAAM1O,EAAOA,EAAM2O,OAAO5hC,KAAKwgC,KAAMrN,EAAOnzB,KAAK0hC,gBAGvDnjC,cAEN,MAAM2F,EAAW,IAAIf,EAA8BnD,KAAKioB,YAQxD,OAAO,IANP,cAA2BiX,GAA3B3gC,kCAEWyB,SAA+BkE,EAASH,YAAYjH,MAOzDyB,MAAY00B,EAAwBuO,GAO1C,OANAxhC,KAAKuhC,QAAQ39B,IAAIqvB,EAAOuO,GAEpBxhC,KAAKwgC,KAAK/B,SAAW+C,EAAOtB,OAC9BsB,EAAOtB,MAAMlgC,KAAKwgC,KAAM,QAGnBgB,EAAO1kC,MAGhByB,SAASwL,EAAe+mB,GACtBryB,EAAQuB,KAAKuhC,QAAQM,UAAW,EAAE5O,EAAOuO,MACvC,GAAIA,EAAOL,SAAU,CAEnB,MAAMW,EAAcN,EAAOL,SAASp3B,EAAGy2B,KAAM1P,GAEzCgR,GACF/3B,EAAGw3B,QAAQ39B,IAAIqvB,EAAO6O,MAM9BvjC,KAAKwjC,GACHtjC,EAAQuB,KAAKuhC,QAAQvkC,SAAUwkC,GAAUA,EAAOQ,MAAQR,EAAOQ,KAAKD,IAGtExjC,MAAMuyB,GACJ9wB,KAAKylB,UACLhnB,EAAQuB,KAAKuhC,QAAQvkC,SAAUwkC,GAAUA,EAAOtB,OAASsB,EAAOtB,MAAMlgC,KAAKwgC,KAAM1P,IAGnFvyB,QACEyB,KAAKylB,UACLhnB,EAAQuB,KAAKuhC,QAAQvkC,SAAUwkC,GAAUA,EAAOX,OAASW,EAAOX,SAGlEtiC,SACEE,EAAQuB,KAAKuhC,QAAQvkC,SAAUwkC,GAAUA,EAAOH,QAAUG,EAAOH,UACjErhC,KAAKuhC,QAAQp4B,QAGf5K,SAASgS,GACPvQ,KAAKm8B,QAAU5rB,EAGjBhS,QAEE,MAAMgS,EAASvQ,KAAKm8B,QAEpBn8B,KAAKm8B,QAAU1/B,EACf8T,WCtYS0xB,WAAuB3hB,MAwBlC/hB,YAAY4W,EAAc6I,GACxBld,MAAMqU,iCAAW6I,IAAMkkB,YAAY,KACnCliC,KAAK8wB,KAAO9S,EAAK8S,KACjB9wB,KAAK+J,GAAKiU,EAAKjU,UAoCNo4B,WAAuB7hB,MAwBlC/hB,YAAY4W,EAAc6I,GACxBld,MAAMqU,iCAAW6I,IAAMkkB,YAAY,KACnCliC,KAAK8wB,KAAO9S,EAAK8S,KACjB9wB,KAAK+F,KAAOiY,EAAKjY,KACjB/F,KAAK+J,GAAKiU,EAAKjU,UAiCNq4B,WAAwB9hB,MA8BnC/hB,YAAY4W,EAAc6I,GACxBld,MAAMqU,iCAAW6I,IAAMkkB,YAAY,KACnCliC,KAAK+F,KAAOiY,EAAKjY,KACjB/F,KAAK+J,GAAKiU,EAAKjU,GACf/J,KAAKgH,OAASgX,EAAKhX,OA7BrB8pB,WACE,MAAO,iBCxJKuR,GAAiBrgC,GAE/B,MAAMoV,EAASpV,EAAQlF,IAAIulB,KACrBE,SAAEA,EAAQmd,QAAEA,GAAYtoB,EACxBwI,EAAa,IAAI3K,GAAmBmC,GACpCkrB,EAAatgC,EAAQlF,IAAIsiC,IACzB1H,EAAQ11B,EAAQlF,IAAIgiC,IACpByD,EAAM7wB,GAAsB4wB,EAAWtkB,QAE7CukB,EAAIzxB,KAAK0xB,GAAaA,EAAUjmB,SAEhC,IAAI1d,EAAqBoN,QAAQC,UAEjC0T,EAAWvV,GAAkB,YAAYN,GAAG+2B,IAE1C,MAAM91B,EAAQs3B,EAAWxB,SAASA,EAAUyB,GAExCv3B,GACF4U,EAAWtV,SAAS,IAAI23B,qBAEpB,CACEnR,KAAwB,MAAlBgQ,EAAStW,MAAgB,SAAW,QAC1CzgB,GAAIiB,EAAMw1B,UAMpB5gB,EAAWvV,GAAG,cAAcN,GAAG,KAE7B,MAAMiB,EAAQs3B,EAAWG,WAAWF,GAEhCv3B,GACF4U,EAAWtV,SAAS,IAAI23B,qBAEpB,CACEnR,KAAM,QACN/mB,GAAIiB,EAAMw1B,UA6EpB,OAAO,IArEP,cAA0BxB,GAExBwB,WACE,OAAO+B,EAAIrxB,GAAGsvB,KAGhB3gC,aACE,OAAO6/B,EAAQ7/B,OAKjBtB,QAAQ+V,GACN,OAAQtU,KAAK0iC,QAAU9iB,EAAWvV,sBAAkDyB,GAAGwI,GAKzF/V,QAAQ+V,GACN,OAAQtU,KAAK2iC,QAAU/iB,EAAWvV,sBAAkDyB,GAAGwI,GAKzF/V,OAAO+V,GACL,OAAQtU,KAAK4iC,OAAShjB,EAAWvV,uBAAoDyB,GAAGwI,GAY1F/V,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAK4D,GAAyBjO,KAAK0iC,UAAW1iC,KAAK2iC,UAAW3iC,KAAK4iC,UAAU92B,GAAGlE,GAK/FrJ,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAOyxB,EAAIzxB,OAAOgF,SAAS9K,GAASA,EAAMw1B,MAAM10B,GAAGlE,GAGlErJ,GAAGskC,GACDnD,EAAQT,GAAG4D,GAGbtkC,KAAK2B,GACH,OAAO89B,EAAS,WAAY,OAAQ99B,GAGtC3B,QAAQ2B,GACN,OAAO89B,EAAS,cAAe,UAAW99B,GAG5C3B,OAAO4U,GACL,OAAOmvB,EAAW/xB,OAAOgyB,EAAKO,EAAM3vB,IAAMqtB,KAG5CjiC,KAAWsZ,EAA0Bsb,GACnC,OAOJ,SAAS4P,EAAUC,GACjB,MAAO,CACLlhC,KAAI,CAAS+V,EAA4Bsb,IAChC4P,EAAU5mB,GAAe6mB,EAAaxC,GAAQA,EAAK9B,IAAI7mB,EAAKsb,KAErE8P,KAAK/iC,GACI89B,EAAS,WAAY,OAAQ99B,EAAQ8iC,GAE9CxpB,QAAQtZ,GACC89B,EAAS,cAAe,UAAW99B,EAAQ8iC,GAEpDzkC,QACI2kC,EACAh8B,EAAoD,EAAC23B,EAAO90B,IAAOA,IAGrE,IAAI7J,EAE4B,mBAArBgjC,GACTh8B,EAAWg8B,EACXhjC,OAAS0F,GAET1F,EAASgjC,EAGX,MAAMC,EAAYC,EAAYljC,GACxBygC,EAAY4B,EAAIrxB,GAChBqvB,EAAUR,EAAS,UAAWY,EAAWwC,EAAWH,GAE1D,IACE,OAAOK,EAAW,UAAW1C,EAAWwC,EAAW5C,GAC7Cr5B,EAASy5B,EAAUH,KAAMD,EAAQC,WACjC56B,UAEN26B,EAAQyB,KAAKO,EAAIrxB,GAAGsvB,SAzCjBuC,CAAUvC,GAAQA,EAAK9B,IAAI7mB,EAAKsb,MA+C3C,SAAS2P,EAAM3vB,GACb,MAAmB,iBAARA,EACF,IAAIuqB,IAAIvqB,EAAKoP,EAASgc,SAExBprB,GAAOovB,EAAIrxB,GAAGsvB,KAAKrtB,IAG5B,SAASiwB,EAAYljC,GACnB,OAAc,MAAVA,GAAoC,iBAAXA,GAAuBA,aAAkBw9B,IAC7D,CAAEvqB,IAAK2vB,EAAM5iC,IAElBA,EAAOiT,eAAeuqB,IACjBx9B,iCAEGA,IAAQiT,IAAK2vB,EAAM5iC,EAAOiT,OAGxC,SAAS6qB,EACLsF,EACAxS,EACA5wB,EACA8iC,EAAoCvmC,GAGtC,MAAM0mC,EAAYC,EAAYljC,GACxByO,EAAU9P,EAAOA,EAAKwN,KAAKk3B,EAAYA,GAE7C,OAAO50B,EAEP,SAAS40B,IAEP,IAAIhD,OAAiC36B,EAErC,IAEE,MAAM49B,EAuBV,WACE,GAAI3kC,IAAS8P,EACX,OAAOqzB,IAGT,MAAMrB,EAAY4B,EAAIrxB,GAChBqvB,EAAUR,EAASuD,EAAW3C,EAAWwC,EAAWH,GACpDS,EAAY,IAAItB,qBAElB,CACErR,KAAMwS,EACNv9B,KAAM46B,EAAUH,KAChBz2B,GAAIw2B,EAAQC,OAIlB,IAAK5gB,EAAWtV,SAASm5B,IAClB5kC,IAAS8P,IACR00B,EAAWC,EAAW3C,EAAWwC,EAAW5C,GAClD,OAAOyB,EAAKzB,GAGd,OAAOA,EA7CYmD,GAEjB,OAAKF,GAILjD,EAAUiD,EACVlB,EAAWxR,GAAMyP,EAASgC,GAC1B3iB,EAAWtV,SAAS,IAAI23B,qBAEpB,CACEnR,KAAAA,EACA/mB,GAAIw2B,EAAQC,QAIXD,EAAQC,MAbNgD,EAcT,MAAOp3B,GAEP,MADA41B,EAAKzB,EAASn0B,GACRA,GA6BV,SAAS41B,EAAKzB,EAAqBv5B,GAcjC,OAbIu5B,GACFA,EAAQyB,KAAKO,EAAIrxB,GAAGsvB,MAGtB5gB,EAAWtV,SAAS,IAAI83B,sBAEpB,CACEr8B,KAAMw8B,EAAIrxB,GAAGsvB,KACbz2B,GAAIo5B,EACJn8B,OAAAA,KAIC,MAKX,SAAS+4B,EACLuD,EACA3C,EACAwC,EACAH,GAGF,MAAMzC,EAAU+B,EAAWvC,SAASoD,GAEpC,IACExC,EAAUQ,SAASZ,EAAS+C,GAC5BN,EAAYzC,EAAQC,MACpB,MAAOp0B,GAEP,MADAm0B,EAAQyB,KAAKO,EAAIrxB,GAAGsvB,MACdp0B,EAGR,OAAOm0B,EAGT,SAAS8C,EACLC,EACA3C,EACAwC,EACA5C,GAGF,IAAIoD,GAAY,EAchB,OAZAjM,EACI,EAAGvkB,IAAAA,EAAKkrB,KAAAA,EAAMF,MAAAA,MACZwF,GAAY,EACZR,EAAUhwB,IAAMA,EAChBgwB,EAAU9E,KAAOA,EACjB8E,EAAUhF,MAAQA,GAEpBmF,EACA3C,EAAUH,KACVD,EAAQC,MAGLmD,GCjTX,MAAMC,GAAyC,CAC7CrlC,MAAMwf,GACJA,EAAMva,QAAQ,CAAE5B,EAAGo9B,GAAYn9B,GAAIwgC,aAS1BwB,GAEXnmB,WAAYA,MACV,OAAOkmB,IC2QX,SAASE,IACL3sB,KACEA,EAAIqpB,KACJA,IAIJ,MAAM7hC,EAAmBwY,EAAKxY,QACxBqhC,EAAOrhC,EAAQswB,aAAa,QAElC,OACSthB,GAASwJ,EADN,MAAR6oB,GACqB,EAW3B,SAAS+D,EAAkBC,EAAcC,GACvC,GAAID,EAAQ9Y,SAAW+Y,EAAQ/Y,OAC7B,OAAQ,EAGV,MAAMgZ,EAAUC,GAAgBH,GAC1BI,EAAUD,GAAgBF,GAEhC,GAAID,EAAQrG,KAAM,CAChB,GAAIuG,IAAYE,EACd,OAAQ,EAIV,MAAMC,EAAoBC,GAA0BN,EAASC,GAE7D,OAAII,EAAoB,GAAKC,GAA0BL,EAASD,GAAW,GACjE,EAGHA,EAAQO,SAAS1kC,OAClBwkC,EACAN,EAAkBtG,GAAWuG,GAAUvG,GAAWwG,IAG1D,MAAMI,EAAoBC,GAA0BN,EAASC,GAE7D,GAAII,EACF,OAAIA,EAAoB,GAGpBH,IAAYE,GAFN,EAKHJ,EAAQO,SAAS1kC,OAASwkC,EAGnC,IAAKD,EAAQI,WAAWN,GACtB,OAAQ,EAGV,OAAOF,EAAQO,SAAS1kC,OA/CFkkC,CAFN,IAAIrG,IAAIsC,EAAMrhC,EAAQ0Y,cAAeknB,SAEJiC,EAAKrtB,MAqDxD,SAASgxB,GAAgBhxB,GAEvB,MAAMjE,EAAOiE,EAAIoxB,SAEjB,OAAOr1B,EAAKu1B,SAAS,KAAOv1B,EAAOA,EAAO,IAM5C,SAASo1B,IACHI,aAAcC,IACdD,aAAcE,IAGlB,IAAIC,EAAS,EAiBb,OAfAF,EAAWp6B,QAAQ,CAACu6B,EAAQrkC,KAC1B,IAoBJ,SAA8BA,GAC5B,OAAOA,EAAI+jC,WAAW,OAAS/jC,EAAIgkC,SAAS,MArBrCM,CAAqBtkC,GAAM,CAE9B,MAAMukC,EAAa,IAAI97B,IAAI07B,EAAWK,OAAOxkC,IAEzCokC,GAAU,IACRF,EAAWM,OAAOxkC,GAAKykC,MAAMC,GAAaH,EAAWlnB,IAAIqnB,IAC3DN,GAAU,EAEVA,GAAU,MAMXA,EAaT,MAAMO,GAA+CloC,OAAO,4BAKtDmoC,GAA2C,CAAC,SAAU9S,ICxS5D,SAAS+S,GAAmBt9B,GAI1B,OAFeA,EAAM9H,OAEP+uB,aAAa,iBChFbsW,GACZx/B,EACAgE,EACAy7B,EACAC,EAAsDC,IAGxD,IAAIC,EAE0B,mBAAnBH,GACTC,EAAgBD,EAChBG,EAAS,MAETA,EAASH,GAAkB,KAG7B,MAAMve,EAAMld,EAAGsN,cAEf,GAAImF,GAAUzW,GAAO,CAEnB,MAAM6/B,EAAe3e,EAAI4e,cAAc9/B,EAAK+/B,QAAQzX,eAMpD,OAJAtoB,EAAKggC,oBAAoBx7B,QAAQy7B,GAAQJ,EAAajW,aAAaqW,EAAMjgC,EAAKkpB,aAAa+W,KAC3FP,EAAc1/B,EAAM6/B,GACpB77B,EAAGk8B,aAAaL,EAAcD,GAEvBC,EAGT,MAAMM,EAAYjf,EAAIse,WAAWx/B,GAAM,GAIvC,OAFAgE,EAAGk8B,aAAaC,EAAWP,GAEpBO,WASOR,GAAkB3/B,EAAYgE,GAC5CtL,EACIiB,EAAUqG,EAAK+1B,YACf3kB,GAAQouB,GAAWpuB,EAAMpN,aC3Efo8B,GAAkB7a,GAEhC,IAAId,EAMJ,OAAOgW,IAEL,MAAMrtB,EAgEV,SAAiBqtB,GACf,OAAO,IAAI9C,IAAI,GAAI8C,EAAKrtB,KAAK6sB,KAjEfoG,CAAQ5F,GAEpB,GAAIhW,EAAO,CACT,GAAIA,EAAMrX,MAAQA,EAChB,OAAOqX,EAAMngB,GAEfmgB,EAAM6b,IAAIv/B,MAGZ,IAAIw/B,EAIJ,MAAMx+B,EAASJ,IAAcF,QAAQ,KACnCgjB,OAAQ5kB,EACR0gC,OAAU1gC,IAGNyE,EAAKiC,GAA8B1E,IACvC,IAAK0+B,EAAS,CAEZ,MAAMC,EAASjb,EAAOkV,GAChBzuB,EAAUL,KACV80B,EAAcD,EAAOx8B,GAAG08B,IAC5B10B,EAAQb,GAAKu1B,IACZj/B,QAAQR,IAEK,MAAVA,GACFc,EAAOhB,IAAIE,KAIfc,EAAO4D,KAAK86B,GAAa96B,KAAKqG,GAE9Bu0B,EAAU,CACRj8B,GAAI0H,EAAQjB,OAAOrE,MACf8rB,GAAYA,EAAW56B,EAAS46B,GAAYz6B,KAEhD4oC,IAAK,GAIT,MAAMC,EAAYL,EAIlB,QAFEK,EAAUD,IAELC,EAAUt8B,GAAGkB,QAAQzD,GAAQiC,GAAGnC,GAAUJ,QAAQR,MAChD2/B,EAAUD,KAEfz6B,QAAQC,UAAUG,KAAK,KAChBs6B,EAAUD,KAAOC,IAAcL,GAClCx+B,EAAOhB,IAAIE,KAEZgI,MAAMyI,QAAQD,WAOvB,OAFAgT,EAAQ,CAAErX,IAAAA,EAAK9I,GAAAA,EAAIg8B,IAAKv+B,GAEjBuC,GCnDX,MAAMu8B,WAA2BtlC,OAqB1B,MAAMulC,GAAuE,IAnBpF,cAAqChJ,GAEnCt/B,OACIu/B,EACAgJ,GAEF,MAAO,CACLhqC,IAAG,IACMgqC,EAETpI,IAAKjiC,WAcEsqC,GAIXxoC,YACqByoC,EACAhd,GADAhqB,iBAAAgnC,EACAhnC,aAAAgqB,EAJJhqB,UAAO,IAAIqD,IAO5B4jC,gBAEE,MAAM5pC,EAAgC,GAEtC,IAAK,MAAMitB,KAAWtqB,KAAM,CAC1B,IAAKsqB,EAAQ4c,SACX,MAAO,GAET7pC,EAAO6H,KAAKolB,EAAQ4c,UAGtB,OAAO7pC,EAGTkB,CAACrB,OAAOgB,YACN,OAAOF,EAAYuB,EAAUS,KAAK0tB,KAAK1wB,WAGzCuB,SAEE,MAAM69B,EAAOp8B,KACPmnC,EAAaz/B,IACnB,IAAI0/B,EAAaz9B,KAEjB,MAAO,CACLpL,QACAA,IAAI+rB,GACF8R,EAAKiL,KAAK/c,IAEZ/rB,SAASwL,EAAU+mB,GACjB,GAAa,YAATA,EACF,OAGF,MAAMgR,EAAc1F,EAAKkL,YAIzB,OAFAv9B,EAAG20B,IAAImI,GAAuB/E,GAEvBA,EAAYN,UAErBjjC,MAAMiiC,EAAY1P,GAChB,GAAa,SAATA,EAEF,OAGFsW,EAAa1/B,IAAcH,MAAM4/B,GAEjC,MAAMZ,EAASj6B,GAA8Bi7B,IAE3C,MAAMj4B,EAAU,IAAIxB,GACdhG,EAASwH,EAAQjF,GAAGk9B,GAgB1B,OAdAnL,EAAKpS,QAAQwW,GACRj1B,QAAQ67B,GACRr9B,GAAGwuB,GAAYjpB,EAAQlH,KAAKmwB,IAC5B/wB,QAAQgQ,SACO5R,IAAV4R,GAAyBA,aAAiBovB,IAE5Ct3B,EAAQlH,KAAK,CACXo/B,IAAI,EACJhH,KAAAA,EACAhpB,MAAAA,MAKH1P,IACNkC,QAEHvL,EACI29B,EACA,EAAG8K,SAAAA,EAAUt/B,SAAAA,KAgDzB,SACI2+B,EACAW,GAEF,OAAOA,EACDX,EAAO95B,MACL8rB,GAAYA,EAASiP,kCAEZjP,IACH2O,UACoB,MAAhBA,EAAS9S,IACHmE,EAAShW,SAASklB,qBAAqBP,EAAS9S,KAAK,GACrDmE,EAAShW,SAASmlB,eAAeR,EAAS5a,WAC/C1mB,IAEL2yB,GAERgO,EAjEgCoB,CAAWpB,EAAQW,GAAUn9B,GAAG,CAC1DjC,OAAQJ,IAAcH,MAAMK,EAASE,QACrCvJ,QAAQyD,EAASu2B,GACf3wB,EAASK,QAAQjG,EAASu2B,QAKpCh6B,QACE6oC,EAAWtgC,IAAI,IAAI8/B,GAAmB,eAExCroC,OACE4oC,EAAWrgC,IAAI,IAAI8/B,GAAmB,0BAExCroC,SACE4oC,EAAWrgC,IAAI,IAAI8/B,GAAmB,qBAMpCroC,KAAK+rB,GAEX,MAAMsd,iCAAWtd,IAAS1iB,SAAUD,EAAc2iB,EAAQ1iB,aACpDE,OAAEA,GAAW8/B,EAAIhgC,SACjBwzB,EAAOp7B,KAAK0tB,KAAK5wB,IAAIgL,GAEvBszB,EACFA,EAAKl2B,KAAK0iC,IAEV5nC,KAAK0tB,KAAK9pB,IAAIkE,EAAQ,CAAC8/B,IACvB9/B,EAAON,QAAQ,IAAMxH,KAAK0tB,KAAKpkB,OAAOxB,KAIlCvJ,YAEN,MAAMujC,EAAc,IAAIiF,GAAiB/mC,KAAKgnC,YAAahnC,KAAKgqB,SAEhE,IAAK,MAAOliB,EAAQszB,KAASp7B,KAAK0tB,KAAKmU,UACrCC,EAAYpU,KAAK9pB,IAAIkE,EAAQhC,MAAMC,KAAKq1B,IAG1C,OAAO0G,GCtHJ,MAAM+F,OACSxQ,GAAkC,mBCpC3CyQ,OACSpxB,GAAa,gBAAiB,CAAEtV,UAAWzE,EAAcF,KCLlEsrC,OAAgCthC,EACzC,cACA,CACErF,UAAWkZ,IAIjB,SAAuBtY,GAErB,MAAMoV,EAASpV,EAAQlF,IAAIulB,IACrB2lB,EAAYhmC,EAAQlF,IAAIk7B,IACxBiQ,EAAYjmC,EAAQlF,IAAIgrC,IACxBpQ,EAAQ11B,EAAQlF,IAAI+qC,IACpBK,EAAoB,IAAK9wB,EAAe+wB,UAE9C,OAAO3H,IAEL,MAAMrtB,EAAM,IAAIuqB,IAAI8C,EAAKrtB,IAAI6sB,MAE7BiI,EAAU90B,GAEV,MAAMmX,EAAU,IAAI2N,QAChB9kB,EAAI6sB,KACJ,CACE3N,KAAM,cACN+V,YAAa,cACbC,QAAS,IAAIC,QAAQ,CAAEC,OAAQ,gBAIrC,OAAOj8B,GAAU1E,GAAY8vB,EAAMH,EAAOjN,GAASvgB,GAAGnC,IAEtD,SAAS2vB,EAAMiR,GAGb,OA0CN,SAA8BhI,EAAYlW,SAExC,MAAM2c,YAAYzG,EAAK1jC,IAAI+pC,0BAAwBI,UAE/CA,GAAaA,EAAUpnC,QACzByqB,EAAQ+d,QAAQzkC,IACZ,kBACA5E,EACIioC,EACA,CAACwB,EAAQvB,KAAcuB,EAASA,EAAS,KAAO,KAC5B,MAAhBvB,EAAS9S,IACH,OAAS4C,GAAUkQ,EAAS9S,KAC5B,MAAQ4C,GAAUkQ,EAAS5a,KAErC,KA1DNoc,CAAqBlI,EAAMgI,GAEpBl8B,GAA8B1E,IAEnC,MAAMgY,EAAa,IAAI7W,GAEvB6W,EAAWvV,GAAGzC,GACdgY,EAAWxX,KAAK,CAAEo4B,KAAAA,IAElBnyB,GAAQ25B,EAAUQ,GAAc/7B,MAC5B8rB,GAAYtsB,QAAQqS,IAAI,CAACia,EAAUA,EAASoQ,WAC7Cl8B,MACC,IAAIm8B,KAAgCC,OCjDpBC,EDiD6BF,EChDhDzrC,EAAS,CAACG,EAAOI,KACtB,IAAK,MAAMiB,KAAWmqC,EACpBxrC,EAAMI,KAAKA,EAAMiB,SAHKmqC,GDkDhB,EAAEvQ,EAAUoQ,MACV,IAAKpQ,EAASiP,GACZ,MAAO,CACLA,IAAI,EACJhH,KAAAA,EACAjI,SAAAA,EACA/gB,MAAO+gB,EAAS3S,QAGpB,IACE,MAAO,CACL4hB,IAAI,EACJhH,KAAAA,EACAjI,SAAAA,EACAhW,SAAUwmB,GAAkBb,EAAQ/0B,EAAKolB,EAAUoQ,IAErD,MAAOnxB,GACP,MAAO,CACLgwB,IAAI,EACJhH,KAAAA,EACAjI,SAAAA,EACA/gB,MAAAA,MAIRzN,GAAGnC,YA0Bb,SAASmhC,GAAkBb,EAAmB/0B,EAAUolB,EAAoBoQ,GAE1E,MAAM1hB,EAAMihB,EAAOc,gBACfL,EACA5R,GAAUwB,EAAS8P,QAAQvrC,IAAI,iBAAmB,aAAa,GAAG81B,GAGtE,GAAI3L,EAAIgiB,KAAM,CAEZ,MAAMzY,EAAOvJ,EAAIgiB,KAAKC,cAAc,QAEpC,GAAI1Y,EACFA,EAAKwP,KAAO,IAAItC,IAAIlN,EAAKvB,aAAa,QAAU9b,GAAK6sB,SAChD,CAEL,MAAMmJ,EAAUliB,EAAI4e,cAAc,QAElCsD,EAAQnJ,KAAO7sB,EAAI6sB,KAEnB/Y,EAAIgiB,KAAKG,YAAYD,IAIzB,OAAOliB,EE7HT,MAAMoiB,WAAuBxL,GAE3Bt/B,OAAOiiC,EAAYlW,EAA0BtoB,GAE3C,MAAM8kC,EAAW,IAAIC,GAAiB/kC,EAAQlF,IAAIkiC,IAAamH,GAAkBnkC,EAAQlF,IAAIirC,MACvFvG,EAASsF,EAAStF,SAKxB,OAHAhB,EAAK9B,IAAImI,GAAuBC,GAChCtF,EAAO9C,IAAIpU,GAEJkX,SAiBE8H,OAAqED,GCpC5EE,OAA0C9iC,EAC5C,oBACA,CACErF,UAAWkZ,GAAiBtY,GAAW,IAAIwnC,GAAgBxnC,YAYpDwnC,GASXjrC,YAAYyD,GAEV,MAAM+lB,EAAM0hB,GAAOznC,EAAQlF,IAAIulB,IAAiBE,UAEhD,GAAKwF,EAGE,CAEL,MAAM2hB,EAAa1nC,EAAQlF,IAAIkiC,IAE/Bh/B,KAAK2pC,YAAch8B,GAASwF,GAAOA,EAAIuxB,aAAa9gC,IAzBzB,oBAyBgDmkB,IAC3E/nB,KAAK03B,MAAQ/pB,GACT,CAAC9O,EAAMyrB,IAAYzrB,EAAK,IAAIo5B,QAAQ3N,EAAQnX,IAAKmX,IAC5C7d,MACG8rB,IACE,GAAIA,EAASiP,GAAI,CAEf,MAAMoC,EAASH,GAAOlR,EAAShW,UAE/B,GAAIqnB,GAAUA,IAAW7hB,EAAK,CAE5B,MAAM5U,EAAM,IAAIuqB,IAAInF,EAASiI,KAAKrtB,IAAI6sB,MAEtC7sB,EAAIuxB,aAAa9gC,IAtCR,oBAsC+BgmC,GACxCF,EAAWn5B,OAAO4C,GAClBu2B,EAAWG,UAIf,OAAOtR,UAzBrBv4B,KAAK2pC,YAAch8B,KACnB3N,KAAK03B,MAAQ/pB,KAbjBjN,WAAYA,KACV,OAAO6oC,IA6CX,SAASE,GAAOxiB,SACd,iBAAOA,EAAIiiB,cAAc,kDAA6Bja,aAAa,oBC/DrD6a,GAAiB9nC,GAE/B,MAAMilB,EAAMjlB,EAAQlF,IAAIulB,IAAiBE,SAEzC,OAAO1jB,GAAQA,IAAO4N,MAClB8rB,IACE,GAAIA,EAASiP,GAAI,CAEf,MAAMuC,EAAa,IAAI7gC,IAAYzJ,EAC/BuqC,GAAgB/iB,EAAKvnB,EAAUunB,EAAIgjB,UACnC,EAAE9zB,KAASA,IAGf1X,EACIW,EACI4qC,GAAgBzR,EAAShW,SAAU7iB,EAAU64B,EAAShW,SAAS+Y,iBAAiB,YAChF,EAAEnlB,MAAU4zB,EAAWjsB,IAAI3H,IAE/B,EAAEA,EAAK+zB,MACL3E,GAAW2E,EAAQjjB,EAAIgiB,KAAM,CAACpK,EAAO90B,IAAOA,EAAGoM,IAAMA,GACrD4zB,EAAW1gC,IAAI8M,KAIvB,OAAOoiB,IAKf,SAASyR,GACL/iB,EACAgjB,GAEF,OAAOxqC,EACHL,EACI6qC,EACAC,KAAYA,EAAO/zB,KAEvB+zB,GAAU,CAAC,IAAIxM,IAAIwM,EAAO/zB,IAAK8Q,EAAIsX,SAASyB,KAAMkK,aCtCxCC,GAAenoC,GAE7B,MAAMilB,EAAMjlB,EAAQlF,IAAIulB,IAAiBE,SAEzC,OAAO1jB,GAAQA,IAAO4N,MAClB8rB,IACE,IAAKA,EAASiP,GACZ,OAAOjP,EAGT,MAAM6R,EAAY7R,EAAShW,SAAS+Y,iBAAkC,wBAEtE,IAAK8O,EAAUvqC,OACb,OAAO04B,EAGT,IAAIr4B,EAAe+mB,EAAIgiB,KACnBtD,EAAsB,KAC1B,MAAM0E,EAAYpjB,EAAIqU,iBAAkC,wBAClDgP,EAAkB,IAAIjnC,IACtBknC,EAAgBF,EAAU1vB,KAAK,GAwCrC,OAtCI4vB,IACFrqC,EAASqqC,EAAcvkB,WACvB2f,EAAS4E,EACT9rC,EACIiB,EAAU2qC,GACVG,GAAQF,EAAgB1mC,IAAI,IAAI85B,IAAI8M,EAAKxK,KAAM/Y,EAAIsX,SAASyB,KAAMwK,KAIxE/rC,EACIiB,EAAU0qC,GACVK,IAEE,MAAMzK,EAAO,IAAItC,IAAI+M,EAASzK,KAAM/Y,EAAIsX,SAASyB,KAC3C0K,EAAWJ,EAAgBxtC,IAAIkjC,GAEjC0K,GAEE3rC,EAASurC,EAAgBhqC,UAAY0/B,GAGvC9/B,EAASwqC,EAAS1kB,WAClB2f,EAAS+E,EAASC,aAGlBzqC,EAAO+lC,aAAayE,EAAU/E,GAEhC2E,EAAgBhhC,OAAO02B,IAGvBuF,GAAWkF,EAAUvqC,EAAQylC,EAAQ,CAAC9G,EAAO90B,IAAOA,EAAGi2B,KAAOA,KAMtEvhC,EAAQ6rC,EAAgBttC,SAAU4tC,GAASA,EAAM5kB,WAAYC,YAAY2kB,IAElErS,aC9DCsS,GAAe7oC,GAE7B,MAAMilB,EAAMjlB,EAAQlF,IAAIulB,IAAiBE,SAEzC,OAAO1jB,GAAQA,IAAO4N,MAAM8rB,IAC1B,GAAIA,EAASiP,GAAI,CAEf,MAAMrJ,EAAQ5F,EAAShW,SAASklB,qBAAqB,SAAS9sB,KAAK,GAE/DwjB,GAASA,EAAM2M,cACjB7jB,EAAIkX,MAAQA,EAAM2M,aAItB,OAAOvS,ICJX,MAAMwS,GAAuC,CAC3CxjC,MAAOs8B,GACPtlC,MAAMwf,GACJA,EAAMva,QAAQ,CACZ5B,EAAGkmC,GACHjmC,GAAKmpC,GAA4BA,EAAOrB,YACxC7nC,KAAM,CAAC0nC,MAETzrB,EAAMva,QAAQ,CACZ5B,EAAGimC,GACHhmC,GAAKmpC,GAA4BA,EAAOtT,MACxC51B,KAAM,CAAC0nC,MAETzrB,EAAMva,QAAQ,CAAE5B,EAAGimC,GAAehmC,GAAIioC,KACtC/rB,EAAMva,QAAQ,CAAE5B,EAAGimC,GAAehmC,GAAIsoC,KACtCpsB,EAAMva,QAAQ,CAAE5B,EAAGimC,GAAehmC,GAAIgpC,aAqB7BI,GAEXvtB,WAAYA,MACV,OAAOqtB,ICwEX,SAASG,IAAsB/3B,IAAEA,IAC/B,OAAO,IAAIuqB,IAAI,GAAIvqB,GAAK6sB,cC3HVmL,GAAS7e,GACvB,OAAO8e,EAAO9e,EAAI,CAAE+e,cAAc,aCHpBC,GAAmB9uC,GACjC,OAAOsJ,MAAMqJ,QAAQ3S,YAgBP+uC,GAAmB5rC,GACjC,QAASA,EAAME,aCYK2rC,GAiBpBjtC,YAAsByC,GACpBhB,KAAKyrC,SAAWzqC,GAAQA,EAAKyqC,YA0B/BltC,YACE,OAAOyB,KAAK0rC,cASdntC,QACE,OAAOyB,KAAK0rC,wBAyDAC,GAAgBpmC,EAAkBC,GAChD,OAAID,IAAUC,IAGO,iBAAVD,EACFA,EAAMnD,GAAGoD,GAEI,iBAAXA,GACFA,EAAOpD,GAAGmD,UCrICqmC,WACVJ,UAmCCK,WAAgBD,GAoC3BrtC,YAAYutC,EAAwB9qC,GAClCF,MAAME,GACNhB,KAAK+rC,EAAIC,GAASF,EAAOC,EAAG,KAC5B/rC,KAAKisC,EAAID,GAASF,EAAOG,EAAG,KAC5BjsC,KAAKksC,EAAIF,GAASF,EAAOI,EAAG,KAC5BlsC,KAAK4B,EAAgB,MAAZkqC,EAAOlqC,EAAYuqC,GAAML,EAAOlqC,EAAG,GAAK,EAnCnDuT,WACE,MAAO,MA0CTi3B,UACE,OAAOpsC,KAMTqsC,UAEE,MAAMzqC,EAAEA,GAAM5B,KACR+rC,EAAa,IAAT/rC,KAAK+rC,EAAU,IACnBE,EAAa,IAATjsC,KAAKisC,EAAU,IACnBC,EAAa,IAATlsC,KAAKksC,EAAU,IACnBI,EAAMzM,KAAKyM,IAAIP,EAAGE,EAAGC,GACrBK,EAAM1M,KAAK0M,IAAIR,EAAGE,EAAGC,GACrBM,EAAI3M,KAAK4M,OAAOH,EAAMC,GAAO,GAEnC,GAAID,IAAQC,EACV,OAAO,IAAIG,GAAQ,CAAEC,EAAG,EAAGrwB,EAAG,EAAGkwB,EAAAA,EAAG5qC,EAAAA,GAAK5B,MAG3C,MAAMozB,EAAIkZ,EAAMC,EACVjwB,EAAIujB,KAAK4M,MAAMD,EAAI,GAAS,IAAJpZ,GAAW,IAAMkZ,EAAMC,GAAW,IAAJnZ,GAAWkZ,EAAMC,IAC7E,IAAII,EAEJ,OAAQL,GACR,KAAKP,EACHY,GAAMV,EAAIC,GAAK9Y,GAAM6Y,EAAIC,EAAI,EAAI,GACjC,MACF,KAAKD,EACHU,GAAMT,EAAIH,GAAK3Y,EAAK,EACpB,MACF,QACEuZ,GAAMZ,EAAIE,GAAK7Y,EAAK,EAMtB,OAHAuZ,GAAK,GACLA,EAAI9M,KAAK4M,MAAME,GAER,IAAID,GAAQ,CAAEC,EAAAA,EAAGrwB,EAAAA,EAAGkwB,EAAAA,EAAG5qC,EAAAA,GAAK5B,MAGrCzB,GAAGc,GAED,OAAOutC,GAAU/qC,GAAGxC,IAAWW,KAGjCzB,GAAGuG,GACD,MAAwB,iBAAVA,GACPA,EAAMqQ,OAASnV,KAAKmV,MACpBrQ,EAAMinC,IAAM/rC,KAAK+rC,GACjBjnC,EAAMmnC,IAAMjsC,KAAKisC,GACjBnnC,EAAMonC,IAAMlsC,KAAKksC,GACjBpnC,EAAMlD,IAAM5B,KAAK4B,GACjBkD,EAAM2mC,WAAazrC,KAAKyrC,SAGjCltC,WAAWktC,GACT,OAAOzrC,KAAKyrC,WAAaA,EAAWzrC,KAAO,IAAI6rC,GAAQ7rC,KAAM,CAAEyrC,SAAAA,IAGjEltC,IAAIutC,GACoB,mBAAXA,IACTA,EAASA,EAAO9rC,OAGlB,MAAM+rC,EAAEA,EAAI/rC,KAAK+rC,EAACE,EAAEA,EAAIjsC,KAAKisC,EAACC,EAAEA,EAAIlsC,KAAKksC,EAACtqC,EAAEA,EAAI5B,KAAK4B,GAAMkqC,EAE3D,OAAO,IAAID,GAAQ,CAAEE,EAAAA,EAAGE,EAAAA,EAAGC,EAAAA,EAAGtqC,EAAAA,GAAK5B,MAGrCzB,WAEE,MAAM6tC,EAAM,GAAGpsC,KAAK+rC,MAAM/rC,KAAKisC,MAAMjsC,KAAKksC,IAE1C,OAAkB,IAAXlsC,KAAK4B,EAAU,OAAOwqC,KAAS,QAAQA,MAAQpsC,KAAK4B,YA0ClD8qC,WAAgBd,GAiC3BrtC,YAAYutC,EAAwB9qC,GA8ItC,IAAoBxE,EA7IhBsE,MAAME,GACNhB,KAAK2sC,GA4IWnwC,EA5IIsvC,EAAOa,GA6I7BnwC,GAAgB,KACD,EAAI,IAAMA,EAAQA,GA7I/BwD,KAAKsc,EAAI6vB,GAAML,EAAOxvB,EAAG,KACzBtc,KAAKwsC,EAAIL,GAAML,EAAOU,EAAG,KACzBxsC,KAAK4B,EAAgB,MAAZkqC,EAAOlqC,EAAYuqC,GAAML,EAAOlqC,EAAG,GAAK,EAnCnDuT,WACE,MAAO,MAwCTi3B,UAEE,MAAMxqC,EAAEA,GAAM5B,KACRsc,EAAItc,KAAKsc,EAAI,IACbkwB,EAAIxsC,KAAKwsC,EAAI,IAEnB,IAAKlwB,EAAG,CAEN,MAAM6R,EAAQ,IAAJqe,EAEV,OAAO,IAAIX,GAAQ,CAAEE,EAAG5d,EAAG8d,EAAG9d,EAAG+d,EAAG/d,EAAGvsB,EAAAA,GAAK5B,MAG9C,MAAM4X,EAAI40B,EAAI,GAAMA,GAAK,EAAIlwB,GAAMkwB,EAAIlwB,EAAMkwB,EAAIlwB,EAC3CwW,EAAK,EAAI0Z,EAAK50B,EACdi1B,EAAgB7sC,KAAK2sC,EAAI,IAE/B,OAAO,IAAId,GACP,CACEE,EAAGe,GAASha,EAAGlb,EAAGi1B,EAAiB,EAAM,GACzCZ,EAAGa,GAASha,EAAGlb,EAAGi1B,GAClBX,EAAGY,GAASha,EAAGlb,EAAGi1B,EAAiB,EAAM,GACzCjrC,EAAAA,GAEF5B,MASNqsC,UACE,OAAOrsC,KAGTzB,GAAGc,GAED,OAAOutC,GAAU/qC,GAAGxC,IAAWW,KAGjCzB,GAAGuG,GACD,MAAwB,iBAAVA,GACPA,EAAMqQ,OAASnV,KAAKmV,MACpBrQ,EAAM6nC,IAAM3sC,KAAK2sC,GACjB7nC,EAAMwX,IAAMtc,KAAKsc,GACjBxX,EAAM0nC,IAAMxsC,KAAKwsC,GACjB1nC,EAAMlD,IAAM5B,KAAK4B,GACjBkD,EAAM2mC,WAAazrC,KAAKyrC,SAGjCltC,WAAWktC,GACT,OAAOzrC,KAAKyrC,WAAaA,EAAWzrC,KAAO,IAAI0sC,GAAQ1sC,KAAM,CAAEyrC,SAAAA,IAGjEltC,IAAIutC,GACoB,mBAAXA,IACTA,EAASA,EAAO9rC,OAGlB,MAAM2sC,EAAEA,EAAI3sC,KAAK2sC,EAACrwB,EAAEA,EAAItc,KAAKsc,EAACkwB,EAAEA,EAAIxsC,KAAKwsC,EAAC5qC,EAAEA,EAAI5B,KAAK4B,GAAMkqC,EAE3D,OAAO,IAAIY,GAAQ,CAAEC,EAAAA,EAAGrwB,EAAAA,EAAGkwB,EAAAA,EAAG5qC,EAAAA,GAAK5B,MAGrCzB,WAEE,MAAM8tC,EAAM,GAAGrsC,KAAK2sC,MAAM3sC,KAAKsc,OAAOtc,KAAKwsC,KAE3C,OAAkB,IAAXxsC,KAAK4B,EAAU,OAAOyqC,KAAS,QAAQA,MAAQrsC,KAAK4B,YAsClDgrC,GAAY,CAWvBruC,GAAGc,GACD,GAAsB,iBAAXA,IAAwC,QAAhBA,EAAO8V,MAAkC,QAAhB9V,EAAO8V,MACjE,OAAO9V,IAkBb,SAAS2sC,GAASxvC,EAAe8vC,GAC/B,OAAOH,GAAMtM,KAAK4M,MAAMjwC,GAAQ8vC,GAMlC,SAASH,GAAM3vC,EAAe8vC,GAC5B,OAAOzM,KAAKyM,IAAIzM,KAAK0M,IAAI/vC,EAAO8vC,GAAM,GAMxC,SAASQ,GAASha,EAAWlb,EAAW+a,GAEtC,IAQIt1B,EARA0vC,EAAOpa,EAoBX,OAlBIoa,EAAO,EACTA,GAAQ,EACCA,EAAO,IAChBA,GAAQ,GAMR1vC,EADE0vC,EAAO,EAAM,EACNja,EAAgB,EAAIia,GAAdn1B,EAAIkb,GACVia,EAAO,GACPn1B,EACAm1B,EAAO,EAAM,EACbja,GAAOlb,EAAIkb,IAAO,EAAM,EAAOia,GAAS,EAExCja,EAGK,IAATz1B,WCtaO2vC,GAAcC,EAAmBC,EAAmBrI,GAElE,MAAMsI,EAAa,EAATtI,EAAa,EACjBuI,EAAQH,EAAOb,IACfiB,EAAQH,EAAOd,IACfkB,EAAQF,EAAMxrC,EAAIyrC,EAAMzrC,EACxB2rC,IAAQJ,EAAIG,IAAW,EAAKH,GAAKA,EAAIG,IAAU,EAAIH,EAAIG,IAAU,GAAK,EACtEE,EAAK,EAAID,EACf,OAAO,IAAI1B,GACP,CACEE,EAAGqB,EAAMrB,EAAIwB,EAAKF,EAAMtB,EAAIyB,EAC5BvB,EAAGmB,EAAMnB,EAAIsB,EAAKF,EAAMpB,EAAIuB,EAC5BtB,EAAGkB,EAAMlB,EAAIqB,EAAKF,EAAMnB,EAAIsB,EAC5B5rC,EAAGwrC,EAAMxrC,EAAIijC,EAASwI,EAAMzrC,GAAK,EAAIijC,IAEvCoI,SCNgBQ,WACVjC,GASVjtC,YAAYyC,GACVF,MAAME,GACNhB,KAAK0tC,IAAM1sC,EAAK0sC,IA8BlBnvC,GAAGc,GACD,OAAOW,KAAK0tC,IAAI7rC,GAAGxC,IAAWW,KAUhCzB,WACE,OAAOyB,KAAK2tC,mBCoCHC,GAAa,CAYxBrvC,IAAOsvC,EAAkC9nC,GAEvC,MAAM1I,EAAuC,GACvCywC,EAAS,CACb/nC,KAAAA,EACAxH,IAAuBkC,GACrB,GAAIA,KAAOpD,EACT,OAAOA,EAAOoD,GAGhB,MACMstC,EA8Bd,SACIC,GAEF,cAAeA,GACf,IAAK,WACH,OAAOA,EACT,IAAK,SACH,OAAQA,EAA2CnsC,GAAGmC,KAAKgqC,GAI7D,MAAM74B,SAAc64B,EAEpB,OAAQjoC,UAAiCA,IAASoP,EAAOpP,EAAcioC,EA5ClDC,CAAgBJ,EAASptC,GACpBytC,CAAOnoC,EAAKtF,GAAgBT,KAAMS,GAItD,OAFApD,EAAOoD,GAAOstC,EAEPA,IAMX,OAFAtvC,EAAQwB,EAAS4tC,GAAWptC,GAAOqtC,EAAOhxC,IAAI2D,IAEvCpD,GAWTwE,GAAMgsC,GACGD,GAAW3rC,IAAI+B,UAAwD4B,EAAWioC,aCtF7EM,GAAuC3xC,GACrD,GAAa,MAATA,EACF,MAAO,MAACoJ,KAGV,cAAepJ,GACf,IAAK,SACH,MAAO,CAACA,EAAOA,EAAMivC,UACvB,IAAK,SACH,GAAIjvC,EAAMioC,SP1EsB,cO2E9B,MAAO,CACLjoC,EAAM4xB,UAAU,EAAG5xB,EAAMqD,OP5EG,aO4E2BA,QAAQuuC,UAQrE,MAAO,CAAC5xC,WClFG6xC,WACDZ,GAyBVlvC,YAAY+vC,EAAaC,EAAYvtC,GACnCF,MAAME,GACNhB,KAAKsuC,IAAMA,EACXtuC,KAAKuuC,KAAOA,EAxBdp5B,WACE,MAAO,YA0BT5W,MAAwBmvC,GAEtB,MAAMc,EAAoCxuC,KAAK0tC,IAE/C,GAAIA,IAAQc,GACLd,IAAQc,EAAQC,IAChBf,KAAuB,MAAd1tC,KAAKuuC,KAAeb,EAAIe,GAAuBD,EAAQE,MACrE,OAAO1uC,KAMXzB,GAAGuG,GACD,OAAIA,IAAU9E,MAGU,iBAAV8E,GACPA,EAAMqQ,OAASnV,KAAKmV,MACpBnV,KAAKuuC,OAASzpC,EAAMypC,MACpBvuC,KAAKsuC,MAAQxpC,EAAMwpC,KACnBtuC,KAAKyrC,WAAa3mC,EAAM2mC,SAGjCltC,WAAWktC,GACT,OAAOzrC,KAAKyrC,WAAaA,EACnBzrC,KACA,IAAIquC,GAAcruC,KAAKsuC,IAAKtuC,KAAKuuC,KAAM,CAAEb,IAAK1tC,KAAK0tC,IAAKjC,SAAAA,IAOhEltC,IAAIowC,EAAsCJ,GAIxC,MAHwB,iBAAbI,IACTA,EAAWC,GAAcD,EAAUJ,GAAQvuC,KAAKuuC,KAAMvuC,OAElC,cAAlB2uC,EAASx5B,MAAwBnV,KAAKuuC,OAASI,EAASJ,KACnDK,GAAc5uC,KAAKsuC,IAAMK,EAASL,IAAKtuC,KAAKuuC,KAAMvuC,MAEpD6uC,GAAW7uC,KAAM,IAAK2uC,GAO/BpwC,IAAIuwC,EAAwCP,GAI1C,MAH0B,iBAAfO,IACTA,EAAaF,GAAcE,EAAYP,GAAQvuC,KAAKuuC,KAAMvuC,OAEpC,cAApB8uC,EAAW35B,MAAwBnV,KAAKuuC,OAASO,EAAWP,KACvDK,GAAc5uC,KAAKsuC,IAAMQ,EAAWR,IAAKtuC,KAAKuuC,KAAMvuC,MAEtD6uC,GAAW7uC,KAAM,IAAK8uC,GAG/BvwC,IAAIwwC,GACF,OAAsB,IAAfA,EAAmB/uC,KAAO4uC,GAAc5uC,KAAKsuC,IAAMS,EAAY/uC,KAAKuuC,KAAMvuC,MAGnFzB,IAAIywC,GACF,OAAmB,IAAZA,EAAgBhvC,KAAO4uC,GAAc5uC,KAAKsuC,IAAMU,EAAShvC,KAAKuuC,KAAMvuC,MAG7EzB,SACE,OAAOqwC,IAAe5uC,KAAKsuC,IAAKtuC,KAAKuuC,KAAMvuC,MAQ7CzB,YACE,OAAOyB,KAAKsuC,IAAMtuC,KAAKuuC,eAkBXK,GACZN,EACAC,EACAvtC,GAEF,OAAOstC,EACD,IAAID,GAAoBC,EAAKC,EAAMvtC,GACnCA,EAAK0sC,IAAIuB,KAAKvD,WAAW1qC,EAAKyqC,mBAMhByD,WAKVzB,GAYVlvC,YACI4wC,EACAC,EACAC,EACAruC,GAEFF,MAAME,GACNhB,KAAKmvC,KAAOA,EAAKG,QACjBtvC,KAAKovC,GAAKA,EACVpvC,KAAKqvC,MAAQA,EAlBfl6B,WACE,MAAO,OAoBT5W,GAAGuG,GACD,OAAI9E,OAAS8E,GAGQ,iBAAVA,GAAsBA,EAAMqQ,OAASnV,KAAKmV,OAC5CnV,KAAKovC,KAAOtqC,EAAMsqC,IAClBpvC,KAAKmvC,KAAK/sC,GAAG0C,EAAMqqC,OACnBxD,GAAgB3rC,KAAKqvC,MAAOvqC,EAAMuqC,QAClCrvC,KAAKyrC,WAAa3mC,EAAM2mC,UASnCltC,IAAIowC,EAAsCJ,GAIxC,MAHwB,iBAAbI,IACTA,EAAWC,GAAcD,EAAUJ,EAAcvuC,OAE5C6uC,GAAW7uC,KAA2B,IAAK2uC,GAOpDpwC,IAAIuwC,EAAwCP,GAI1C,MAH0B,iBAAfO,IACTA,EAAaF,GAAcE,EAAYP,EAAcvuC,OAEhD6uC,GAAW7uC,KAA2B,IAAK8uC,GAGpDvwC,IAAIwwC,GACF,OAAOQ,GAAQvvC,KAA2B+uC,GAG5CxwC,IAAIywC,GACF,OAAOQ,GAAQxvC,KAA2BgvC,GAS5CzwC,WACE,MAAO,OAASuC,MAAM2uC,kBAYbC,WACDR,GAGV3wC,YAAY4wC,EAAyBC,EAAeC,EAA0BruC,GAC5EF,MAAMquC,EAAMC,EAAIC,EAAMC,QAAStuC,GAGjCzC,WAAWktC,GACT,OAAOzrC,KAAKyrC,WAAaA,EACnBzrC,KACA,IAAI0vC,GAAW1vC,KAAKmvC,KAAMnvC,KAAKovC,GAAIpvC,KAAKqvC,MAAO,CAAE3B,IAAK1tC,KAAK0tC,IAAKjC,SAAAA,IAGxEltC,MAAwBmvC,GAEtB,MAAMyB,EAAOnvC,KAAKmvC,KAAKQ,MAAMjC,GAE7B,IAAKyB,EACH,OAGF,MAAME,EAAQrvC,KAAKqvC,MAAMM,MAAMjC,GAE/B,OAAK2B,EAIDF,IAASnvC,KAAKmvC,MAA4BE,IAAUrvC,KAAKqvC,MACpDrvC,KAGF,IAAI0vC,GAAcP,EAAMnvC,KAAKovC,GAAIC,EAAO,CAAE3B,IAAAA,EAAKjC,SAAUzrC,KAAKyrC,gBARrE,EAWFltC,SACE,MAAmB,MAAZyB,KAAKovC,GACN,IAAIM,GAAW1vC,KAAKqvC,MAAOrvC,KAAKovC,GAAIpvC,KAAKmvC,KAAMnvC,MAC/C,IAAI0vC,GAAW1vC,KAAKmvC,KAAKS,SAAU,IAAK5vC,KAAKqvC,MAAOrvC,MAQ5DzB,YACE,MAAO,IAAIyB,KAAKmvC,KAAKxB,eAAe3tC,KAAKovC,MAAMpvC,KAAKqvC,MAAM1B,gBAK9D,SAASkB,GACLM,EACAC,EACAC,GAEF,OAAQA,EAAMl6B,KAAc,IAAIu6B,GAAWP,EAAMC,EAAIC,EAAOF,GAAvCA,QAUVU,WACDX,GAGV3wC,WAAWktC,GACT,OAAOzrC,KAAKyrC,WAAaA,EACnBzrC,KACA,IAAI6vC,GAAW7vC,KAAKmvC,KAAMnvC,KAAKovC,GAAIpvC,KAAKqvC,MAAO,CAAE3B,IAAK1tC,KAAK0tC,IAAKjC,SAAAA,IAGxEltC,MAAwBmvC,GAEtB,MAAMyB,EAAOnvC,KAAKmvC,KAAKQ,MAAMjC,GAE7B,GAAKyB,EAIL,OAAIA,IAASnvC,KAAKmvC,KACTnvC,KAGF,IAAI6vC,GAAcV,EAAMnvC,KAAKovC,GAAIpvC,KAAKqvC,MAAO,CAAE3B,IAAAA,EAAKjC,SAAUzrC,KAAKyrC,WAG5EltC,IAAIwwC,GACF,OAAoB,MAAZ/uC,KAAKovC,GACPG,GAAQvvC,KAAKmvC,KAAMnvC,KAAKqvC,MAAQN,GAChCS,GAAQxvC,KAAKmvC,KAAMnvC,KAAKqvC,MAAQN,IACjCrD,WAAW1rC,KAAKyrC,UAGvBltC,IAAIywC,GACF,OAAoB,MAAZhvC,KAAKovC,GACPI,GAAQxvC,KAAKmvC,KAAMnvC,KAAKqvC,MAAQL,GAChCO,GAAQvvC,KAAKmvC,KAAMnvC,KAAKqvC,MAAQL,IACjCtD,WAAW1rC,KAAKyrC,UAGvBltC,SACE,OAAO,IAAIsxC,GAAW7vC,KAAKmvC,KAAMnvC,KAAKovC,IAAKpvC,KAAKqvC,MAAOrvC,MAQzDzB,YACE,MAAO,IAAIyB,KAAKmvC,KAAKxB,eAAe3tC,KAAKovC,MAAMpvC,KAAKqvC,UAKxD,SAASE,GAA6BJ,EAAyBE,GAC7D,OAAQA,EAEQ,IAAVA,EACIF,EAAKzD,WAAWyD,EAAK1D,UACrB,IAAIoE,GAAWV,EAAM,IAAKE,EAAOF,GAHrCA,EAAKzB,IAAIuB,KAAKvD,WAAWyD,EAAK1D,UAMtC,SAAS+D,GAA6BL,EAAyBE,GAC7D,OAAiB,IAAVA,EACDF,EAAKzD,WAAWyD,EAAK1D,UACrB,IAAIoE,GAAWV,EAAM,IAAKE,EAAOF,GClXzC,MAAMW,WAAkCrC,GAEtClvC,YAA6BwxC,EAAmC/uC,GAC9DF,MAAME,GADqBhB,iBAAA+vC,EAI7B56B,WACE,OAAO,EAGT5W,MAAwBmvC,GACtB,OAAOA,EAAIuB,KAAKvD,WAAW1rC,KAAKyrC,UAGlCltC,GAAGuG,GACD,OAAI9E,OAAS8E,IAGQ,iBAAVA,EACFA,EAAMqQ,OAASnV,KAAKmV,MAAQrQ,EAAM2mC,WAAazrC,KAAKyrC,SAE/C,IAAV3mC,GAAyB,MAAVA,MACV9E,KAAKyrC,SAEA,iBAAV3mC,OACK9E,KAAKyrC,UAShBltC,IAAIowC,EAAsCJ,GAIxC,MAHwB,iBAAbI,IACTA,EAAWC,GAAcD,EAAUJ,EAAcvuC,OAE5C2uC,EAASjD,WAAW1rC,KAAKyrC,UAOlCltC,IAAIuwC,EAAwCP,GAI1C,MAH0B,iBAAfO,IACTA,EAAaF,GAAcE,EAAYP,EAAcvuC,OAEhD8uC,EAAWc,SAASlE,WAAW1rC,KAAKyrC,UAG7CltC,MACE,OAAOyB,KAGTzB,MACE,OAAOyB,KAGTzB,SACE,OAAOyB,KAGTzB,WAAWktC,GACT,OAAOzrC,KAAK+vC,YAAYjzC,IAAI2uC,GAG9BltC,YACE,OAAOyB,KAAK+vC,YAAYC,UAG1BzxC,QACE,OAAOyB,KAAK+vC,YAAYT,MAG1B/wC,YACE,MAAO,KAKX,MAAM0xC,GAKJ1xC,YAAqBmvC,GAAA1tC,SAAA0tC,EACnB1tC,KAAKsvC,MAAQ,IAAIQ,GAAK9vC,KAAM,CAAE0tC,IAAAA,IAC9B1tC,KAAKgwC,UAAY,IAAIF,GAAK9vC,KAAM,CAAE0tC,IAAAA,EAAKjC,aAGzCltC,IAAIktC,GACF,OAAQA,GACR,OAAyB,OAAOzrC,KAAKsvC,MACrC,OAA6B,OAAOtvC,KAAKgwC,UAEzC,OAAO,IAAIF,GAAK9vC,KAAM,CAAE0tC,IAAK1tC,KAAK0tC,IAAKjC,SAAAA,cC9F3ByE,IACZzB,GACEA,EAAEC,KACFA,IAOJ,MAAMyB,EAAmD,CAEvDlB,WAEE,OAAOA,GAGTR,SACE,OAAOA,KAGTC,WACE,OAAOA,KAGTnwC,GAAG+vC,EAAaC,GAEd,OAAOD,EAAM,IAAI8B,GAAe9B,EAAKC,EAAM,CAAEb,IAAK1tC,OAAUivC,GAG9D1wC,GAAGc,GACD,aFsVwBA,GAC5B,MAAyB,iBAAXA,IAAwC,cAAhBA,EAAO8V,MAAwC,SAAhB9V,EAAO8V,MAAmC,IAAhB9V,EAAO8V,MEvV7Fk7B,CAAchxC,GACjB,OAKF,OAFuCA,EAExBswC,MAAM3vC,QAKnBivC,ED6DC,IAAIgB,GC7DoBE,GD6DMb,MC3DrC,OAAOa,QC1BIG,GAA8EJ,GAA0B,CACnHzB,GAAE,IACO8B,GAET7B,KAAI,IACK4B,KAuBEC,GACKL,GAA0B,CACtCzB,GAAE,IACO8B,GAET7B,KAAI,IACK4B,WChDFE,WAAgBhF,GAiD3BjtC,YAAY4U,EAAanS,GACvBF,MAAME,GACNhB,KAAKmT,IAAMA,EAzCbgC,WACE,MAAO,MAcT5W,UAAUc,GACR,cAAeA,GACf,IAAK,SAAU,CAEb,MAAO8T,EAAKs4B,GAAY0C,GAAkB9uC,GAE1C,OAAO,IAAImxC,GAAQr9B,EAAK,CAAEs4B,SAAAA,IAE5B,IAAK,SACH,GAAoB,QAAhBpsC,EAAO8V,KACT,OAAO9V,GAmBbd,GAAGc,GACD,OAAOmxC,GAAQ3uC,GAAGxC,IAAWW,KAG/BzB,WAAWktC,GACT,OAAOA,IAAazrC,KAAKyrC,SAAWzrC,KAAO,IAAIwwC,GAAQxwC,KAAKmT,IAAK,CAAEs4B,SAAAA,IAGrEltC,GAAGuG,GACD,MAAwB,iBAAVA,GACQ,QAAfA,EAAMqQ,MACNrQ,EAAMqO,MAAQnT,KAAKmT,KACnBrO,EAAM2mC,WAAazrC,KAAKyrC,SAGjCltC,WACE,MAAO,QAAQ6sC,EAAOprC,KAAKmT,UC/DxB,MAAMs9B,GAAgE9iC,GAAS,aAKtE+iC,KACd,OAAOD,YAMOE,GAAqBC,EAAgBnvC,GACnD,IAAKA,EACH,OAAOgvC,GAET,GAAoB,iBAAThvC,EAAmB,CAC5B,GAAIkF,EAAclF,GAChB,OAAOovC,GAAkBpvC,GAE3B,GAAI+H,GAAc/H,GAChB,OAAOovC,GAAkBC,GAAiBrvC,IAE5C,GAAoB,mBAATA,EAAqB,CAE9B,MAAMsvC,EAAqBtvC,EAAKmvC,GAEhC,GAAkC,iBAAvBG,EAAiC,CAC1C,GAAIpqC,EAAcoqC,GAChB,OAAOF,GAAkBE,GAE3B,GAAIvnC,GAAcunC,GAChB,OAAOF,GAAkBC,GAAiBC,IAI9C,OAAOpjC,GAASqjC,GAAcD,KAIlC,OAAOpjC,GAASqjC,GAAcvvC,IAGhC,SAASqvC,GAAiB5lC,GACxB,OAAOoC,GAAcpC,EAAQnO,EAAe,KAG9C,SAAS8zC,GAAkBI,GACzB,OAAO3jC,GAAc2jC,GAAYn7B,SAC7Bk7B,GAMN,WAEE,IAAIE,EAEJ,OAAO3gC,GACD2gC,GAWR,SAAyB3rC,EAAuBC,GAE9C,MAAM8W,EAAIte,EAAYmzC,GAAgB3rC,IAEtC,IAAK,MAAO/E,EAAKjE,KAAU20C,GAAgB5rC,GAAQ,CAEjD,MAAQ/I,MAAO40C,GAAW90B,EAAEzd,OAE5B,IAAKuyC,GAAU3wC,IAAQ2wC,EAAO,KAAOzF,GAAgBnvC,EAAO40C,EAAO,IACjE,OAAO,EAIX,OAAQ90B,EAAEzd,OAAOrC,MAxBD60C,CAAgB9gC,EAAQ2gC,GAC7BpzC,IAEFozC,mBAAc3gC,GAbnB+gC,GACA/0C,GAgBN,SAASy0C,GAAcC,GACrB,MAA6B,iBAAfA,EAA0B,CAAEM,MAAON,GAAeA,EAmBlE,SAASE,GAAgBF,GACvB,OAAO7xC,EAASiB,EAAY4wC,GAAav0C,YAM3B80C,GACZhhB,EACAme,GAEF,OAAOkC,GACHrjC,GAAS,CAAEgjB,KAAAA,EAAMme,SAAAA,IAAY74B,SACzB,EAAG0a,MAAOihB,GAAiB9C,UAAW+C,MAKhD,SAAmBlhB,EAAsBme,GACvC,OAAO3vC,EACHqB,EAAYsuC,GACZ,CAACtxC,GAASs0C,EAAG/e,KAKnB,SACIqe,EACAxwC,EACAjE,GAEEo1C,GAAWX,EAAWxwC,KAASmxC,GAAWp1C,YACrCy0C,EAAWxwC,GAClBwwC,EAAWxwC,GAAOjE,GAEpB,OAAOy0C,EAdiBY,CAASx0C,EAAQs0C,EAAG/e,oBACnCpC,IAT+DshB,CAAUL,EAAgBC,KAyBpG,SAASE,GAAWp1C,GAClB,cAAeA,GACf,IAAK,SACH,OAAOA,EAAMioC,SbxImB,cawIc,EAAI,EACpD,IAAK,SACH,OAAOjoC,EAAMivC,SACf,QACE,OAAO,YC7IKsG,GACZp3B,GAEF,MAAgB,MAATA,GAAyB,MAATA,GAAyB,MAATA,WAuBzBq3B,GAAsBvX,GACpC,IAAK6Q,GAAgB7Q,GACnB,MAAO,CAACwX,GAAaxX,IAGvB,MAAMyX,EAAmC,GACzC,IAAIC,EAEJ,IAAK,MAAMx3B,KAAQ8f,EAAU,CAE3B,MAAM2X,EAAiBD,EAOvB,IAAIE,EAEJ,GAPIF,IACFD,EAAWhtC,KAAKitC,GAChBA,OAAavsC,GAKXmsC,GAAap3B,GAAO,CAEtB,GADAw3B,EAAax3B,GACRy3B,EACH,SAEFC,EAAO,QAEPA,EAAOJ,GAAat3B,GAGtBu3B,EAAWhtC,KAAKmtC,GAMlB,OAJIF,GACFD,EAAWhtC,KAAKitC,EAAY,IAGvBD,EAGT,SAASD,GAAaxxC,GACpB,MAAmB,iBAARA,EACJA,EAGE,CAAE6b,EAAG7b,GAFH,GAIJ6xC,GAA0B7xC,YAMnB6xC,GAA0BD,GAExC,MAAM5/B,EAAK4/B,EAAK5/B,SAAM7M,EAChBhG,EAAIyyC,EAAKzyC,QAAKgG,EACduoB,EAcR,SACIokB,GAEF,IAAKA,EACH,OAEF,GAAIh/B,GAAgBg/B,GAClB,MAAO,CAACA,GAGV,MAAMl1C,EAASk1C,EAAQC,OAAOrkB,KAAOA,GAErC,OAAOod,GAAgBluC,GAAUA,EAAOo1C,KAAKh/B,SAAgB7N,EA1BnD8sC,CAAiBL,EAAKlkB,GAC1BwkB,EA4BR,SACIC,GAEF,IAAKA,EACH,OAEF,GAUF,SACIA,GAEF,MAA0B,iBAAZA,EAAK,GAbCC,CAAoBD,GAAO,CAE7C,MAAMv1C,EAASu1C,EAAK3wC,IAAI6wC,IAExB,OAAOvH,GAAgBluC,GAAUA,OAASuI,EAG5C,MAAO,CAACktC,GAAqBF,IAzCnBG,CAAsBV,EAAKM,GAErC,MAAO,CACLlgC,GAAAA,EACArG,GAAe,MAAXimC,EAAKjmC,IAAcqG,IAAO7S,IAAMuuB,GAAKwkB,GAAKK,GAAoBL,EAAE,MAAQN,EAAKjmC,QAAKxG,EACtFhG,EAAAA,EACAuuB,EAAAA,EACAwkB,EAAAA,EACAr2B,EAAG+1B,EAAK/1B,QAAK1W,EACb6sB,EAAGwgB,GAAoBZ,EAAK5f,IAyChC,SAASqgB,GAAqBI,GAC5B,IAAKF,GAAoBE,GACvB,OAAOA,EAET,GAAIA,EAAIrzC,OAAS,EACf,OAAOqzC,EAGT,MAAOC,EAAQvyC,KAASwyC,GAAUF,EAElC,OAwBO5H,GAxB0C8H,EAwBpB,IAvBpB,CAACD,EAAQvyC,KAASwyC,EAAOnxC,IAAI+vC,KAG/B,CAACmB,EAAQvyC,EAAMoxC,GAAsBoB,aAa9BJ,GAAoBE,GAClC,OAAOA,EAAIrzC,OAAS,IAAiB,MAAXqzC,EAAI,IAAyB,OAAXA,EAAI,IASlD,SAASD,GACLI,GAEF,GAAKA,EAUL,OAAO9H,GAHL8H,EAHG/H,GAAgB+H,GAGNvtC,MAAMC,KAAK,IAAImD,IAAI3J,EAAU8zC,EAAYC,MAAmBb,OAF5D3sC,MAAMC,KAAKutC,GAAgBD,KAKLA,OAAaztC,EAGpD,MAAM2tC,GAA4B,IAAIrqC,IAEtC,SAASoqC,GAAgBE,GACvB,IAAKA,EACH,OAAOD,GAGT,MAAME,EAAQD,EAAUruC,QAAQ,KAC1BvE,EAAO6yC,EAAQ,EAAID,EAAYA,EAAUplB,UAAU,EAAGqlB,GACtDC,EAAU,IAAIxqC,IACpB,IAAIyqC,EAEJ,IAAK,MAAMtB,KAAQzxC,EAAKgzC,MAAM,KACxBD,EACFA,GAAe,IAAMtB,EAErBsB,EAActB,EAEhBqB,EAAQrqC,IAAIsqC,GAMd,OAJIF,GAAS,GACXC,EAAQrqC,IAAImqC,GAGPE,EAGT,MAAMG,GAAqB,CAAC,aAKZC,GACZrZ,GAEF,IAAKA,EAAS56B,OACZ,OAAOg0C,GAGT,IACI1B,EADAvyC,EAAI,EAGR,OAAS,CAEP,MAAMyyC,EAAO5X,EAAS76B,KAEtB,IAAImyC,GAAaM,GAOjB,MAAO,CAFkBF,EAAa,CAACA,EAAYE,GAAQ,CAACA,GAE/C5X,EAAS9qB,MAAM/P,IAN1BuyC,EAAaE,GAUnB,MAAM0B,GAAwC,GC3I9C,SAASC,GACLzB,EACA0B,GAEF,OAAO1B,GAAW0B,EAAM/O,MAAMgP,GAAU3B,EAAQ4B,KAAKC,YrKpC5B7uC,EAAsBC,GAC/C,GAAqB,iBAAVD,EACT,MAAyB,iBAAXC,EAAsBD,IAAUC,GAAUA,EAAO,GAAG2N,KAAO3N,EAAO,KAAOD,EAGzF,MAAOoO,GAAaR,IAAKS,IAAcrO,EAEvC,MAAsB,iBAAXC,GACDoO,GAAYD,IAAcnO,EAG7BmO,IAAcnO,EAAO,IAAMoO,IAAapO,EAAO,GAAG2N,IqKyBMkhC,CAAWH,EAAQE,cC5EpEE,GAAa7Z,GAC3B,OAAOuX,GAAsBvX,GC3B/B,MAAM8Z,GAAsC,CAC1CC,QAAQhB,GACC,IAAIrI,GAASqI,aAORiB,GAAgBh0C,GAC9B,OAAOi0C,GAAmBj0C,EAAK8zC,IAgBjC,MAAMI,GAAoC,YAK1BD,GACZja,GACA+Z,QACEA,EAAOjiC,QACPA,EAAUsB,MACY8gC,IAG1B,MAAMC,EAAqB,CAAEJ,QAAAA,EAASjiC,QAAAA,GAEtC,OAAOkoB,EAASzb,OACZ,CAAC3hB,EAAQsd,IACHo3B,GAAap3B,GACRtd,EAASsd,GAEdtd,IAAW00C,GAAa10C,EAAOA,EAAOwC,OAAS,MACjDxC,GAAU,KAELA,EAUf,SACIsd,GACA65B,QACEA,EAAOjiC,QACPA,IAIJ,MAAME,GAAEA,EAAErG,EAAEA,EAACxM,EAAEA,EAACuuB,EAAEA,EAAC7R,EAAEA,EAACq2B,EAAEA,EAAClgB,EAAEA,GAAM9X,EACjC,IAAIk6B,GAAgB,EAChBrhB,EAAM,GAEN5zB,IACFi1C,GAAgB,EAChBrhB,GAAO,IAAI2X,GAASp4B,GAAWnS,KAAKhB,EAAG2S,KAErC4b,IACF0mB,GAAgB,EAChBrhB,EAAMrF,EAAEnP,OACJ,CAAC3hB,EAAQy3C,IAAc,GAAGz3C,KAAU8tC,GAASl4B,GAAYrS,KAAKk0C,EAAWviC,MACzEihB,IAGN,GAAImf,EAAG,CACLkC,GAAgB,EAEhB,MAAME,EAAwB,CAAExiC,QAAAA,GAEhCihB,EAAMmf,EAAE3zB,OACJ,CAAC3hB,EAAQ61C,IAkCjB,SACI1f,EACA0f,EACA0B,GAEF,GAAI5B,GAAoBE,GAAM,CAK5B,GAJA1f,GAAO0f,EAAI,GAAKA,EAAI,GAERA,EAAIrzC,OAEN,EAAG,CACX2zB,GAAO,IAAMkhB,GAAmBxB,EAAI,GAAI0B,GACxC,IAAK,IAAIh1C,EAAI,EAAGA,EAAIszC,EAAIrzC,SAAUD,EAChC4zB,GAAO,IAAMkhB,GAAmBxB,EAAItzC,GAA2Cg1C,GAEjFphB,GAAO,IAGT,OAAOA,EAGT,MAAOwhB,EAAUC,EAAQC,EAASC,GAAYjC,EAE9C1f,GAAO,IAAM2X,GAAS6J,GAClBC,IACFzhB,GAAOyhB,EAAS7J,EAAO8J,EAAU,CAAEE,OAAQ,SAAUC,MAAM,KAEzDF,IACF3hB,GAAO,IAAM2hB,GAGf,OAAO3hB,EAAM,IAjEU8hB,CAAkBj4C,EAAQ61C,EAAK6B,GAChDvhB,GAGFlX,IACFu4B,GAAgB,EAChBrhB,GAAOlX,GAELk4B,GAAW/hB,IACbe,EAAMf,EAAEzT,OAAO,CAAC3hB,EAAQm2C,IAAcn2C,EAASm3C,EAAQhB,GAAYhgB,IAErE,GAAI/gB,EAAI,CAEN,MAAME,EAuDV,SAAeF,EAA2BF,GACxC,MAAqB,iBAAPE,EAAkBA,EAAKA,EAAGU,IAAMZ,EAAQE,QAAM7M,EAxD5C2vC,CAAM9iC,EAAIF,GAGtBihB,EADE7gB,EACI,GAAGA,KAASvG,GAAK,MAAMonB,IAEvBgiB,SAGRhiB,EAAMgiB,IAGR,OAAOhiB,EAEP,SAASgiB,IACP,OAAIX,EACK,GAAGzoC,EAAIyG,GAAajS,KAAKwL,EAAGmG,GAAW,KAAKihB,IAE9C,GAAGpnB,EAAIyG,GAAajS,KAAKwL,EAAGmG,GAAW,MAAMihB,KArEhCiiB,CAAW96B,EAAMi6B,IAEnC,IChDN,MAAMc,GAEJn3C,YAA6Bo3C,GAAA31C,WAAA21C,EAG7Bp3C,KAAK0yC,GAEH,IAAI2E,EAAQ51C,KAAK21C,MAAMC,MAEvB,KAAOA,GACL3E,EAAaO,GAAoBoE,EAAM9kC,OAAOgF,SAAS+/B,IAAmB5E,GAC1E2E,EAAQA,EAAMA,MAGhB,OAAO3E,EAGT1yC,OAAOu3C,EAAyB7E,GAE9B,MAAMxW,SAAEA,GAAaqb,EACrB,IAAIC,OAAEA,GAAWD,EAEjB,IAAKC,EAAOC,QAEV,YADAF,EAASzkB,OAAO4f,GAIlB,IAAIgF,EAAQF,EACZ,MAAMG,EAuHV,SACIzb,GAGF,MAAM0b,EAAc,IAAI9yC,IAClB+yC,EAA6B,GAEnC,IAAK,MAAM/D,KAAQ5X,EACbsX,GAAaM,GACf+D,EAAKlxC,KAAKmtC,GAEV+D,EAAKlxC,KAAKmxC,GAAuBhE,EAAM8D,IAI3C,IAAKA,EAAY/sC,KACf,OAGF,MAAO,CAAC+sC,EAAa7B,GAAa8B,IA1IdE,CAAmB7b,GAErC,IAAKyb,EAEH,YADAJ,EAASzkB,OAAO4f,GAIlB,MAAOkF,EAAaI,GAAgBL,EAEpC,IAAK,MAAMM,KAAcL,EAAa,CAEpC,MAAOv1C,EAAMwyC,GAAUqD,GAAgBxF,EAAYuF,GAEnD,IAAIpD,EAEG,CACL2C,EAASE,EAAMS,SAAS91C,GACxB,MAHAm1C,EAASE,EAAQA,EAAMU,SAAS/1C,EAAMwyC,GAO1C0C,EAASzkB,OAAO4f,EAAY,CAAE8E,OAAAA,EAAQtb,SAAU8b,KAQpD,SAASE,GACLxF,GACCxwC,GAAMm2C,EAAOC,KAGhB,IAAI5C,EAAQ,GACZ,MAAM6C,EAAYl/B,IACZA,IACEq8B,IACFA,GAAS,SAEXA,GAASr8B,IAIb,IAAK,MAAMhX,KAAQg2C,EAAO,CAExB,MAAOG,GAAc5I,GAAkB8C,EAAWrwC,IAElDk2C,EAASC,GAKX,OAFAD,EAASD,GAEF5C,EAAQ,CAACxzC,EAAKwzC,GAAS,CAACxzC,SA6BpBu2C,GAAkC,CAE7CC,OChIgC,MDkIhCrV,OAAOgP,GACE,IAAI8E,GAAgB9E,IAQ/B,SAASiF,GAAiB5E,GACxB,OAAOjyC,EACHI,EACIiB,EAAY4wC,GACZiG,IAEJ,CAAC75C,GAAiCoD,EAAKjE,MACrCa,EAAOoD,GAAOjE,EACPa,GAET,IAON,SAAS65C,GAAUlsC,GACjB,MAA+B,MAAxB8Q,OAAO9Q,EAAM,IAAI,GA+B1B,SAASqrC,GACLhE,EACA8D,GAGF,MAAM9C,EAAahB,EAAK5f,EAExB,IAAK4gB,EACH,OAAOhB,EAGT,MAAM8E,EAA0B,GAEhC,IAAK,MAAM3D,KAAaH,EACD,MAAjBG,EAAU,GACZ4D,GAAcjB,EAAa3C,GAE3B2D,EAAcjyC,KAAKsuC,GAIvB,OAAI2D,EAAct3C,SAAWwzC,EAAWxzC,OAC/BwyC,EAEL9G,GAAgB4L,kCACN9E,IAAM5f,EAAG0kB,mCAGX9E,IAAM5f,OAAG7sB,IAMvB,SAASwxC,GAAcjB,EAAkD3C,GAEvE,MAAMC,EAAQD,EAAUruC,QAAQ,KAChC,IAAIvE,EACAqzC,EAEAR,EAAQ,EACV7yC,EAAO4yC,GAEP5yC,EAAO4yC,EAAUplB,UAAU,EAAGqlB,GAC9BQ,EAAQT,EAAUplB,UAAUqlB,EAAQ,IAGtC,MAAM4D,EAAWz2C,EAAKuE,QAAQ,KACxB1E,EAAM42C,EAAW,EAAIz2C,EAAOA,EAAKwtB,UAAU,EAAGipB,GAC9Cb,EAAaL,EAAYr5C,IAAI2D,GAEnC,GAAK+1C,EAEE,CAEL,MAAOI,EAAOU,GAAad,EAE3BI,EAAMvtC,IAAIzI,GACNqzC,IACFuC,EAAW,GAAKc,EAAY,GAAGA,SAAiBrD,IAAUA,QAP5DkC,EAAYvyC,IAAInD,EAAK,EAAC,IAAIyI,KAAcG,IAAIzI,GAAOqzC,UExL1CsD,GAAkC,CAE7CN,OAAOO,MAEPjwC,MAAOyvC,GAEPz4C,OAAOu3C,EAAyB7E,GAE9B,MAAMwG,GAAY3B,EAASlF,KAAKnW,SAAS56B,QAEnCo2C,MAAEA,GAAUH,EAClB,IAAI4B,EAAc,EACdC,EAAU,EAEd,IAAK,MAAOhG,EAAG/e,KAAMvyB,EAAY4wC,GAAa,CAE5C,MAAMxwC,EAAMqb,OAAO61B,GAEnB,GAAe,MAAXlxC,EAAI,GAAY,CAElB,MAAOjE,GAAS2xC,GAAkBvb,GAC5BglB,EAAcH,EAAWI,GAAa5B,EAAOyB,EAAaj3C,EAAKjE,GAAS,EAE9Ek7C,GAAeE,EACfD,GAAWC,EAEX,MAAMzkC,EAAMq9B,GAAQ3uC,GAAGrF,GAEnB2W,IACFwkC,GAAWG,GAAuB7B,EAAO0B,EAASl3C,EAAK0S,GACvDwkC,GAAWI,GAAsB9B,EAAO0B,EAASl3C,EAAK0S,KAK5D2iC,EAASzkB,OAAO4f,KAapB,SAAS4G,GACL5B,EACAtrC,EACAlK,EACAjE,GAEF,IAAKiE,EAAI+jC,WAXW,YAYlB,OAAO,EAGT,MAAMrxB,EAAM,IAAIq9B,GAAQ/vC,EAAI2tB,UAfR,WAegCvuB,SACpD,IAAIm4C,EAAMl8B,OAAO3I,GAQjB,OANI3W,IACFw7C,GAAO,IAAMx7C,GAGfy5C,EAAMgC,UAAU,UAAWD,EAAKrtC,GAEzB,EAMT,SAASmtC,GACL7B,EACAtrC,EACAlK,EACA0S,GAEF,MAAY,eAAR1S,EACK,GAGTw1C,EAAMgC,UAAU,aAAcn8B,OAAO3I,GAAMxI,GAEpC,GAWT,SAASotC,GACL9B,EACAtrC,EACAlK,EACA0S,GAEF,IAAK1S,EAAI+jC,WAXO,eAYd,OAAO,EAGT,MAAM2O,EAAS1yC,EAAI2tB,UAfH,cAeuBvuB,QAIvC,OAFAo2C,EAAMgC,UAAU,aAAc,GAAG9E,KAAUhgC,IAAOxI,GAE3C,WCxJOutC,GAAqBpC,EAAyB7E,GAE5D,MAAMrG,EAAQkL,EAASY,WAEvBj4C,EACIW,EACIiB,EAAY4wC,GACZkH,IAEJ,EAAExG,EAAG/e,MAEH,MAAOp2B,EAAOivC,GAAY0C,GAAkBvb,GAE5CgY,EAAMhnC,IAAIw0C,EAAmBzG,GAAI,GAAGn1C,EAASivC,KAInDqK,EAASzkB,OAAO4f,EAAY,CAAE8E,OAAQnL,IAMxC,SAASuN,GACLntC,GAGF,MAAOvK,EAAKjE,GAASwO,EAErB,GAAa,MAATxO,EACF,OAAO,EAGT,MAAM+I,EAAQuW,OAAOrb,GAAK,GAE1B,OAAO8E,GAAS,KAAOA,GAAS,KAAOA,GAAS,KAAOA,GAAS,aCpClD8yC,GAAevC,EAAyB7E,GAEtD,MAAM+G,EAAM/G,EAAWM,MAEvB,GAAKyG,EAEE,CAEL,MAAMpN,EAAQkL,EAASY,WAEvB9L,EAAMpxB,QAAQw+B,GACdlC,EAASzkB,OAAO4f,EAAY,CAAE8E,OAAQnL,SANtCkL,EAASzkB,OAAO4f,SCIPqH,GAAgC,CAE3CrB,OJxBgC,MI0BhC1vC,MAAOgwC,GAEPh5C,OAAOu3C,EAAyB7E,GAE9B,MAAMsH,EAwBDn5C,EACHK,EACIC,EA1B6Bo2C,EAASrb,UA2BtC4X,IAASN,GAAaM,IAASA,EAAK5/B,IAAyB,iBAAZ4/B,EAAK5/B,GAAkB4/B,EAAK5/B,GAAK,MAEtF/V,GArBF,SAAS87C,EAAUn7C,EAAgCoV,GAMjD,OAFApV,EAAO,cAFOy4C,EAASvjC,QAAQE,IAEC,IAAI+9B,GAAQ/9B,EAAGU,KAExC9V,EAZTy4C,EAASzkB,OAAOzyB,EAAS25C,GAAatH,EAG7BjyC,EAAau5C,EAAWC,mBAAgBvH,OCUrD,SAASwH,GAAgB7nB,GACvB,GAAwB,mBAAbA,EACT,MAAO,CACLgR,OAAM,KACG,CAAEvQ,OAAQT,KAIvB,GAqBF,SAA2BA,GACzB,MAAO,WAAYA,EAtBf8nB,CAAkB9nB,GACpB,MAAO,CACLqmB,MAAOrmB,EAASqmB,MAChB1vC,MAAOqpB,EAASrpB,MAChBq6B,OAAOgP,GA6Bb,SAAsBhgB,GACpB,MAA2B,mBAAbA,EAA0B,CAAES,OAAQT,GAAaA,EA7BlD+nB,CAAa/nB,EAASgR,OAAOgP,KAK1C,MAAMvf,EAAST,EAASS,OAAOrtB,KAAK4sB,GAEpC,MAAO,CACLqmB,MAAOrmB,EAASqmB,MAChB1vC,MAAOqpB,EAASrpB,MAChBq6B,OAAM,KACG,CAAEvQ,OAAAA,KASf,SAASunB,GAAiBrzC,EAA6BC,GAErD,MAAMqzC,EAAatzC,EAAM0xC,OAAS,EAC5B6B,EAActzC,EAAOyxC,OAAS,EAEpC,OAAO4B,EAAaC,EAAc,EAAID,EAAaC,GAAe,EAAI,WAUxDC,GACZ/f,EACApW,EAA6BzI,IAE/B,MAAO,CAAClD,EAAU,MAEhB,MAAME,KAAEA,EAAO6hB,EAAMxhB,MAAEA,GAAUP,EAEjC,OAAO2L,iCACF3L,IACHE,KAAAA,EACAK,MAAOA,GAASA,EAAMxT,KAAKiT,gBAQjB+hC,GAAmBr6C,mBACjCA,EAAQqnB,2BAAYC,YAAYtnB,GCSlC,MAAMs6C,GAAuD,CAC3DC,OAAQ,MAMJC,GAA8C,CAClDC,GAAI,GACJC,IAAK,GACLC,IAAK,GACL/6C,SACE,OAAOyB,OAOX,MAAMu5C,GAEJh7C,YACqBi7C,EACRF,EAAM,IADEt5C,aAAAw5C,EACRx5C,SAAAs5C,EAIbF,SACE,MAAO,IAGTC,UACE,MAAO,KAGT96C,SACE,OAAO,IAAIg7C,GAAmBv5C,KAAKw5C,QAASx5C,KAAKs5C,IAAMt5C,KAAKw5C,QAAQN,SAQxE,MAAMO,GAKJl7C,YACqBm7C,EACRjf,GADQz6B,OAAA05C,EACR15C,cAAAy6B,EAJLz6B,UAAO,GAMbA,KAAK25C,GAAKD,EAAER,SAGdlD,cACE,OAAO,EAGTz3C,IAAIqC,EAAcpE,EAAeivC,GAE/B,MAAM3Y,EAAI2Y,KAAqC,cAAgB,IACzD6N,IAAEA,EAAGF,GAAEA,EAAEC,IAAEA,GAAQr5C,KAAK25C,GAE1B35C,KAAKwiB,OACPxiB,KAAKwiB,MAAQ,IAAI62B,GAGnBr5C,KAAKwiB,MAAQ,GAAG82B,IAAM14C,KAAQw4C,IAAK58C,IAAQs2B,IAG7Cv0B,QAAQy5C,GACNh4C,KAAKwiB,KAAOw1B,EAAI5J,OACZpuC,KAAKwiB,KAAKiiB,SAAS,OACrBzkC,KAAKwiB,KAAOxiB,KAAKwiB,KAAKo3B,OAAO,EAAG55C,KAAKwiB,KAAK3iB,OAAS,IAIvDtB,WAEE,MAAM+6C,IAAEA,EAAGF,GAAEA,EAAEC,IAAEA,GAAQr5C,KAAK05C,EAE9B,GAAI15C,KAAKwiB,KAAM,CAEb,MAAMq3B,EAAYR,EAAM,IAAIA,EAAQ,GAEpC,MAAO,GAAGC,IAAMt5C,KAAKy6B,WAAW2e,KAAMC,IAAMr5C,KAAKwiB,OAAOq3B,IAAYP,KAGtE,MAAO,IAQX,MAAeQ,GAIbv7C,YAA+Bo7C,GAAA35C,QAAA25C,EAFtB35C,aAAiB,GAK1Bg2C,cACE,OAAO,EAGTz3C,SAASqC,EAAcwyC,EAAgBzoC,GACrC,OAAO3K,KAAKqnC,KAAK,IAAI0S,GAAoB/5C,KAAK25C,GAAI/4C,EAAMwyC,GAASzoC,GAGnEpM,SAASk8B,EAAkB9vB,GACzB,OAAO3K,KAAKqnC,KAAK,IAAIoS,GAAoBz5C,KAAK25C,GAAIlf,GAAW9vB,GAG/DpM,WAEE,IAAIi1B,EAAM,GAEV,IAAK,MAAM/jB,KAAUzP,KAAK0P,QAAS,CAEjC,MAAMi5B,EAAO7sB,OAAOrM,GAEhBk5B,IACEnV,IACFA,GAAOxzB,KAAK25C,GAAGN,KAEjB7lB,GAAOmV,GAIX,OAAOnV,EAGCj1B,KAAQkR,EAAW9E,EAAQ3K,KAAK0P,QAAQ7P,QAEhD,OADAG,KAAK0P,QAAQtK,OAAOuF,EAAO,EAAG8E,GACvBA,GAQX,MAAMsqC,WAA4BD,GAEhCv7C,YAAqBm7C,EAA+B94C,EAAuBwyC,GACzEtyC,MAAM44C,EAAER,UADWl5C,OAAA05C,EAA+B15C,UAAAY,EAAuBZ,YAAAozC,EAI3E70C,WAEE,MAAMikB,EAAO1hB,MAAM2uC,WAEnB,IAAKjtB,EACH,MAAO,GAGT,MAAM82B,IAAEA,EAAGF,GAAEA,EAAEC,IAAEA,GAAQr5C,KAAK05C,EAE9B,MAAO,GAAGJ,IAAMt5C,KAAKY,QAAQZ,KAAKozC,SAASgG,KAAMC,IAAM72B,IAAO62B,IAAMC,MAQxE,MAAMU,WAA4BF,GAEhCv7C,YACa+tB,EACAotB,EACAxuC,GAEXpK,MAAM44C,GAJK15C,QAAAssB,EACAtsB,OAAA05C,EACA15C,YAAAkL,EAKb3M,UAAUqC,EAAcpE,EAAemO,GACrC3K,KAAKqnC,KAAK,GAAGrnC,KAAK05C,EAAEJ,MAAM14C,KAAQpE,KAAUmO,GAG9CpM,QACEyB,KAAK0P,QAAQ7P,OAAS,EAGxBtB,SACEyB,KAAKmJ,QACLnJ,KAAKkL,OAAO9C,KAAK,CAAEkkB,GAAItsB,KAAKssB,KAG9B/tB,OACEyB,KAAKkL,OAAO9C,KAAK,CACfkkB,GAAItsB,KAAKssB,GACT0rB,IAAKh4C,KAAKyvC,uBCxQAwK,GACZ/hC,EAA8B,UAGhC,MAAMqK,SACJA,aAAWrK,EAAO8gB,6BAAQ3hB,gBAAiBD,OAAOmL,SAAQyW,OAC1DA,EAASzW,EAAS0mB,MAChB/wB,EACEgiC,WDiRuBhiC,EAA+B,IAE5D,MAAMiiC,GAAqE,IAAlBjiC,EAAOiiC,QAAoC,MAAjBjiC,EAAOiiC,OACpFlB,GACC/gC,EAAOiiC,SAAU,GAClBv3B,UAAEA,EAAYhJ,IAA6B1B,EAC3ChN,EAAS,IAAI4C,GACnB,IAAIssC,EAAYxyC,IACZwyC,EAAUlvC,EAAOb,KAAKyB,GACxBlE,GACF,MAAMyyC,EAA+BF,EAAS,IAAIZ,GAAmBY,GAAUhB,GAC/E,IAAImB,EAAQ,EAEZ,sCACKpiC,IACHiiC,OAAAA,EACAv3B,UAAAA,EACAw3B,QAAAA,EACAG,SAAQ,IACC,IAAIP,GAAoBl+B,SAASw+B,GAAQD,EAAWnvC,KCpS5CsvC,CAAetiC,GAC5B0K,EAAYm2B,GAAoB/f,EAAQ9gB,EAAO0K,WAC/C9K,EAAW8K,IACXkmB,EAAW,IAAIzlC,IACfyE,EAASoyC,EAAWE,QAAQ,EAAG9tB,GAAAA,EAAI0rB,IAAAA,MAGvC,IAAIr5C,EAAUmqC,EAAShsC,IAAIwvB,GAEhB,MAAP0rB,GACFlP,EAASx/B,OAAOgjB,GAChB0sB,GAAmBr6C,IACVA,EACTA,EAAQmsC,YAAckN,GAEtBr5C,EAAU4jB,EAASsjB,cAAc,SACjClnC,EAAQgxB,aAAa,OAAQ,YAC7BhxB,EAAQmsC,YAAckN,EACtBhf,EAAOoQ,YAAYzqC,GACnBmqC,EAASllC,IAAI0oB,EAAI3tB,GACjBmJ,EAAON,QAEH,IAAMsQ,EAAS,IAAMkhC,GAAmBr6C,QAKhD,sCACKuZ,IACH0K,UAAAA,EACArkB,SAASu3C,GAGP,OAFAhuC,EAAOP,MAAMuuC,GACb91C,KAAKu6C,SAAWL,EAAWK,SAASv2C,KAAKk2C,GAClCl6C,KAAKu6C,SAASzE,MCrF3B,MAAM2E,GAEJl8C,YAA6B2W,GAAAlV,aAAAkV,EAG7B8gC,cACE,OAAO,EAGTz3C,IAAIqC,EAAcpE,EAAeivC,GAC/BzrC,KAAKkV,QAAQ01B,MAAM8P,YAAY95C,EAAMpE,EAAOivC,KAAqC,YAAc,MAGjGltC,QAAQy5C,GACNh4C,KAAKkV,QAAQ01B,MAAM+P,QAAU3C,GAQjC,MAAM4C,GAEJr8C,YAAqB2W,GAAAlV,aAAAkV,EAGrB8gC,cACE,OAAO,EAGTz3C,SAASqC,EAAcwyC,EAAgBzoC,GACrC,OAAO,IAAIiwC,GACP56C,KAAKqnC,KACD,GAAGzmC,KAAQwyC,MACXzoC,IAKVpM,SAASk8B,EAAkB9vB,GACzB,OAAO,IAAI8vC,GAAsBz6C,KAAKqnC,KAAQ5M,EAAH,KAAiB9vB,IAGpDpM,KACNs8C,EACAlwC,EAAQ3K,KAAKkV,QAAQ4lC,SAASj7C,QAGhC,MAAM+I,EAAM5I,KAAKkV,QAAQ6lC,WAAWF,EAAUlwC,GAE9C,OAAO3K,KAAKkV,QAAQ4lC,SAASlyC,IAQjC,MAAMoyC,WAA8BJ,GAElCr8C,YAA6Bs+B,GAC3B/7B,MAAM+7B,EAASoZ,OADYj2C,cAAA68B,EAI7Bt+B,UAAUqC,EAAcpE,EAAemO,GACrC3K,KAAKqnC,KAAK,GAAGzmC,KAAQpE,KAAUmO,GAGjCpM,QAEE,MAAMu8C,SAAEA,GAAa96C,KAAKkV,QAE1B,KAAO4lC,EAASj7C,QACdG,KAAKkV,QAAQ+lC,WAAWH,EAASj7C,OAAS,GAI9CtB,SACEy6C,GAAmBh5C,KAAK68B,UAG1Bt+B,kBCzDc28C,GAAkBC,EAAkBvG,GAElD,MAAMb,aACJA,EAAe,CAAE3nC,EAAG,QAAQwW,UAC5BA,EAAYzI,GAAiB5H,QAC7BA,EAAUsB,MACR+gC,EACE9sC,EAASJ,IACT0zC,EAAqC,CAAE7oC,QAAAA,GACvC8oC,WJ9B4BzG,GAElC,MAAMyG,EAAY,IAAIh4C,IAKtB,OAHAi4C,EAAa1G,EAAOhkB,UACpByqB,EAAU/xC,OAAO4uC,IAEV,IAAImD,EAAUr+C,SAAUy7C,GAAgBP,KAAuBzF,KAAKmG,IAE3E,SAAS0C,EAAaC,GAChBA,IACEjQ,GAAgBiQ,GAClBA,EAAUhxC,QAAQixC,GAElBA,EAAYD,IAKlB,SAASC,EAAY5qB,GACnB,GAAIyqB,EAAUv9B,IAAI8S,GAChB,OAGF,MAAM/sB,EAAU40C,GAAgB7nB,GAEhCyqB,EAAUz3C,IAAIgtB,EAAU/sB,GACxBy3C,EAAaz3C,EAAQ0D,QIGLk0C,CAAoB7G,GAChC8G,EAoFG18C,EACHS,EArF2B07C,EAqFNQ,GACrB,CAACx0C,EAAMW,IAAWJ,IAAcgE,KAAK5D,GAAQ4D,KAAKvE,GAClDO,KAtFN,MAAM8+B,EA0FN,WAEE,MAAM1+B,EAASJ,IAEf,OAAOsG,GAAWmtC,GAAOpxC,GAAG,CAC1BjC,OAAAA,EACAG,QAAS,CAACmC,EAAM0wB,KACdA,EAAMvwB,QAAQwhC,GAAK4P,EAAW5P,GAAGxkC,MAAMO,OAjGzB8zC,GAEpB,OAAO9zC,EAAOP,MAAMm0C,GACfn0C,MAAMi/B,GACN96B,KAAKgwC,GACLhwC,KAAK86B,GAEV,SAASqV,EACLjL,EACAhgB,EACAkrB,GAiEF,OAAO,IA1DP,MAEEl1C,IAAKA,KACH,OAAOkB,EAGT8oC,WACE,OAAOA,EAGTqF,YACE,OAAO6F,EAAW7F,MAGpBF,aACE,OAAO+F,EAAW/F,OAGpBtb,eACE,OAAOqhB,EAAWrhB,SAGpBl8B,QAAQkU,GACN,OAAOF,EAAQE,GAGjBlU,OAAO0yC,EAA4Bh6B,GAI/B2Z,EAHG3Z,EAIC4kC,EACIjL,EACAhgB,EACA,CACEqlB,MAAO6F,EAAW7F,MAClBF,OAAQ9+B,EAAQ8+B,QAAU+F,EAAW/F,OACrCtb,SAAUxjB,EAAQwjB,UAAYqhB,EAAWrhB,WAT1Cz6B,KAYLixC,GAKR1yC,SAASw9C,EAAqCD,EAAWrhB,UAEvD,MAAMsb,OAAEA,GAAW+F,EAEnB,OAAK/F,EAAOC,QAILD,EAAOW,kBC1EWjc,EAA2Cma,GAC1E,OAAOF,GAAmBJ,GAAa7Z,GAAWma,GDkFzCoH,CATiCD,EASNX,IAZrBrF,IAmCf,SAAS4F,EAAW/K,GAElB,MAAOqL,EAAQrrB,GAgEjB,SAAyBggB,GAEvB,MAAMsL,EAAQb,EAAUp5C,IAAI4B,GAAWA,EAAQ+9B,OAAOgP,IAMtD,MAAO,CALQsL,EAAMl9B,OACjB,CAAClO,EAAMrP,IAASA,EAAKqP,KAAOxD,GAAc7L,EAAKqP,KAAKA,IAASA,EAC7D8/B,EAAK9/B,QAKT,SAASqrC,EAASxxC,GAChB,MAAO,CAACmrC,EAAU7E,KAEhB,MAAMmL,EAAYzxC,EAAQ,EAC1B,IAAI0xC,EAGFA,EADED,IAAcf,EAAUx7C,OACXpD,EAEA0/C,EAASC,GAG1B,MAAME,EAAeT,EAAc/F,EAASlF,KAAMyL,EAAcvG,GAEhEoG,EAAMvxC,GAAO0mB,OAAOirB,EAAcrL,IAhBtBkL,CAAS,IAxEEI,CAAgB3L,GAC3C,IAAIqF,EACJ,MAAMxb,EA8CR,SAAsBmW,GAEpB,MAAMnW,EAAWmW,EAAKnW,SAEtB,IAAKA,EAAS56B,OAEZ,OAAOy0C,GAAaP,GAEtB,GAAIhC,GAAatX,EAAS,IAExB,MAAO,IAAI6Z,GAAaP,MAAkBtZ,GAG5C,OAAOA,EA3DU+hB,CAAa5L,GACxB94B,EAAW8K,IAEjB,OAAOq5B,EAAOlyC,IAEd,SAA0BknC,GACxBn5B,EAAS,KACPm+B,MAAAA,GAAAA,EAAO9sC,QAEP,MAAM2sC,EAAW+F,EACbjL,EACAhgB,EACA,CACEqlB,YAIE,OAHKA,IACHA,EAAQrB,EAAO2F,SAASzE,IAEnBG,GAETF,aACE,OAAO/1C,KAAKi2C,OAEdxb,SAAAA,IAINqb,EAASzkB,OAAO4f,GAChBgF,MAAAA,GAAAA,EAAOn3C,YAxBwB0I,SA4BnC,WACEsQ,EAAS,KAEP,MAAM2kC,EAAYxG,EAElB,GAAIwG,EAEF,OADAxG,OAAQrwC,EACD62C,EAAUC,wBEvLXC,GACZ/rB,GAGF,MAAMvzB,EAAyB,CAC7B25C,GACAsB,GACAf,GACAc,IAWF,OARIznB,IACE0a,GAAgB1a,GAClBvzB,EAAO6H,QAAQ0rB,GAEfvzB,EAAO6H,KAAK0rB,IAITvzB,WCHOu/C,GAAazB,EAAkBvG,GAC7C,OAAOsG,GAAkBC,iCAAYvG,IAAQhkB,SAAU+rB,GAAqB/H,EAAOhkB,mBCH/DisB,GA2DpBt+C,CAACmI,KACC,OAAO1G,KAAK8Q,OAmBdvS,IAAI0yC,GACF,OAAOjxC,KAAKm7C,MAAM9xC,IAAI,GAAI4nC,GAU5B1yC,QACE,OAAOyB,KAAK4D,aAqBMk5C,GAoBpBv+C,CAACmI,KACC,OAAO1G,KAAK8Q,OAyBdvS,CAACgL,MACC,OAAOvJ,KAAKyQ,kBAqBMssC,WAA0BD,UClMnCE,WAAcF,GAOzBv+C,YAA6B0+C,EAAkBC,GAC7Cp8C,QAD2Bd,WAAAi9C,EAEvBC,GACFl9C,KAAKm9C,WAAa,IAAM/9C,EAAS69C,EAAOC,GACxCl9C,KAAKo9C,aAAejC,GAASA,EAAM3I,OAAO0K,KAE1Cl9C,KAAKm9C,WAAa,IAAMF,EACxBj9C,KAAKo9C,aAAe7gD,GAMxBgC,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAOzD,GAChBrN,KAAKyQ,WAAWjG,KAAK7N,EAAcqD,OACnCjD,EAAeiD,OACjB8L,GAAGlE,GAKPrJ,SAASqJ,GACP,OAAQ5H,KAAKyQ,SAAWnE,GAAoC1E,IAE1D,MAAMuzC,EAAQn7C,KAAKq9C,WAAar9C,KAAKq9C,SAAW,IAAIn0C,IAAIlJ,KAAKm9C,eAE7DnvC,GAAWhO,KAAKi9C,OAAOlzC,GAAG,CACxBjC,OAAQF,EAASE,OAAON,QAAQ,IAAMxH,KAAKq9C,cAAWz3C,GACtDqC,QAAS,CAACjG,EAAS84B,EAAOY,KACxBZ,EAAQ96B,KAAKo9C,aAAatiB,KAC1BY,EAAU17B,KAAKo9C,aAAa1hB,IAChB77B,QAAUi7B,EAAMj7B,UAC1B67B,EAAQnxB,QAAQqmC,GAAQuK,EAAM7xC,OAAOsnC,IACrC9V,EAAMvwB,QAAQqmC,GAAQuK,EAAM9xC,IAAIunC,IAChChpC,EAASK,QAAQjG,EAAS84B,EAAOY,SAItC1xB,QAAQ8B,GAAGlE,GAGhBrJ,CAACrB,OAAOgB,YACN,OAAI8B,KAAKq9C,SAEAr9C,KAAKq9C,SAASrgD,SAIhBmB,EAAY6B,KAAKm9C,cAG1B5+C,KAAK01C,GACH,OAAOqJ,GAAUt9C,KAAMi0C,aAQXqJ,GAAUliB,EAAoB6Y,GAE5C,MAAMr8B,WlBZkBq8B,GACxB,OAAO3B,GAA0B2B,GkBWvBsJ,CAAUtJ,GAEpB,OAAO,IAAI+I,GAAM5hB,EAAMwV,YlBArBnW,EACAwZ,GAEF,IAAKxZ,EAAS56B,OACZ,OAAO,EAGT,MAAMwyC,EAAO5X,EAASA,EAAS56B,OAAS,GAExC,QAAIo0C,EAAMxhC,IAAM4/B,EAAK5/B,KAAOwhC,EAAMxhC,QAG9BwhC,EAAM7nC,GAAKimC,EAAKjmC,IAAM6nC,EAAM7nC,OAG5B6nC,EAAMr0C,GAAKyyC,EAAKzyC,IAAMq0C,EAAMr0C,OAG5Bq0C,EAAM9lB,IAAM6lB,GAAa3B,EAAKlkB,EAAG8lB,EAAM9lB,OAIvC8lB,EAAMxhB,IAAMuhB,GAAa3B,EAAK5f,EAAGwhB,EAAMxhB,OkBtBZ+qB,CAAoB5M,EAAKnW,SAAU7iB,IC1DpE,MAAM6lC,WAAiBV,GAKrBx+C,YAA6B2R,EAA2BT,GACtD3O,QAD2Bd,WAAAkQ,EAA2BlQ,YAAAyP,EAHvCzP,cAAW,IAAI8N,GAK9B9N,KAAKo8B,KA2FT,SAAsBwU,EAAiBtyB,GAErC,MAAM7N,EAAW,IAAI3C,GACfqtC,EAAQ,CAACvK,GAEftyB,EAAI7N,SAAS,CAACitC,EAAQhiB,KAChBA,EAAQ,KAAOkV,IACjBuK,EAAMt7C,OAAS,EACf4Q,EAASrI,KAAK,GAAI,CAACwoC,OAEpBllC,KAAK+E,GAER,MAAMktC,EAEJp/C,CAACgL,MACC,OAAOkH,EAASpG,KAGlB9L,CAACrB,OAAOgB,YACN,OAAOC,EAAYg9C,IAKvB,OAAO,IAAI6B,GAAM,IAAIW,GAnHPC,CAAa1tC,EAAOlQ,MAKlCzB,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAOzD,GAChBrN,KAAKy8B,SAASpyB,KAAKG,KAAK7N,EAAcqD,OACtCjD,EAAeiD,OACjB8L,GAAGlE,GAKPrJ,SAASqJ,GACP,OAAQ5H,KAAKyQ,SAAWzQ,KAAKy8B,SAASpyB,KAAKyB,GAAGlE,GAGhDrJ,CAACrB,OAAOgB,YACN,OAAO2/C,GAAgB79C,KAAKkQ,OAG9B3R,KAAK01C,GACH,OAAOqJ,GAAUt9C,KAAMi0C,GAGzB11C,IAAIk8B,EAAwBwW,GAC1B,OAsOJ,SAAS6M,EACLlN,EACAmN,EACA9M,EACA+M,GAGF,MAAOv9C,EAAKw9C,GAAQnK,GAAmBiK,GAEvC,IAAKE,EAGH,OADArN,EAAKsN,MAAMhtC,GAmBf,SAAoB0/B,EAAiBK,GAEnC,MAAMkN,EAAUvN,EAAKsN,MAAMhtC,GAE3B,IAAK+/B,EACH,OAAOkN,EAGT,GAAIvN,EAAKwN,MACP,OAAOrS,GAAK4E,GAAqB5E,EAAGkF,GAGtC,OAAOlF,GAAKyF,GAAoB2M,EAAQpS,GAAI4E,GAAqB5E,EAAGkF,IA/BlDoN,CAAWzN,EAAMK,GAC1BL,EAGT,MAAM0N,EAAU7J,GAAgBh0C,GAC1BgD,EAAQmtC,EAAKuK,MAAM1rC,OAAOkmC,MAAM2I,GAEtC,GAAI76C,EACF,OAAOq6C,EAAWr6C,EAAOw6C,EAAMhN,EAAY+M,GAG7C,MAAMO,EAAY,IAAIC,GAAU5N,EAAKjY,KAAM,IAAIiY,EAAKnW,YAAah6B,GAAMA,GACjEpD,EAASygD,EAAWS,EAAWN,EAAMhN,GAAY,GAIvD,OAFAL,EAAKuK,MAAM1rC,OAAO43B,KAAKiX,EAASC,EAAWP,GAEpC3gD,EAjQEygD,CAAW99C,KAAKkQ,MAAOokC,GAAa7Z,GAAWwW,GAAY,GAGpE1yC,IAAIk8B,GACF,OAAOz6B,KAAKy+C,KAAKnK,GAAa7Z,IAGxBl8B,KAAKk8B,GAEX,MAAOh6B,EAAKw9C,GAAQnK,GAAmBrZ,GAEvC,IAAKwjB,EACH,OAAOj+C,KAAKkQ,MAGd,MAAMzM,EAAQzD,KAAKyP,OAAOkmC,MAAMlB,GAAgBh0C,IAEhD,OAAKgD,EAIEA,EAAM03C,MAAMr+C,IAAImhD,QAJvB,EAOF1/C,MAAMk8B,GAEJ,MAAMnQ,EAAUgqB,GAAa7Z,GAE7B,OAAOvtB,GAA+BtF,IAEpC,MAAMmK,EAAUL,GAA2B,IACrCgtC,EAAmB1+C,KAAK8Q,OAAOvE,QAAQ,KAE3C,MAAM9I,EAAQzD,KAAKy+C,KAAKn0B,GAExB,OAAO7mB,GAASA,EACXqN,KAAKmgC,GAAcl/B,EAAQb,GAAK+/B,GAChCzpC,QAAQ,IAAMuK,EAAQb,GAAK,MAGlC,OAAOa,EAAQjB,KAAKlJ,GAAU8D,KAAKgzC,KAClC10C,QAGLzL,KAAKqyC,EAAiBoN,GACpBpN,EAAKuK,MAAM1qC,SAAS,CAACqqB,EAAOY,IAAY17B,KAAKy8B,SAASr0B,KAAK0yB,EAAOY,IAC9DsiB,GACFh+C,KAAKy8B,SAASr0B,KAAKu2C,GAAS/N,GAAO,IAIvCryC,QAAQyI,GAEN,MAAM00B,EAAUijB,GAAS3+C,KAAKkQ,OAE9BlQ,KAAKy8B,SAASr0B,KAAK,GAAIszB,GACvBA,EAAQnxB,QAAQqmC,IACdA,EAAKuK,MAAM1e,SAAS39B,KAAKkI,GACzB4pC,EAAKsN,MAAMp/C,KAAKkI,MAiCtB,SAAS23C,GAAS/N,GAChB,OAAO9qC,MAAMC,KAAK83C,GAAgBjN,IAGpC,SAAUiN,GAAgBjN,SAClBA,EACN,IAAK,MAAMnhC,KAAUmhC,EAAKuK,MAAM1rC,aACvBkvC,GAASlvC,GAIpB,MAAMmvC,WAAoB9B,GAMxBv+C,YAAYo6B,GACV73B,QAJed,cAAW,IAAI8N,GACf9N,YAAS,IAAIqD,IAI5BrD,KAAK6+C,KAAO,IAAIpB,GAAS9kB,EAAM34B,MAKjCzB,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAOzD,GAChBrN,KAAKy8B,SAASpyB,KAAKG,KAAK7N,EAAcqD,OACtCjD,EAAeiD,OACjB8L,GAAGlE,GAKPrJ,SAASqJ,GACP,OAAQ5H,KAAKyQ,SAAWzQ,KAAKy8B,SAASpyB,KAAKyB,GAAGlE,GAGhDrJ,CAACrB,OAAOgB,YACN,OAAO8B,KAAK8+C,OAAO9hD,SAGrBuB,KAAK01C,GACH,OAAOqJ,GAAUt9C,KAAMi0C,GAGzB11C,MAAMkC,GACJ,OAAOT,KAAK8+C,OAAOhiD,IAAI2D,GAGzBlC,KAAKkC,EAAamwC,EAAiBoN,GACjCh+C,KAAK8+C,OAAOl7C,IAAInD,EAAKmwC,GACrBA,EAAKuK,MAAM1qC,SAAS,CAACitC,EAAQhiB,KACvBA,EAAQ,KAAOkV,IACjB5wC,KAAK8+C,OAAOx1C,OAAO7I,GACnBT,KAAKy8B,SAASr0B,KAAK,GAAI,CAACwoC,OAGxBoN,GACFh+C,KAAKy8B,SAASr0B,KAAK,CAACwoC,GAAO,IAE7B5wC,KAAK6+C,KAAKxX,KAAKuJ,EAAMoN,UAQZQ,WAAkB3B,GAuC7Bt+C,YACIo6B,EACA8B,EACAh6B,EACAgB,EAA+BivC,IAEjC5vC,QACAd,KAAKkQ,MAAQyoB,GAAQ34B,KACrBA,KAAK+7C,UAAYthB,EACjBz6B,KAAKwW,KAAO/V,EACZT,KAAKk+C,MAAQxsC,GAAWjQ,GACxBzB,KAAK0P,QAAU,IAAIkvC,GAAY5+C,MAzCjC24B,WACE,OAAO34B,KAAKkQ,MAGd0lC,YACE,QAAoBhwC,IAAhB5F,KAAK++C,OACP,OAAO/+C,KAAK++C,OAGd,MAAMC,WpBwBNvkB,GAGF,IAAI76B,EAAI66B,EAAS56B,OAAS,EAE1B,GAAID,GAAK,EACP,OAAOA,OAAIgG,EAAYmuC,GAGzB,GAEE,SADEn0C,EACM66B,EAAS76B,IACjB,IAAK,IACH,OAAO66B,EAAS9qB,MAAM,EAAG/P,GAC3B,IAAK,IACL,IAAK,MACDA,EACF,SACF,QACE,OAAO66B,EAAS9qB,MAAM,EAAG/P,EAAI,UAExBA,EAAI,GoB7CWq/C,CAAkBj/C,KAAKy6B,UAE7C,OAAOz6B,KAAK++C,OAASC,GAAiBh/C,KAAK24B,KAAKwiB,MAAMr+C,IAAIkiD,IAAkB,KAG9EvkB,eACE,OAAOz6B,KAAK+7C,UAGdt7C,UACE,OAAOT,KAAKwW,KAGd4nC,YACE,OAAOp+C,KAAKk+C,MAAMhtC,KAAOw/B,GAG3ByK,YACE,OAAOn7C,KAAK0P,QAAQmvC,KAmBtBtgD,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAO9Q,KAAKk+C,MAAMptC,OAAOgF,SAASopC,GAAWtxC,GAAesxC,EAAQl/C,QAAQ8L,GAAGlE,GAG9FrJ,IAAI0yC,GAEF,OADAjxC,KAAKk+C,MAAMhtC,GAAK+/B,EAAalF,GAAK4E,GAAqB5E,EAAGkF,GAAcP,GACjE1wC,KAGTzB,OAAOyI,GAEL,OADAhH,KAAKm7C,MAAMprC,QAAQ/I,GACZhH,MC9QX,MAAM+zC,GAAwC,SCexBoL,GAoBpB5gD,CAACmI,KACC,OAAO1G,KAAK8Q,OA4BdvS,QACE,OAAOyB,KAAK4D,OAyBhB,MAAMw7C,WAAkDD,GAEtD5gD,YACqB2R,EACA6rC,EACAruB,GAEnB5sB,QAJmBd,WAAAkQ,EACAlQ,eAAA+7C,EACA/7C,UAAA0tB,EAOrBnvB,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAOtD,GAAS,CAC3B6xC,GAAIr/C,KAAK0tB,KAAK1tB,KAAKkQ,OACnBovC,GAAIt/C,KAAKkQ,MAAMirC,MAAMoE,MAAMv/C,KAAK+7C,aAC/BjmC,SACC,EACEupC,IAAKG,GACLF,IAAKG,MACDjiD,EAAWowC,GAAW3rC,IAAOu9C,EAAWC,KAChD3zC,GAAGlE,GAGPrJ,IAAI0yC,GAEF,OADAjxC,KAAKkQ,MAAMirC,MAAM9xC,IAAIrJ,KAAK+7C,UAAW9K,GAC9BjxC,KAGTzB,IAAI0yC,GAEF,OADAjxC,KAAKkQ,MAAMirC,MAAM9xC,IAAIrJ,KAAK+7C,WAAWn4C,IAAIqtC,GAClCjxC,YAQE0/C,GAAc,CAazBnhD,GACIk8B,EACAoT,GAMF,IAAI5rC,EAQJ,OALEA,EADsB,mBAAb4rC,EACHlV,GAAQgnB,GAAe9R,EAASlV,IAEhCh8B,EAAcgjD,GAAe9R,IAG9BlV,GAAQ,IAAIymB,GAAazmB,EAAM8B,EAAUx4B,KAQpD,SAAS09C,GACL9R,GAEF,OAAOlnC,EAAcknC,GAAYA,EAAWlgC,GAASkgC,SCrK1C+R,GA2CXrhD,YAAYshD,GACV7/C,KAAK6/C,KAAOA,EApBdthD,UACIuhD,EACAnnB,GAGF,MAAMknB,EAA8C,GAEpD,IAAK,MAAMp/C,KAAOiC,OAAOpC,KAAKw/C,GAC5BD,EAAKp/C,GAAkBq/C,EAAUr/C,GAAKk4B,GAGxC,OAAO,IAAIinB,GAAgBC,GA6B7BthD,KAAKqJ,GAEH,MAAMm4C,EAAmEvyC,GAASxN,KAAK6/C,MAEvF,OAAQ7/C,KAAK8Q,KAAQivC,EAAQjqC,SAASkqC,IAAuCl0C,GAAGlE,GAGlFrJ,CAACmI,KACC,OAAO1G,KAAK8Q,QAQhB,SAASkvC,GACLhP,GAGF,MAAM3zC,EAAkD,GAExD,IAAK,MAAMuD,KAAQ8B,OAAOpC,KAAK0wC,GAC7B3zC,EAAOuD,GAAQowC,EAAcpwC,GAAM,GAGrC,OAAOvD,EC1CT,MAAM4iD,OAA+CjD,GAAM,CACzDz+C,CAACgL,IAAgB,IACRwE,GAETxP,CAACrB,OAAOgB,UAAS,IACR,GAAGhB,OAAOgB,uBAYLgiD,MAAazyC,GAC3B,OAAOA,EAAQ5N,OAASsgD,GAAY1yC,EAAQxL,IAAIm+C,KAAoBH,GAMtE,SAASG,GAAgB/gD,GACvB,MAAyB,mBAAXA,EA4DhB,SAAmBA,GAEjB,IAAIghD,EAEJ,MAAO,CACL9hD,CAACrB,OAAOgB,UAAS,IACRi9C,IAAQj+C,OAAOgB,YAExBK,CAACgL,IAAgB,IACR4xC,IAAQ5xC,OAInB,SAAS4xC,IACP,OAAOkF,IAAWA,EAASC,GAAajhD,OA1EJkhD,CAAUlhD,GAAUihD,GAAajhD,YAiBzDmhD,MAAiB/yC,GAC/B,OAAOA,EAAQ5N,OAASsgD,GAAY1yC,EAAQxL,IAAIw+C,KAAwBR,GAM1E,SAASQ,GAAoBphD,GAC3B,MAAyB,mBAAXA,EAwDhB,SAAmBA,GAEjB,MAAMqhD,EAAU,IAAIx3C,IACd6C,EAAUO,GAAoC1E,IAElD,MAAMuzC,EAAQmF,GAAajhD,KAE3BshD,GAAoBxF,EAAOuF,EAAS94C,GACpCuzC,EAAM5xC,MAAmBQ,GAAG,CAC1BjC,OAAQF,EAASE,OAAON,QAAQ,IAAMk5C,EAAQv3C,SAC9C5K,QAAQyD,EAAS84B,EAAOY,GACtBA,EAAQnxB,QAAQqmC,GAAQ8P,EAAQp3C,OAAOsnC,IACvC9V,EAAMvwB,QAAQqmC,GAAQ8P,EAAQr3C,IAAIunC,IAClChpC,EAASK,QAAQjG,EAAS84B,EAAOY,QAGpC1xB,QAEH,MAAO,CACLzL,CAACgL,IAAgB,IACRwC,EAETxN,CAACrB,OAAOgB,UAAS,IACRwiD,EAAQ1jD,UA/EmB4jD,CAAUvhD,GAAUihD,GAAajhD,GAMzE,SAAS8gD,GAAY1yC,GACnB,GAAuB,IAAnBA,EAAQ5N,OAAc,CAExB,MAAMR,EAASoO,EAAQ,GAEvB,OAAOpO,aAAkBy9C,GAAez9C,EAAS,IAAI29C,GAAM39C,GAE7D,OAAO,IAAI29C,GAAM,CACfz+C,EAAErB,OAAOgB,YACP,IAAK,MAAMi9C,KAAS1tC,QACX0tC,GAGX58C,CAACgL,IAAgB,IACR+C,GAAoC1E,IACzC6F,EAAQlD,QAAQlL,GAAU2O,GAAW3O,GAAQ0K,GAAG,CAC9CjC,OAAQJ,IAAcH,MAAMK,EAASE,QACrCvJ,QAAQyD,EAAS84B,EAAOY,GACtB9zB,EAASK,QAAQjG,EAAS84B,EAAOY,SAGpC1xB,UA4DT,SAASs2C,GAAajhD,GACpB,OAAOA,aAAkBw9C,GAAWx9C,EAAO87C,MAAM/e,KAAO5yB,GAAcnK,GAAUA,EAMlF,SAAoBA,GAElB,MAAMqhD,EAAU,IAAIx3C,IACd6C,EAAUO,GAAoC1E,IAElD,IAAI0G,EAAe3E,KACnB,MAAM7B,OAAEA,GAAWF,EAEnBE,EAAO4D,KAAK4C,GACP9G,QAAQ,IAAMk5C,EAAQv3C,SAE3B9J,EAAOgN,KACHw0C,IACE,IAAK/4C,EAAOV,MAAO,CAEjB,MAAM+zC,EAAQ0F,aAAsBhE,GAAWgE,EAAW1F,MAAQ0F,EAElEF,GAAoBxF,EAAOuF,EAAS94C,GAEpC0G,EAAeN,GAAWmtC,GAAOpxC,GAAG,CAClCxL,QAAQyD,EAAS84B,EAAOY,GACtBA,EAAQnxB,QAAQqmC,GAAQ8P,EAAQp3C,OAAOsnC,IACvC9V,EAAMvwB,QAAQqmC,GAAQ8P,EAAQr3C,IAAIunC,IAClChpC,EAASK,QAAQjG,EAAS84B,EAAOY,MAElCn0B,MAAMO,MAGfkH,MACEwI,GAAS1P,EAAOhB,IAAI0Q,MAEvBxN,QAEH,MAAO,CACLzL,CAACgL,IAAgB,IACRwC,EAETxN,CAACrB,OAAOgB,UAAS,IACRwiD,EAAQ1jD,UA5CsE8jD,CAAWzhD,GAoDtG,SAASshD,GACLxF,EACAuF,EACA94C,GAGF,MAAMkD,EAAuB,GAM7B,GAJArM,EAAQ08C,EAAOvK,IACb9lC,EAAS5F,KAAK0rC,GACd8P,EAAQr3C,IAAIunC,KAEV9lC,EAASjL,OAAQ,CAEnB,MAAM+f,EAAa,IAAI7W,GAEvB6W,EAAWvV,GAAGzC,GACdgY,EAAWxX,KAAK0C,EAAU,WCrPjBi2C,OACSt6C,EAAyC,4BCblDu6C,OACSn7C,EAAuC,2BCJhDo7C,OAAwC/tC,GACjD,8CACA,OACA,oBAMSguC,OAAsEz6C,EAC/E,uBACA,CAAErF,UAWN,SAAyB+/C,GAEvB,MAAMC,EAAUD,EAAcrkD,IAAI2lB,IAC5BzgB,EAAUm/C,EAAcrkD,IAAIojB,IAC5BuE,EAAaziB,EAAQlF,IAAIgoB,IAEzBtS,EAAQ,GADOiS,EAAW7jB,KAAOiS,GAAajS,KAAK6jB,EAAW7jB,KAAMwgD,GAAW,iBAC1DC,KACrBC,EAAYL,GAAmBrgD,KAAKwgD,EAAQH,IAAqBzuC,EAAOS,IAK9E,OAJgBjR,EAAQrD,QAEhB4iD,UAAUl4C,IAAIi4C,GAEfA,KAjBT,IAAID,GAAiB,ECiDrB,MAAMG,OACgB/6C,EACd,+BAacg7C,GAKpB/gD,WAAYA,KACV,OAAO8gD,GAkBTjjD,QACI48C,EACAjjC,GAGF,MAAM49B,EAAW91C,KAAK0hD,YAAYvG,EAAOjjC,GACnCpQ,EAASJ,IAMf,OAJA1H,KAAKgC,QAAQ6jB,YAAY,KACvBiwB,IAAWvuC,MAAMO,GAAQ4D,KAAK5D,KAGzBA,EAaTvJ,YACI48C,EACAjjC,GAGF,MAAM8/B,EAAMwI,GAAcrF,GAC1B,IAAIrF,EACJ,MAAM6L,EAAkBr6C,EAActH,KAAKgC,SAe3C,OAbA8zC,EAAW,IAEY91C,KAAKgC,QAAQlF,IAAIikD,GAE/BnE,CAAa5E,EAAKh4C,KAAK40C,OAAO18B,IAAS3Q,MAAMo6C,GAItDA,EAAgBn6C,QAAQ,KAEtBsuC,EAAWn5C,EAAcglD,KAGpB,IAAM7L,IAyBfv3C,SACI2Z,GAGF,MAAM4Z,EAAa9xB,KAAKgC,QAAQlF,IAAI80B,GAAmB,CAAEntB,GAAI,QACvDmsB,SAAEA,GAAa1Y,EACfqjC,EAAY,IAAI/gC,GAAuBoW,GACxCvnB,OAAOrJ,KAAKgC,QAAQlF,IAAIkkD,KACvBY,EAAe1pC,EAAO0pC,aACtBtN,GAAap8B,EAAO0pC,cAAc,QAClCh8C,EAMN,OAJA21C,EAAUlyC,IAAIyoB,EAalB,SAAwB8vB,GACtB,MAAO,CACL3K,OAAQ,IACR14C,OAAOu3C,EAAU7E,GAEf,IAAIxW,SAAEA,GAAaqb,EAEnB,GAAKrb,EAAS56B,QAEP,GAAI+hD,EAAc,CAEvB,MAAOxL,EAAMyL,GAAQC,GAAoBrnB,GAErConB,IAEApnB,EADEonB,EAAKhiD,OACI,CAAC,CAAE8yC,EAAG,CAAC,CAAC,IAAK,OAAQoP,GAAmBF,EAAMD,SAAsBxL,GAEpE,CAAC,CAAEzD,EAAG,CAAC,CAAC,IAAK,OAAQ,CAACiP,SAAsBxL,UAT3D3b,EAAW,CAACmnB,GAAgB,CAAEjP,EAAG,CAAC,CAAC,IAAK,WAc1CmD,EAASzkB,OAAO4f,EAAY,CAAExW,SAAAA,MAlC1BunB,CAAeJ,GA0CzB,SAA0BA,GACxB,MAAO,CACL3K,OAAQ,IACR14C,OAAOu3C,EAAU7E,GAEf,IAAIxW,SAAEA,GAAaqb,EAEnB,GAAKrb,EAAS56B,OAEP,CAEL,MAAOu2C,EAAMyL,GAAQC,GAAoBrnB,GAGvCA,EADEonB,GAAQA,EAAKhiD,OACJ,IAAIkiD,GAAmBF,EAAMD,MAAkBxL,GAE/C,CAACwL,KAAiBxL,QAR/B3b,EAAW,CAACmnB,GAYd9L,EAASzkB,OAAO4f,EAAY,CAAExW,SAAAA,MA7D1BwnB,CAAiBL,GAAgB,CAAEzzB,EAAG,CAACnuB,KAAKgC,QAAQlF,IAAIokD,QAEvD3F,EAAU/+C,OAmErB,SAASslD,GACLrnB,GAEF,GAA2B,iBAAhBA,EAAS,GAAiB,CAEnC,OAAOhoB,GAAEA,EAAErG,EAAEA,EAACxM,EAAEA,EAACuuB,EAAEA,EAACwkB,EAAEA,EAACr2B,EAAEA,EAACmW,EAAEA,MAAQyvB,GAAaznB,EAEjD,IAAKhoB,IAAOrG,IAAMxM,IAAMuuB,IAAM7R,GAAKq2B,EAAG,CAEpC,OAAQQ,EAAQvyC,KAASwyC,IAAWT,EAEpC,GAAe,MAAXQ,GAA2B,SAATvyC,EAAiB,CAErC,IAAIihD,EASJ,OAPIzO,EAAOvzC,QACTgiD,EAAO/7C,MAAMC,KAAKqtC,EAAO,IACxByO,EAAK,GAAWpvB,EAAIA,GAErBovB,EAAOpvB,EAAI,CAAC,CAAEA,EAAAA,IAAO,GAGhB,CAACyvB,EAAWL,KAIzB,MAAO,CAACpnB,GAMV,SAASsnB,GACLtnB,GACAhoB,GACEA,EAAErG,EACFA,EAACxM,EACDA,EAACuuB,EACDA,EAACwkB,EACDA,EAACr2B,EACDA,IAIJ,MAAO/W,KAAU6wC,GAAQ3b,EAEzB,MAAO,CACL,CACEhoB,GAAIlN,EAAM6G,GAAK7G,EAAMkN,GAAKlN,EAAMkN,GAAKA,EACrCrG,EAAG7G,EAAM6G,GAAK7G,EAAMkN,GAAKlN,EAAM6G,EAAIA,EACnCxM,EAAG2F,EAAM3F,GAAKA,EACduuB,EAAG5oB,EAAM4oB,EAAKA,EAAI,IAAI5oB,EAAM4oB,KAAMA,GAAK5oB,EAAM4oB,EAAiBA,EAC9DwkB,EAAGptC,EAAMotC,EAAKA,EAAI,IAAIptC,EAAMotC,KAAMA,GAAKptC,EAAMotC,EAAiBA,EAC9Dr2B,GAAK/W,EAAM+W,GAAK,KAAOA,GAAK,UAAQ1W,EACpC6sB,EAAGltB,EAAMktB,MAER2jB,SClTM+L,WAA+BV,GAiB1CljD,YACayD,GACT8uB,KACEA,EAAO,WAGL,IAENhwB,QAPWd,aAAAgC,EAQXhC,KAAK8wB,KAAOA,EAGdvyB,OAAO2Z,GACL,OAAO+hC,GAAcj6C,KAAKkY,OAAOA,IAYnC3Z,OACI2Z,GAEF,OAAOkqC,GAA6BpiD,KAAMkY,EAAQ,CAAE4Y,KAAM9wB,KAAK8wB,iBAmBnDsxB,GACZxN,EACA18B,EAA0D,GAC1DmZ,GAGF,MAAMrvB,QAAEA,GAAY4yC,EAEpB,sCACK18B,IACHqK,SAAUrK,EAAOqK,UAAYvgB,EAAQlF,IAAIulB,IAAiBE,SAC1DyW,OAAQ9gB,EAAO8gB,QAAUh3B,EAAQoe,YACjC2zB,aAAc,GACdnxB,UAAW1K,EAAO0K,WAAay/B,GAA2BrgD,EAASqvB,GACnE9e,QAAS2F,EAAO3F,SAAWvQ,EAAQlF,IAAI2lB,IACvCmO,SAAUgkB,EAAOhkB,SAAS1Y,KAO9B,SAASmqC,GACLrgD,EACAqvB,EAAoB,IAGtB,MAAMzO,EAAY5gB,EAAQlF,IAAIy0B,IAE9B,MAAO,CAACvwB,EAAO,KAAO4hB,iCAAe5hB,GAASqwB,UCnGnCixB,WAAkCb,GAO7CljD,YAAqByD,GACnBlB,QADmBd,aAAAgC,EAIrBzD,OAAO2Z,GACL,gBjBgHAA,EAAiC,IAGnC,MAAM8gB,OAAEA,EAASzW,SAAS0mB,MAAS/wB,EAEnC,sCACKA,IACH0K,UAAWm2B,GAAoB/f,EAAQ9gB,EAAO0K,WAC9CrkB,WAEE,MAAMI,EAAU4jB,SAASsjB,cAAc,SAOvC,OALAlnC,EAAQgxB,aAAa,OAAQ,YAC7BhxB,EAAQuqB,OAAO3G,SAASggC,eAAe,KAEvCvpB,EAAOoQ,YAAYzqC,GAEZ,IAAIq8C,GAAsBr8C,MiBjI5B6jD,CAAiBxiD,KAAKkY,OAAOA,IAYtC3Z,OAAO2Z,GACL,OAAOkqC,GAA6BpiD,KAAMkY,EAAQ,CAAE4Y,KAAM,eC5B9D,MAAM2xB,GAAiD,CACrDl7C,MAAOyoB,GACPzxB,MAAMwf,GACJA,EAAMva,QAAQ,CAAE5B,EAAGm/C,GAAwB3+C,GAAI84C,KAC/Cn9B,EAAM8K,aAAa,CACjBjnB,EAAG6/C,GACH9+C,GAAI2/C,aAgBGI,GAEXhlC,WAAYA,MACV,OAAO+kC,aCdKE,GACZzqC,GAKF,OAAOsI,GAAkB,EAAG1jB,IAAAA,OAC1B8jB,aAAc,CACZ/B,QAAS,CACPtX,MAAOm7C,IAETnkD,OAAOgmB,GACLA,EAAW4B,cAAcnkB,IACvBA,EAAQ2jB,UAAU,EAAGhF,UAAAA,MAEnB,MAAMnkB,EAAQM,EAAI6jB,GACZthB,EAA4C,mBAAV7C,EAAuBA,EAAMwH,KAAK2c,GAAankB,EACxEwF,EAAQlF,IAAI2kD,IAEpBmB,QAAQvjD,EAAQ6Y,YC7BnC,MAAM2qC,GAA4C,CAChD/kC,IAAK4kC,GACLn7C,MAAOyoB,GACPzxB,MAAMwf,GACJA,EAAMva,QAAQ,CAAE5B,EAAGm/C,GAAwB3+C,GAAIw6C,KAC/C7+B,EAAM8K,aAAa,CACjBjnB,EAAG6/C,GACH9+C,GAAI2/C,OCVV,MAAMQ,GAAa,IAAIr8C,EAAwB,eAUzBs8C,GAKpBriD,WAAYA,KACV,OAAOoiD,GAmBTvkD,IAAiCykD,GAC/B,OAAOA,EAAShjD,KAAK24B,OCrCzB,MAAMsqB,GAAoB,IAAIx8C,EAA+B,uBAEvCy8C,GAEpBxiD,WAAYA,KACV,OAAOuiD,UC+HEE,GAAsD,IAlEnE,cAA4Bz9C,EAE1BnH,cACEuC,MAAM,eAGRvC,KACIyC,GAGF,MAAM2E,EAAY,IAAItC,IAEtB,IAAK,MAAMunC,KAAS5pC,EAAKE,KAAM,CAE7B,IAAIT,EACA5D,EACAumD,EAEiB,mBAAVxY,GACTnqC,EAAM5D,EAAW+tC,EACjBwY,GAAO,IAEP3iD,EAAMmqC,EAAMA,MACZ/tC,EAAW+tC,EAAMpnC,QAAQQ,KAAK4mC,GAC9BwY,GAAO,GAGT,MAAMj8C,EAAOxB,EAAU7I,IAAI2D,GAE3B,GAAK0G,EAEE,CAEL,MAAOk8C,EAAcC,GAASn8C,EAE9BxB,EAAU/B,IACNnD,EACA,CACE2iD,EAAOG,GAAc1mD,EAAUwmD,GAAgBE,GAAcF,EAAcxmD,GAC3EumD,GAAQE,SATd39C,EAAU/B,IAAInD,EAAK,CAAC5D,EAAUumD,IAelC,OAAOz9C,EAAUyD,KAAOo6C,EAAOxiD,EAAKI,UAAU,IAAMoiD,GAEpD,SAASA,EAAKl3B,GAEZ,MAAMxhB,EAAWnF,EAAU7I,IAAIwvB,GAE/B,IAAKxhB,EACH,OAAOwhB,EAGT,MAAOzvB,EAAUymD,GAASx4C,EAE1B,OAAOw4C,EAAQzmD,EAAW0mD,GAAcj3B,EAAIzvB,MAclD,SAAS0mD,GAAch+C,EAA4BC,GACjD,OAAOi+C,GAASvD,GAAU36C,EAAMk+C,GAAQj+C,EAAOi+C,UC7IpCV,WAAcW,GAKzBnlD,YAA6BolD,OhBeN1S,EgBdrBnwC,QAD2Bd,aAAA2jD,EAHpB3jD,UhBmBF,IAAI4jD,QAAUh+C,EAAWmuC,GAAc,GAAI9C,EAAalF,GAAK4E,GAAqB5E,EAAGkF,QAAcrrC,GgBlBzF5F,YAAS,IAAIqD,IAM9B9E,SAASslD,GAEP,MAAMJ,EAAQzjD,KAEd,OAAOwgD,MAAiBqD,EAAO7kC,QAE/B,SAAuB9e,EAAqB0qC,GAE1C,MAAM9/B,EAAW24C,EAAMpD,OAAOvjD,IAAI8tC,GAElC,GAAI9/B,EACF5K,EAAOgF,KAAK4F,OACP,CAEL,MAAMzG,EAAco/C,EAAME,QAAQ/Y,EAAd6Y,CAAqBA,GAEzCA,EAAMpD,OAAOz8C,IAAIgnC,EAAOvmC,GACxBnE,EAAOgF,KAAKb,GAGd,OAAOnE,IAhByD,YCbzDgjD,WAAqBY,GAEhCvlD,YAA6BolD,GAC3B7iD,QAD2Bd,aAAA2jD,EAI7BplD,WACE,OAAO,IAAIwkD,GAAM/iD,KAAK2jD,UCA1B,MAAMI,GAAoC,CACxCx8C,MAAOm7C,GACPnkD,MAAMwf,GACJA,EAAMva,QAAQ,CAAE5B,EAAGshD,GAAcvgD,GAAImhD,GAAehiD,KAAM,CAACqhD,MAC3DplC,EAAMva,QAAQ,CACZ5B,EAAGmhD,GACHlhD,GAAGgC,GACMA,EAAQmgD,WAEjBliD,KAAM,CAACohD,cAUAe,GAEXvmC,WAAYA,MACV,OAAOqmC,UC3BEG,WAAoBh7C,IAa/B3K,YAAYvB,GACV8D,QACAd,KAAK09C,OAAS,IAAIx0C,IAAOlM,GACzBgD,KAAKmkD,SAAW,IAAIj7C,IACpBlJ,KAAK09C,OAAOnzC,QAAQ/N,GAASwD,KAAKqJ,IAAI7M,IAaxC+B,IAAI/B,GAMF,OALKwD,KAAK8d,IAAIthB,KACZwD,KAAK09C,OAAOr0C,IAAI7M,GAChBwD,KAAKmkD,SAAS76C,OAAO9M,GACrBsE,MAAMuI,IAAI7M,IAELwD,KAYTzB,OAAO/B,GACL,QAAIsE,MAAMwI,OAAO9M,KACfwD,KAAK09C,OAAOp0C,OAAO9M,GACnBwD,KAAKmkD,SAAS96C,IAAI7M,IACX,GAUX+B,QACEyB,KAAK09C,OAAOv0C,QACZnJ,KAAKuK,QAAQ/N,GAASwD,KAAKmkD,SAAS96C,IAAI7M,IACxCsE,MAAMqI,QAeR5K,MAAM8K,EAAkBqzC,EAAsB,IAE5C,OADA0H,GAAsBpkD,KAAtBokD,CAA4B/6C,EAAKqzC,GAC1B18C,KAUTzB,QAAQqJ,GAMN,OAJoC,mBAAbA,EAA0BA,EAAWw8C,GAAsBx8C,IAE1E9B,MAAMC,KAAK/F,KAAK09C,QAAS53C,MAAMC,KAAK/F,KAAKmkD,WAE1CnkD,KAUTzB,UAGE,OAFAyB,KAAK09C,OAAOv0C,QACZnJ,KAAKmkD,SAASh7C,QACPnJ,MA4DX,SAASokD,GACLx8C,GAEF,MAAO,CAACyB,EAAKqzC,KACX,IAAK,MAAMhhB,KAAWghB,EACpB90C,EAAS0B,OAAOoyB,GAElB,IAAK,MAAMZ,KAASzxB,EAClBzB,EAASyB,IAAIyxB,UCvJNupB,GAAkCnnD,OAAO,aC9BzConD,GAAgD,CAC3DC,SAAU,KACVC,UAAW/nD,YAMGgoD,GACZC,EACAC,EACAC,EACAL,EACAr5B,GAKF,YAHiBtlB,IAAb2+C,IACFA,EAAWK,EAAMF,EAASx5B,IAErB,CACLq5B,SAAAA,EACAC,UAActkD,GACLukD,GACHvkD,EACAykD,EACAC,OACAh/C,EACA8+C,GAGNG,SAAS3kD,GACAukD,GACHvkD,EACAykD,EACAC,EACCF,EAAQI,OAAOH,IAAuCC,EAAM1kD,cASvD6kD,GACZL,EACAC,EACAJ,EAA4B,MAE9B,OAAOE,GAAoBC,EAASC,EAAWhoD,EAAc,MAAO4nD,YAMtDS,GAAwBT,GACtC,MAAO,CACLA,SAAAA,EACAhmD,YACE,OAAOyB,aCvCAilD,OAAoD/xC,GAC7D,2CACA,QACA,iBAMEgyC,GAA2D,CAE/DC,QAAO,IACEH,GAAcnxC,OAQZuxC,GAAqB,CAEhCf,IAAKA,MACH,OAAOa,IAUTn7C,GAAUwI,IACD,CACL8yC,YACIP,GAEKA,IAAWI,GACZF,GAAczyC,QACd3M,KC3CR0/C,GAAyD,CAE7DH,QAAO,IACEH,GAAc7qC,KAQZorC,GAAoB,CAE/BlB,IAAKA,MACH,OAAOiB,IAUTv7C,GAAU6Y,IACD,CACLyiC,YACIP,GAEKA,IAAWQ,GACZN,GAAcpiC,QACdhd,cCgLE4/C,GACZC,KACGC,GAOL,IAAKD,EACH,OAAOE,GAGT,MAAMC,EAAYC,GAAYJ,GAE9B,IAAKC,EAAW7lD,OACd,OAAO+lD,EAGT,MAAME,EAAmBrmD,EACrBimD,EACAG,IAGJ,MAAO,CACH9/C,EACAgE,KAGF,MAAMg8C,EAAaH,EAAU7/C,EAAMgE,GAa7Bs7C,EAAgCrmD,EAZlBO,EAA4C,CAC5D,CAACwmD,GACD3mD,EACIK,EACIqmD,EACAE,GAAOA,EAAIjgD,EAAMgE,IAErBrN,KAOJ,CAACyK,EAAwB8+C,IAAyCA,EAAGZ,YAC9DP,GAAU39C,EAAK29C,IAAWmB,EAAGZ,YAAaP,GAC3C39C,EACN1K,GAGJ,OAAoBypD,GAAqBH,GAChC,CACLV,YAAAA,GAIG,CACLzhD,IAAKmiD,EAAWniD,IAAII,KAAK+hD,GACzBjpD,IAAKipD,EAAWjpD,IAAIkH,KAAK+hD,GACzBV,YAAAA,aAcUc,GACZC,GAEF,OAAOA,GAKW5pD,EAJc4pD,EAKzBtgD,MAAMqJ,QAAQ3S,GALuBgpD,MAAmBY,GAAWZ,GAAgBY,IACpFZ,KAGR,IAAoBhpD,EAOpB,MAAM6pD,GAAuD,CAC3D9nD,iBAQF,SAASonD,KACP,OAAOU,YAYOH,GACZH,GAEF,OAASA,EAAmBniD,IAwB9B,SAASiiD,GACLD,GAEF,MAA4B,mBAAdA,EAA2BA,EAAYjpD,EAAmBipD,SCvVpDU,WAAyBz1C,GAA/CtS,kCAKmByB,cAAW,IAAIqD,IA8BhC9E,OACIomD,GAEF,OAAO3kD,KAAKumD,QAAQ5B,EAAUN,KAAmBE,SA2BnDhmD,MACIioD,EACAC,EAIYhqD,GAOd,OAoFK4nD,MAzFWmC,EACdC,EAAYzmD,KAAK8kD,OAAO0B,GAAmBxmD,MAE3CwmD,EAAiBxmD,MAEZA,KAiCTzB,QACIsD,KACG6kD,GAEL,OAAO,IAAIC,GAAY3mD,KAAMwlD,GAAgB3jD,KAAO6kD,IAMtDnoD,QACIumD,GAGF,MAAMh6C,EAAW9K,KAAK4mD,SAAS9pD,IAAIgoD,GAEnC,GAAIh6C,EACF,OAAOA,EAGT,MAAM+7C,EAAU7mD,KAAK8mD,aAAahC,IAAWA,EAAOK,QAAQnlD,MAI5D,OAFAA,KAAK4mD,SAAShjD,IAAIkhD,EAAQ+B,GAEnBA,EAaCtoD,aACNgoD,KA8BN,MAAMI,WAA8BL,GAUlC/nD,YAAY4X,EAAsBtU,GAChCf,QARed,SAAM,IAAI8N,GASzB9N,KAAK+mD,QAAUr/C,IAAcH,MAAM4O,GAEnC,IACI6wC,EADA3gC,EAAU,EAGd,MAAM0/B,EAAalkD,EAAGsU,EAAKnW,MAC3B,IAAI4D,EACA9G,EACAmqD,EAIAf,GAAqBH,IACvBniD,EAAMrH,EACNO,EAAMP,EACN0qD,EAAmEnC,IAEjE,MAAM13C,EAAuC+I,EAAIowC,QAAQzB,GAEzD,OAAO13C,EAASy3C,SAAWz3C,EAASy3C,SAAS7kD,MAAQoN,EAASo3C,UAAUxkD,SAG1E4D,EAAMmiD,EAAWniD,IACjB9G,EAAMipD,EAAWjpD,IACjBmqD,EAAmEnC,GAEpB3uC,EAAIowC,QAAQzB,GAEzCN,UAAUxkD,OAI9BA,KAAK8mD,aAAehC,UAAU,iBAAAiB,EAAWV,uCAAXU,EAAyBjB,KAAWmC,EAAcnC,IAChF9kD,KAAKyR,IAAMC,GAAW,CAAC9N,EAAIuS,EAAIjF,IAAK,IACpC5J,EAActH,KAAKyR,KAAKlK,MAAMvH,KAAK+mD,SACnC/mD,KAAKyR,IAAIpH,GAAG,EAAEkF,IAAYC,MACpBD,IAAaC,GACfxP,KAAK6L,IAAIzD,KAAKmH,EAAUC,KAEzB9D,KAAK1L,KAAK6L,KACbsK,EAAI9L,GAAG7N,IACDA,IAAUwqD,IACZhnD,KAAKyR,IAAIP,GAAK,CAACtN,EAAIpH,KAAU6pB,MAE9B3a,KAAK1L,MACRA,KAAKyR,IAAIpH,GAAG,EAAE7N,EAAOurB,MACnB,GAAIA,IAAQ1B,EAAS,CACnBA,EAAU0B,EACVi/B,EAAWlqD,EAAIN,GACf,IACE2Z,EAAIjF,GAAK81C,UAETA,OAAWphD,MAMnBgB,IAAKA,KACH,OAAO5G,KAAK+mD,QAGd71C,SACE,OAAOlR,KAAKyR,IAAIP,GAAG,GAGrBA,OAAO1U,GAEL,MAAO0qD,EAAWC,GAAWnnD,KAAKyR,IAAIP,GAElC1U,IAAU0qD,IACZlnD,KAAKyR,IAAIP,GAAK,CAAC1U,EAAO2qD,EAAU,IAMpC5oD,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAK6L,IAAIxB,KAAKyB,GAAGlE,IC9RvC,MAAMw/C,WAAkCd,GAItC/nD,YAA6B8oD,GAC3BvmD,QAD2Bd,cAAAqnD,EAI7BzgD,IAAKA,KACH,OAAO5G,KAAK+mD,UAAY/mD,KAAK+mD,QAAUr/C,IAAcH,MAAMvH,KAAKqnD,WAGlEn2C,SACE,OAAOlR,KAAKqnD,SAASn2C,GAGvBA,OAAO1U,GACLwD,KAAKqnD,SAASn2C,GAAK1U,EAKrB+B,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAKqnD,SAASh9C,KAAKyB,GAAGlE,UCjBtB0/C,WAAiChB,GAarD/nD,aACI6nD,QACEA,IAKJtlD,QACAd,KAAKunD,kBAAoBpB,GAAqBC,EAArBD,CDYpB,IAAIiB,GCZwDpnD,MAAOA,MAGhEzB,aACNumD,GAEF,OAAO9kD,KAAKunD,kBAAkBlC,YAAYP,IAAWhkD,MAAMgmD,aAAahC,ICrB5E,MAAM0C,GAAsE,CAC1ErC,QAAQT,GACCK,GAAmBL,EAAS+C,WAYjBA,WAA2BH,GAE/CjD,WAAYA,MACV,OAAOmD,GAQCjpD,aACNumD,GAEF,OAAOA,IAAW0C,GACZzC,GAAmB/kD,KAAMynD,GAAaznD,MACtCc,MAAMgmD,aAAahC,UAiDP4C,GA2BpBnpD,CAACgL,MACC,OAAOvJ,KAAKqK,KAqBd9L,CAACmI,KACC,OAAO1G,KAAK8Q,QC7HhB,MAAM62C,GAAyC,CAC7CxC,QAAQT,GACCM,GAAc,IAAI4C,GAAiBlD,WAgBxBmD,GAGpBxD,WAAYA,MACV,OAAOsD,GA2BTppD,CAACgL,MACC,OAAOvJ,KAAKqK,KAqBd9L,CAACmI,KACC,OAAO1G,KAAK8Q,QA0ChB,MAAM82C,WAAyBC,GAK7BtpD,YAA6B8oD,GAC3BvmD,QAD2Bd,cAAAqnD,EAHZrnD,UAAO,IAAIqD,IACXrD,SAAM,IAAI8N,GAIzBxG,EAActH,KAAK6L,KAAKtE,MAAMvH,KAAKqnD,UAGrC9oD,IAAIyM,GAEF,MAAM88C,EAAiB9nD,KAAK0tB,KAAK5wB,IAAIkO,GAErC,GAAI88C,EAEF,OAAOA,EAIT,MAAMhgD,EAASJ,EAAY,KACzB1H,KAAK0tB,KAAKpkB,OAAO0B,GACjBhL,KAAK6L,IAAIzD,KAAK,GAAI,CAAC4C,MAMrB,OAHAhL,KAAK0tB,KAAK9pB,IAAIoH,EAAOlD,GACrB9H,KAAK6L,IAAIzD,KAAK,CAAC4C,GAAQ,IAEhBlD,EACFP,MAAMvH,KAAKqnD,UACX9/C,MAAMyD,EAAMguB,QAKnBz6B,GACIqJ,GAEF,OAAQ5H,KAAKqK,GAAKrK,KAAK6L,IAAIxB,KAAKyB,GAAGlE,GAKrCrJ,KAAKqJ,GAEH,MAAMmgD,EAAa,IAAyC/nD,KAAK0tB,KAAKptB,OAEtE,OAAQN,KAAK8Q,KAAOzD,GAChBrN,KAAKqK,KAAKG,KAAKu9C,GACf,IAAM,CAACA,MACTj8C,GAAGlE,ICjLT,MAAMogD,GAAgE,CACpE7C,QAAQT,GACCK,GAAmBL,EAASuD,WAajBA,WAA4CX,GAYhEjD,WAAYA,MACV,OAAO2D,GAmBCzpD,aACNumD,GAEF,OAAOA,IAAiCkD,GAClCjD,GACE/kD,KACAioD,GACAjoD,MAEFc,MAAMgmD,aAAahC,IC9B7B,MAAMoD,GAAmC,CAEvC/C,QAAeT,GACND,GACHC,EACAyD,GACAC,GAAQ,IAAIC,GAAcD,WAuBZD,GAEpB9D,WAAYA,MACV,OAAO6D,GAyBT3pD,CAACgL,MACC,OAAOvJ,KAAKqK,KAqBd9L,CAACmI,KACC,OAAO1G,KAAK8Q,OAedvS,eAAe8zB,GACb,MAAgB,QAATA,GAA8B,MAAZA,EAAK,GAsBhC9zB,KAAKyI,GAEH,OADAhH,KAAKgd,IAAIle,KAAKkI,GACPhH,MAiCX,MAAMsoD,WAAuBz3C,GAI3BtS,YAAYI,GACVmC,QACAd,KAAKwQ,SAAWkB,GAAW/S,EAkK/B,SAAuBA,GACrB,OAA2C,MAApCA,EAAQswB,aAAa,YACtB,MACsC,MAApCtwB,EAAQswB,aAAa,YAAsB,KAAO,KArKnBs5B,CAAc5pD,EAAQA,SAAW,MAGxEiI,IAAKA,KACH,OAAOU,EAActH,KAAKwQ,UAG5BU,SACE,OAAOlR,KAAKwQ,SAASU,GAGvBA,OAAO1U,GACL,OAAQA,GACR,IAAK,MACL,IAAK,KACL,IAAK,MACL,IAAK,MACH,MACF,QACEA,EAAQ,KAGVwD,KAAKwQ,SAASU,GAAK1U,EAKrB+B,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAKwQ,SAASnG,KAAKyB,GAAGlE,IAQ5C,MAAM4gD,GAMJjqD,cAHiByB,UAAO,IAAIkJ,IACXlJ,SAAM,IAAI8N,GAIzB,MAAML,EAAyDJ,GAC3DrN,KAAK6L,IAAIxB,KAAKG,KAAK,IAAMxK,KAAK6+C,MAC9B9hD,EAAeiD,KAAK6+C,OAGxB7+C,KAAK8Q,KAAOrD,EAAQqI,SACflS,GAAyCgK,GAAeF,MAAa9J,IACtE6kD,IAINlqD,IAAIc,GAEF,MAAMyI,EAASJ,EAAY,KACzB1H,KAAK6+C,KAAKv1C,OAAOjK,GACjBW,KAAK6L,IAAIzD,SAMX,OAHApI,KAAK6+C,KAAKx1C,IAAIhK,GACdW,KAAK6L,IAAIzD,OAEFN,GAQX,MAAMugD,WAAsBF,GAK1B5pD,YAA6B8oD,GAC3BvmD,QAD2Bd,cAAAqnD,EAFZrnD,cAAW,IAAIwoD,GAK9B,MAAM7pD,EAAU0oD,EAASvC,OAAOmD,IAEhCjoD,KAAKgd,IAAM,IAAIsrC,GAAe3pD,GAC9B2I,EAActH,KAAKgd,KAAKzV,MAAM8/C,GAC9BrnD,KAAK0oD,OAAOrB,EAASvC,OAAO6D,IAAiB73C,OAAO3D,UAAUy7C,KAC1DjqD,GACFqB,KAAK8Q,KAAKtU,GAqFhB,SAAqBmC,EAAsBnC,GACzC,OAAQA,GACR,IAAK,MACHmC,EAAQgxB,aAAa,WAAY,IACjC,MACF,IAAK,KACL,IAAK,MAEHhxB,EAAQgxB,aAAa,WAAY,IACjChxB,EAAQixB,gBAAgB,YACxBjxB,EAAQgxB,aAAa,WAAY,IACjC,MACF,QAEEhxB,EAAQgxB,aAAa,WAAY,IACjChxB,EAAQixB,gBAAgB,YAExBjxB,EAAQgxB,aAAa,WAAY,IACjChxB,EAAQixB,gBAAgB,aAvGHi5B,CAAYlqD,EAAQA,QAASnC,IAMpD+B,KAAKqJ,GAEH,IAAIiN,EAAqB,KAEzB,OAAQ7U,KAAK8Q,KAAOzD,GACZG,GAAS,CACPs7C,QAAS9oD,KAAK+oD,SAASj4C,KACvBkM,IAAKhd,KAAKgd,MACTxS,KACC,EACEs+C,SAAUA,GACV9rC,KAAMA,OAGN,IAAIne,EAEJ,GAAY,QAARme,GAA6B,QAAZ8rC,EACnBjqD,EAAO,UACF,CAEL,IAAIiI,GAAM,EAEK,MAAXkW,EAAI,KACNlW,GAAM,EACNkW,EAAMA,EAAIoR,UAAU,IAEH,MAAf06B,EAAQ,KACVhiD,GAAM,EACNgiD,EAAUA,EAAQ16B,UAAU,IAE9BvvB,EAAmB,OAAZiqD,EAAmB,KAAO9rC,EAC7BlW,IACFjI,EAAO,IAAMA,GAIjB,OAAOgW,IAAShW,EAAOf,IAAaH,EAASkX,EAAOhW,KAG1D9B,EAA+B8X,IACjC/I,GACJlE,GAKJrJ,GAAGqJ,GACD,IAAIohD,EAA2B,KAE/B,OAAQhpD,KAAKqK,GAAKrK,KAAK8Q,OAAOtG,KAAKhO,IAEjC,MAAMoV,EAAMo3C,EAEZ,OAAOp3C,IAAQpV,EAAQsB,IAAaH,EAASqrD,EAAaxsD,EAAOoV,KAChE9F,GAAGlE,GAGRrJ,OAAOc,GACL,OAAOW,KAAK+oD,SAAS1/C,IACjBiE,GAAc3G,EAActH,GAAUA,EAASA,EAAOW,KAAKqnD,WACtD97C,QAAQvL,KAAKqnD,WACpB9/C,MAAMvH,KAAKqnD,WA2CjB,SAASuB,GAAcK,GAErB,MAAMC,EAAapjD,MAAMC,KAAKkjD,GAE9B,OAAKC,EAAWrpD,OAMT+N,GAAeF,MAFFw7C,EAAWjnD,IAAI,EAAG+2B,OAAAA,KAAaA,EAAO8rB,OAAOqD,MAEjBh7C,UAAUs7C,KALjD9qD,EAAS,MAQpB,SAAS8qD,MAAgBU,GACvB,mBAW6BA,GAE7B,IAAIC,GAAK,EACLtiD,GAAM,EAEV,IAAK,MAAMurB,KAAQ82B,EACjB,OAAQ92B,GACR,IAAK,MACH,MAAO,MACT,IAAK,KACH+2B,GAAK,EACL,MACF,IAAK,MACHtiD,GAAM,EACN,MACF,IAAK,MACHA,GAAM,EACNsiD,GAAK,EAMT,OAAOtiD,EAAOsiD,EAAK,MAAQ,MAAUA,EAAK,KAAO,KAlC1CC,IAAe9pD,EAAwB4pD,IC5XhD,MAAMG,GAAyB,CAE7BnE,QAAeT,GAEND,GAAoBC,EAAS6E,GAAYnB,GAAuB56C,GAAS,CAC9EhR,MAAO4rD,EACP/1B,KAAM+1B,EAAKtD,OAAOqD,MACjBryC,SACC,EAAGtZ,OAAQA,GAAQ61B,MAAOA,MAAY81B,GAAOqB,QAAQn3B,GAC/C10B,EAASnB,GACTmB,OAwBD4rD,GAAS,CAEpBlF,IAAKA,MACH,OAAOiF,KC5BLG,GAA0D,CAC9DtE,QAAQT,GACCK,GAAmBL,EAASgF,WAiBjBA,WAAsCjC,GAE1DpD,WAAYA,MACV,OAAOoF,GAQClrD,aACNumD,GAEF,OAAOA,IAAW2E,GACZ1E,GAAmB/kD,KAAM0pD,GAAS1pD,MAClCc,MAAMgmD,aAAahC,UAuDP6E,WACVjC,GAqCVnpD,OAAOkC,GACLT,KAAK4D,IAAInD,OAAKmF,IA0BlB,MAAMgkD,GAA0B,GAKhC,MAAMC,GAEJtrD,YAA6BmvB,GAAA1tB,UAAA0tB,EAG7BnvB,IAA2BkC,GAEzB,MAAMuK,EAAQhL,KAAK0tB,KAAK5wB,IAAI2D,GAE5B,OAAOuK,GAASA,EAAM,GAGxBzM,CAACrB,OAAOgB,YACN,OAAOC,EAAYsB,EAAMO,KAAK0tB,KAAK1wB,SAAU,EAAE0nD,KAAaA,IAG9DnmD,UACE,OAAOJ,EAAYsB,EAAMO,KAAK0tB,KAAKmU,UAAW,EAAEphC,GAAMikD,MAAc,CAACjkD,EAAKikD,MAQ9E,MAAMoF,GAMJvrD,YAA6BwrD,GAAA/pD,eAAA+pD,EAJpB/pD,aAAU0H,IACX1H,UAAO,IAAIqD,IAMnB9E,IACIkC,EACAikD,EACA5pB,EACAY,GAGF,MAAMsuB,EAAWhqD,KAAK0tB,KAAK5wB,IAAI2D,GAC/B,IAAIqH,EAEJ,GAAI48C,EAAS,CACX58C,EAASJ,IAET,MAAMsD,EAAQhL,KAAK+/B,SAASt/B,EAAKikD,EAAS58C,GAE1C,IAAIk2C,GAAa,EAEbgM,IACEA,EAAS,KAAOtF,EAElB1G,GAAa,EAEbtiB,EAAQx2B,KAAK,CAACzE,EAAKupD,KAInBhM,GACFh+C,KAAKiqD,SAASrmD,IAAInD,EAAKuK,GACvB8vB,EAAM51B,KAAK,CAACzE,EAAKuK,KAEjBhL,KAAK0tB,KAAK9pB,IAAInD,EAAKuK,QAGrBlD,EAAS6B,KACLqgD,IACFtuB,EAAQx2B,KAAK,CAACzE,EAAKupD,IACnBhqD,KAAKiqD,SAAS3gD,OAAO7I,IAOzB,OAJIupD,GACFA,EAAS,GAAGljD,IAAI8iD,IAGX9hD,EAGDvJ,SACJkC,EACAikD,EACA58C,GAEF,MAAO,CACL48C,EACAh9C,EAAYV,IACNA,IAAW4iD,IACb5pD,KAAK+pD,UAAUrN,OAAOj8C,KAGrB8G,MAAMvH,KAAK+mD,SACXx/C,MAAMO,GACNN,QACGR,GAAUc,EAAOhB,IAAIE,IAAW4iD,QAA0BhkD,EAAYoB,KAK1EzI,SACN,GAAIyB,KAAKkqD,MAAO,CAEd,MAAMjoD,EAAM,IAAIoB,IAEhB5E,EAAQuB,KAAK0tB,KAAKmU,UAAW,EAAE8P,EAAGvlC,KAAOnK,EAAI2B,IAAI+tC,EAAGvlC,IACpDpM,KAAKkqD,WAAQtkD,EACb5F,KAAK0tB,KAAOzrB,EAGd,OAAOjC,KAAK0tB,KAGdnvB,WACE,OAAOyB,KAAKkqD,QAAUlqD,KAAKkqD,MAAQ,IAAIL,GAAuB7pD,KAAK0tB,OAGrEnvB,QAEE,MAAMu8B,EAAuC,GACvCY,EAAyC,GAI/C,OAFAj9B,EAAQuB,KAAK0tB,KAAKptB,OAAQG,GAAOT,KAAK4D,IAAInD,OAAKmF,EAAWk1B,EAAOY,IAE1DA,GAQX,MAAMyuB,WAAqDR,GAKzDprD,YAA6B6rD,GAC3BtpD,QAD2Bd,YAAAoqD,EAFZpqD,cAAW,IAAI8N,GA4B9B9N,KAAK0tB,KAAO,IAAIo8B,GAAkB9pD,MAClCA,KAAK0tB,KAAKq5B,QAAQx/C,MAAM6iD,EAAOt5C,KAxBDu5C,IAC5BrqD,KAAK8Q,OAAOjH,KAAKygD,IAEf,MAAMC,EAAa,IAAIrhD,IAEvBzK,EAAQ4B,EAAYgqD,GAAQ,EAAE5pD,EAAKjE,MACjC+tD,EAAWlhD,IAAI5I,GAEf,MAAMikD,EAAU4F,EAASxtD,IAAI2D,GAEzBikD,IACFA,EAAQxzC,GAAK1U,KAIjBiC,EAAQ6rD,EAASzoB,UAAW,EAAEphC,EAAKikD,MAC5B6F,EAAWzsC,IAAIrd,KAClBikD,EAAQxzC,QAAKtL,UAYvBrH,GACIqJ,GAEF,OAAQ5H,KAAKqK,GAAKrK,KAAKy8B,SAASpyB,KAAKG,KACjC,CAACswB,EAAOY,IAAY/9B,EAChBm9B,EAAM74B,IAAIuoD,IACV9uB,EAAQz5B,IAAIuoD,MAElB1+C,GAAGlE,GAKPrJ,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAOzD,GAChBrN,KAAKy8B,SAASpyB,KAAKG,KACf,IAAMxK,KAAK0tB,KAAK48B,YAEpB,IAAM,CAACtqD,KAAK0tB,KAAK48B,aACnBx+C,GAAGlE,GAGPrJ,IACIksD,EACAC,GAGF,MAAMC,EAAQ3qD,KAAKoqD,OACbtvB,EAAuC,GACvCY,EAAyC,GAC/C,IAAI5zB,EAiBJ,MAf6B,iBAAlB2iD,GACT3iD,EAASJ,IACTjJ,EAAQ4B,EAAYoqD,GAAgB,EAAEhqD,EAAKjE,MACzCwD,KAAK0tB,KAAK9pB,IAAInD,EAAKjE,EAAOs+B,EAAOY,GAASn0B,MAAMO,MAGlDA,EAAS9H,KAAK0tB,KAAK9pB,IAAI6mD,EAAeC,EAAY5vB,EAAOY,IAEvDZ,EAAMj7B,QAAU67B,EAAQ77B,UAC1BG,KAAKy8B,SAASr0B,KAAK0yB,EAAOY,GACtBZ,EAAMj7B,QAOZ,WAEE,IAAI+qD,EAEJ9vB,EAAMvwB,QAAQ,EAAE9J,GAAMikD,EAAS58C,OAC7B48C,EAAQI,OAAO+C,IACVx+C,IAAI,CAAE2vB,OAAQ2xB,IACdpjD,MAAMO,GACN4D,KAAK5D,GAEV,MAAMtL,EAAQkoD,EAAQxzC,GAEtB,GAAI05C,EACFA,EAASnqD,GAAOjE,MACX,CAEL,MAAM6tD,EAAQM,EAAMz5C,GAEhBm5C,EAAM5pD,KAASjE,IACjBouD,iCAAgBP,IAAO9rD,CAACkC,GAAMjE,QAKhCouD,IACFD,EAAMz5C,GAAK05C,GAGb9vB,EAAMvwB,QAAQ,EAAE9J,GAAMikD,EAAS58C,OAC7B48C,EAAQ5zC,OAAOvF,QAAQzD,GAAQiC,GAAGvN,IAC5BmuD,EAAMz5C,GAAGzQ,KAASjE,IACpBmuD,EAAMz5C,kCACDy5C,EAAMz5C,KACT3S,CAACkC,GAAMjE,OAGVkP,KAAK5D,KA1CR+iD,IAIG/iD,EA2CTvJ,QAEE,MAAMm9B,EAAU17B,KAAK0tB,KAAKvkB,QAEtBuyB,EAAQ77B,QACVG,KAAKy8B,SAASr0B,KAAK,GAAIszB,IAS7B,SAAS8uB,IACJ/pD,GAAMikD,KAET,MAAO,CAACjkD,EAAKikD,GAMf,MAAMoG,WAA6CpB,GAKjDnrD,YACI8rD,EACArpD,GAIFF,MAAME,GACNhB,KAAK+qD,OAASr5C,GAAW24C,GACzBrqD,KAAKgrD,SAAW,IAAIb,GAAuBnqD,MAC3CsH,EAActH,MAAMwH,QAAQ,IAAMxH,KAAKgrD,SAAS7hD,SAGlDvC,IAAKA,KACH,OAAOU,EAActH,KAAK+qD,QAG5B75C,SACE,OAAOlR,KAAK+qD,OAAO75C,GAGrBA,OAAO1U,GACLwD,KAAK+qD,OAAO75C,GAAK1U,EAKnB+B,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAK+qD,OAAO1gD,KAAKyB,GAAGlE,GAG9BrJ,aACNumD,GAEF,OAAIA,IAAWyE,GAAOlF,IACb,CACLE,UAYmCoG,EAZb3qD,KAarBwN,GAAS,CACdy9C,GAAIN,EAAMK,SACVX,MAAOM,EACPt4B,KAAMs4B,EAAM7F,OAAOqD,MAClBh7C,UACC+9C,KAjBE1G,UAAW/nD,GAGRqE,MAAMgmD,aAAahC,GAQ9B,IAA2C6F,GAa3C,SAASO,IAEHD,IAAKD,GACLX,OAAQA,GACRh4B,MAAOA,KAOX,IAAK81B,GAAOqB,QAAQn3B,GAClB,OAAO10B,IAGT,MAAMwtD,EAAgD,GAMtD,OAJA1sD,EAAQusD,EAASnpB,UAAW,EAAEphC,EAAKikD,MACjCyG,EAAO1qD,GAAsBikD,EAAQI,OAAOyE,MAGvC37C,GAAeJ,GAAS29C,GAAQr1C,SAASs1C,IAE9C,MAAM/sB,mBAA4BgsB,GAMlC,OAJA5rD,EAAQ4B,EAAY+qD,GAAe,EAAE3qD,GAAM4qD,OACzChtB,EAAK59B,GAAO4qD,IAGP7tD,EAAQ6gC,eAeHitB,GACZjB,GACAjE,QACEA,GAGE,IAEN,OAAO,IAAI0E,GAAeT,EAAO,CAAEjE,QAAAA,IC5kBrC,MAAMmF,GAAiC59C,cAOvB69C,KACd,OAAOD,YC6COE,GACZC,GAEF,OAAI/kD,EAAc+kD,GACT/uD,EAAc2Q,GAAco+C,IAEZ,mBAAdA,EACFhH,GAAWp3C,GAAco+C,EAAUhH,IAErCA,GAAWA,EAAQ5zC,OAAOgF,SAMnC,SACI4uC,EACAgH,GAEF,MAAO,KAEL,MAAMn0C,EAAWm0C,EAAUC,SAASjH,GAEpC,OAAmB,MAAZntC,EACD5Z,IACAmI,MAAMqJ,QAAQoI,GACV5Z,KAAY4Z,GACZ5Z,EAAS4Z,IAlBqBq0C,CAAkBlH,EAASgH,ICvDvE,MAAMG,GAAa,SAKNC,GAKXvtD,YAAYmmD,GAEV,MAAMp1C,EAAU,IAAIxB,GACdi+C,EAAa,IAAI1oD,IACjB2oD,EAAoB,IAAI3oD,IAE9B,IAAI+E,EAAmB3L,EAEnBkvD,EAAkGlvD,EAEtGuD,KAAKisD,UAAY/+C,GAAatF,IAG5B,MAAMskD,EAAe5+C,GAAcgC,EAASvS,KAAkBgN,GAAGnC,GAAUJ,QAAQ,KACjFY,EAAO3L,EACPkvD,EAAWlvD,IAIbkvD,EAAW,CAACD,EAA+CS,KAEzD,MAAMrkD,EAAS4jD,EAAU3hD,GACrB,IAAIwN,KACF,GAAIA,EAAS1X,OAEXmsD,EAAkBpoD,IAAI8nD,EAAWn0C,QAC5B,IAAKy0C,EAAkB1iD,OAAOoiD,GAEnC,OAEFtjD,MAGDb,MAAM4kD,GACN3kD,QAAQR,IACHA,IAAW6kD,IACbM,EAAgBrlD,IAAIE,GAElBglD,EAAkB1iD,OAAOoiD,IAE3BtjD,MAIR8jD,EAAa1kD,QAAQ,IAAMM,EAAOhB,IAAI+kD,MAIxCptD,EAAQstD,EAAWlqB,UAAW,EAAE6pB,EAAWS,KAAqBR,EAASD,EAAWS,IAGpF/jD,EAAO,KACLkH,EAAQlH,QAuBH7I,EAAUysD,EAAkBhvD,SAAUT,KAnBzCyvD,EAAkB5iD,MACpBhB,MAED4B,QAAQuB,QAAQm5C,GAEnB1kD,KAAK+F,KAAO2lD,IAEV,MAAMrsD,EAASosD,GAAYC,EAAZD,CAAuB/G,GAChCyH,EAAkBzkD,EAAY,KAClCqkD,EAAWziD,OAAOjK,KAMpB,OAHA0sD,EAAWnoD,IAAIvE,EAAQ8sD,GACvBR,EAAStsD,EAAQ8sD,GAEVA,EAAgB5kD,MAAMm9C,IAQjCnmD,CAACmI,KACC,OAAO1G,KAAKisD,WC9EhB,MAAMG,GAAkE,CACtEjH,QAAeT,GACND,GACHC,EACA2H,GACA,CAAIjE,EAAoBl9B,KAEtB,MAAMohC,EAAa,IAAIC,GAAuBnE,GAE9C,GAAIl9B,EAAQ,CAEV,MAAMnlB,EAAOmlB,EAAO45B,OAAOuH,IAE3BC,EAAWzqD,GAAGkE,EAAK+K,OAAOgF,SAASzY,GAAUM,KAAYN,EAAOka,cAGlE,OAAO+0C,WAoBKD,GAKpBhI,WAAYA,MACV,OAAO+H,GAqBT7tD,CAACmI,KACC,OAAO1G,KAAK8Q,QAiJhB,MAAM07C,GAA4C,CAChDhlB,SACE,OAAO,GAETjwB,SAAQ,IACC,GAETuG,IAAG,KACM,EAET2uC,OAAM,KACG,EAETluD,CAACrB,OAAOgB,UAAS,IACR,GAAGhB,OAAOgB,aAOrB,MAAMwuD,GAKJnuD,YAAYgZ,GAFKvX,aAAU,IAAIqD,IAG7BrD,KAAK6+C,KAAO,GACZpgD,EACI8Y,EACAhW,IAEE,IAAIorD,GAAW,EAEfluD,EAAQ4B,EAAYkB,GAAU,EAAEqrD,EAAMC,MACpC,GAAIA,EAAa,CACfF,GAAW,EAEX,MAAMxlD,EAAOnH,KAAK8sD,QAAQhwD,IAAI8vD,GAE1BzlD,EACFA,EAAKjC,KAAK3D,GAEVvB,KAAK8sD,QAAQlpD,IAAIgpD,EAAM,CAACrrD,OAM1BorD,GACF3sD,KAAK6+C,KAAK35C,KAAK3D,KAMzBimC,SACE,OAAQxnC,KAAK6+C,KAAKh/C,OAGpBtB,SAASquD,GACP,OAAe,MAARA,EAAe5sD,KAAK6+C,KAAO7+C,KAAK8sD,QAAQhwD,IAAI8vD,IAAS,GAG9DruD,IAAIquD,GACF,OAAe,MAARA,GAAgB5sD,KAAK8sD,QAAQhvC,IAAI8uC,GAG1CruD,UAAUwuD,GACR,OAAO/sD,KAAK6+C,KAAKmO,KACbzrD,GAAWwrD,EAAM7nB,MAAM0nB,IAASrrD,EAAQqrD,KAI9CruD,CAACrB,OAAOgB,YACN,OAAO8B,KAAK6+C,KAAK3hD,OAAOgB,sBAsBZ+uD,MAAsB11C,GACpC,OAAOA,EAAS1X,OAAS,IAAI6sD,GAAmBn1C,GAAYi1C,GAM9D,MAAMD,WAAmCF,GAIvC9tD,YAAYmmD,GACV5jD,QACAd,KAAKisD,UAAY,IAAIH,GAAqBpH,GAE1C,MAAMpzC,EAAYozC,EAAQI,OAAO2C,IAG7Bn2C,GACFtR,KAAKisD,UAAUlmD,KAoBrB,SAAoCuL,GAClC,OAAOA,EAAU05C,SAASl6C,OAAOgF,SAC7Bo3C,GACAC,IAvBoBC,CAA2B97C,IAKnD/S,MAAMwtD,GACJ,OAAO/rD,KAAKisD,UAAUlmD,iBCtVWgmD,GAEnC,MAAMsB,EAAgBtB,EAAWlsD,OAEjC,OAAsB,IAAlBwtD,EACKtB,EAAW,GAEfsB,EAIG3I,IAEN,MAAMntC,EAAW,IAAIu0C,GAAqBpH,GAI1C,OAFAqH,EAAWxhD,QAAQmhD,GAAan0C,EAASxR,KAAK2lD,IAEvCn0C,GATAi0C,GD8UoB8B,IAAcvB,IAK3CxtD,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAOxD,GAActN,KAAKisD,WAAWn2C,SAASm3C,IAAoBnhD,GAAGlE,IAkBtF,SAASslD,GACLlC,GAEF,OAAOp9C,GAAeF,MAAajO,EAAMurD,EAAUtG,GAAWA,EAAQI,OAAOuH,OAM/E,SAASc,MACFI,GAEL,OAAO5vD,KACA4B,EAAUE,EAAM8tD,EAASlwD,GAAUA,EAAO,eElXnCmwD,GACZ9I,GAEF,OAAOA,EACDA,EAAQ5zC,OAAOgF,SAAStZ,GAASA,EAAQmB,IAAa,CAAE8vD,QAAS,YACjED,SCLKE,WAA0DzF,GAkBrE1pD,YACaI,GACTynD,QACEA,EAAOtpD,IACPA,EAAG8G,IACHA,IAOJ9C,MAAM,CAAEslD,QAAAA,IAXGpmD,aAAArB,EAdIqB,YAAwD,IAAI8N,GA2B3E,MAAMsuB,EAAOp8B,KAEbA,KAAKy+C,KAAO3hD,EACZkD,KAAK2tD,KAAO/pD,EACZ5D,KAAK8kC,OAAS9kC,KAAKkR,GAEnB,MAAM08C,EAAW5tD,KAAKm8B,QAAU,CAAC3/B,EAAcgT,IAA0Be,EAAO,CAAE/T,MAAAA,GAASgT,GAM3F,SAASe,EAAO4iB,EAA+B3jB,GAC7C,OAAS,CAKP,IAAIq+C,EAJJzxB,EAAK0I,OAAS3R,EAAM32B,MAOpB4/B,EAAKD,QAAU,CAAC5sB,EAAiBqC,KAE/Bi8C,EAAa,gCAAM16B,IAAO32B,MAAO+S,IAAYqC,IAE/C,IACEwqB,EAAK0xB,OAAO1lD,KAAK+qB,EAAO3jB,WAExB4sB,EAAKD,QAAUyxB,EAGjB,IAAKC,EACH,OAKD16B,EAAO3jB,GAAYq+C,GA7BxB7tD,KAAK+tD,OAAS,IAAI94C,GAAmBtW,GACrC2I,EAActH,KAAK+tD,QAAQxmD,MAAMvH,MACjCA,KAAKguD,eAAe76B,GAAS5iB,EAAO4iB,EAAOnzB,KAAK8kC,SAgClDl+B,IAAKA,KACH,OAAOU,EAActH,KAAK8tD,QAG5B58C,SACE,OAAOlR,KAAKy+C,OAGdvtC,OAAO1U,GAEL,MAAMgT,EAAWxP,KAAKkR,GAElB1U,IAAUgT,IACZxP,KAAK2tD,KAAKnxD,GACVwD,KAAKm8B,QAAQn8B,KAAKy+C,OAAQjvC,IAM9BjR,MAAMqJ,GACJ,OAAQ5H,KAAKmzB,MAAQ9lB,GACjBrN,KAAK8tD,OAAOzjD,KAAKG,KAAKjO,GACtB,IAAM,CAAC,CAAEC,MAAOwD,KAAKkR,MACvBpF,GAAGlE,GAKPrJ,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAK8tD,OAAOzjD,KAAKG,KAC/B,EAAGhO,MAAO+S,GAAYC,IAAaD,IAAaC,EAAW1R,IAAaH,EAAS4R,EAAUC,IAC7F1D,GAAGlE,GAWGrJ,eAAegS,GAEvB,MAAM09C,EAAWjmD,GAAuBuI,EAAO,CAAE/T,MAAOwD,KAAKkR,GAAIlJ,MAAAA,IAEjEhI,KAAK+tD,OAAO1jD,GAAG,SAASN,GAAGkkD,GAC3BjuD,KAAK+tD,OAAO1jD,GAAG,UAAUN,GAAGkkD,aC5GhBC,GACZvvD,GACAynD,QACEA,GAGE,IAEN,OAAO,IAAIsH,GACP/uD,EACA,CACEJ,MACE,OAAOyB,KAAKrB,QAAQnC,OAEtB+B,IAAI/B,GACFwD,KAAKrB,QAAQnC,MAAQA,GAEvB4pD,QAAAA,ICnCR,MAAM+H,GAA4C,CAEhDhJ,QAAeT,GACND,GAAoBC,EAAS0J,GAAShG,IAE3C,MAAMzpD,EAAUypD,EAAKtD,OAAOmD,IAE5B,OAAOtpD,GAAW,IAAI0vD,GAAe1vD,YAarByvD,WAAgBv9C,GAEpCwzC,WAAYA,MACV,OAAO8J,IAQX,MAAME,WAAuBD,GAI3B7vD,YAAY+vD,GACVxtD,QAEA,MAAMnC,QAAEA,EAAOovD,OAAEA,GAAWO,EACtBC,EAAqC5vD,EAAQ6vD,YAC7C7vD,EAAQ6vD,cACR7vD,EAAQ0Y,cAEdrX,KAAKyR,IAAMC,KAAa68C,GAASA,EAAME,gBAAkB9vD,GACzD2I,EAActH,MAAMuH,MAAM+mD,GAE1BP,EAAO1jD,GAAG,SAASN,GAAG,IAAM/J,KAAKyR,IAAIP,IAAK,GAC1C68C,EAAO1jD,GAAG,QAAQN,GAAG,IAAM/J,KAAKyR,IAAIP,IAAK,GACzClR,KAAKqK,GAAG,CACN9L,QAAQgE,EAAKgN,GACXhN,EAAIyO,YAAYvU,GACZ8S,EACF5Q,EAAQ+vD,QAER/vD,EAAQgwD,UAMhB/nD,IAAKA,KACH,OAAOU,EAActH,KAAKyR,KAG5BP,SACE,OAAOlR,KAAKyR,IAAIP,GAGlBA,OAAO1U,GACLwD,KAAKyR,IAAIP,GAAK1U,EAKhB+B,GAAGqJ,GACD,OAAQ5H,KAAKqK,GAAKrK,KAAKyR,IAAIpH,KAAKyB,GAAGlE,ICpEvC,MAAMgnD,GAAuC,CAE3CzJ,QAAeT,GACND,GAAoBC,EAASmK,GAAUzG,IAE5C,MAAM92C,EAAY82C,EAAKtD,OAAO2C,IAE9B,OAAoB,MAAbn2C,EAAoB,IAAIw9C,GAAkBx9C,GAAa,IAAIy9C,GAAgB3G,YAiBlEyG,GAEpBxK,WAAYA,MACV,OAAOuK,GAqBTrwD,CAACmI,KACC,OAAO1G,KAAK8Q,QA8DhB,MAAMk+C,GAAuC,CAC3CC,UAAU,EACVC,SAAS,EACTC,QAAQ,GAMV,MAAMJ,WAAwBF,GAI5BtwD,YAAYmmD,GACV5jD,QAHed,YAAS0R,GAA2Bs9C,IAInD1nD,EAActH,KAAKovD,QAAQ7nD,MAAMm9C,GACjC1kD,KAAKovD,OAAOvtD,GAiDhB,SACIqpB,EACAw5B,GAGF,MAAM/lD,EAAU+lD,EAAQI,OAAOmD,IAG/B,OAAOz6C,GAAS,CACdyhD,SAHYvK,EAAQI,OAAOsJ,KAGRzgD,IAAS,GAC5BwhD,OAAQxwD,EAAUA,EAAQw0B,QAAQrd,SAAS,EAAG9N,MAAAA,OAAcA,GAAS2F,IAAS,KAC7EmI,SACC,EAAGm5C,UAAWA,GAAWE,QAASA,MAOxC,SAA6BE,EAAuBJ,EAAmBE,GAEnEE,EADEJ,iCACWI,IAAOJ,SAAAA,EAAUC,SAAS,mCAE1BG,IAAOJ,SAAAA,IAElBE,IACFE,iCAAaA,IAAOF,OAAAA,EAAQD,SAAS,KAEvC,OAAOG,EAhB6CC,CAAoBpkC,EAAOha,GAAI+9C,EAAUE,IA7D5EI,CAAqBvvD,KAAKovD,OAAQ1K,IAKnDnmD,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAO9Q,KAAKovD,OAAOt+C,OAAOhF,GAAGlE,GAG5CrJ,YAAY2wD,GAAU,GAEpB,MAAMG,EAAQrvD,KAAKovD,OAAOl+C,GAa1B,OAXKg+C,EAMOG,EAAMH,UAEhBlvD,KAAKovD,OAAOl+C,kCAAUm+C,IAAOH,QAAAA,KAPzBG,EAAMH,UAGRlvD,KAAKovD,OAAOl+C,kCAAUm+C,IAAOH,QAASG,EAAMJ,SAAUE,QAAQ,KAO3DnvD,KAGTzB,WAAW4wD,GAAS,GAElB,MAAME,EAAQrvD,KAAKovD,OAAOl+C,GAY1B,OAVIi+C,EACGE,EAAMF,SAETnvD,KAAKovD,OAAOl+C,kCAAUm+C,IAAOH,SAAS,EAAMC,OAAAA,KAErCE,EAAMF,SAEfnvD,KAAKovD,OAAOl+C,kCAAUm+C,IAAOF,OAAAA,KAGxBnvD,MA0CX,MAAM8uD,WAA0BD,GAE9BtwD,YAA6BixD,GAC3B1uD,QAD2Bd,gBAAAwvD,EAM7BjxD,KAAKqJ,GACH,OAAQ5H,KAAK8Q,MA4BeQ,EA5BetR,KAAKwvD,WA6B3Cl+C,EAAU05C,SAASl6C,OAAOvF,QAAQ+F,GAAWnE,UAC/Cm9C,GAAmC18C,GAAeF,MAQzD,SAA2B48C,GACzB,OAAO7qD,EAAM6qD,EAAUn8B,GAAKA,EAAE22B,OAAO+J,KAT+BY,CAAkBnF,KAClFoF,KA/B0D5jD,GAAGlE,GA4BnE,IAAgC0J,EAzB9B/S,WAAW4wD,GAOT,OANAnvD,KAAKwvD,WAAWxE,SAASl6C,OAAOjH,KAC5BygD,GAAY7rD,EACR6rD,EACA5F,GAAWA,EAAQI,OAAO+J,IAAUc,WAAWR,KAGhDnvD,KAGTzB,YAAY2wD,GAOV,OANAlvD,KAAKwvD,WAAWxE,SAASl6C,OAAOjH,KAC5BygD,GAAY7rD,EACR6rD,EACA5F,GAAWA,EAAQI,OAAO+J,IAAUe,YAAYV,KAGjDlvD,MAyBX,SAAS0vD,MAAwBL,GAE/B,MAAMhyD,EAAuE,CAC3E4xD,UAAU,EACVC,SAAS,EACTC,QAAQ,GAmBV,OAhBA1wD,EACI4wD,KACKJ,SAAAA,EAAUC,QAAAA,EAASC,OAAAA,OACdD,IACF7xD,EAAO6xD,SAAU,GAEfD,IACF5xD,EAAO4xD,SAAW5xD,EAAO6xD,SAAU,GAEjCC,IACF9xD,EAAO8xD,OAAS9xD,EAAO6xD,SAAU,KAMtC7xD,ECvST,MAAMwyD,GAA4D,CAEhEtxD,QAAQmmD,GAEN,MAAM/lD,EAAU+lD,EAAQI,OAAOmD,IAE/B,OAAOtpD,EAAUqmD,GAAcrmD,EAAQA,SAAW2lD,KAQzCwL,GAAkB,CAE7BzL,IAAKA,MACH,OAAOwL,IAaT9lD,GAAE,CAAQpL,EAAkC,QACnC,CACL0mD,YACIP,GAEKA,IAAW+K,GACZ7K,GAAcrmD,QACdiH,KCzBRmqD,GAA+C,CAEnD5K,QAAQT,IACC,CACLH,SAAU,IAAIyL,GAAoBtL,GAClCF,UAAW/nD,WAaKwzD,GAEpB5L,WAAYA,MACV,OAAO0L,GAqBTxxD,CAACmI,KACC,OAAO1G,KAAK8Q,QAgHhB,MAAMo/C,GAA2ChzD,OAAO,UAYxD,SAASizD,GAAoBnpD,GAC3B,OAAOA,GAA4B,iBAAXA,GAAuBkpD,MAA6BlpD,EAM9E,MAAMgpD,WAA4BC,GAKhC1xD,YAA6B8oD,GAC3BvmD,QAD2Bd,cAAAqnD,EAHZrnD,cAA6E0R,GAAW,CAAC,IAAIrO,MAM5G,MAAM1E,EAAU0oD,EAASvC,OAAOgL,IAE5BnxD,GACFqB,KAAKmlD,QAAQxmD,EAASqB,KAAK8X,UAG7BxQ,EAAc+/C,GAAU7/C,QAAQR,GAAUhH,KAAKlB,KAAKkI,IAGtD8Q,eACE,OAAO9X,KAAKowD,YAAcpwD,KAAKowD,UAAYC,GACvCrwD,KAAKqnD,SACLrnD,KAAKqnD,SAASvC,OAAOgL,MAM3BvxD,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAO9Q,KAAKswD,SAASx/C,OAAOvF,QAAQvL,KAAKqnD,UAAUl6C,UAC5D,EAAEM,KAAaG,GAAeF,MAAaD,EAAQnN,SACnD,IAAIiyC,KAEF,MAAMl1C,EAAsC,GAI5C,OAFAk1C,EAAQhoC,QAAQ,EAAEtI,KAASsuD,GAAqBtuD,EAAK5E,IAE9CA,IAEXyO,GAAGlE,GAKPrJ,MACIqJ,GAEF,OAAQ5H,KAAK4Q,MAAQ1D,GAAqDtF,IACxEA,EAASE,OAAOP,MAAMvH,KAAKqnD,UAE3B,MAAM9U,EAAU,IAAI2R,GACd50C,EAAU,IAAIvG,GACpB,IAAIynD,GAAc,EAUlB,OAFAlhD,EAAQjF,GAAGzC,GAEJ5H,KAAK8Q,KAAK7O,IAEf,MAAMy6C,EAAS,IAAIxzC,IAAIqpC,GACjBlpC,EAAgB,GAEtB5K,EACIW,EACIiB,EAA8B4B,GAC9B,GAAIwuD,OAAYA,GAEpB,EAAE7vD,MACK87C,EAAOpzC,OAAO1I,IACjByI,EAAInE,KAAKtE,OAKZ4vD,GAAennD,EAAIxJ,QAAU68C,EAAOtzC,QACvCmpC,EAAQ1P,MAAMx5B,EAAKqzC,GA1BrB8T,GAAc,EACdje,EAAQme,QACJ,CAACrnD,EAAKqzC,IAAWptC,EAAQlH,KAAKiB,EAAKqzC,IACrCiU,eA2BH7kD,GAAGlE,GAGRrJ,MAAMc,GACJ,OAAOiO,GAAc3G,EAActH,GAAUA,EAASA,EAAOW,KAAKqnD,WAGpE9oD,QAAQc,GAEN,MAAMkT,EAAUvS,KAAKqnD,SAASvC,OAAOM,IAErC,OAAOplD,KAAKk8C,MAAM78C,GAAQyW,SACtB,IAAI8gC,KAEF,MAAMv5C,EAAsC,GAU5C,OARAu5C,EAAMrsC,QAAQ3J,IACR2S,GAAgB3S,GAClBvD,EAAO4V,GAAYrS,KAAKA,EAAM2R,KAAY,EAE1Cg+C,GAAqB3vD,EAAMvD,KAIxBA,IAKfkB,IAAIc,GAEF,MAAMuxD,EAAWtpD,EAActH,KAAKqnD,UAEpC,GAAIuJ,EAASxpD,MACX,OAAOwpD,EAGT,MAAMC,EAAgBnpD,IAChByO,EAAMjJ,GAAiCtF,IAE3C,MAAME,EAAS9H,KAAKkM,QAAQ7M,GAAQ0K,GAAG,CACrCxL,QAAQyD,KAAYgG,GAClBJ,EAASK,QAAQjG,KAAYgG,MAIjCJ,EAASE,OAAON,QAAQR,IACtB6pD,EAAc/pD,IAAI,CAAEvI,CAAC2xD,IAA4BlpD,MAEnD6pD,EAActpD,MAAMO,GAAQN,QAAQR,IAC9BmpD,GAAoBnpD,IACtBc,EAAOhB,IAAIE,EAAOkpD,SAGrBlmD,SAEIyD,GAAWzN,KAAKswD,SAASp/C,GAYhC,OAVAzD,EAAQ7J,IAAIuS,EAAK06C,GACjBA,EAAcrpD,QAAQR,IACfmpD,GAAoBnpD,KACvByG,EAAQnE,OAAO6M,GACfnW,KAAKswD,SAASp/C,GAAK,CAACzD,MAIxBzN,KAAKswD,SAASp/C,GAAK,CAACzD,GAEbojD,EAActpD,MAAMqpD,GAG7BryD,QACII,EACAmZ,EAA2Bu4C,GAAgBrwD,KAAKqnD,SAAU1oD,IAG5D,MAAM4iD,UAAEA,GAAc5iD,EAChB4zC,EAAU,IAAI2R,GACd4M,EAAgB,KACpBve,EAAQme,QAAQ,CAACrnD,EAAKqzC,KACpB6E,EAAU7E,UAAUA,GACpB6E,EAAUl4C,OAAOA,KAChBsnD,WAGL,OAAO3wD,KAAK4Q,MAAM,CAACvH,EAAKqzC,KACtBnK,EAAQ1P,MAAMx5B,EAAKqzC,GACnB5kC,EAASg5C,KACRtpD,QAAQ,KACL+qC,EAAQnpC,OACVmpC,EAAQppC,QACR2O,EAASg5C,MAKfvyD,KAAKyI,GAMH,OALAvI,EACIuB,KAAKswD,SAASp/C,GAAG,GAAGlU,SACpB8K,GAAUA,EAAOhB,IAAIE,IAEzBhH,KAAKswD,SAASxxD,KAAKkI,GACZhH,MAQX,SAASuwD,GAAqBtuD,EAAuB5E,GACnDoB,EACI4B,EAAY4B,GACZ,EAAErB,EAAM6vD,MACM,MAARA,IACFpzD,EAAOuD,GAAQ6vD,KASzB,SAASJ,GAAgB3L,EAAyBvtC,GAChD,OAAOutC,EAAQI,OAAOS,GAAfb,CAAkC,CAAEvtC,KAAAA,ICnZ7C,MAAM45C,GAA8C,CAAC,CAAC,YAAa9L,KAKnE,SAAS+L,GAAqBC,GAC5B,OAAQA,EAAOzpB,YCiBD0pB,IACZz+C,GACEA,EAAKwyC,IAGH,IAEN,OAAQP,IAEN,MAAMyM,EAAOvwD,GAAiB,CAACA,EAAM6R,GAErC,OAAOjF,GAAS,CACd4jD,GAAI1M,EAAQI,OAAOqD,IACnBkJ,GAAI3M,EAAQI,OAAOuH,IACnB9hC,GAAIm6B,EAAQI,OAAO+J,MAClB/4C,SACC,EAAGs7C,IAAK/+B,GAAOg/B,IAAKC,GAAQ/mC,KAAO0kC,SAAAA,EAAUC,QAAAA,EAASC,OAAAA,QAEpD,MAAMvY,EAAyB,GA2B/B,OAzBKuR,GAAOqB,QAAQn3B,IAClBukB,EAAM1xC,KAAKisD,EAAI,aAEJ,OAAT9+B,GAA0B,QAATA,GACnBukB,EAAM1xC,KAAKisD,EAAI,aAEZG,EAAM9pB,IACToP,EAAM1xC,KAAKisD,EAAI,YAEbG,EAAMxzC,IAAI,YACZ84B,EAAM1xC,KAAKisD,EAAI,YAEbG,EAAMxzC,IAAI,eACZ84B,EAAM1xC,KAAKisD,EAAI,eAEblC,GACFrY,EAAM1xC,KAAKisD,EAAI,cAEbjC,GACFtY,EAAM1xC,KAAKisD,EAAI,YAEbhC,GACFvY,EAAM1xC,KAAKisD,EAAI,WAGVxzD,KAAYi5C,MCtD7B,MAAM2a,WACM96C,GAEVH,YACE,OAAOtW,KAGTzB,cACEuC,MAAM,sBAGRvC,KACIyC,GAOF,MAAMuR,EAAUvR,EAAKgB,QAAQlF,IAAI2lB,IAC3BG,EAAY5hB,EAAKgB,QAAQlF,IAAIy0B,IAEnC,OAAOvwB,EAAKE,KAAK4U,SACb,IAAIc,IAAQ4uC,MACL5uC,EACH2uC,GAAkBx7C,GAAG6Y,GACrBwiC,GAAmBr7C,GAAGwI,KAE5BhH,QAAQvK,EAAKgB,QAAQlF,IAAI4Y,YAQlB87C,OACSD,GClBTE,OACS36C,GACd,qBACA,CACE1V,UAAW,oBAgBLswD,GACZ/4B,EACA+rB,GAWF,OAAOh9C,EARKixB,EAAK77B,IAAIu8B,IAAkB71B,QAAQ,CAC7C5B,EAAG6vD,GACH5vD,GAAI,MACF82B,KAAAA,EACA+rB,QAAAA,OAKCn9C,MAAMoxB,GACNpxB,MAAMm9C,SC9EAiN,GAAe,IAAIz+C,GAC5B,mCACA,MACA,kBCQS0+C,GAA4ClS,GAAY79C,GACjE,CAAE4wB,EAAG,YACL,CACEo/B,OAAQ,IAAIhmB,GAAQ,CAAEE,EAAG,IAAKE,EAAG,IAAKC,EAAG,MACzC4lB,SAAU,IAAIjmB,GAAQ,CAAEE,EAAG,GAAIE,EAAG,GAAIC,EAAG,KACzC6lB,UAAW,sBACXC,UAAWzhB,GAAarzB,GAAG,EAAG,MAC9B+0C,YAAa,IACbC,YAAa,MACbC,gBAAiB,MACjBC,kBAAmB9hB,GAAWpzB,GAAG,IAAK,iBAI5Bm1C,IAAWD,kBAAEA,IAC3B,MAAO,CACLE,YAAa,eAAeF,eCzBhBG,GAAU9O,GAExB,MAAM+O,EAAW/O,EAAM5rC,IAAI+5C,IAAe9gD,QAClC6nB,MAAMwiB,MAAEA,IAAYsI,EAE5B,OAAOvD,GACH/E,EAAM9xC,IAAI,CAAE+C,EAAG,KAAOomD,EAAS18C,SAAS28C,KACxCtX,EAAM9xC,IAAI,CAAE+C,EAAG,IAAKkQ,EAAG,YAAck2C,EAAS18C,SAAS28C,KACvDtX,EAAM9xC,IAAI,CAAE+C,EAAG,IAAKkQ,EAAG,UAAY,CAAEo2C,eAAgB,cACrDvX,EAAM9xC,IAAI,CAAE+C,EAAG,IAAKkQ,EAAG,WAAa,CAAEo2C,eAAgB,qBACtDvX,EAAM9xC,IAAI,CAAE+C,EAAG,IAAKkQ,EAAG,UAAY,CAAEo2C,eAAgB,sBAI3D,SAASD,IACLZ,OACEA,EAAMM,gBACNA,IAGJ,MAAO,CACLQ,MAAOd,EACPe,WAAYT,EACZO,eAAgB,iBCtBJG,GAAapP,GAE3B,MAAM+O,EAAW/O,EAAM5rC,IAAI+5C,IAAe9gD,OAE1C,OAAOovC,GACHuD,EAAM9qB,KACDtvB,IAAImpD,EAAS18C,SAASg9C,KACtBzpD,IAAImpD,EAAS18C,SAASu8C,KAC3B5O,EAAM7Y,MAAM2nB,KAIlB,SAASO,IACLjB,OACEA,EAAME,UACNA,EAASC,UACTA,EAASC,YACTA,EAAWC,YACXA,IAGJ,MAAO,CACLS,MAAOd,EACPkB,KAAM,UAAUb,KAAeF,KAAaC,KAAeF,cCvB/CiB,GAAUvP,GAExB,MAAM+O,EAAW/O,EAAM5rC,IAAI+5C,IAAe9gD,QAClC6nB,MAAMwiB,MAAEA,IAAYsI,EAE5B,OAAOvD,GACH/E,EAAM9xC,IACF,CAAE+C,EAAG,QACL,CACE6mD,OAAQ,OACRC,OAAQ,EACRC,QAAS,IAGfhY,EAAM9xC,IACF,CAAE+C,EAAG,QACLomD,EAAS18C,SAASs9C,KAEtB3P,EAAM7Y,MAAMioB,KAIlB,SAASO,IACLtB,SACEA,IAGJ,MAAO,CACLuB,gBAAiBvB,EACjBmB,OAAQ,OACRC,OAAQ,EACRC,QAAS,SChBAG,GAAoD5T,GAAY79C,GACzE,CAAE4wB,EAAG,iBACLkG,GAAQinB,GAAa/9C,GACjB,CACE0xD,OAAQ3B,IAEVj5B,GACF7nB,OAAOgF,SAAS09C,KAGtB,SAASA,IAEHD,QAAQ1B,OACNA,EAAMC,SACNA,EAAQC,UACRA,EAASC,UACTA,EAASC,YACTA,EAAWC,YACXA,KAMN,MAAO,CACLL,OAAAA,EACAC,SAAUA,EAASzlB,IAAIzoC,IAAI,EAAG4oC,EAAAA,OAAWA,EAAO,GAAJA,KAC5CinB,WAAY3B,EAASzlB,IAAIzoC,IAAI,EAAG4oC,EAAAA,OAAWA,EAAO,IAAJA,KAC9CulB,UAAAA,EACAC,UAAAA,EACA0B,eAAgB1B,EAAU2B,IAAI,IAC9B1B,YAAAA,EACAC,YAAAA,EACA0B,aAAc9B,EACd+B,SAAU7B,EAAU8B,IAAI,GACxBC,SAAU/B,EAAU8B,IAAI,GACxBE,UAAWhC,EAAU8B,IAAI,GACzBG,UAAWjC,EACXkC,SAAU5jB,GAAWpzB,GAAG,EAAG,OCrB/B,IAAai3C,GAAb,MAEE51D,YAA6BwJ,GAAA/H,cAAA+H,EAI7BxJ,QACE,OAAOyB,KAAK+H,SAASjL,IAAIimD,IAAOnY,MAAMwpB,UCdtC50D,GDaF60D,GADC1R,iCALUwR,MA3BZ30C,GACG,CAAC,WAAYmyC,gBEeVl3C,GAEL,OAAO+E,GAAU,CACfX,QAAS,CAAEtX,MAAOioB,IAClBjxB,MAAMwf,GACJ,IAAK,MAAMpD,KAAQF,EACjB,GAAoB,iBAATE,EAAmB,CAE5B,MAAM/Z,EAAOstB,GAAuBvT,GAEpCoD,EAAM6K,cAAc,CAClBhnB,EAAGisB,GACHzrB,GAAI,CACFxB,KAAAA,EACA8tB,OAAQV,GAAqBptB,WAIjC,IAAK,MAAOH,EAAK0f,KAAgBzd,OAAOm/B,QAAQlnB,GAAO,CAErD,MAAM/Z,EAAOstB,GAAuBztB,GAEpCsd,EAAM6K,cAAc,CAClBhnB,EAAGisB,GACHzrB,GAAI,CACFxB,KAAAA,EACA8tB,OAAQV,GAAqBptB,EAAMuf,UFxC/Cm0C,CAAW,SCkBX90D,GDhBI,EAAGklD,SAAWA,QAAAA,GAAW0B,QAAAA,EAASpkD,QAAAA,cjKyDtCA,EACApB,EACAsO,EAAkB6e,GAAgBntB,IAEpC,OAAO,IAAIqvB,GAAiBjuB,EAASpB,EAAMsO,GiK3DGqlD,CAAevyD,EAAS,QACzD8O,OACA3D,UACGy/C,GAAQA,EAAOA,EAAKxe,OAAOwF,MAAM,OAAS,IAGrC99B,SACTgb,GAAQ4zB,EAAQllD,QACZswD,GAAgB/lD,GAAG/H,EAAQrD,SAC3BynD,GACFroC,MACEkyC,GACAuE,IACEA,EAAWnrD,IAAI6nD,MACfsD,EAAWnrD,cVO3BorD,KACEA,EAAI3jC,KACJA,GAIE,IAGN,IAAI4jC,EAUAC,EAUJ,OAfED,EAHG5jC,EAEMhrB,MAAMqJ,QAAQ2hB,GACZA,EAAKjxB,OAASoxD,GAAUngC,EAAKoU,MAAM0nB,GAAQqE,EAAOnzC,IAAI8uC,IAASoE,GAE/DC,GAAUA,EAAOnzC,IAAIgT,GAJrBkgC,GAYX2D,EAHGF,EAEM3uD,MAAMqJ,QAAQslD,GACfA,EAAK50D,OAAS40D,EAAO1D,GAErB,CAAC0D,GAJD1D,GAOHrM,GAAWA,EAAQI,OAAOuH,IAAcv7C,OAAOgF,SAClDm7C,GAAUyD,EAASzD,GAAUtzD,KAAYg3D,GAASh3D,KUrCrBi3D,CAAW,CAAE9jC,KAAAA,QCEvCtR,GAAU,CACfX,QAAS,CACPtX,MAAOyoB,IAETzxB,OAAOgmB,GACLA,EAAW4B,cAAcnkB,IAEvB,MAAMw3B,GAAEA,GAAOx3B,EAAQlF,IAAIu8B,IAE3B7rB,GAAS,CACPwrB,OAAQQ,IAAKrsB,UACTusB,GAASA,EAAQ9rB,GAAe8rB,EAAM58B,IAAI20D,KAAqBj0D,EAA4B,KAE/F4oD,QAASpkD,EAAQlF,IAAI00D,MACpBrkD,UACC,EACE6rB,QAAS0rB,GACT0B,SAAUA,OAEV,GAAI1B,EAAQA,QAAS,CAEnB,MAAMmQ,EAAYr1D,GAAQ,CAAEklD,QAAAA,EAAS1iD,QAAAA,EAASokD,QAAAA,IAE9C,GAAIyO,EACF,OAAOA,aAAqBvO,GACtB3oD,EAASk3D,GACTjnD,GAAeinD,GAIzB,OAAOl3D,MAEX4O,QACE,CAACm4C,EAAiC58C,KAChC,IAAK48C,EACH,OAGF,MAAMoQ,EAAcpD,GAAiB1vD,EAAS0iD,GAI9C,OAFC58C,GAAUR,EAAco9C,IAAUn9C,MAAMutD,GAElCA,YDrCRX,IAYb,MACMY,GAAoC,CAAC,YAAa9P,IAExD,SAASmP,GAAa3Q,GAEpB,MAAM+O,EAAW/O,EAAM5rC,IAAIy7C,IAAmBxiD,QACtC6nB,MAAMwiB,MAAEA,IAAYsI,EACtBuR,EAAUzkB,GAAarzB,GAAG,EAAG,MAEnC,OAAOgjC,GACH/E,EAAM9xC,IACF,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EAXH,gBAYjB+/B,EAAS18C,SAAS,EAAG+7C,OAAAA,EAAQ6B,eAAAA,OAC3BuB,QAAS,OACTC,SAAUxB,EACVP,QAASO,EAAeI,IAAI,GAC5BqB,WAAY,GAAGH,YAAkBnD,IACjCuD,YAAa1B,EAAexgB,IAAI8hB,OAGtC7Z,EAAM9xC,IACF,CACEspC,EAAG,CACD,IACA,OACA,CACExkB,EAAG,CAAC4mC,GAAoB,CAAC,UAAW9P,KACpCtS,EAAG,CAAC,IAAK,MAAO,CAAExkB,EAAG,CAAC,YAAa82B,QAGvCxyB,EA9Be,gBAgCjB,CACEwiC,QAAS,UAGf9Z,EAAM9xC,IACF,CACEspC,EAAG,CACD,IACA,OACA,CACExkB,EAAG4mC,GACHpiB,EAAG,CACD,CAAC,IAAK,MAAO,CAAEA,EAAG,CAAC,OAAQ,KAAM,aACjC,CAAC,IAAK,MAAO,CAAEA,EAAG,CAAC,OAAQ,KAAM,mBAIvClgB,EAjDe,gBAmDjB,CACEwiC,QAAS,WGzFrB,IAAaI,GAAb,QAAaA,MAPZ72C,GAAQ,CACPjX,MAAO,CACLi2B,GACA22B,GACAlQ,OAGSoR,ICSb,IAAaC,GAAb,iBAGgBC,IACZvD,UACEA,IAGJ,MAAO,CACLwD,KAAM,WACNrC,QAAS,EACTD,OAAQ,SAASlB,EAAU8B,IAAI,IAXtBwB,MAfZ91C,GACG,CAAC,OAAQmyC,ahGiCT9zC,EAAuC,IAGzC,MAAM43C,EAAa53C,EAAI43C,WAAa53C,EAAI43C,WAAWzxD,KAAK6Z,GAAOphB,EACzDi5D,EAAa73C,EAAI63C,WAAa73C,EAAI63C,WAAW1xD,KAAK6Z,GAAOqtB,GAE/D,OAAO1rB,GAAU,CACfX,QAAS,CACPtX,MAAO,CAAC0jC,GAAiBjb,KAE3BzxB,OAAOyD,GACLA,EAAQmkB,cAAcnkB,IAEpB,MAAMklC,SAAEA,EAAQ7V,OAAEA,GAAWxT,EACvB0E,EAAWvgB,EAAQlF,IAAIulB,IAAiBE,SACxCzK,EAAW9V,EAAQlF,IAAIy0B,GAAZvvB,CAAoCqvB,GAC/CqY,EAAa1nC,EAAQlF,IAAIkiC,IAC/B,IACI22B,EADAC,EAAkCF,EAAWhsB,EAAWlJ,MAI1Dm1B,EADEzuB,EACevqC,EAAcuqC,GAEd,KAEf,MAAQvoC,SAAS2tB,GAAEA,EAAIwZ,QAAS1R,IAAgCpyB,EAEhE,OAAOsqB,EAAK,CAAEA,GAAAA,GAAO,CAAE8H,IAAAA,IAI3BpyB,EAAQ8jB,cAAc,KAEpB,MAAM+vC,EAAQtzC,EAASuzC,cAEvBD,EAAME,mBAAmB/zD,EAAQoe,aAEjCspB,EAAW54B,OAAOjH,KAAK22B,IACrBA,EAAK9B,IACD4K,GACA,CACEpC,SAAUyuB,IACV/tD,SAAU,CACRE,OAAQJ,IAAcH,MAAMvF,GAC5BiG,QAAS,CAACmC,EAAMmuB,IAM1B,SAAwBA,GAEtB,MAAMy9B,EAAaN,EAAWn9B,EAASiI,MAEvC,GAAIw1B,IAAeJ,EACjB,OAGF,IAAKr9B,EAASiP,GAEZ,YADA1vB,EAAS,IAAM29C,EAAW,CAAEzzD,QAAAA,EAAS6zD,MAAAA,EAAOt9B,SAAAA,KAI9Cq9B,EAAcI,EACdl+C,EAAS,KACP+9C,EAAMI,iBAEN,MAAM/1D,EAASqiB,EAAS2zC,0BAClBhvB,SAAEA,GAAa3O,EAEjB2O,IACFxB,GAAkBwB,EAAUhnC,GAC5B21D,EAAMM,WAAWj2D,IAGnBu1D,EAAW,CAAEzzD,QAAAA,EAAS6zD,MAAAA,EAAOt9B,SAAAA,MA/BM69B,CAAe79B,egG5E5D89B,CAAY,CACV93D,YAAWg6B,SAAEA,EAAQs9B,MAAEA,IAChBt9B,EAASiP,KACZquB,EAAMI,iBACa,MAAf19B,EAASiP,GACXquB,EAAMM,WAAW5zC,SAASggC,eAAe,eAEzCsT,EAAMM,WAAW5zC,SAASggC,eAAe,UAAUhqB,EAAS/gB,cAM3D89C,ICTb,IAAagB,GAAb,MAIE/3D,YAAYyD,GACVhC,KAAKu2D,OAASv0D,EAAQlF,IAAIimD,IAI5BxkD,QACE,OAAOyB,KAAKu2D,OAAO3rB,MAAM4rB,MAD3BnC,GADC1R,iCARU2T,MALZ92C,GACG,CAAC,MAAOmyC,a/GcR9zC,EAA0C,IAG5C,MAAM2jB,EAAS3jB,EAAI2jB,OAAS3jB,EAAI2jB,OAAOx9B,KAAK6Z,GAoG9C,SACIA,GASF,MAAM44C,EAAU54C,EAAImiB,KAAOniB,EAAImiB,KAAKh8B,KAAK6Z,GAAOynB,GAEhD,MAAO,EACLt9B,MAAAA,EACAw4B,KAAAA,EACAkJ,WAAAA,MAGA,MAAM1J,EAAOy2B,EAAQzuD,GAErB,GAAY,MAARg4B,EACF,OAGF,MAAM9/B,EAAS8H,EAAM9H,OACf+jC,EAAUzD,EAAKrtB,IACfA,EAAM,IAAIuqB,IAAIsC,EAAM9/B,EAAOmX,cAAeknB,SAE5CprB,EAAI+X,SAAW+Y,EAAQ/Y,SAI3BljB,EAAM0M,iBACFuvB,EAAQjE,OAAS7sB,EAAI6sB,MACvB0J,EAAWzG,KAAKjD,GAAMhxB,MAAMyI,QAAQD,SAtIWk/C,CAAsB74C,GACnEkwC,EAAS,IAAIvzC,GAASqD,EAAI7V,OAAS,SAEzC,OAAOwX,GAAU,CACfX,QAAS,CACPtX,MAAOs8B,IAETtlC,OAAOgmB,GACLA,EAAW4B,cAAcnkB,IACvBA,EAAQ8jB,cAAc,KAEpB,MAAM4jB,EAAa1nC,EAAQlF,IAAIkiC,IAE/B,IAAK,MAAM23B,KAAa5I,EACtB/rD,EAAQqI,GAAGssD,GAAW5sD,GAAG/B,IACvB0hC,EAAW54B,OAAOjH,KACd22B,GAAQgB,EAAO,CACbx5B,MAAAA,EACAw4B,KAAAA,EACAx+B,QAAAA,EACA0nC,WAAAA,c+GpChBktB,YhHmDA/4C,EAA2C,IAG7C,MAAM4d,OAAEA,EAAS,IAAGo7B,KAAEA,EAAO,CAAEv4C,KAAK,EAAMkc,MAAM,IAAW3c,EAE3D,OAAO2B,GAAU,CACfX,QAAS,CACPtX,MAAO,CAACi2B,GAAsBqG,KAEhCtlC,OAAOgmB,GACLA,EAAW4B,cAAcnkB,IAEvB,MAAM80D,EAwVd,SACI90D,EACA6b,GAGF,MAAM+E,EAAY5gB,EAAQlF,IAAIy0B,KACxBF,OAAEA,EAAM0lC,OAAEA,EAAS1xB,IAA8BxnB,EACjDm5C,EAAc/jD,GAAYrS,KAAKm2D,EAAQ/0D,EAAQlF,IAAI2lB,KACnDq0C,EAAWj5C,EAAIi5C,SAAWj5C,EAAIi5C,SAAS9yD,KAAK6Z,GAAOphB,EAazD,OAAOuE,IAEL,MAAMrC,QAAEA,GAAYqC,EAAKmW,KACnBW,EAAWnZ,EAAQymC,MACjBzmC,EAAQymC,IAAiCxiB,EAAUyO,IACrD4lC,EAAcF,IAClBj/C,EAAS,IAlBO,EAACi/C,GAAmB5/C,KAAAA,MAEtC,MAAMxY,EAAmBwY,EAAKxY,SACxB4iD,UAAEA,GAAc5iD,EAElBo4D,EACFxV,EAAUl4C,IAAI2tD,GAEdzV,EAAU7E,OAAOsa,IAUFE,CAAYH,EAAQ/1D,IACnC81D,EAASC,EAAQ/1D,IAKnB,IAAIm2D,EAEJ,OAJAF,GAAW,GAIJ,CACL14D,SAEE,MAAMuJ,EAASqvD,EAAazvD,EAAY,KAClCyvD,IAAervD,GACjBmvD,GAAW,KAIf,OAAOnvD,KApYUsvD,CAAgBp1D,EAAS6b,GACpCw5C,EAuLd,SACIx5C,GAEF,IAAKA,EAAIw5C,MACP,OAAOvzB,GAET,OAAO9iC,IAEL,MAAM6jC,EAAShnB,EAAIw5C,MAAOr2D,GAE1B,GAAsB,iBAAX6jC,EACT,OAAOl3B,GAAS3M,EAAKmW,KAAM0tB,GAG7B,IAAIt3B,EAAsCD,GAAcu3B,GAAQ13B,UAC5D03B,GAAUlnC,EAASqD,EAAKmW,KAAM0tB,IAGlC,OAAO33B,GAA4BtF,IACjC2F,EAASxD,GAAG,CACVjC,OAAQJ,IACHH,MAAMK,EAASE,QACfN,QAAQ,KAEP+F,EAAWI,GAAS3M,EAAKmW,KAAM,GAC/B5J,EAASxD,GAAGnC,KAElBK,QAASL,EAASK,QAAQjE,KAAK4D,QAlNjB0vD,CAAcz5C,GACtB6rB,EAAa1nC,EAAQlF,IAAIkiC,IACzBu4B,EAAgBv1D,EAAQlF,IAAIm9B,IAElCj4B,EAAQ8jB,cAAc,KAEpB,IAAIixC,EAAyB,IAAI1zD,IAEjCqmC,EAAW54B,OAAOvF,QAAQvJ,GAASuK,QAC/Bi0B,GAAQ+2B,EAAc97B,OAAOA,EAAQo7B,GAAM/lD,OAAO3D,UAC9C0uB,GAASjuB,GAAeF,MACjBjO,EAAMo8B,EAAO1kB,GAAQkgD,EAAM,CAAElgD,KAAAA,EAAMnV,QAAAA,EAASw+B,KAAAA,QAErDj0B,QACE,IAAIirD,KAEF,MAAM58B,EAmJ1B,SAA8B48B,GAE5B,IAAIC,EAAY,EACZV,EAAwB,GAW5B,OATAS,EAAQjtD,QAAQ,EAAE4M,EAAM0tB,MAClBA,EAAS4yB,GACXA,EAAY5yB,EACZkyB,EAAS,CAAC5/C,IACD0tB,IAAW4yB,GACpBV,EAAO7xD,KAAKiS,KAIT4/C,EAjK4BW,CAAqBF,GAChCG,EAA4B,IAAIt0D,IAChChG,EAASqK,IAoBf,OAlBAkzB,EAASrwB,QAAQ4M,IAEf,IAAIygD,EACJ,MAAM9sD,EAAWisD,EAAOj6D,IAAIqa,GAExBrM,GACF6sD,EAAU/zD,IAAIuT,EAAMrM,GACpB8sD,EAAa9sD,IAEb8sD,EAAad,EAAS,CAAE3/C,KAAAA,EAAMnV,QAAAA,EAASw+B,KAAAA,IACvCm3B,EAAU/zD,IAAIuT,EAAMygD,IAGtBA,EAAW9vD,SAASP,MAAMlK,KAG5B05D,EAASY,EAEFt6D,YgHrGvBw6D,KAESvB,IAiBb,SAASE,GAAS/S,GAEhB,MAAM+O,EAAW/O,EAAM5rC,IAAI+5C,IAAe9gD,QAClC6nB,MAAMwiB,MAAEA,IAAYsI,EAE5B,OAAOvD,GACH/E,EAAM9xC,IACF,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EATP,WAUb+/B,EAAS18C,SAASgiD,KAEtB3c,EAAM9xC,IACF,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EAbP,WAcb+/B,EAAS18C,SAASiiD,KAChBvC,KAAM,YACNvC,OAAQ,OACR+E,WAAYC,GAAkBF,OAGpC5c,EAAM9xC,IACF,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EAAG,CArBV,UAqB2B,cACxC,CACE+iC,KAAM,aAGZra,EAAM9xC,IACF,CAAC,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EA3BR,WA2B6B,CAAErmB,EAAG,IAAKqmB,EA3BvC,YA4Bb+/B,EAAS18C,SAASoiD,KAEtB/c,EAAM9xC,IACF,CAAC,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EA/BR,WA+B6B,CAAErmB,EAAG,IAAK+hB,EAAG,CAAC,SAAUoE,IAAYE,EA/BjE,YAgCb+/B,EAAS18C,SAASqiD,MAK5B,SAASL,IACL9F,UACEA,IAGJ,MAAO,CACLmB,QAAS,EACTD,OAAQ,KAAKlB,EAAU8B,IAAI,mBAIfmE,IAAkBnG,SAAEA,IAClC,OAAOA,EAASzlB,IAAIzoC,IAAI,EAAG4oC,EAAAA,OAAWA,EAAO,GAAJA,KAG3C,SAAS0rB,GACL1F,GAGF,MAAMR,UAAEA,GAAcQ,EAEtB,MAAO,CACLyC,QAAS,QACT/B,OAAQ,EACRC,QAAS,GAAGnB,EAAU8B,IAAI,MAAM9B,IAChCoG,OAAQ,EACRC,QAAS,EACTL,WAAYC,GAAkBzF,IAIlC,SAAS2F,IACLnG,UACEA,EAASH,OACTA,EAAMC,SACNA,IAIJ,MAAMkD,EAAUzkB,GAAarzB,GAAG,EAAG,MAEnC,MAAO,CACL86C,WAAYlG,EACZqD,WAAY,GAAGH,WAAiBnD,IAChCuD,YAAapD,EAAU9e,IAAI8hB,IC1F/B,IAAasD,GAAb,MAEE/5D,YAA6BwJ,GAAA/H,cAAA+H,EAI7BxJ,cAEE,MAAQkmB,YAAc7jB,KAAM23D,UAAqBv4D,KAAK+H,SAASjL,IAAIud,IAAkBuE,YAAY02C,IAEjG,OAAOt1D,KAAK+H,SAASjL,IAAIimD,IAAOnY,MAOpC,SAAwB2tB,GACtB,OAAO9U,IAEL,MAAM+O,EAAW/O,EAAM5rC,IAAI+5C,IAAe9gD,QAClC6nB,MAAMwiB,MAAEA,IAAYsI,EAE5B,OAAOvD,GACH/E,EAAM9xC,IACF,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EAVH,iBAWjB,CACEwgC,OAAQ,OACRgC,QAAS,OACTuD,SAAU,WACVC,WAAY,UACZC,aAAc,eAElBrvD,IACEmpD,EAAS18C,SAASu8C,KAEtBlX,EAAM9xC,IACF,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EAAG,CAtBN,gBAsB6B,cAC9C,CACEwgC,OAAQ,SAGd9X,EAAM9xC,IACF,CAAC,CAAEspC,EAAG,CAAC,IAAK,QAASlgB,EA5BJ,iBA4B+B,CAAErmB,EAAGmsD,EAAU9lC,EA5B9C,kBA6BjB+/B,EAAS18C,SAASy/C,OAlCYoD,CAAeJ,MAJvDlE,GADC1R,iCALU2V,MATZ94C,GAAU,CACT5e,KAAM,CAAC,YAAa+wD,IACpB9yC,QAAS,CACPtX,MAAO,CACL+tD,GACAgB,QAIOgC,ICJb,IAAaM,GAAb,QAAaA,MATZp6C,GAAQ,CACPjX,MAAO,CACL+wD,GACA96B,GACAyN,SnD8BFvtB,WAAYA,MACV,OAAOmlC,KmD7BPoB,OAGS2U,ICEb,IAAaC,GAAb,QAAaA,MAXZr6C,GAAQ,CACPjX,MAAO08C,GACP1lD,MAAMwf,GACJA,EAAM8K,aAAa,CAAEjnB,EAAG6/C,GAAqB9+C,GAAIw/C,MAEnD5jD,KAAKyD,GACHA,EAAQ2jB,UAAU,KAChBu1B,GAAkBl5C,EAAQlF,IAAIimD,IAAOnY,MAAMooB,IAAY/Y,YAIhD4e,QCJAC,GAAb,iBCPgBC,GAAWtV,GAEzB,MAAMuV,EAAevV,EAAM5rC,IAAIy7C,IAAmBxiD,QAC1C6nB,MAAMwiB,MAAEA,IAAYsI,EAE5B,OAAOvD,GACH/E,EAAM9xC,IAAI,CAAE+C,EAAG,SAAW4sD,EAAaxuD,KAAKyuD,KAC5C9d,EAAM9xC,IAAI,CAAE+C,EAAG,QAASkQ,EAAG,cAAgB08C,EAAaxuD,KAAK0uD,KAC7D/d,EAAM9xC,IAAI,CAAE+C,EAAG,QAASkQ,EAAG,cAAgB08C,EAAaxuD,KAAK0uD,KAC7D/d,EAAM9xC,IAAI,CAAE+C,EAAG,QAASkQ,EAAG,UAAY08C,EAAaxuD,KAAK2uD,KACzDhe,EAAM9xC,IACF,CACE+C,EAAG,QACH+hB,EAAG,CACD,CAAC,UAAW82B,IACZ,CAAC,UAAWA,MAGhB+T,EAAaljD,SAASsjD,KAE1Bje,EAAM9xC,IACF,CACE+C,EAAG,QACH+hB,EAAG,CACD,CAAC,UAAW82B,IACZ,CAAC,UAAWA,MAGhB,CACEoU,aAAc,WAGpBle,EAAM9xC,IACF,CACE+C,EAAG,QACH+hB,EAAG,CACD,CAAC,aAAc82B,IACf,CAAC,UAAWA,MAGhB,CACEoU,aAAc,qBAMVJ,IACZpH,OACEA,EAAME,UACNA,EAASC,UACTA,EAASC,YACTA,EAAWC,YACXA,EAAW2B,SACXA,EAAQE,SACRA,EAAQC,UACRA,EAASC,UACTA,EAASnC,SACTA,EAAQ8B,aACRA,EAAYM,SACZA,IAGJ,MAAO,CACLvB,MAAOd,EACPkB,KAAM,UAAUb,KAAeF,KAAaC,KAAeF,IAC3DoB,QAAS,GAAGa,KAAaC,IACzBf,OAAQ,GAAGW,KAAYE,IACvBV,gBAAiBvB,EACjBsG,OAAQ,SACRC,QAAS,GAAGnE,WAAkBN,IAC9B0F,UAAW,+BACXC,UAAW,aACXC,MAAO,iBAIKN,IACZzF,WACEA,IAGJ,MAAO,CACLJ,gBAAiBI,GAIrB,SAAS0F,IACLtH,OACEA,EAAM+B,aACNA,IAGJ,MAAO,CACL6F,aAAczsB,GAAc4mB,EAAc/B,EAAQ,KAItD,SAASuH,IACLvH,OACEA,EAAMqC,SACNA,EAAQN,aACRA,IAGJ,MAAO,CACLyE,QAAS,GAAGnE,EAASP,IAAI,aAAa3mB,GAAc4mB,EAAc/B,EAAQ,QDnGjEiH,MAPZt6C,GAAQ,CACPjX,MAAO,CACLsxD,GACAxD,GACAuD,OAGSE,UEJAY,eCkB0BC,GAErC,MAAMC,EAA2B/3C,GAAyB+f,UACpDrnB,iBAAEA,EAAgBs/C,SAAEA,GA6B5B,SACID,GAMF,MAAMruC,EAAQ7Z,MACR1U,EAAS48D,EAAyB58D,OA4GxC,MAAMud,EAAmB,IA1GzB,cAAgCF,GAI9B9b,cACEuC,QAHOd,SAAMhD,EAAOF,IAIpB88D,EAAyBp2D,QAAQ,CAAE5B,EAAG6gB,GAAyB5gB,GAAIgS,KACnE+lD,EAAyBp2D,QAAQ,CAAE5B,EAAGyY,GAAkBjY,GAAIpC,OAG9DzB,YAA8BogB,GAC5B,gBxLjEFyE,EACAzE,GAGF,GAAIA,EAAc7B,eAAe8Q,IAC/B,OAAQjP,EAAsBiP,IAGhC,MAAMvwB,EAA0CyR,GAC5C7C,QAAQC,QAAQkX,EAAUuC,aACrBtZ,KAAK,IAAM+W,EAAUtmB,IAAIsnB,IAAgBxF,YAAYD,IACrDtS,KAAK,IAAM4X,GAAoBtF,KAGxC,OAAQA,EAAsBiP,IAAuBvwB,EwLmD1CuhB,CAAY5e,KAAM2e,GAK3BpgB,UAAUqJ,GACR,OAAQ5H,KAAK2lB,UAAY4F,EAAMza,OAAOtG,KAClC8R,GAAKA,EAAI3e,EAASqC,MAAQlC,KAC5B+L,OAAOiC,GAAGlE,GAGdrJ,KAAKsgB,GAOH,MAAM+G,EAAS1Y,GAA4BtF,IAGzC,MAAM0iB,EAAU/P,EAAiBzd,IAAI2wB,IAAkBnD,QAAQzL,GACzDi7C,EAAOpoD,GAAwB,CACnCkU,OAAQ,CACN/G,QAAAA,EACAuJ,OAAO,KAIXpoB,KAAKlD,IAAIkuB,GAAW9N,GAAG2B,IAAU9U,GAAG,CAClCjC,OAAQF,EAASE,OACjBvJ,QAAQ6L,EAAM2vD,GAIZ,MAAMzuC,EAASyuC,EAEfD,EAAK5oD,GAAK,CACR0U,OAAQ,CACN/G,QAASyM,EAAOhB,QAAQzL,QACxBuJ,MAAOkD,EAAOlD,OAEhB4D,KAAMV,EAAOU,MAEVV,EAAOlD,OACVkD,EAAOtN,OAAO3R,KAAK,KACjBytD,EAAK5oD,GAAK,CACR0U,OAAQ,CACN/G,QAASyM,EAAOhB,QAAQzL,QACxBuJ,OAAO,GAET4D,KAAMV,EAAOU,QAEdhd,MAAMyI,QAAQD,UAGpBhQ,QAAQ,KACT8iB,EAAQ+C,UAIVysC,EAAKhpD,KAAKlJ,KACToC,QAEH,IAAIgwD,EACJ,MAAMlyD,EAAS8d,EAAO7b,GAAG,EAAGiiB,KAAAA,MAC1BguC,EAAWhuC,IAwBb,OAAO,IArBP,cAAkB9M,GAEhB8M,WACE,OAAOguC,EAKTz7D,KAAKqJ,GACH,OAAQ5H,KAAK8Q,KAAO8U,EAAOra,QAAQzD,GAAQgO,SACvCgkD,GAAQA,EAAKl0C,QACf9Z,GAAGlE,GAGPrJ,QAAQyI,GAEN,OADAc,EAAOhB,IAAIE,GACJgzD,MAYf,MAAO,CACLz/C,iBAAAA,EACAhc,WACEgtB,EAAMra,OAtJ6B+oD,CAAcL,GAC/C/6C,EAA8B,IAApB86C,EAAS95D,OAAe85D,EAAS,IAazBpyD,EAb+CoyD,EAchEx7C,GAAWI,OAAO,QAA2B,CAAEhX,MAAAA,KADxD,IAA0BA,EANxB,OALAgT,EAAiBzd,IAAI2wB,IAAkBnD,QAAQzL,GAC/CtE,EAAiBzd,IAAIkuB,GAAW9N,GAAG2B,IAAU9U,GAAGuhB,IAC9CA,EAAQtN,OAAO3R,KAAKwtD,GAAU7qD,MAAMyI,QAAQD,SAGvC+C,ED7BsB2/C,CAAoBpB"}