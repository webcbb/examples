{"version":3,"file":"common.83117148.js","sources":["../../../../proc7ts/primitives/src/array/array-of-elements.ts","../../../../proc7ts/primitives/src/value/are-the-same.ts","../../../../proc7ts/primitives/src/value/value-providers.ts","../../../../proc7ts/primitives/src/value/lazy-value.ts","../../../../proc7ts/primitives/src/value/value-recipe.ts","../../../../proc7ts/primitives/src/array/arrays-are-equal.ts","../../../../proc7ts/primitives/src/array/element-or-array.ts","../../../../proc7ts/primitives/src/array/set-of-elements.ts","../../../../proc7ts/primitives/src/class/super-class-of.ts","../../../../proc7ts/primitives/src/fn/asis.ts","../../../../proc7ts/primitives/src/fn/count-args.ts","../../../../proc7ts/primitives/src/fn/merge-functions.ts","../../../../proc7ts/primitives/src/fn/noop.ts","../../../../proc7ts/primitives/src/object/has-own-property.ts","../../../../proc7ts/primitives/src/type/presence.ts","../../../../proc7ts/push-iterator/src/push-iterable.ts","../../../../proc7ts/push-iterator/src/base/is-push-iterable.ts","../../../../proc7ts/push-iterator/src/base/iterator-of.ts","../../../../proc7ts/push-iterator/src/base/make-push-iterable.ts","../../../../proc7ts/push-iterator/src/base/push-iterated.ts","../../../../proc7ts/push-iterator/src/base/make-push-iterator.ts","../../../../proc7ts/push-iterator/src/base/push-head.ts","../../../../proc7ts/push-iterator/src/base/iterate-over-indexed.impl.ts","../../../../proc7ts/push-iterator/src/base/iterate-over-array.impl.ts","../../../../proc7ts/push-iterator/src/construction/over-array.ts","../../../../proc7ts/push-iterator/src/consumption/its-iterated.ts","../../../../proc7ts/push-iterator/src/consumption/its-each.ts","../../../../proc7ts/push-iterator/src/consumption/its-elements.ts","../../../../proc7ts/push-iterator/src/consumption/its-empty.ts","../../../../proc7ts/push-iterator/src/consumption/its-every.ts","../../../../proc7ts/push-iterator/src/consumption/its-first.ts","../../../../proc7ts/push-iterator/src/base/raw-iterator.impl.ts","../../../../proc7ts/push-iterator/src/consumption/its-head.ts","../../../../proc7ts/push-iterator/src/consumption/its-iterator.ts","../../../../proc7ts/push-iterator/src/consumption/its-reduction.ts","../../../../proc7ts/push-iterator/src/construction/over-none.ts","../../../../proc7ts/push-iterator/src/construction/over-iterator.ts","../../../../proc7ts/push-iterator/src/construction/over-elements-of.ts","../../../../proc7ts/push-iterator/src/construction/over-iterable.ts","../../../../proc7ts/push-iterator/src/construction/over-one.ts","../../../../proc7ts/push-iterator/src/objects/over-keys.ts","../../../../proc7ts/push-iterator/src/transformation/filter-array.ts","../../../../proc7ts/push-iterator/src/transformation/iterate-over-filtered-indexed.impl.ts","../../../../proc7ts/push-iterator/src/transformation/filter-it.ts","../../../../proc7ts/push-iterator/src/transformation/flat-map-array.ts","../../../../proc7ts/push-iterator/src/transformation/iterate-over-flattened-indexed.impl.ts","../../../../proc7ts/push-iterator/src/transformation/flat-map-it.ts","../../../../proc7ts/push-iterator/src/transformation/map-it.ts","../../../../proc7ts/push-iterator/src/transformation/value-it.ts","../../../../proc7ts/push-iterator/src/objects/over-entries.ts","../../../../proc7ts/supply/src/impl/unexpected-abort.ts","../../../../proc7ts/supply/src/impl/off.ts","../../../../proc7ts/supply/src/impl/state.ts","../../../../proc7ts/supply/src/supply.ts","../../../../proc7ts/supply/src/always-supply.ts","../../../../proc7ts/supply/src/never-supply.ts","../../../../proc7ts/context-values/src/context-key-error.ts","../../../../proc7ts/context-values/src/key/context-key.ts","../../../../proc7ts/context-values/src/key/context-seed-key.ts","../../../../proc7ts/context-values/src/context-values.ts","../../../../proc7ts/context-values/src/conventional/contextual.ts","../../../../proc7ts/context-values/src/singleton/iterative-context-key.ts","../../../../proc7ts/context-values/src/singleton/multi-context-key.ts","../../../../proc7ts/context-values/src/singleton/simple-context-key.ts","../../../../proc7ts/context-values/src/singleton/single-context-key.ts","../../../../proc7ts/context-values/src/conventional/context-supply.ts","../../../../proc7ts/context-values/src/registry/context-builder.ts","../../../../proc7ts/context-values/src/registry/context-seeders.impl.ts","../../../../proc7ts/context-values/src/registry/context-value-spec.ts","../../../../proc7ts/context-values/src/registry/context-values.impl.ts","../../../../proc7ts/context-values/src/registry/context-registry.ts","../../../../proc7ts/amend/src/base/amendment.ts","../../../../proc7ts/amend/src/base/noop-amender.ts","../../../../proc7ts/amend/src/base/all-amender.ts","../../../../proc7ts/amend/src/base/amend-target.ts","../../../../proc7ts/amend/src/class/ae-class.target.impl.ts","../../../../proc7ts/amend/src/class/ae-class.ts","../../../../proc7ts/amend/src/class/amend.ts","../../../../proc7ts/amend/src/impl/ae-prop.accessibility.ts","../../../../proc7ts/amend/src/impl/ae-prop.ts","../../../../proc7ts/amend/src/impl/ae-prop-accessor.ts","../../../../proc7ts/amend/src/impl/ae-prop-applicator.ts","../../../../proc7ts/amend/src/member/ae-member.ts","../../../../frontmeans/namespace-aliaser/src/naming.ts","../../../../frontmeans/namespace-aliaser/src/namings.ts","../../../../frontmeans/namespace-aliaser/src/namespace-def.ts","../../../../frontmeans/namespace-aliaser/src/name.ts","../../../../frontmeans/namespace-aliaser/src/namespace-aliaser.ts","../../../../proc7ts/fun-events/src/base/event-keeper.ts","../../../../proc7ts/fun-events/src/base/event-receiver.ts","../../../../proc7ts/fun-events/src/base/event-notifier.impl.ts","../../../../proc7ts/fun-events/src/base/event-notifier.ts","../../../../proc7ts/fun-events/src/base/event-sender.ts","../../../../proc7ts/fun-events/src/base/no-events-error.ts","../../../../proc7ts/fun-events/src/base/send-events-to.ts","../../../../proc7ts/fun-events/src/impl/after-event.no-fallback.ts","../../../../proc7ts/fun-events/src/impl/dig-events.ts","../../../../proc7ts/fun-events/src/impl/on-event.do.ts","../../../../proc7ts/fun-events/src/impl/on-event.supplier.ts","../../../../proc7ts/fun-events/src/impl/once-event.ts","../../../../proc7ts/fun-events/src/impl/on-event.then.ts","../../../../proc7ts/fun-events/src/impl/share-events.ts","../../../../proc7ts/fun-events/src/impl/supply-events.ts","../../../../proc7ts/fun-events/src/impl/translate-events.ts","../../../../proc7ts/fun-events/src/base/impl/never-receive.ts","../../../../proc7ts/fun-events/src/on-event.ts","../../../../proc7ts/fun-events/src/after-event.ts","../../../../proc7ts/fun-events/src/keepers/after-all.ts","../../../../proc7ts/fun-events/src/keepers/after-each.ts","../../../../proc7ts/fun-events/src/keepers/after-sent.ts","../../../../proc7ts/fun-events/src/keepers/after-supplied.ts","../../../../proc7ts/fun-events/src/keepers/after-the.ts","../../../../proc7ts/fun-events/src/keepers/after-value.ts","../../../../proc7ts/fun-events/src/processors/consume-events.ts","../../../../proc7ts/fun-events/src/processors/share-after.ts","../../../../proc7ts/fun-events/src/processors/deduplicate-after.ts","../../../../proc7ts/fun-events/src/processors/dig-after.ts","../../../../proc7ts/fun-events/src/senders/event-emitter.ts","../../../../proc7ts/fun-events/src/senders/on-never.ts","../../../../proc7ts/fun-events/src/senders/on-supplied.ts","../../../../proc7ts/fun-events/src/senders/on-any.ts","../../../../proc7ts/fun-events/src/senders/on-promise.ts","../../../../proc7ts/fun-events/src/base/impl/always-receive-value.ts","../../../../proc7ts/fun-events/src/processors/share-on.ts","../../../../proc7ts/fun-events/src/processors/dig-on.ts","../../../../proc7ts/fun-events/src/processors/translate-on.ts","../../../../proc7ts/fun-events/src/processors/map-after.ts","../../../../proc7ts/fun-events/src/processors/map-on.ts","../../../../proc7ts/fun-events/src/processors/once-after.ts","../../../../proc7ts/fun-events/src/processors/once-on.ts","../../../../proc7ts/fun-events/src/processors/supply-on.ts","../../../../proc7ts/fun-events/src/processors/resolve-on-ordered.ts","../../../../proc7ts/fun-events/src/processors/resolve-on.ts","../../../../proc7ts/fun-events/src/processors/supply-after.ts","../../../../proc7ts/fun-events/src/processors/translate-after.ts","../../../../proc7ts/fun-events/src/processors/value-on.ts","../../../../proc7ts/fun-events/src/state/state-path.ts","../../../../proc7ts/fun-events/src/state/state-tracker.ts","../../../../proc7ts/fun-events/src/value/value-tracker.ts","../../../../proc7ts/fun-events/src/value/track-value.ts","../../../../proc7ts/fun-events/src/value/value-sync.ts","../../../../frontmeans/dom-events/src/on-dom-event.ts","../../../../frontmeans/dom-events/src/dom-event-dispatcher.ts","../../../../proc7ts/context-values/src/updatable/context-destroyed.ts","../../../../proc7ts/context-values/src/updatable/context-up-key.ts","../../../../proc7ts/context-values/src/updatable/conventional/apply-context-after.ts","../../../../proc7ts/context-values/src/updatable/fn-context-key.ts","../../../../proc7ts/context-values/src/updatable/modules/context-module-dependency-error.ts","../../../../proc7ts/context-values/src/updatable/modules/context-module-usage.impl.ts","../../../../proc7ts/context-values/src/updatable/modules/context-module-key.impl.ts","../../../../proc7ts/context-values/src/updatable/modules/context-module.impl.ts","../../../../proc7ts/context-values/src/updatable/modules/context-module.ts","../../../../frontmeans/dom-primitives/src/node-document.ts","../../../../frontmeans/dom-primitives/src/node-types.ts","../../../../frontmeans/dom-primitives/src/import-node.ts","../../../../frontmeans/dom-primitives/src/node-host.ts","../../../../frontmeans/render-scheduler/src/render-schedule.ts","../../../../frontmeans/dom-primitives/src/node-window.ts","../../../../frontmeans/render-scheduler/src/custom-render-scheduler.ts","../../../../frontmeans/render-scheduler/src/render-queue.ts","../../../../frontmeans/render-scheduler/src/animation-render-scheduler.ts","../../../../frontmeans/render-scheduler/src/async-render-scheduler.ts","../../../../frontmeans/render-scheduler/src/immediate-render-scheduler.ts","../../../../frontmeans/render-scheduler/src/queued-render-scheduler.ts","../../../../frontmeans/render-scheduler/src/render-scheduler.ts","../../../../frontmeans/drek/src/context.registrar.impl.ts","../../../../frontmeans/drek/src/common/build.ts","../../../../frontmeans/drek/src/placement.status.impl.ts","../../../../frontmeans/drek/src/placement.ts","../../../../frontmeans/drek/src/context.ts","../../../../frontmeans/drek/src/context.impl.ts","../../../../frontmeans/drek/src/context.of-document.impl.ts","../../../../frontmeans/drek/src/context.of-root-node.impl.ts","../../../../frontmeans/drek/src/context-of.ts","../../../../frontmeans/drek/src/common/css-classes.ts","../../../../frontmeans/drek/src/fragment/fragment.context.impl.ts","../../../../frontmeans/drek/src/fragment/fragment.ts","../../../../frontmeans/drek/src/target/appender.target.ts","../../../../frontmeans/drek/src/target/charger.target.ts","../../../../proc7ts/workbench/src/work-done-error.ts","../../../../proc7ts/workbench/src/workload.ts","../../../../proc7ts/workbench/src/stages/ordered-tasks.impl.ts","../../../../proc7ts/workbench/src/stages/work-ordering.impl.ts","../../../../proc7ts/workbench/src/stages/work-stage.ts","../../../../proc7ts/workbench/src/workbench.impl.ts","../../../../proc7ts/workbench/src/workbench.ts","../../../../frontmeans/httongue/src/escape-css.ts","../../../../frontmeans/httongue/src/escape-css-val.ts","../../../../frontmeans/httongue/src/hyphenate.impl.ts","../../../../frontmeans/httongue/src/hyphenate.ts","../../../wesib/src/boot/bootstrap-context.key.impl.ts","../../../wesib/src/boot/bootstrap-context.ts","../../../wesib/src/boot/bootstrap-default.ts","../../../wesib/src/common/meta-accessor.ts","../../../wesib/src/feature/init-method.impl.ts","../../../wesib/src/feature/feature-def.ts","../../../wesib/src/feature/feature.amendment.ts","../../../wesib/src/feature/feature-context.ts","../../../wesib/src/feature/loader/bootstrap-workbench.impl.ts","../../../wesib/src/component/component-def.ts","../../../wesib/src/component/component.amendment.ts","../../../wesib/src/component/component-context.key.impl.ts","../../../wesib/src/component/component-event-dispatcher.key.impl.ts","../../../wesib/src/component/content-root.ts","../../../wesib/src/component/state-updater.ts","../../../wesib/src/component/component-context.ts","../../../wesib/src/component/component-member.amendment.ts","../../../wesib/src/component/component-slot.impl.ts","../../../wesib/src/component/component-slot.ts","../../../wesib/src/boot/impl/bootstrap-context-registry.impl.ts","../../../wesib/src/boot/impl/component-context-registry.impl.ts","../../../wesib/src/boot/impl/definition-context-registry.impl.ts","../../../wesib/src/boot/impl/post-def-setup.impl.ts","../../../wesib/src/boot/globals/bootstrap-window.ts","../../../wesib/src/boot/globals/default-namespace-aliaser.ts","../../../wesib/src/boot/globals/render-scheduler.key.impl.ts","../../../wesib/src/boot/globals/default-pre-render-scheduler.ts","../../../wesib/src/boot/globals/default-render-scheduler.ts","../../../wesib/src/boot/globals/document-render-kit.ts","../../../wesib/src/boot/impl/definition-context.symbol.impl.ts","../../../wesib/src/component/definition/custom-elements.ts","../../../../proc7ts/primitives/src/promises/promise-resolver.ts","../../../wesib/src/component/definition/definition.context.key.impl.ts","../../../wesib/src/component/definition/element-def.ts","../../../wesib/src/component/definition/definition-context.ts","../../../wesib/src/component/definition/component.impl.ts","../../../wesib/src/boot/impl/component-status.impl.ts","../../../../proc7ts/fun-events/src/processors/filter-on.ts","../../../wesib/src/boot/impl/component-context.impl.ts","../../../wesib/src/boot/impl/custom-element.impl.ts","../../../wesib/src/boot/impl/when-component.impl.ts","../../../wesib/src/boot/impl/definition-context.impl.ts","../../../wesib/src/boot/impl/element-builder.impl.ts","../../../wesib/src/feature/loader/component-registry.impl.ts","../../../wesib/src/feature/loader/feature-context.impl.ts","../../../wesib/src/feature/loader/feature-module.impl.ts","../../../wesib/src/boot/impl/when-defined.impl.ts","../../../wesib/src/feature/attributes/attribute-path.ts","../../../wesib/src/feature/attributes/attribute-state-update.impl.ts","../../../wesib/src/feature/attributes/attribute-registry.ts","../../../wesib/src/feature/attributes/attribute.amendment.ts","../../../wesib/src/feature/attributes/attribute-descriptor.impl.ts","../../../wesib/src/feature/state/component-state.ts","../../../wesib/src/feature/attributes/track-attribute.ts","../../../wesib/src/feature/render/render-def.ts","../../../wesib/src/feature/render/component-render-ctl.impl.ts","../../../wesib/src/feature/render/component-render-ctl.ts","../../../wesib/src/feature/render/component-render-scheduler.ts","../../../wesib/src/feature/shadow-dom/shadow-content-root.ts","../../../wesib/src/feature/shadow-dom/shadow-root-builder.ts","../../../wesib/src/feature/shadow-dom/attach-shadow.amendment.ts","../../../wesib/src/wesib.ns.ts","../../../../proc7ts/delta-set/src/delta-set.ts","../../../../frontmeans/input-aspects/src/applied-aspect.ts","../../../../frontmeans/input-aspects/src/aspect.ts","../../../../frontmeans/input-aspects/src/aspects/namespace-aliaser.aspect.ts","../../../../frontmeans/input-aspects/src/aspects/render-scheduler.aspect.ts","../../../../frontmeans/input-aspects/src/aspects/role.aspect.ts","../../../../frontmeans/input-aspects/src/aspect.impl.ts","../../../../frontmeans/input-aspects/src/noop-converter.impl.ts","../../../../frontmeans/input-aspects/src/converter.ts","../../../../frontmeans/input-aspects/src/builder.impl.ts","../../../../frontmeans/input-aspects/src/builder.ts","../../../../frontmeans/input-aspects/src/control.impl.ts","../../../../frontmeans/input-aspects/src/control.ts","../../../../frontmeans/input-aspects/src/containers/container.control.ts","../../../../frontmeans/input-aspects/src/containers/parents.aspect.ts","../../../../frontmeans/input-aspects/src/element.control.ts","../../../../frontmeans/input-aspects/src/data/mode.aspect.ts","../../../../frontmeans/input-aspects/src/data/data.aspect.ts","../../../../frontmeans/input-aspects/src/containers/group.control.ts","../../../../frontmeans/input-aspects/src/validation/require-nothing.validator.ts","../../../../frontmeans/input-aspects/src/validation/validator.impl.ts","../../../../frontmeans/input-aspects/src/validation/validator.ts","../../../../frontmeans/input-aspects/src/validation/validation.aspect.ts","../../../../frontmeans/input-aspects/src/validation/require-all.validator.ts","../../../../frontmeans/input-aspects/src/validation/require-present.validator.ts","../../../../frontmeans/input-aspects/src/submit.aspect.ts","../../../../frontmeans/input-aspects/src/elements/abstract-element.control.ts","../../../../frontmeans/input-aspects/src/elements/text.control.ts","../../../../frontmeans/input-aspects/src/elements/focus/focus.aspect.ts","../../../../frontmeans/input-aspects/src/elements/focus/status.aspect.ts","../../../../frontmeans/input-aspects/src/elements/forms/form-element.control.ts","../../../../frontmeans/input-aspects/src/data/modes/mode-by-form.ts","../../../../frontmeans/input-aspects/src/elements/style/styled-element.aspect.ts","../../../../frontmeans/input-aspects/src/elements/style/css-classes.aspect.ts","../../../../frontmeans/input-aspects/src/elements/style/css-error.ts","../../../../frontmeans/input-aspects/src/elements/style/css-info.ts","../../../../hatsy/http-header-value/src/impl/hthv-item.ts","../../../../hatsy/http-header-value/src/parser/add-param.ts","../../../../hatsy/http-header-value/src/parser/parse-none.ts","../../../../hatsy/http-header-value/src/parser/date-time-parser.ts","../../../../hatsy/http-header-value/src/parser/next-in-item.ts","../../../../hatsy/http-header-value/src/parser/item-parser.ts","../../../../hatsy/http-header-value/src/parser/angle-brackets-parser.ts","../../../../hatsy/http-header-value/src/parser/quoted-string-parser.ts","../../../../hatsy/http-header-value/src/parser/next-in-comment.ts","../../../../hatsy/http-header-value/src/parser/spaces-parser.ts","../../../../hatsy/http-header-value/src/parser/param-parser.ts","../../../../hatsy/http-header-value/src/parser/parser-config.ts","../../../../hatsy/http-header-value/src/hthv-parser.ts","../../../../hatsy/http-header-value/src/parser/item-delimit-parser.ts","../../../../hatsy/http-header-value/src/parser/comment-parser.ts","../../../../hatsy/http-header-value/src/hthv-parse.ts","../../../../hatsy/http-header-value/src/hthv-quote.ts","../../../generic/src/fetch/fetch-agent-key.impl.ts","../../../generic/src/fetch/http-fetch-agent.ts","../../../generic/src/fetch/http-fetch.impl.ts","../../../generic/src/fetch/http-fetch.ts","../../../generic/src/fragment/fragment-render-ctl.ts","../../../generic/src/fragment/render-fragment.amendment.ts","../../../generic/src/navigation/hash-url/hash-url.ts","../../../generic/src/navigation/page-param.ts","../../../generic/src/navigation/navigation-agent.ts","../../../generic/src/navigation/page-param-context.ts","../../../generic/src/navigation/nav-history.impl.ts","../../../generic/src/navigation/navigation.event.ts","../../../generic/src/navigation/navigation.ts","../../../generic/src/navigation/nav-links/nav-element.ts","../../../../frontmeans/drek/src/common/derive-context.ts","../../../generic/src/navigation/nav-links/nav-menu.ts","../../../generic/src/navigation/page-load/page-load-agent.ts","../../../generic/src/navigation/page-load/caching-page-loader.impl.ts","../../../generic/src/navigation/page-load/page-load-requests.impl.ts","../../../generic/src/navigation/page-load/page-load-url-modifier.ts","../../../generic/src/navigation/page-load/page-loader.impl.ts","../../../generic/src/navigation/page-load/page-load-param.ts","../../../generic/src/navigation/page-load/page-cache-buster.impl.ts","../../../generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../../generic/src/navigation/page-load/page-style-agent.impl.ts","../../../generic/src/navigation/page-load/page-title-agent.impl.ts","../../../generic/src/navigation/page-load/page-load-support.feature.ts","../../../generic/src/navigation/page-render/page-render-ctl.ts","../../../generic/src/shares/share-ref.ts","../../../generic/src/shares/share-registry.impl.ts","../../../generic/src/shares/share-key.impl.ts","../../../generic/src/shares/share.impl.ts","../../../generic/src/shares/shared-value.ts","../../../generic/src/shares/shared-value.impl.ts","../../../../proc7ts/context-values/src/conventional/apply-context-to.ts","../../../generic/src/shares/share.ts","../../../generic/src/shares/share-locator.ts","../../../generic/src/shares/shareable.ts","../../../generic/src/shares/share-accessor.impl.ts","../../../generic/src/shares/shared.amendment.ts","../../../generic/src/shares/target-share.ts","../../../generic/src/forms/default.preset.impl.ts","../../../generic/src/forms/form-preset.ts","../../../generic/src/forms/form-unit.ts","../../../generic/src/forms/field.ts","../../../generic/src/forms/field.share.ts","../../../generic/src/forms/form.share.ts","../../../generic/src/forms/adjacent-field.ts","../../../generic/src/forms/field.impl.ts","../../../generic/src/forms/field-name.amendment.ts","../../../generic/src/forms/form.ts","../../../generic/src/forms/form-scope.ts","../../../generic/src/forms/presets/abstract-form-preset.ts","../../../generic/src/forms/scoped-form-config.ts","../../../generic/src/forms/shared-field.amendment.ts","../../../../frontmeans/style-producer/src/internal/types.ts","../../../../frontmeans/style-producer/src/value/value.ts","../../../../frontmeans/style-producer/src/value/color/color.ts","../../../../frontmeans/style-producer/src/value/color/mix.ts","../../../../frontmeans/style-producer/src/value/numeric/numeric.ts","../../../../frontmeans/style-producer/src/value/mapper.ts","../../../../frontmeans/style-producer/src/value/priority.ts","../../../../frontmeans/style-producer/src/internal/css.ts","../../../../frontmeans/style-producer/src/value/numeric/numeric.impl.ts","../../../../frontmeans/style-producer/src/value/numeric/zero.impl.ts","../../../../frontmeans/style-producer/src/value/numeric/dimension-kind.impl.ts","../../../../frontmeans/style-producer/src/value/unit/length.ts","../../../../frontmeans/style-producer/src/value/url.ts","../../../../frontmeans/style-producer/src/rule/properties.impl.ts","../../../../frontmeans/style-producer/src/selector/selector.impl.ts","../../../../frontmeans/style-producer/src/selector/query.ts","../../../../frontmeans/style-producer/src/selector/selector-constructor.ts","../../../../frontmeans/style-producer/src/selector/selector-text.impl.ts","../../../../frontmeans/style-producer/src/producer/renderers/at-rules.renderer.ts","../../../../frontmeans/style-producer/src/producer/renderers/renderer.impl.ts","../../../../frontmeans/style-producer/src/producer/renderers/globals.renderer.ts","../../../../frontmeans/style-producer/src/producer/renderers/properties.renderer.ts","../../../../frontmeans/style-producer/src/producer/renderers/text.renderer.ts","../../../../frontmeans/style-producer/src/producer/renderers/xml-ns.renderer.ts","../../../../frontmeans/style-producer/src/producer/formats/format.impl.ts","../../../../frontmeans/style-producer/src/producer/formats/text.format.ts","../../../../frontmeans/style-producer/src/producer/formats/dom.format.ts","../../../../frontmeans/style-producer/src/producer/formats/object.format.ts","../../../../frontmeans/style-producer/src/producer/produce-basic-style.ts","../../../../frontmeans/style-producer/src/selector/selector-text.ts","../../../../frontmeans/style-producer/src/producer/renderers/default-renderers.impl.ts","../../../../frontmeans/style-producer/src/producer/produce-style.ts","../../../../frontmeans/style-producer/src/rule/rule.ts","../../../../frontmeans/style-producer/src/rule/rules.impl.ts","../../../../frontmeans/style-producer/src/rule/rule.impl.ts","../../../../frontmeans/style-producer/src/rule/root.ts","../../../../frontmeans/style-producer/src/rule/rule-ref.ts","../../../../frontmeans/style-producer/src/rule/rule-refs.ts","../../../../frontmeans/style-producer/src/rule/rules.ts","../../../generic/src/styp/component-style-producer.ts","../../../generic/src/styp/component-styp-dom.format-config.ts","../../../generic/src/styp/component-styp-renderer.ts","../../../generic/src/styp/element-id-class.impl.ts","../../../generic/src/styp/component-styp-format.ts","../../../generic/src/styp/component-styp-dom.format.ts","../../../generic/src/styp/produce-style.amendment.ts","../../../generic/src/styp/style-producer-support.feature.ts","../../../generic/src/theme/theme-style.ts","../../../generic/src/theme/theme.ts","../../src/common/examples.ns.ts","../../src/common/theme/theme-settings.ts","../../src/common/theme/link.style.ts","../../src/common/theme/default.style.ts","../../src/common/theme/body.style.ts","../../src/common/forms/form.theme-settings.ts","../../src/common/forms/field-error.component.ts","../../src/common/forms/forms-support.feature.ts","../../../generic/src/forms/presets/form-mode.preset.ts","../../../../frontmeans/input-aspects/src/data/modes/mode-by-validity.ts","../../../generic/src/forms/presets/form-css.preset.ts","../../src/common/layout/main.component.ts","../../../generic/src/navigation/page-render/render-page.amendment.ts","../../../../frontmeans/drek/src/target/replacer.target.ts","../../../../frontmeans/dom-primitives/src/remove-node-content.ts","../../src/common/layout/nav.component.ts","../../../../proc7ts/push-iterator/src/transformation/map-indexed.ts","../../../generic/src/navigation/nav-links/nav-anchor.ts","../../src/common/layout/container.component.ts","../../src/common/layout/layout-support.feature.ts","../../src/common/theme/body-style-support.feature.ts","../../src/common/app.feature.ts","../../src/common/forms/form.style.ts","../../src/common/index.ts","../../../wesib/src/boot/bootstrap/bootstrap-components.ts"],"sourcesContent":["/**\n * Checks whether the given value is an array.\n *\n * @param value - Either element, array of elements, `null`, or `undefined`.\n *\n * @returns `true` if the given `value` is an array, or `false` otherwise.\n */\nexport function isArrayOfElements<T>(value: T | T[] | null | undefined): value is T[];\n\n/**\n * Checks whether the given value is a readonly array.\n *\n * @param value - Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns `true` if the given `value` is an array, or `false` otherwise.\n */\nexport function isArrayOfElements<T>(value: T | readonly T[] | null | undefined): value is readonly T[];\n\nexport function isArrayOfElements<T>(value: T | readonly T[] | null | undefined): value is T[] {\n  return Array.isArray(value);\n}\n\n/**\n * Converts element or array of elements to array of elements.\n *\n * @param value - Either element, array of elements, `null`, or `undefined`.\n *\n * @returns The `value` itself if it is an array, empty array if `value` is `null` or `undefined`, or an array\n * containing only `value` otherwise.\n */\nexport function arrayOfElements<T>(value: T | T[] | null | undefined): T[];\n\n/**\n * Converts element or readonly array of elements to readonly array of elements.\n *\n * @param value - Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns The `value` itself if it is an array, empty array if the `value` is `null` or `undefined`, or an array\n * containing only `value` otherwise.\n */\nexport function arrayOfElements<T>(value: T | readonly T[] | null | undefined): readonly T[];\n\nexport function arrayOfElements<T>(value: T | T[] | null | undefined): T[] {\n  return (/*#__INLINE__*/ isArrayOfElements(value)) ? value : value != null ? [value] : [];\n}\n","/**\n * Checks whether two values are the same. I.e. strictly equal to each other.\n *\n * @typeParam T - A type of values.\n * @param first - First value to compare.\n * @param second - Second value to compare.\n *\n * @returns `true` if `first === second`, or `false` otherwise.\n */\nexport function areTheSame<T>(first: T, second: T): boolean {\n  return first === second;\n}\n","/**\n * Creates a provider of the only argument.\n *\n * @param value - A value to return.\n *\n * @returns A function that returns `value`.\n */\nexport function valueProvider<T>(value: T): (this: void) => T {\n  return (): T => value;\n}\n\n/**\n * Creates a provider of arguments tuple.\n *\n * The returned tuple should never be modified as it is not cloned.\n *\n * @param values - Values to return.\n *\n * @returns A function that returns `values` tuple.\n */\nexport function valuesProvider<T extends readonly any[]>(...values: T): (this: void) => T {\n  return (): T => values;\n}\n\n/**\n * Creates a provider of cloned arguments tuple.\n *\n * The returned tuple can be modified as it is cloned before the return.\n *\n * @param values - Values to return.\n *\n * @returns A function that returns a clone of `values` tuple.\n */\nexport function valuesCloner<T extends any[]>(...values: T): (this: void) => T {\n  return (): T => values.slice() as T;\n}\n","import { valueProvider } from './value-providers';\n\n/**\n * Creates a provider of lazily evaluated value.\n *\n * The returned function evaluates the value first time it is called. Then it just returns previously evaluated value.\n *\n * @param provider - A no-arg function evaluating the value.\n *\n * @returns A function that returns the value evaluated by `provider`.\n */\nexport function lazyValue<T>(provider: (this: void) => T): (this: void) => T {\n\n  let get = (): T => {\n    get = lazyValue$recurrent; // Prevent recurrent evaluation\n\n    const value = provider();\n\n    get = valueProvider(value);\n\n    return value;\n  };\n\n  return (): T => get();\n}\n\nfunction lazyValue$recurrent(): never {\n  throw new TypeError('Recurrent evaluation');\n}\n","import { valueProvider } from './value-providers';\n\n/**\n * A recipe of value evaluation.\n *\n * This is either a value as-is, or its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n */\nexport type ValueRecipe<TValue, TArgs extends any[] = []> =\n    | TValue\n    | ValueRecipe.Evaluator<TValue, TArgs>;\n\nexport namespace ValueRecipe {\n\n  /**\n   * Value evaluator signature.\n   *\n   * @typeParam TValue - Evaluated value type. This can not be a function.\n   * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n   */\n  export type Evaluator<TValue, TArgs extends any[] = []> =\n  /**\n   * @param args - Parameters required for value evaluation.\n   *\n   * @returns Evaluated value.\n   */\n      (this: void, ...args: TArgs) => TValue;\n\n}\n\n/**\n * @internal\n */\nfunction isValueEvaluator<TValue, TArgs extends any[]>(\n    value: ValueRecipe<TValue, TArgs>,\n): value is ValueRecipe.Evaluator<TValue, TArgs> {\n  return typeof value === 'function';\n}\n\n/**\n * Evaluates a value by its recipe.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Value evaluation recipe.\n * @param args - Parameters required for value evaluation.\n *\n * @returns Either the value itself, or the one evaluated by the given evaluator recipe.\n */\nexport function valueByRecipe<TValue, TArgs extends any[]>(\n    recipe: ValueRecipe<TValue, TArgs>,\n    ...args: TArgs\n): TValue {\n  return (/*#__INLINE__*/ isValueEvaluator(recipe)) ? recipe(...args) : recipe;\n}\n\n/**\n * Converts a value recipe to its {@link ValueRecipe.Evaluator evaluator} function.\n *\n * @typeParam TValue - Evaluated value type. This can not be a function.\n * @typeParam TArgs - A type of parameters tuple required for value evaluation.\n * @param recipe - Value recipe to convert.\n *\n * @returns Either evaluator itself, or the one evaluating to the given value.\n */\nexport function valueRecipe<TValue, TArgs extends any[]>(\n    recipe: ValueRecipe<TValue, TArgs>,\n): ValueRecipe.Evaluator<TValue, TArgs> {\n  return (/*#__INLINE__*/ isValueEvaluator(recipe)) ? recipe : valueProvider(recipe);\n}\n","import { areTheSame } from '../value';\n\n/**\n * Checks whether two arrays are equal.\n *\n * @typeParam T - Array elements type.\n * @param first - First array to compare.\n * @param second - Second array to compare.\n * @param length - The maximum number of elements to compare. Defaults to array length. Negative value means `0`.\n *\n * @returns `true` if up to `length` corresponding array elements are strictly equal to each other.\n */\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    length?: number | null,\n): boolean;\n\n/**\n * Checks whether two array ranges are equal.\n *\n * @typeParam T - Array elements type.\n * @param first - First array to compare.\n * @param second - Second array to compare. Negative or absent value means `0`.\n * @param from - The first element index to compare. Negative value means `0`. Absent value means array length.\n * @param to - The number one more than the last element index to compare.\n *\n * @returns `true` if all corresponding elements in corresponding array ranges are strictly equal to each other.\n */\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    from: number | null | undefined,\n    to: number | null,\n): boolean;\n\n/**\n * Checks whether two arrays are equal by comparing corresponding elements with the given comparator function.\n *\n * @typeParam T - Array elements type.\n * @param first - First array to compare.\n * @param elementsAreEqual - Array elements comparator. Accepts elements to compare and their index as arguments.\n * Returns `true` if elements are equal, or `false` otherwise.\n * @param second - Second array to compare.\n * @param length - The maximum number of elements to compare. Defaults to array length.\n *\n * @returns `true` if `elementsAreEqual` comparator returned `true` for up to `length` corresponding array element\n * pairs.\n */\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    elementsAreEqual: (this: void, first: T, second: T, index: number) => boolean,\n    length?: number | null,\n): boolean;\n\n/**\n * Checks whether two array ranges are equal by comparing corresponding elements with the given comparator function.\n *\n * @typeParam T - Array elements type.\n * @param first - First array to compare.\n * @param elementsAreEqual - Array elements comparator. Accepts elements to compare and their index as arguments.\n * Returns `true` if elements are equal, or `false` otherwise.\n * @param second - Second array to compare.\n * @param from - The first element index to compare. Negative value means `0`. Absent value means array length.\n * @param to - The number one more than the last element index to compare.\n *\n * @returns `true` if `elementsAreEqual` comparator returned `true` for up to `length` corresponding array element\n * pairs.\n */\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    elementsAreEqual: (this: void, first: T, second: T, index: number) => boolean,\n    from: number | null | undefined,\n    to: number | null,\n): boolean;\n\nexport function arraysAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    compareOrFromOrLength?: ((this: void, first: T, second: T, index: number) => boolean) | number | null,\n    fromOrLength?: number | null,\n    to?: number | null,\n): boolean {\n  return typeof compareOrFromOrLength === 'function'\n      ? arrayElementsAreEqual(\n          first,\n          second,\n          compareOrFromOrLength,\n          fromOrLength,\n          to,\n      )\n      : arrayElementsAreEqual(\n          first,\n          second,\n          areTheSame,\n          compareOrFromOrLength,\n          fromOrLength,\n      );\n}\n\nfunction arrayElementsAreEqual<T>(\n    first: ArrayLike<T>,\n    second: ArrayLike<T>,\n    elementsAreEqual: (this: void, first: T, second: T, index: number) => boolean,\n    fromOrLength?: number | null,\n    to?: number | null,\n): boolean {\n\n  let start: number;\n  let end: number;\n\n  if (to !== undefined) {\n    start = fromOrLength ? Math.max(fromOrLength, 0) : 0;\n    end = to != null ? to : Math.max(first.length, second.length);\n  } else if (fromOrLength != null) {\n    start = 0;\n    end = fromOrLength;\n  } else {\n    start = 0;\n    end = Math.max(first.length, second.length);\n  }\n\n  if ((first.length <= end || second.length <= end) && first.length !== second.length) {\n    return false;\n  }\n\n  for (let i = start; i < end; ++i) {\n    if (!elementsAreEqual(first[i], second[i], i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * Builds element or array of the given elements.\n *\n * @param source - A source of elements as their iterable or array-like container.\n *\n * @returns The only element of the `source`, an array of all elements of non-empty source, or `undefined` if the\n * `source` is empty.\n */\nexport function elementOrArray<T>(source: Iterable<T> | ArrayLike<T>): T | T[] | undefined {\n\n  const array = Array.from(source);\n  const { length } = array;\n\n  if (length) {\n    return length === 1 ? array[0] : array;\n  }\n\n  return;\n}\n","import { isArrayOfElements } from './array-of-elements';\n\n/**\n * Builds a set of the given element or array of elements.\n *\n * @param elements Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns A new set containing all of the given elements, or empty set if `elements` is `null` or `undefined`.\n */\nexport function setOfElements<T>(elements: T | readonly T[] | null | undefined): Set<T> {\n  return (/*#__INLINE__*/ isArrayOfElements(elements))\n      ? new Set(elements)\n      : (elements != null ? new Set([elements]) : new Set());\n}\n\n/**\n * Adds element of array of elements to the given set.\n *\n * Adds to the set a single element, all `elements` of the given array, or nothing when `elements` is `null`\n * or `undefined`.\n *\n * @param set - Target set to add elements to.\n * @param elements - Element(s) to add to the `set`. Either element, readonly array of elements, `null`, or `undefined`.\n *\n * @returns The target `set`.\n */\nexport function extendSetOfElements<T>(set: Set<T>, elements: T | readonly T[] | null | undefined): Set<T> {\n  if (/*#__INLINE__*/ isArrayOfElements(elements)) {\n    elements.forEach(element => set.add(element));\n  } else if (elements != null) {\n    set.add(elements);\n  }\n  return set;\n}\n","import type { AbstractClass } from './abstract-class';\n\n/**\n * Detects a super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @param type - The class constructor to find super class of.\n * @param satisfying - The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(\n    type: AbstractClass,\n    satisfying: (this: void, type: AbstractClass) => boolean = () => true,\n): AbstractClass | undefined {\n\n  const prototype = Reflect.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as AbstractClass;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * A function that returns its argument as is.\n *\n * @param value - A value to return.\n *\n * @returns `value`.\n */\nexport function asis<T>(value: T): T {\n  return value;\n}\n","/**\n * Counts meaningful arguments passed to function.\n *\n * Ignores trailing `undefined` values.\n *\n * @param args - Function call arguments tuple.\n *\n * @returns The number of arguments, except for the trailing `undefined` values.\n */\nexport function countArgs(args: ArrayLike<unknown>): number {\n\n  let len = args.length;\n\n  while (len > 0) {\n\n    const idx = len - 1;\n\n    if (args[idx] !== undefined) {\n      break;\n    }\n\n    len = idx;\n  }\n\n  return len;\n}\n","/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @typeParam TArgs - Function parameter types as tuple.\n * @typeParam TReturn - A type of function result.\n * @typeParam TThis - A type if `this` object expected by function.\n * @param first - The first function to call.\n * @param second - The second function to call.\n * @param merge - Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: (this: TThis, ...args: TArgs) => TReturn,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge: (first: TReturn, second: TReturn) => TReturn,\n): (this: TThis, ...args: TArgs) => TReturn;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: (this: TThis, ...args: TArgs) => TReturn,\n    merge?: (first: TReturn, second: TReturn) => TReturn,\n): (this: TThis, ...args: TArgs) => TReturn;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge?: (first: TReturn, second: TReturn) => TReturn,\n): ((this: TThis, ...args: TArgs) => TReturn) | undefined;\n\nexport function mergeFunctions<TArgs extends any[], TReturn, TThis>(\n    first: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    second: ((this: TThis, ...args: TArgs) => TReturn) | undefined,\n    merge: (first: TReturn, second: TReturn) => TReturn = (_f, s) => s,\n): ((this: TThis, ...args: TArgs) => TReturn) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function (this: TThis, ...args: TArgs): TReturn {\n    return merge(\n        first.apply(this, args),\n        second.apply(this, args),\n    );\n  };\n}\n","/**\n * A function that does nothing.\n *\n * @returns `undefined`.\n */\nexport function noop(): undefined {\n  return;\n}\n","const hasOwnProperty$ = Object.prototype.hasOwnProperty;\n\n/**\n * Checks whether the `target` object has own property with the given `key`.\n *\n * This is a safer variant of `target.hasOwnProperty(key)` call.\n *\n * @param target - Target object to check.\n * @param key - A key of the property to check.\n *\n * @returns `true` if `target` object has own property with the given `key`, or `false` otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\n */\nexport function hasOwnProperty(target: object, key: PropertyKey): boolean {\n  return hasOwnProperty$.call(target, key);\n}\n","/**\n * A function that checks whether the given value is present.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is not `null` or `undefined`, or `false` otherwise.\n */\nexport function isPresent<T>(value: T | undefined | null): value is T {\n  return value != null;\n}\n\n/**\n * A function that checks whether the given value is not present.\n *\n * This is a direct opposite to `isPresent()`.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is `null` or `undefined`, or `false` otherwise.\n */\nexport function isNotPresent<T>(value: T | undefined | null): value is T {\n  return value == null;\n}\n\n/**\n * A function that checks whether the given value is defined.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is not `undefined`, or `false` otherwise.\n */\nexport function isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n/**\n * A function that checks whether the given value is undefined.\n *\n * This is a direct opposite to `isDefined()`.\n *\n * @param value - A value to check.\n *\n * @returns `true` when the given `value` is `undefined`, or `false` otherwise.\n */\nexport function isUndefined<T>(value: T | undefined): value is T {\n  return value === undefined;\n}\n","import type { PushIterator } from './push-iterator';\n\n/**\n * A key of {@link PushIterable} iteration method.\n */\nexport const PushIterator__symbol = (/*#__PURE__*/ Symbol('push-iterator'));\n\n/**\n * An iterable implementing push iteration protocol.\n *\n * @typeParam T - Iterated elements type.\n */\nexport interface PushIterable<T> extends Iterable<T> {\n\n  /**\n   * Creates a {@link PushIterator | push iterator} over elements of this iterable.\n   *\n   * @returns New push iterator instance.\n   */\n  [Symbol.iterator](): PushIterator<T>;\n\n  /**\n   * Iterates over elements of this push iterable.\n   *\n   * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n   * `true` or `false`.\n   *\n   * Calling this method with `accept` parameter is a faster alternative to creating a push iterator and iterating with\n   * it.\n   *\n   * Calling this method without arguments is the same as calling `[Symbol.iterator]()` one.\n   *\n   * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n   * `true` to suspend iteration, or `false` to stop it.\n   *\n   * @returns A push iterator instance to continue iteration with. If `accept` returned `false` then further iteration\n   * won't be possible with returned iterator.\n   */\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<T>): PushIterator<T>;\n\n}\n\nexport namespace PushIterable {\n\n  /**\n   * A signature of function conforming to push iteration protocol.\n   *\n   * Used as `PushIterable[PushIterator__symbol]` method implementation when passed to {@link makePushIterable}\n   * function.\n   *\n   * @typeParam T - Iterated elements type.\n   */\n  export type Iterate<T> =\n  /**\n   * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n   * `true` to suspend iteration, or `false` to stop it.\n   *\n   * @returns A push iterator instance to continue iteration with. If `accept` returned `false` then further iteration\n   * won't be possible with returned iterator.\n   */\n      (this: void, accept?: PushIterator.Acceptor<T>) => PushIterator<T>;\n\n}\n","import type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Checks whether the given iterable conforms to {@link PushIterable | push iteration protocol}.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to check.\n *\n * @returns `true` if the given `iterable` has a {@link PushIterator__symbol [PushIterator__symbol]} property,\n * or `false` otherwise.\n */\nexport function isPushIterable<T>(iterable: Iterable<T>): iterable is PushIterable<T>;\n\n/**\n * Checks whether the given iterator conforms to {@link PushIterable | push iteration protocol}.\n *\n * @typeParam T - Iterated elements type.\n * @param iterator - An iterator to check.\n *\n * @returns `true` if the given `iterator` has a {@link PushIterator__symbol | [PushIterator__symbol]} property,\n * or `false` otherwise.\n */\nexport function isPushIterable<T>(iterator: Iterator<T>): iterator is PushIterator<T>;\n\nexport function isPushIterable<T>(iterable: Iterable<T> | Iterator<T>): iterable is PushIterator<T> {\n  return !!(iterable as Partial<PushIterable<T>>)[PushIterator__symbol];\n}\n","import type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a push iterator over elements of the given push `iterable`.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to construct iterator of.\n *\n * @returns Push iterator.\n */\nexport function iteratorOf<T>(iterable: PushIterable<T>): PushIterator<T>;\n\n/**\n * Creates an iterable iterator over elements of the given `iterable` supporting iterable iteration.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to construct iterator of.\n *\n * @returns Iterable iterator.\n */\nexport function iteratorOf<T>(iterable: { [Symbol.iterator](): IterableIterator<T> }): IterableIterator<T>;\n\n/**\n * Creates iterator over elements of the given `iterable`.\n *\n * Calls `iterable[Symbol.iterator]()` and returns its result.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to construct iterator of.\n *\n * @returns Either push or raw iterator.\n */\nexport function iteratorOf<T>(iterable: Iterable<T>): Iterator<T>;\n\nexport function iteratorOf<T>(iterable: Iterable<T>): Iterator<T> {\n  return iterable[Symbol.iterator]();\n}\n","import { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a push iterable implementation.\n *\n * @typeParam T - Iterated elements type.\n * @param iterate - A function iterating over iterable elements conforming to {@link PushIterable.Iterate} requirements.\n *\n * @returns New push iterable instance performing iteration by `forNext` function.\n */\nexport function makePushIterable<T>(iterate: PushIterable.Iterate<T>): PushIterable<T> {\n  return {\n    [Symbol.iterator]: PushIterable$iterator,\n    [PushIterator__symbol]: iterate,\n  };\n}\n\n/**\n * @internal\n */\nfunction PushIterable$iterator<T>(this: PushIterable<T>): PushIterator<T> {\n  return this[PushIterator__symbol]();\n}\n","import { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `!iterable[PushIterator__symbol](accept).isOver()`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nexport function pushIterated<T>(iterable: PushIterable<T>, accept: PushIterator.Acceptor<T>): boolean {\n  return !iterable[PushIterator__symbol](accept).isOver();\n}\n","import { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { pushIterated } from './push-iterated';\n\n/**\n * Creates a push iterator implementation.\n *\n * @typeParam T - Iterated elements type.\n * @param forNext - A function iterating over elements conforming to push iteration protocol.\n *\n * @returns New push iterator instance performing iteration by `forNext` function.\n */\nexport function makePushIterator<T>(forNext: PushIterator.Pusher<T>): PushIterator<T> {\n\n  let over = false;\n  let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n    if (accept && !forNext(accept)) {\n      over = true;\n      iterate = PushIterator$dontIterate;\n    }\n  };\n\n  return {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](accept) {\n      iterate(accept);\n      return this;\n    },\n    next: PushIterator$next,\n    isOver: () => over,\n  };\n}\n\n/**\n * @internal\n */\nexport function PushIterator$iterator<T>(this: T): T {\n  return this;\n}\n\n/**\n * @internal\n */\nexport function PushIterator$next<T>(this: PushIterator<T>): IteratorResult<T> {\n  for (; ;) {\n\n    let result: IteratorYieldResult<T> | undefined;\n    const over = !pushIterated(\n        this,\n        value => {\n          result = { value };\n          return true;\n        },\n    );\n\n    if (result) {\n      return result;\n    }\n    if (over) {\n      return { done: true } as IteratorReturnResult<T>;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function PushIterator$noNext<T>(): IteratorReturnResult<T> {\n  return { done: true } as IteratorReturnResult<T>;\n}\n\n/**\n * @internal\n */\nexport function PushIterator$dontIterate<T>(\n    _accept?: PushIterator.Acceptor<T>, // unused parameter to prevent deoptimization\n): void {\n  /* do not iterate */\n}\n\n/**\n * @internal\n */\nexport const emptyPushIterator: PushIterator<any> & PushIterable<any> = {\n  [Symbol.iterator]: PushIterator$iterator,\n  [PushIterator__symbol](\n      _accept, // unused parameter to prevent deoptimization\n  ) {\n    return this;\n  },\n  next: () => ({ done: true } as IteratorReturnResult<unknown>),\n  isOver: () => true,\n};\n","import { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over the head elements of the given push iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * Calling this function is the same as calling `iterable[PushIterator__symbol](accept)`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - A push iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nexport function pushHead<T>(iterable: PushIterable<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  return iterable[PushIterator__symbol](accept);\n}\n","import type { IndexedItemList } from '../construction';\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport {\n  emptyPushIterator,\n  PushIterator$dontIterate,\n  PushIterator$iterator,\n  PushIterator$noNext,\n} from './make-push-iterator';\n\n/**\n * @internal\n */\nexport interface IndexedElements {\n\n  readonly length: number;\n\n}\n\n/**\n * @internal\n */\nexport function indexedItemOf<T>(indexed: IndexedItemList<T>, index: number): T {\n  return indexed.item(index) as T; // The index is always valid.\n}\n\n/**\n * @internal\n */\nexport function iterateOverIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementOf: (indexed: TIndexed, index: number) => T,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      if (i >= indexed.length) {\n        return false;\n      }\n      for (; ;) {\n\n        const goOn = accept(elementOf(indexed, i++));\n\n        if (i >= indexed.length || goOn === false) {\n          return false;\n        }\n        if (goOn === true) {\n          return true;\n        }\n      }\n    };\n\n    if (accept && !forNext(accept)) {\n      return emptyPushIterator;\n    }\n\n    let over = false;\n    let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n      if (accept && !forNext(accept)) {\n        over = true;\n        iterate = PushIterator$dontIterate;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        next = PushIterator$noNext;\n      }\n    };\n    let next = (): IteratorResult<T> => {\n      if (i < indexed.length) {\n        return { value: elementOf(indexed, i++) };\n      }\n\n      over = true;\n      iterate = PushIterator$dontIterate;\n      next = PushIterator$noNext;\n\n      return { done: true } as IteratorReturnResult<T>;\n    };\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        iterate(accept);\n        return this;\n      },\n      next: () => next(),\n      isOver: () => over,\n    };\n\n  };\n}\n","import type { PushIterable } from '../push-iterable';\nimport { iterateOverIndexed } from './iterate-over-indexed.impl';\n\n/**\n * @internal\n */\nexport function arrayElementOf<T>(array: ArrayLike<T>, index: number): T {\n  return array[index];\n}\n\n/**\n * @internal\n */\nexport function iterateOverArray<T>(array: ArrayLike<T>): PushIterable.Iterate<T> {\n  return iterateOverIndexed<ArrayLike<T>, T>(array, arrayElementOf);\n}\n","import { makePushIterable } from '../base';\nimport { iterateOverArray } from '../base/iterate-over-array.impl';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of array-like structure.\n *\n * @typeParam T - Array elements type.\n * @param array - An array-like structure. E.g. `Array`, DOM `NodeList`, etc.\n *\n * @returns New push iterable over array elements.\n */\nexport function overArray<T>(array: ArrayLike<T>): PushIterable<T> {\n  return makePushIterable<T>(iterateOverArray(array));\n}\n","import { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushIterated} function, this one accepts any iterable instance.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns `true` if there are more elements to iterate, or `false` otherwise. The former is possible only when\n * iteration suspended, i.e. `accept` returned `true`.\n */\nexport function itsIterated<T>(iterable: Iterable<T>, accept: PushIterator.Acceptor<T>): boolean {\n  if (isPushIterable(iterable)) {\n    return pushIterated(iterable, accept);\n  }\n\n  const it = iteratorOf(iterable);\n\n  if (isPushIterable(it)) {\n    return pushIterated(it, accept);\n  }\n\n  for (; ;) {\n\n    const next = it.next();\n\n    if (next.done) {\n      return false;\n    }\n\n    const status = accept(next.value);\n\n    if (typeof status === 'boolean') {\n      return status;\n    }\n  }\n}\n","import { itsIterated } from './its-iterated';\n\n/**\n * Performs the given `action` for each element of the given `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable of elements to perform actions on.\n * @param action - An action to perform on each iterable element. This is a function accepting an element as its only\n * parameter.\n */\nexport function itsEach<T>(iterable: Iterable<T>, action: (this: void, element: T) => void): void {\n  itsIterated(iterable, element => { action(element); });\n}\n","import { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * @internal\n */\nconst itsElements$defaultConverter = <T, TConv>(element: T): TConv => element as unknown as TConv;\n\n/**\n * Creates a new, shallow-copied array instance containing elements of the `source` iterable.\n *\n * Calling this function result to the same result as calling `Array.from(source)`, except it is optimized for\n * {@link PushIterable push iterables}.\n *\n * @typeParam T - Iterated elements type.\n * @param source - A source iterable to copy elements from.\n *\n * @returns New array of `source` elements.\n */\nexport function itsElements<T>(source: Iterable<T>): T[];\n\n/**\n * Creates a new, shallow-copied array instance containing elements of the `source` iterable converted by the given\n * converter function.\n *\n * Calling this function result to the same result as calling `Array.from(source, convert)`, except it is optimized for\n * {@link PushIterable push iterables}.\n *\n * @typeParam T - Iterated elements type.\n * @typeParam TConv - Resulting array elements type.\n * @param source - A source iterable to convert elements from.\n * @param convert - A function that produces an element of result array, taking element of `source` iterable as the only\n * parameter.\n *\n * @returns New array of elements converted from `source` ones.\n */\nexport function itsElements<T, TConv>(source: Iterable<T>, convert: (this: void, element: T) => TConv): TConv[];\n\nexport function itsElements<T, TConv>(\n    source: Iterable<T>,\n    convert: (this: void, element: T) => TConv = itsElements$defaultConverter,\n): TConv[] {\n  if (isPushIterable(source)) {\n    return pushedElements(source, convert);\n  }\n\n  const it = iteratorOf(source);\n\n  return isPushIterable(it) ? pushedElements(it, convert) : Array.from(source, convert);\n}\n\n/**\n * @internal\n */\nfunction pushedElements<T, TConv>(\n    it: PushIterable<T>,\n    convert: (this: void, element: T) => TConv,\n): TConv[] {\n\n  const result: TConv[] = [];\n\n  pushIterated(it, element => { result.push(convert(element)); });\n\n  return result;\n}\n","import { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Checks whether the given `iterable` is empty.\n *\n * @param iterable - An iterable or push iterable to check for elements.\n *\n * @returns `true` if the given iterable contains at least one element, or `false` otherwise.\n */\nexport function itsEmpty(iterable: Iterable<unknown>): boolean {\n  if (isPushIterable(iterable)) {\n    return pushedEmpty(iterable);\n  }\n\n  const it = iteratorOf(iterable);\n\n  return isPushIterable(it) ? pushedEmpty(it) : !!it.next().done;\n}\n\n/**\n * @internal\n */\nfunction pushedEmpty(it: PushIterable<unknown>): boolean {\n\n  let isEmpty = true;\n\n  pushIterated(it, _element /* Unused parameter to prevent deoptimization */ => isEmpty = false);\n\n  return isEmpty;\n}\n","import { itsIterated } from './its-iterated';\n\n/**\n * Tests whether all elements of the given `iterable` pass the test implemented by the provided function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to test elements of.\n * @param test - A predicate function to test each element. Returns `true` to continue tests, or `false` to stop it\n * and return `false` from the method call. It accepts the tested element as the only parameter.\n *\n * @returns `true` if the `test` function returned a truthy value for every element, or `false` otherwise.\n * Returns `true` for empty iterable.\n */\nexport function itsEvery<T>(\n    iterable: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): boolean {\n\n  let allMatch = true;\n\n  itsIterated(\n      iterable,\n      element => {\n        allMatch = !!test(element);\n        if (!allMatch) {\n          return false;\n        }\n        return;\n      },\n  );\n\n  return allMatch;\n}\n","import { isPushIterable, iteratorOf, pushIterated } from '../base';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Extracts the first element of the given `iterable`, if any.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to extract element from.\n *\n * @returns Either the first element, or `undefined` if the given `iterable` is empty.\n */\nexport function itsFirst<T>(iterable: Iterable<T>): T | undefined {\n  if (isPushIterable(iterable)) {\n    return pushedFirst(iterable);\n  }\n\n  const it = iteratorOf(iterable);\n\n  return isPushIterable(it) ? pushedFirst(it) : rawFirst(it);\n}\n\n/**\n * @internal\n */\nfunction pushedFirst<T>(it: PushIterable<T>): T | undefined {\n\n  let first: T | undefined;\n\n  pushIterated(\n      it,\n      element => {\n        first = element;\n        return false;\n      },\n  );\n\n  return first;\n}\n\n/**\n * @internal\n */\nfunction rawFirst<T>(it: Iterator<T>): T | undefined {\n\n  const result = it.next();\n\n  return result.done ? undefined : result.value;\n}\n","import { PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { PushIterator$dontIterate, PushIterator$iterator, PushIterator$noNext } from './make-push-iterator';\n\n/**\n * @internal\n */\nexport function toPushIterator<T>(it: Iterator<T>, forNext: PushIterator.Pusher<T>): PushIterator<T> {\n\n  let over = false;\n  let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n    if ((over = !!accept && !forNext(accept))) {\n      iterate = PushIterator$dontIterate;\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      next = PushIterator$noNext;\n    }\n  };\n  let next = (): IteratorResult<T> => {\n\n    const res = it.next();\n\n    if (res.done) {\n      over = true;\n      iterate = PushIterator$dontIterate;\n      next = PushIterator$noNext;\n    }\n\n    return res;\n  };\n\n  return {\n    [Symbol.iterator]: PushIterator$iterator,\n    [PushIterator__symbol](accept) {\n      iterate(accept);\n      return this;\n    },\n    next() {\n      return next();\n    },\n    isOver: () => over,\n  };\n}\n\n/**\n * @internal\n */\nexport function rawIteratorPusher<T>(it: Iterator<T>): PushIterator.Pusher<T> {\n  return accept => {\n    for (; ;) {\n\n      const res = it.next();\n\n      if (res.done) {\n        return false;\n      }\n\n      const status = accept(res.value);\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","import { isPushIterable, iteratorOf, pushHead } from '../base';\nimport { iterateOverArray } from '../base/iterate-over-array.impl';\nimport { emptyPushIterator } from '../base/make-push-iterator';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Iterates over elements of the given iterable.\n *\n * Calls `accept` method for each iterated element until there are elements to iterate, or `accept` returned either\n * `true` or `false`.\n *\n * In contrast to {@link pushHead} function, this one accepts any iterable instance.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate elements of.\n * @param accept - A function to push iterated elements to. Accepts iterated element as its only parameter. May return\n * `true` to suspend iteration, or `false` to stop it.\n *\n * @returns A push iterator instance representing the tail of the given iterable. This iterator can be used to continue\n * iteration with, unless `accept` returned `false`. In the latter case the further iteration won't be possible.\n */\nexport function itsHead<T>(iterable: Iterable<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  if (isPushIterable(iterable)) {\n    return pushHead(iterable, accept);\n  }\n  if (Array.isArray(iterable)) {\n    return arrayHead(iterable, accept);\n  }\n  return rawIterableHead(iterable, accept);\n}\n\n/**\n * @internal\n */\nfunction arrayHead<T>(array: ArrayLike<T>, accept: PushIterator.Acceptor<T>): PushIterator<T> {\n  return array.length ? iterateOverArray(array)(accept) : emptyPushIterator;\n}\n\n/**\n * @internal\n */\nfunction rawIterableHead<T>(\n    iterable: Iterable<T>,\n    accept: PushIterator.Acceptor<T>,\n): PushIterator<T> {\n\n  const it = iteratorOf(iterable);\n\n  if (isPushIterable(it)) {\n    return pushHead(it, accept);\n  }\n\n  const forEach = rawIteratorPusher(it);\n\n  return forEach(accept) ? toPushIterator(it, forEach) : emptyPushIterator;\n}\n\n","import { isPushIterable, iteratorOf } from '../base';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Starts iteration over the given `iterable`.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable or push iterable to iterate over.\n *\n * @returns A push iterator iterating over the given iterable.\n */\nexport function itsIterator<T>(iterable: Iterable<T>): PushIterator<T> {\n\n  const it = iteratorOf(iterable);\n\n  return isPushIterable(it) ? it : toPushIterator(it, rawIteratorPusher(it));\n}\n","import { itsIterated } from './its-iterated';\n\n/**\n * Applies a function against an accumulator and each element of the given `iterable` to reduce elements to a single\n * value.\n *\n * @typeParam T - Iterated elements type.\n * @typeParam TResult - A type of reduced value.\n * @param iterable - An iterable to reduce values of.\n * @param reducer - A function to apply the value returned from the previous `reducer` call and to each element.\n * @param initialValue - Initial value passed to the first `reducer` call.\n *\n * @returns Reduced value returned from the last `reducer` call, or `initialValue` if there is no elements in the given\n * `iterable`.\n */\nexport function itsReduction<T, TResult>(\n    iterable: Iterable<T>,\n    reducer: (this: void, prev: TResult, element: T) => TResult,\n    initialValue: TResult,\n): TResult {\n\n  let reduced = initialValue;\n\n  itsIterated(iterable, element => { reduced = reducer(reduced, element); });\n\n  return reduced;\n}\n","import { emptyPushIterator } from '../base/make-push-iterator';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Returns a {@link PushIterator | push iterable iterator} without elements.\n *\n * @typeParam T - Iterated elements type.\n *\n * @returns Empty push iterable and push iterator instance.\n */\nexport function overNone<T>(): PushIterable<T> & PushIterator<T> {\n  return emptyPushIterator;\n}\n","import { isPushIterable, makePushIterable } from '../base';\nimport { rawIteratorPusher, toPushIterator } from '../base/raw-iterator.impl';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of iterator created by the given function.\n *\n * @typeParam T - Iterated elements type.\n * @param iterate - A function creating new iterator.\n *\n * @returns New push iterable over elements of created iterator.\n */\nexport function overIterator<T>(iterate: (this: void) => Iterator<T>): PushIterable<T> {\n  return makePushIterable(iterateOverRawIterator(iterate));\n}\n\n/**\n * @internal\n */\nfunction iterateOverRawIterator<T>(iterate: (this: void) => Iterator<T>): PushIterable.Iterate<T> {\n  return accept => {\n\n    const it = iterate();\n\n    if (isPushIterable(it)) {\n      return it[PushIterator__symbol](accept);\n    }\n\n    const forNext = rawIteratorPusher(it);\n\n    return accept && !forNext(accept) ? overNone() : toPushIterator(it, forNext);\n  };\n}\n","import { makePushIterable, makePushIterator } from '../base';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\nimport { overIterable } from './over-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of other iterables.\n *\n * @typeParam T - Iterated elements type.\n * @param sources - Source iterables to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `sources`.\n */\nexport function overElementsOf<T>(...sources: readonly Iterable<T>[]): PushIterable<T> {\n  return sources.length > 1\n      ? makePushIterable(iterateOverSubElements(sources))\n      : (sources.length\n          ? overIterable(sources[0])\n          : overNone());\n}\n\n/**\n * @internal\n */\nfunction iterateOverSubElements<T>(sources: readonly Iterable<T>[]): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    let src: Iterable<T> = sources[0];\n\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      for (; ;) {\n\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        let status: boolean | void;\n        const srcTail = itsHead(src, element => status = accept(element));\n\n        if (srcTail.isOver()) {\n          if (++i >= sources.length) {\n            return false;\n          }\n\n          src = sources[i];\n        } else {\n          src = srcTail;\n        }\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    };\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  };\n}\n","import { iteratorOf } from '../base';\nimport type { PushIterable } from '../push-iterable';\nimport { overArray } from './over-array';\nimport { overIterator } from './over-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} over elements of the given raw iterable.\n *\n * @typeParam T - Iterated elements type.\n * @param iterable - An iterable to iterate over elements of.\n *\n * @returns New push iterable over elements of the given `iterable`.\n */\nexport function overIterable<T>(iterable: Iterable<T>): PushIterable<T> {\n  return Array.isArray(iterable)\n      ? overArray<T>(iterable)\n      : overIterator(() => iteratorOf(iterable));\n}\n","import { makePushIterable } from '../base';\nimport { PushIterator$iterator } from '../base/make-push-iterator';\nimport type { PushIterable } from '../push-iterable';\nimport { PushIterator__symbol } from '../push-iterable';\nimport { overNone } from './over-none';\n\n/**\n * Creates a {@link PushIterable | push iterable} over one value.\n *\n * @typeParam T - Iterated element value type.\n * @param value - A value to iterate over.\n *\n * @returns New push iterable over the given value.\n */\nexport function overOne<T>(value: T): PushIterable<T> {\n  return makePushIterable(iterateOverOneValue(value));\n}\n\n/**\n * @internal\n */\nfunction iterateOverOneValue<T>(value: T): PushIterable.Iterate<T> {\n  return accept => {\n    if (accept) {\n      accept(value);\n      return overNone();\n    }\n\n    let over = false;\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        if (over) {\n          return overNone();\n        }\n        if (accept) {\n          over = true;\n          accept(value);\n          return overNone();\n        }\n        return this;\n      },\n      next() {\n        if (over) {\n          return { done: over } as IteratorReturnResult<undefined>;\n        }\n\n        over = true;\n\n        return { value };\n      },\n      isOver: () => over,\n    };\n\n  };\n}\n","import { overArray } from '../construction';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable | push iterable} over keys of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam TObj - Source object type.\n * @param source - An object to select keys from.\n *\n * @returns New push iterable over own object keys retrieved by `Reflect.ownKeys()`.\n */\nexport function overKeys<TObj extends object>(source: TObj): PushIterable<keyof TObj> {\n  return overArray(Reflect.ownKeys(source) as (keyof TObj)[]);\n}\n","import { makePushIterable } from '../base';\nimport { arrayElementOf } from '../base/iterate-over-array.impl';\nimport type { PushIterable } from '../push-iterable';\nimport { iterateOverFilteredIndexed } from './iterate-over-filtered-indexed.impl';\n\n/**\n * Creates a {@link PushIterable push iterable} with all `array` elements extending the given type.\n *\n * @typeParam T - A type of array elements.\n * @typeParam TTarget - Target type.\n * @param array - A source array.\n * @param test - A predicate function to test that element extends the type `TTarget`. Returns `true` to keep the\n * element, or `false` otherwise. It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterArray<T, TTarget extends T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => element is TTarget,\n): PushIterable<TTarget>;\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `array` elements that pass the test implemented by\n * the provided function.\n *\n * @typeParam T - A type of array elements.\n * @param array - A source array.\n * @param test - A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T>;\n\nexport function filterArray<T>(\n    array: ArrayLike<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T> {\n  return makePushIterable(iterateOverFilteredIndexed(array, arrayElementOf, test));\n}\n","import type { IndexedElements } from '../base/iterate-over-indexed.impl';\nimport { PushIterator$dontIterate, PushIterator$iterator, PushIterator$noNext } from '../base/make-push-iterator';\nimport { overNone } from '../construction';\nimport { PushIterable, PushIterator__symbol } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * @internal\n */\nexport function iterateOverFilteredIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementOf: (indexed: TIndexed, index: number) => T,\n    test: (this: void, element: T) => boolean,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      for (; ;) {\n        if (i >= indexed.length) {\n          return false;\n        }\n\n        const value = elementOf(indexed, i++);\n\n        if (test(value)) {\n\n          const status = accept(value);\n\n          if (typeof status === 'boolean') {\n            return status;\n          }\n        }\n      }\n    };\n\n    if (accept && !forNext(accept)) {\n      return overNone();\n    }\n\n    let over = false;\n    let iterate = (accept?: PushIterator.Acceptor<T>): void => {\n      if (accept && !forNext(accept)) {\n        over = true;\n        iterate = PushIterator$dontIterate;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        next = PushIterator$noNext;\n      }\n    };\n    let next = (): IteratorResult<T> => {\n      for (; ;) {\n        if (i >= indexed.length) {\n          over = true;\n          iterate = PushIterator$dontIterate;\n          next = PushIterator$noNext;\n          return { done: true } as IteratorReturnResult<T>;\n        }\n\n        const value = elementOf(indexed, i++);\n\n        if (test(value)) {\n          return { value };\n        }\n      }\n    };\n\n    return {\n      [Symbol.iterator]: PushIterator$iterator,\n      [PushIterator__symbol](accept) {\n        iterate(accept);\n        return this;\n      },\n      next: () => next(),\n      isOver: () => over,\n    };\n  };\n}\n","import { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `source` iterable elements extending the given type.\n *\n * @typeParam T - A type of source elements.\n * @typeParam TTarget - Target type.\n * @param source - A source iterable.\n * @param test - A predicate function to test that element extends the type `TTarget`. Returns `true` to keep the\n * element, or`false` otherwise. It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterIt<T, TTarget extends T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => element is TTarget,\n): PushIterable<TTarget>;\n\n/**\n * Creates a {@link PushIterable | push iterable} with all `source` iterable elements that pass the test implemented by\n * the provided function.\n *\n * @typeParam T - A type of source elements.\n * @param source - A source iterable.\n * @param test - A predicate function to test each element. Returns `true` to keep the element, or `false` otherwise.\n * It accepts the tested element as the only parameter.\n *\n * @returns New push iterable with the elements that pass the test. If no elements passed the test, an empty iterable\n * will be returned.\n */\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T>;\n\nexport function filterIt<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterable<T> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? filterPusher(source, test) : filterRawPusher(source, test);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction filterPusher<T>(\n    source: PushIterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterator.Pusher<T> {\n  return accept => {\n\n    const tail = pushHead(\n        source,\n        element => {\n          if (test(element)) {\n            return accept(element);\n          }\n          return;\n        },\n    );\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction filterRawPusher<T>(\n    source: Iterable<T>,\n    test: (this: void, element: T) => boolean,\n): PushIterator.Pusher<T> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return filterPusher(it, test);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const value = next.value;\n\n      if (test(value)) {\n\n        const status = accept(value);\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    }\n  };\n}\n","import { makePushIterable } from '../base';\nimport type { PushIterable } from '../push-iterable';\nimport { iterateOverFlattenedIndexed } from './iterate-over-flattened-indexed.impl';\n\n/**\n * Flattens the source `array` of iterables into new {@link PushIterable | push iterable}.\n *\n * Calling this function is the same as calling `flatMapArray(source, element => element)`.\n *\n * @typeParam T - A type of converted elements.\n * @param array - A source array-like instance of iterables.\n *\n * @returns New push iterable with each element of `array` being flattened.\n */\nexport function flatMapArray<T>(array: ArrayLike<Iterable<T>>): PushIterable<T>;\n\n/**\n * First maps each element of the source `array` using a mapping function, then flattens the result into new\n * {@link PushIterable | push iterable}.\n *\n * @typeParam TSrc - A type of array elements.\n * @typeParam TConv - A type of converted elements.\n * @param array - A source array-like instance of elements to convert.\n * @param convert - A function that produces new iterable, taking array element as the only parameter.\n *\n * @returns New push iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapArray<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv>;\n\nexport function flatMapArray<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    convert?: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv> {\n  return makePushIterable(iterateOverFlattenedIndexed<ArrayLike<TSrc>, TConv>(\n      array,\n      convert\n          ? (array, index) => convert(array[index])\n          : flatMapArray$defaultElementOf,\n  ));\n}\n\n/**\n * @internal\n */\nfunction flatMapArray$defaultElementOf<TSrc, TConv>(\n    array: ArrayLike<TSrc>,\n    index: number,\n): Iterable<TConv> {\n  return array[index] as unknown as Iterable<TConv>;\n}\n\n","import { makePushIterator } from '../base';\nimport type { IndexedElements } from '../base/iterate-over-indexed.impl';\nimport { overNone } from '../construction';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * @internal\n */\nexport function iterateOverFlattenedIndexed<TIndexed extends IndexedElements, T>(\n    indexed: TIndexed,\n    elementsOf: (indexed: TIndexed, index: number) => Iterable<T>,\n): PushIterable.Iterate<T> {\n  return accept => {\n\n    let i = 0;\n    let subs: Iterable<T> | undefined;\n\n    const forNext = (accept: PushIterator.Acceptor<T>): boolean => {\n      if (i >= indexed.length) {\n        return false;\n      }\n      if (!subs) {\n        subs = elementsOf(indexed, i);\n      }\n\n      for (; ;) {\n\n        let status: boolean | void;\n        const subsTail: PushIterator<T> = itsHead<T>(subs, element => status = accept(element));\n\n        if (subsTail.isOver()) {\n          if (++i >= indexed.length) {\n            return false;\n          }\n          subs = elementsOf(indexed, i);\n        } else {\n          subs = subsTail;\n        }\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    };\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  };\n}\n","import { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport { itsHead } from '../consumption';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Flattens the source iterable of iterables into new {@link PushIterable | push iterable}.\n *\n * Calling this function is the same as calling `flatMapIt(source, element => element)`.\n *\n * @typeParam T - A type of converted elements.\n * @param source - A source iterable of iterables.\n *\n * @returns New push iterable with each element of `source` being flattened.\n */\nexport function flatMapIt<T>(source: Iterable<Iterable<T>>): PushIterable<T>;\n\n/**\n * First maps each element of the `source` iterable using a mapping function, then flattens the result into new\n * {@link PushIterable | push iterable}.\n *\n * @typeParam TSrc - A type of source elements.\n * @typeParam TConv - A type of converted elements.\n * @param source - A source iterable of elements to convert.\n * @param convert - A function that produces new iterable, taking the source element as the only parameter.\n *\n * @returns New push iterable with each element being the flattened result of the `convert` function call.\n */\nexport function flatMapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterable<TConv>;\n\nexport function flatMapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv> = flatMapIt$defaultConverter,\n): PushIterable<TConv> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? flatMapPusher(source, convert) : flatMapRawPusher(source, convert);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction flatMapPusher<TSrc, TConv>(\n    source: PushIterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterator.Pusher<TConv> {\n\n  let subs: Iterable<TConv> | undefined;\n  let lastSrc = false;\n\n  return accept => {\n    for (; ;) {\n      while (!subs) {\n\n        const sourceTail = pushHead(source, src => {\n          subs = convert(src);\n          return true;\n        });\n\n        source = sourceTail;\n\n        if (sourceTail.isOver()) {\n          if (!subs) {\n            return false;\n          }\n          lastSrc = true;\n        }\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n      let status: boolean | void;\n      const subsTail: PushIterator<TConv> = itsHead(subs, element => status = accept(element));\n\n      if (subsTail.isOver()) {\n        subs = undefined;\n        if (lastSrc) {\n          return false;\n        }\n      } else {\n        subs = subsTail;\n      }\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n\n/**\n * @internal\n */\nfunction flatMapRawPusher<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => Iterable<TConv>,\n): PushIterator.Pusher<TConv> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return flatMapPusher(it, convert);\n  }\n\n  let subs: Iterable<TConv> | undefined;\n\n  return accept => {\n    for (; ;) {\n      if (!subs) {\n\n        const next = it.next();\n\n        if (next.done) {\n          return false;\n        }\n\n        subs = convert(next.value);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n      let status: boolean | void;\n      const subsTail: PushIterator<TConv> = itsHead(subs, element => status = accept(element));\n\n      subs = subsTail.isOver() ? undefined : subsTail;\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n\n/**\n * @internal\n */\nfunction flatMapIt$defaultConverter<T, TConv>(\n    element: T,\n): Iterable<TConv> {\n  return element as unknown as Iterable<TConv>;\n}\n\n","import { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} with the results of calling a provided function on every element\n * of the `source` iterable.\n *\n * @typeParam TSrc - A type of source elements.\n * @typeParam TConv - A type of converted elements.\n * @param source - A source iterable.\n * @param convert - A function that produces an element of the new iterable, taking the source element as the only\n * parameter.\n *\n * @returns New push iterable of transformed elements.\n */\nexport function mapIt<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterable<TConv> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? mapPusher(source, convert) : mapRawPusher(source, convert);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction mapPusher<TSrc, TConv>(\n    source: PushIterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterator.Pusher<TConv> {\n  return accept => {\n\n    const tail = pushHead(source, element => accept(convert(element)));\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction mapRawPusher<TSrc, TConv>(\n    source: Iterable<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterator.Pusher<TConv> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return mapPusher(it, convert);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const status = accept(convert(next.value));\n\n      if (typeof status === 'boolean') {\n        return status;\n      }\n    }\n  };\n}\n","import { isPushIterable, iteratorOf, makePushIterable, makePushIterator, pushHead } from '../base';\nimport { overNone } from '../construction';\nimport type { PushIterable } from '../push-iterable';\nimport type { PushIterator } from '../push-iterator';\n\n/**\n * Creates a {@link PushIterable | push iterable} with the values of elements of the `source` iterable.\n *\n * Element value is the result of provided function call, except `false`, `null`, and `undefined` which are filtered\n * out.\n *\n * This can be used as a more effective {@link mapIt} / {@link filterIt} combination.\n *\n * @typeParam T - A type of source elements.\n * @typeParam TValue - A type of source element values.\n * @param source - A source iterable.\n * @param valueOf - A function that values elements, taking the source element as the only parameter, and returning\n * either its value, or `false`/`null`/`undefined` to filter it out.\n *\n * @returns New push iterable with the element values.\n */\nexport function valueIt<T, TValue>(\n    source: Iterable<T>,\n    valueOf: (this: void, element: T) => TValue | false | null | undefined,\n): PushIterable<TValue> {\n  return makePushIterable(accept => {\n\n    const forNext = isPushIterable(source) ? valuePusher(source, valueOf) : valueRawPusher(source, valueOf);\n\n    return accept && !forNext(accept) ? overNone() : makePushIterator(forNext);\n  });\n}\n\n/**\n * @internal\n */\nfunction valuePusher<T, TValue>(\n    source: PushIterable<T>,\n    valueOf: (this: void, element: T) => TValue | false | null | undefined,\n): PushIterator.Pusher<TValue> {\n  return accept => {\n\n    const tail = pushHead(\n        source,\n        element => {\n\n          const value = valueOf(element);\n\n          if (value != null && value !== false) {\n            return accept(value);\n          }\n          return;\n        },\n    );\n\n    source = tail;\n\n    return !tail.isOver();\n  };\n}\n\n/**\n * @internal\n */\nfunction valueRawPusher<T, TValue>(\n    source: Iterable<T>,\n    valueOf: (this: void, element: T) => TValue | false | null | undefined,\n): PushIterator.Pusher<TValue> {\n\n  const it = iteratorOf(source);\n\n  if (isPushIterable(it)) {\n    return valuePusher(it, valueOf);\n  }\n\n  return accept => {\n    for (; ;) {\n\n      const next = it.next();\n\n      if (next.done) {\n        return false;\n      }\n\n      const value = valueOf(next.value);\n\n      if (value != null && value !== false) {\n\n        const status = accept(value);\n\n        if (typeof status === 'boolean') {\n          return status;\n        }\n      }\n    }\n  };\n}\n","import type { PushIterable } from '../push-iterable';\nimport { mapIt } from '../transformation';\nimport type { ObjectEntry } from './object-entry';\nimport { overKeys } from './over-keys';\n\n/**\n * Creates a {@link PushIterable | push iterable} over the property key/value entries of the given object.\n *\n * A list of keys is constructed using `Reflect.ownKeys()`.\n *\n * @typeParam TObj - Object type.\n *\n * @param source - An object to select keys and values from.\n *\n * @returns New push iterable of object property entries.\n */\nexport function overEntries<TObj extends object>(source: TObj): PushIterable<ObjectEntry<TObj>> {\n  return mapIt(\n      overKeys(source),\n      key => [key, source[key]],\n  );\n}\n","/**\n * @internal\n */\nexport let Supply$unexpectedAbort: (reason: unknown) => void = Supply$unexpectedAbort$byDefault;\n\n/**\n * @internal\n */\nexport function Supply$unexpectedAbort$handle(handler = Supply$unexpectedAbort$byDefault): void {\n  Supply$unexpectedAbort = handler;\n}\n\nfunction Supply$unexpectedAbort$byDefault(reason: unknown): void {\n  console.error('Supply aborted unexpectedly.', reason);\n}\n","import { Supply$unexpectedAbort } from './unexpected-abort';\n\nlet Supply$off = false;\nlet Supply$off$unexpected$reasons: Set<unknown> | undefined;\n\n/**\n * @internal\n */\nexport function Supply$off$start(): boolean {\n\n  const prevOff = Supply$off;\n\n  Supply$off = true;\n\n  return prevOff;\n}\n\n/**\n * @internal\n */\nexport function Supply$off$unexpected(reason: unknown): void {\n  if (reason !== undefined) {\n    if (!Supply$off$unexpected$reasons) {\n      Supply$off$unexpected$reasons = new Set<unknown>();\n    }\n    Supply$off$unexpected$reasons.add(reason);\n  }\n}\n\n/**\n * @internal\n */\nexport function Supply$off$end(prevOff: boolean): void {\n  Supply$off = prevOff;\n  if (!prevOff) {\n\n    const reasons = Supply$off$unexpected$reasons;\n\n    if (reasons) {\n      Supply$off$unexpected$reasons = undefined;\n      for (const reason of reasons) {\n        Supply$unexpectedAbort(reason);\n      }\n    }\n  }\n}\n","import type { Supply } from '../supply';\nimport { Supply$off$end, Supply$off$start, Supply$off$unexpected } from './off';\n\n/**\n * @internal\n */\nexport const SupplyState__symbol = (/*#__PURE__*/ Symbol('SupplyState'));\n\n/**\n * @internal\n */\nexport interface SupplyState {\n\n  readonly isOff: boolean;\n\n  off(supply: Supply, reason?: unknown): void;\n\n  whenOff(supply: Supply, callback: (reason?: unknown) => void): void;\n\n}\n\nconst SupplyState$done: SupplyState = {\n  isOff: true,\n  off: SupplyState$done$off,\n  whenOff(_supply: Supply, callback: (reason?: unknown) => void) {\n    callback();\n  },\n};\n\nfunction SupplyState$off(reason: unknown): SupplyState {\n  if (reason === undefined) {\n    return SupplyState$done;\n  }\n\n  return {\n    isOff: true,\n    off: SupplyState$done$off,\n    whenOff(_supply: Supply, callback: (reason?: unknown) => void) {\n      callback(reason);\n    },\n  };\n}\n\nfunction SupplyState$done$off(_supply: Supply, _reason?: unknown): void {\n  /* no off */\n}\n\n/**\n * @internal\n */\nexport const SupplyState$noCallback: SupplyState = {\n  isOff: false,\n  off(supply: Supply, reason?: unknown): void {\n\n    const prevOff = Supply$off$start();\n\n    try {\n      supply[SupplyState__symbol] = SupplyState$off(reason);\n      Supply$off$unexpected(reason);\n    } finally {\n      Supply$off$end(prevOff);\n    }\n  },\n  whenOff(supply: Supply, callback: (reason?: unknown) => void): void {\n    supply[SupplyState__symbol] = SupplyState$withCallback(callback);\n  },\n};\n\n/**\n * @internal\n */\nexport function SupplyState$withCallback(off: (this: void, reason?: unknown) => void): SupplyState {\n  return {\n    isOff: false,\n    off(supply: Supply, reason?: unknown): void {\n\n      const prevOff = Supply$off$start();\n\n      try {\n        supply[SupplyState__symbol] = SupplyState$off(reason);\n        off(reason);\n      } finally {\n        Supply$off$end(prevOff);\n      }\n    },\n    whenOff(_supply: Supply, callback: (reason?: unknown) => void): void {\n\n      const prev = off;\n\n      off = reason => {\n        prev(reason);\n        callback(reason);\n      };\n    },\n  };\n}\n","import type { SupplyState } from './impl';\nimport {\n  Supply$unexpectedAbort$handle,\n  SupplyState$noCallback,\n  SupplyState$withCallback,\n  SupplyState__symbol,\n} from './impl';\nimport type { SupplyPeer } from './supply-peer';\n\n/**\n * Supply handle.\n *\n * Represents a supply of something.\n *\n * The supply can be {@link off cut off}, and can {@link whenOff inform} on cutting off.\n */\nexport class Supply implements SupplyPeer {\n\n  /**\n   * Assigns unexpected abort handler.\n   *\n   * When a supply {@link off aborted}, and there is no {@link whenOff cut off callback} registered, the given handler\n   * will be called with the abort reason.\n   *\n   * By default, the unexpected abort reason will be logged to console.\n   *\n   * @param handler - A handler to call on unexpected abort, or `undefined` to reset to default one.\n   */\n  static onUnexpectedAbort(handler?: (this: void, reason: unknown) => void): void {\n    Supply$unexpectedAbort$handle(handler);\n  }\n\n  /**\n   * @internal\n   */\n  [SupplyState__symbol]: SupplyState;\n\n  /**\n   * Constructs new supply instance.\n   *\n   * @param off - A function to call when the supply is {@link Supply.off cut off}. Accepts optional cut off reason\n   * as its only parameter. No-op by default.\n   */\n  constructor(off?: (this: void, reason?: unknown) => void) {\n    this[SupplyState__symbol] = off ? SupplyState$withCallback(off) : SupplyState$noCallback;\n  }\n\n  /**\n   * `this` supply instance.\n   */\n  get supply(): this {\n    return this;\n  }\n\n  /**\n   * Whether this supply is {@link off cut off} already.\n   *\n   * `true` means nothing would be supplied any more.\n   */\n  get isOff(): boolean {\n    return this[SupplyState__symbol].isOff;\n  }\n\n  /**\n   * Cuts off this supply.\n   *\n   * After this method call nothing would be supplied any more.\n   *\n   * Calling this method for the second time has no effect.\n   *\n   * @param reason - An optional reason why the supply is cut off. It will be reported to {@link whenOff} callbacks.\n   * By convenience, an absent reason means the supply is done successfully.\n   *\n   * @returns The cut off supply instance.\n   */\n  off(reason?: unknown): Supply {\n    this[SupplyState__symbol].off(this, reason);\n    return this;\n  }\n\n  /**\n   * Registers a callback function that will be called as soon as this supply is {@link off cut off}. This callback\n   * will be called immediately if {@link isOff} is `true`.\n   *\n   * @param callback - A callback function accepting optional cut off reason as its only parameter.\n   * By convenience an `undefined` reason means the supply is done successfully.\n   *\n   * @returns `this` instance.\n   */\n  whenOff(callback: (this: void, reason?: unknown) => void): this {\n    this[SupplyState__symbol].whenOff(this, callback);\n    return this;\n  }\n\n  /**\n   * Builds a promise that will be resolved once this supply is {@link off done}.\n   *\n   * @returns A promise that will be successfully resolved once this supply is cut off without a reason, or rejected\n   * once this supply is cut off with any reason except `undefined`.\n   */\n  whenDone(): Promise<void> {\n    return new Promise((resolve, reject) => this.whenOff(\n        reason => reason === undefined ? resolve() : reject(reason),\n    ));\n  }\n\n  /**\n   * Makes another supply depend on this one.\n   *\n   * Once this supply is {@link off cut off}, `another` one will be cut off with the same reason.\n   *\n   * Calling this method has the same effect as calling `another.supply.needs(this)`.\n   *\n   * @param another - A supply peer to make dependent on this one.\n   *\n   * @returns `this` instance.\n   */\n  cuts(another: SupplyPeer): this {\n    another.supply.needs(this);\n    return this;\n  }\n\n  /**\n   * Makes this supply depend on another one.\n   *\n   * Once `another` supply is {@link off cut off}, this one will be cut off with the same reason.\n   *\n   * @param another - A supply peer to make this one depend on.\n   *\n   * @returns `this` instance.\n   */\n  needs(another: SupplyPeer): this {\n    another.supply.whenOff(reason => this.off(reason));\n    return this;\n  }\n\n  /**\n   * Makes this and another supply depend on each other.\n   *\n   * Calling this method is the same as calling `.needs(another).cuts(another)`.\n   *\n   * @param another - A supply peer to make this one to mutually depend on.\n   *\n   * @returns `this` instance.\n   */\n  as(another: SupplyPeer): this {\n    return this.needs(another).cuts(another);\n  }\n\n}\n","import { Supply } from './supply';\nimport type { SupplyPeer } from './supply-peer';\n\n/**\n * @internal\n */\nclass AlwaysSupply extends Supply {\n\n  get isOff(): false {\n    return false;\n  }\n\n  off(_reason?: unknown): Supply {\n    return this;\n  }\n\n  whenOff(_callback: (this: void, reason?: unknown) => void): this {\n    return this;\n  }\n\n  cuts(_another: SupplyPeer): this {\n    return this;\n  }\n\n  needs(_another: SupplyPeer): this {\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst alwaysSupply$ = (/*#__PURE__*/ new AlwaysSupply());\n\n/**\n * Builds an always-supply instance.\n *\n * The {@link Supply.off} method of the returned supply does nothing.\n *\n * @returns A supply instance that can not be cut off.\n */\nexport function alwaysSupply(): Supply {\n  return alwaysSupply$;\n}\n\n/**\n * Checks whether the given supply is an {@link AlwaysSupply | always-supply} instance.\n *\n * @param supply - A supply to check.\n *\n * @returns `true` is the given `supply` can not be cut off, or `false` otherwise.\n */\nexport function isAlwaysSupply(supply: Supply): boolean {\n  return supply === alwaysSupply$;\n}\n","import { Supply } from './supply';\nimport type { SupplyPeer } from './supply-peer';\n\n/**\n * @internal\n */\nclass NeverSupply extends Supply {\n\n  get isOff(): true {\n    return true;\n  }\n\n  off(): this {\n    return this;\n  }\n\n  whenOff(callback: (reason?: any) => void): this {\n    callback();\n    return this;\n  }\n\n  cuts(another: SupplyPeer): this {\n    another.supply.off();\n    return this;\n  }\n\n  needs(_another: SupplyPeer): this {\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nconst neverSupply$ = (/*#__PURE__*/ new NeverSupply());\n\n/**\n * Builds a never-supply instance.\n *\n * @returns A supply instance that is already cut off without any particular reason.\n */\nexport function neverSupply(): Supply {\n  return neverSupply$;\n}\n","import type { ContextKey } from './key';\n\n/**\n * An error indicating the absence of context value with the given key.\n */\nexport class ContextKeyError extends Error {\n\n  /**\n   * A missing value key.\n   */\n  readonly key: ContextKey<any, any, any>;\n\n  /**\n   * Constructs an invalid context key error.\n   *\n   * @param key - Missing value key.\n   * @param message - Arbitrary error message.\n   */\n  constructor(key: ContextKey<any, any, any>, message = `There is no value with key ${key}`) {\n    super(message);\n    this.key = key;\n  }\n\n}\n","import type { ContextRef } from '../context-ref';\nimport type { ContextSeedKey } from './context-seed-key';\nimport type { ContextValueSlot } from './context-value-slot';\n\n/**\n * A symbol of the property containing a {@link ContextKey} instance.\n */\nexport const ContextKey__symbol = (/*#__PURE__*/ Symbol('ContextKey'));\n\n/**\n * Context value key.\n *\n * Every key should be an unique instance of this class.\n *\n * Multiple source values pay be provided per per value key. They all grouped into single seed.\n * The value is grown from this seed by {@link ContextKey.grow} method.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextKey<TValue, TSrc = TValue, TSeed = unknown> implements ContextRef<TValue, TSrc> {\n\n  /**\n   * Human-readable key name.\n   *\n   * This is not necessarily unique.\n   */\n  readonly name: string;\n\n  /**\n   * A key of context value holding a seed of the value associated with this key.\n   *\n   * Different context value keys may have the same {@link seedKey} to grow them from the same seed.\n   */\n  abstract readonly seedKey: ContextSeedKey<TSrc, TSeed>;\n\n  /**\n   * Constructs context value key.\n   *\n   * @param name - Human-readable key name.\n   */\n  protected constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Always the key itself.\n   *\n   * This is to use this context value key both as a context value request and its definition target.\n   */\n  get [ContextKey__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Grows context value out of its seed.\n   *\n   * @param slot - Context value slot to insert the value to.\n   */\n  abstract grow(slot: ContextValueSlot<TValue, TSrc, TSeed>): void;\n\n  toString(): string {\n    return `ContextKey(${this.name})`;\n  }\n\n}\n","import type { ContextValues } from '../context-values';\nimport { ContextKey } from './context-key';\nimport type { ContextSeeder } from './context-seeder';\nimport type { ContextValueSlot } from './context-value-slot';\n\n/**\n * A key of context value holding a seed of context value.\n *\n * @typeParam TSrc - Source value type.\n * @typeParam TSeed - Value seed type.\n */\nexport abstract class ContextSeedKey<TSrc, TSeed> extends ContextKey<TSeed, TSrc, TSeed> {\n\n  /**\n   * Constructs context value sources key.\n   *\n   * @param key - A key of context value having its sources associated with this key.\n   */\n  constructor(key: ContextKey<unknown, TSrc>) {\n    super(`${key.name}:seed`);\n  }\n\n  /**\n   * Always refers to itself.\n   */\n  get seedKey(): this {\n    return this;\n  }\n\n  /**\n   * Creates a seeder for values associated with this key.\n   *\n   * @typeParam TCtx - Context type.\n   *\n   * @returns New value seeder instance.\n   */\n  abstract seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, TSrc, TSeed>;\n\n  grow(opts: ContextValueSlot<TSeed, TSrc, TSeed>): void {\n\n    const { seeder, seed } = opts;\n\n    if (!seeder.isEmpty(seed)) {\n      opts.insert(seed);\n    } else if (!opts.hasFallback) {\n      opts.insert(seed);\n    }\n  }\n\n}\n","import type { ContextRequest } from './context-request';\nimport type { ContextSupply } from './conventional';\n\n/**\n * The values available from context.\n *\n * The values are available by their keys.\n */\nexport abstract class ContextValues {\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `null` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrNull<TValue>): TValue | null;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value or `undefined` when there is no associated value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts: ContextRequest.OrUndefined<TValue>): TValue | undefined;\n\n  /**\n   * Returns a value associated with the given key.\n   *\n   * @typeParam TValue - A type of associated value.\n   * @param request - Context value request with target key.\n   * @param opts - Context value request options.\n   *\n   * @returns Associated value. Or the default one when there is no associated value. Or key default when there is\n   * neither.\n   *\n   * @throws Error  If there is no value associated with the given key, the default value is not provided,\n   * and the key has no default value.\n   */\n  abstract get<TValue>(request: ContextRequest<TValue>, opts?: ContextRequest.OrFallback<TValue>): TValue;\n\n}\n\nexport interface ContextValues {\n\n  /**\n   * Context values supply.\n   *\n   * When provided, this value is available under {@link ContextSupply} key, unless overridden.\n   */\n  readonly supply?: ContextSupply;\n\n}\n","import type { ContextValues } from '../context-values';\n\n/**\n * A key of {@link Contextual contextual value reference} method resolving a contextual instance.\n */\nexport const Contextual__symbol = (/*#__PURE__*/ Symbol('Contextual'));\n\n/**\n * Contextual value reference.\n *\n * @typeParam T - Referred contextual instance type.\n * @typeParam TCtx - Supported context type.\n */\nexport interface Contextual<T, TCtx extends ContextValues = ContextValues> {\n\n  /**\n   * Resolves a contextual instance for the target context.\n   *\n   * @param context - Target context.\n   *\n   * @returns Either contextual instance, or `null`/`undefined` when not resolved.\n   */\n  [Contextual__symbol](context: TCtx): T | null | undefined;\n\n}\n\nexport namespace Contextual {\n\n  /**\n   * Mandatory contextual value reference.\n   *\n   * Always resolves to some value.\n   *\n   * @typeParam T - Referred contextual instance type.\n   * @typeParam TCtx - Supported context type.\n   */\n  export interface Mandatory<T, TCtx extends ContextValues = ContextValues> {\n\n    /**\n     * Resolves a contextual instance for the target context.\n     *\n     * @param context - Target context.\n     *\n     * @returns Contextual instance.\n     */\n    [Contextual__symbol](context: TCtx): T;\n\n  }\n\n}\n\n/**\n * Checks whether the given value is a {@link Contextual.Mandatory mandatory contextual reference}.\n *\n * @typeParam T - Expected referred contextual instance type.\n * @typeParam TCtx - Expected context type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the given `value` has a {@link Contextual__symbol} method that always returns some value,\n * or `false` otherwise.\n */\nexport function isContextual<T, TCtx extends ContextValues = ContextValues, TOther = unknown>(\n    value: Contextual.Mandatory<T, TCtx> | TOther,\n): value is Contextual.Mandatory<T, TCtx>;\n\n/**\n * Checks whether the given value is a {@link Contextual contextual reference}.\n *\n * @typeParam T - Expected referred contextual instance type.\n * @typeParam TCtx - Expected context type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the given `value` has a {@link Contextual__symbol} method, or `false` otherwise.\n */\nexport function isContextual<T, TCtx extends ContextValues = ContextValues, TOther = unknown>(\n    value: Contextual<T, TCtx> | TOther,\n): value is Contextual<T, TCtx>;\n\nexport function isContextual<T, TCtx extends ContextValues = ContextValues, TOther = unknown>(\n    value: Contextual<T, TCtx> | TOther,\n): value is Contextual<T, TCtx> {\n  return !!value\n      && (typeof value === 'object' || typeof value === 'function')\n      && typeof (value as Partial<Contextual<T, TCtx>>)[Contextual__symbol] === 'function';\n}\n","import { lazyValue } from '@proc7ts/primitives';\nimport {\n  itsElements,\n  itsEmpty,\n  overElementsOf,\n  overIterator,\n  overNone,\n  PushIterable,\n  valueIt,\n} from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport type { ContextValues } from '../context-values';\nimport type { ContextSeeder } from '../key';\nimport { ContextKey, ContextSeedKey } from '../key';\nimport type { ContextValueProvider } from '../registry';\n\n/**\n * @internal\n */\nclass IterativeContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, PushIterable<TSrc>> {\n\n  private readonly _providers = new Map<Supply, ContextValueProvider<TSrc, TCtx>>();\n\n  provide(provider: ContextValueProvider<TSrc, TCtx>): Supply {\n\n    const supply = new Supply();\n\n    this._providers.set(supply, provider);\n\n    return supply.whenOff(() => this._providers.delete(supply));\n  }\n\n  seed(context: TCtx, initial: Iterable<TSrc> = overNone()): PushIterable<TSrc> {\n    return overElementsOf(\n        initial,\n        iterativeSeed(context, this._providers),\n    );\n  }\n\n  isEmpty(seed: Iterable<TSrc>): boolean {\n    return itsEmpty(seed);\n  }\n\n  combine(first: Iterable<TSrc>, second: Iterable<TSrc>): PushIterable<TSrc> {\n    return overElementsOf(first, second);\n  }\n\n}\n\n/**\n * @internal\n */\nclass IterativeSeedKey<TSrc> extends ContextSeedKey<TSrc, PushIterable<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): IterativeContextSeeder<TCtx, TSrc> {\n    return new IterativeContextSeeder();\n  }\n\n}\n\n/**\n * Iterative context value key implementation.\n *\n * Collects value sources as iterable instance.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class IterativeContextKey<TValue, TSrc = TValue> extends ContextKey<TValue, TSrc, Iterable<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, Iterable<TSrc>>;\n\n  /**\n   * Constructs iterative context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, Iterable<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new IterativeSeedKey(this);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction iterativeSeed<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providers: Map<Supply, ContextValueProvider<TSrc, TCtx>>,\n): PushIterable<TSrc> {\n\n  // Lazily evaluated providers\n  const lazyProviders = itsElements(\n      overIterator(() => providers.values()),\n      provider => lazyValue(provider.bind(undefined, context)),\n  );\n\n  return valueIt(lazyProviders, provider => provider());\n}\n","import { valuesProvider } from '@proc7ts/primitives';\nimport { itsElements } from '@proc7ts/push-iterator';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from '../key';\nimport { IterativeContextKey } from './iterative-context-key';\n\n/**\n * Multiple context value reference.\n *\n * Represents context value as read-only array of source values.\n *\n * @typeParam TSrc - TValue source type and context value item type.\n */\nexport type MultiContextRef<TSrc> = ContextRef<readonly TSrc[], TSrc>;\n\n/**\n * Multiple context values key.\n *\n * Represents context value as read-only array of source values.\n *\n * Associated with empty array by default.\n *\n * @typeParam TSrc - TValue source type and context value item type.\n */\nexport class MultiContextKey<TSrc>\n    extends IterativeContextKey<readonly TSrc[], TSrc>\n    implements MultiContextRef<TSrc> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<readonly TSrc[], ContextKey<readonly TSrc[], TSrc>>;\n\n  /**\n   * Constructs multiple context values key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified then the default value is empty array.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = valuesProvider(),\n      }: {\n        seedKey?: ContextSeedKey<TSrc, Iterable<TSrc>>;\n        byDefault?: ContextKeyDefault<readonly TSrc[], ContextKey<readonly TSrc[], TSrc>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<readonly TSrc[], TSrc, Iterable<TSrc>>,\n  ): void {\n\n    const result = itsElements(slot.seed);\n\n    if (result.length) {\n      slot.insert(result);\n    } else if (!slot.hasFallback) {\n\n      const defaultSources = this.byDefault(slot.context, this);\n\n      if (defaultSources) {\n        slot.insert(Array.from(defaultSources));\n      }\n    }\n  }\n\n}\n\n","import { lazyValue, noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport type { ContextValues } from '../context-values';\nimport type { ContextSeeder } from '../key';\nimport { ContextKey, ContextSeedKey } from '../key';\nimport type { ContextValueProvider } from '../registry';\n\n/**\n * @internal\n */\nclass SimpleContextSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  private readonly _providers: (readonly [ContextValueProvider<TSrc, TCtx>])[] = [];\n\n  provide(provider: ContextValueProvider<TSrc, TCtx>): Supply {\n\n    // Ensure the same provider may be registered multiple times\n    const entry: readonly [ContextValueProvider<TSrc, TCtx>] = [provider];\n\n    this._providers.unshift(entry);\n\n    return new Supply(() => this._providers.splice(this._providers.lastIndexOf(entry), 1));\n  }\n\n  seed(context: TCtx, initial?: SimpleContextKey.Seed<TSrc>): SimpleContextKey.Seed<TSrc> {\n\n    const { length } = this._providers;\n\n    if (!length) {\n      return initial || noop;\n    }\n\n    const makeSeed = (\n        [provider]: readonly [ContextValueProvider<TSrc, TCtx>],\n    ): SimpleContextKey.Seed<TSrc> => lazyValue(\n        provider.bind(undefined, context),\n    );\n\n    if (!initial && length === 1) {\n      return makeSeed(this._providers[0]);\n    }\n\n    const seeds: SimpleContextKey.Seed<TSrc>[] = this._providers.map(makeSeed);\n\n    if (initial) {\n      seeds.push(initial);\n    }\n\n    return combineSimpleSeeds(seeds);\n  }\n\n  isEmpty(seed: SimpleContextKey.Seed<TSrc>): boolean {\n    return seed() == null;\n  }\n\n  combine(\n      first: SimpleContextKey.Seed<TSrc>,\n      second: SimpleContextKey.Seed<TSrc>,\n  ): SimpleContextKey.Seed<TSrc> {\n    if (first === noop) {\n      return second;\n    }\n    if (second === noop) {\n      return first;\n    }\n    return combineSimpleSeeds([second, first]);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction combineSimpleSeeds<TSrc>(\n    seeds: readonly SimpleContextKey.Seed<TSrc>[],\n): SimpleContextKey.Seed<TSrc> {\n  return lazyValue(() => {\n    for (const seed of seeds) {\n\n      const value = seed();\n\n      if (value != null) {\n        return value;\n      }\n    }\n    return;\n  });\n}\n\n/**\n * @internal\n */\nclass SimpleSeedKey<TSrc> extends ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  seeder<TCtx extends ContextValues>(): SimpleContextSeeder<TCtx, TSrc> {\n    return new SimpleContextSeeder();\n  }\n\n}\n\n/**\n * Simple context value key implementation.\n *\n * Collects the most recent source value.\n *\n * A context value associated with this key is never changes once constructed.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class SimpleContextKey<TValue, TSrc = TValue>\n    extends ContextKey<TValue, TSrc, SimpleContextKey.Seed<TSrc>> {\n\n  readonly seedKey: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextSeedKey<TSrc, SimpleContextKey.Seed<TSrc>>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new SimpleSeedKey(this);\n  }\n\n}\n\nexport namespace SimpleContextKey {\n\n  /**\n   * A seed of {@link SimpleContextKey simple context key}.\n   *\n   * @typeParam TSrc - Source vale type.\n   */\n  export type Seed<TSrc> =\n  /**\n   * @returns Either source value, or `null`/`undefined` when absent.\n   */\n      (this: void) => TSrc | null | undefined;\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextKey, ContextKeyDefault, ContextSeedKey, ContextValueSlot } from '../key';\nimport { SimpleContextKey } from './simple-context-key';\n\n/**\n * Single context value reference.\n *\n * @typeParam TValue - Context value type.\n */\nexport type SingleContextRef<TValue> = ContextRef<TValue, TValue>;\n\n/**\n * Single context value key.\n *\n * Treats the last source value as context one and ignores the rest of them.\n *\n * @typeParam TValue - Context value type.\n */\nexport class SingleContextKey<TValue>\n    extends SimpleContextKey<TValue>\n    implements SingleContextRef<TValue> {\n\n  /**\n   * A provider of context value used when there is no value associated with this key.\n   */\n  readonly byDefault: ContextKeyDefault<TValue, ContextKey<TValue>>;\n\n  /**\n   * Constructs single context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Optional default value provider. If unspecified or `undefined` the key has no default\n   * value.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextSeedKey<TValue, SimpleContextKey.Seed<TValue>>;\n        byDefault?: ContextKeyDefault<TValue, ContextKey<TValue>>;\n      } = {},\n  ) {\n    super(name, { seedKey });\n    this.byDefault = byDefault;\n  }\n\n  grow(\n      slot: ContextValueSlot<TValue, TValue, SimpleContextKey.Seed<TValue>>,\n  ): void {\n\n    const value = slot.seed();\n\n    if (value != null) {\n      slot.insert(value);\n    } else if (!slot.hasFallback) {\n      slot.insert(this.byDefault(slot.context, this));\n    }\n  }\n\n}\n","import { alwaysSupply, Supply } from '@proc7ts/supply';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextValueSlot } from '../key';\nimport { SimpleContextKey } from '../singleton';\n\n/**\n * Context values supply.\n *\n * It is used to signal when context is no longer used (e.g. destroyed).\n *\n * A context value provider can (and probably should) destroy the provided value in such case.\n */\nexport type ContextSupply = Supply;\n\n/**\n * @internal\n */\nclass ContextSupplyKey extends SimpleContextKey<ContextSupply> {\n\n  constructor() {\n    super('context-supply');\n  }\n\n  grow(\n      slot: ContextValueSlot<ContextSupply, ContextSupply, SimpleContextKey.Seed<ContextSupply>>,\n  ): void {\n    slot.insert(\n        slot.seed()\n        || slot.context.supply\n        || (slot.hasFallback ? slot.or : alwaysSupply()),\n    );\n  }\n\n}\n\n/**\n * A key of context value containing a {@link ContextSupply context values supply}.\n *\n * It is guaranteed to present.\n *\n * Predefined to the supply of the context if the latter implements `SupplyPeer` interface. Defaults to supply-always\n * otherwise.\n */\nexport const ContextSupply: ContextRef<ContextSupply> = (/*#__PURE__*/ new ContextSupplyKey());\n","import type { Supply } from '@proc7ts/supply';\nimport type { ContextValues } from '../context-values';\nimport type { ContextRegistry } from './context-registry';\n\n/**\n * A key of {@link ContextBuilder context builder} method that provides context values.\n */\nexport const ContextBuilder__symbol = (/*#__PURE__*/ Symbol('ContextBuilder'));\n\n/**\n * Context builder.\n *\n * Able to provide arbitrary context values.\n *\n * @typeParam TCtx - Supported context type.\n */\nexport interface ContextBuilder<TCtx extends ContextValues = ContextValues> {\n\n  /**\n   * Provides context values with the given registry.\n   *\n   * @param registry - A context registry to provide values with.\n   *\n   * @returns A supply instance that removes the added context value providers once cut off.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry<TCtx>): Supply;\n\n}\n","import type { ContextValues } from '../context-values';\nimport type { ContextKey, ContextSeeder, ContextSeedKey } from '../key';\nimport type { ContextSeeds } from './context-seeds';\n\n/**\n * @internal\n */\nexport type SeedIssuer<TCtx extends ContextValues, TSrc, TSeed> = readonly [\n  seeder: ContextSeeder<TCtx, TSrc, TSeed>,\n  factory: (this: void, context: TCtx) => TSeed,\n];\n\n/**\n * @internal\n */\nexport class ContextSeeders<TCtx extends ContextValues> {\n\n  private readonly _issuers = new Map<ContextSeedKey<any, any>, SeedIssuer<TCtx, any, any>>();\n\n  constructor(private readonly _initial: ContextSeeds<TCtx>) {\n  }\n\n  issuer<TSrc, TSeed>(seedKey: ContextSeedKey<TSrc, TSeed>): SeedIssuer<TCtx, TSrc, TSeed> {\n\n    const found: SeedIssuer<TCtx, TSrc, TSeed> | undefined = this._issuers.get(seedKey);\n\n    if (found) {\n      return found;\n    }\n\n    const seeder: ContextSeeder<TCtx, TSrc, TSeed> = seedKey.seeder();\n    const issuer: SeedIssuer<TCtx, TSrc, TSeed> = [\n      seeder,\n      context => seeder.seed(context, this._initial(seedKey, context)),\n    ];\n\n    this._issuers.set(seedKey, issuer);\n\n    return issuer;\n  }\n\n  newSeed<TSrc, TSeed>(\n      context: TCtx,\n      key: ContextKey<any, TSrc, TSeed>,\n  ): readonly [seeder: ContextSeeder<TCtx, TSrc, TSeed>, seed: TSeed] {\n\n    const { seedKey } = key;\n    const [seeder, factory] = this.issuer(seedKey);\n\n    if (seedKey !== key as any) {\n      // This is not a seed key\n      // Retrieve the seed by seed key\n      return [seeder, context.get(seedKey)];\n    }\n\n    return [seeder, factory(context)];\n  }\n\n}\n","import { valueProvider } from '@proc7ts/primitives';\nimport type { ContextRequest } from '../context-request';\nimport type { ContextValues } from '../context-values';\nimport type { ContextBuilder } from './context-builder';\nimport type { ContextTarget } from './context-target';\nimport type { ContextValueProvider } from './context-value-provider';\n\n/**\n * Context value specifier.\n *\n * Either explicit one, or a {@link ContextBuilder context builder}.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TDeps - Dependencies tuple type.\n */\nexport type ContextValueSpec<\n    TCtx extends ContextValues,\n    TValue,\n    TSrc = TValue,\n    TDeps extends any[] = unknown[]> =\n    | ContextValueSpec.Explicit<TCtx, TValue, TSrc, TDeps>\n    | ContextBuilder<TCtx>;\n\nexport namespace ContextValueSpec {\n\n  /**\n   * Explicit context value specifier.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export type Explicit<\n      TCtx extends ContextValues,\n      TValue,\n      TSrc = TValue,\n      TDeps extends any[] = unknown[]> =\n      | ContextValueSpec.IsConstant<TSrc>\n      | ContextValueSpec.ViaAlias<TSrc>\n      | ContextValueSpec.ByProvider<TCtx, TSrc>\n      | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>\n      | ContextValueSpec.AsInstance<TCtx, TSrc>\n      | ContextValueSpec.SelfInstance<TCtx, TSrc>\n      | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>\n      | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps>;\n\n  /**\n   * A specifier defining a context value is constant.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface IsConstant<TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Constant context value.\n     */\n    is: TSrc;\n\n  }\n\n  /**\n   * A specifier defining a context value via another one (alias).\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface ViaAlias<TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value request for the another value that will be used instead as provided one.\n     */\n    via: ContextRequest<TSrc>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface ByProvider<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value provider.\n     */\n    by: ContextValueProvider<TSrc, TCtx>;\n\n  }\n\n  /**\n   * A specifier of context value defined by provider function depending on other context values.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export interface ByProviderWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value provider function.\n     */\n    by: (this: void, ...args: TDeps) => TSrc | null | undefined;\n\n    /**\n     * Context value requests for corresponding value provider function arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface AsInstance<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (context: TCtx) => TSrc;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value.\n   *\n   * @typeParam TCtx - Context type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SelfInstance<TCtx extends ContextValues, TSrc> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc> & (new (context: TCtx) => TSrc);\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of some class with constructor depending on other context values.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface AsInstanceWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define.\n     */\n    a: ContextTarget<TSrc>;\n\n    /**\n     * Context value class constructor.\n     */\n    as: new (...args: TDeps) => TSrc;\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * A specifier of context value defined as instance of the same class as value with constructor depending on other\n   * context values.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export interface SelfInstanceWithDeps<TSrc, TDeps extends any[]> {\n\n    /**\n     * Target value to define as its class constructor.\n     */\n    as: ContextTarget<TSrc> & (new (...args: TDeps) => TSrc);\n\n    /**\n     * Context value requests for corresponding constructor arguments.\n     */\n    with: DepsRequests<TDeps>;\n\n  }\n\n  /**\n   * Dependencies requests.\n   *\n   * This is a tuple of context value requests, each of which corresponds to dependency.\n   *\n   * @typeParam TDeps - Dependencies tuple type.\n   */\n  export type DepsRequests<TDeps extends any[]> = {\n    [K in keyof TDeps]: ContextRequest<TDeps[K]>;\n  };\n\n}\n\n/**\n * Constructs a specifier of context value defined by provider out of arbitrary one.\n *\n * @typeParam TCtx - Context type.\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n * @typeParam TDeps - Dependencies tuple type.\n * @param spec - Explicit context value specifier to convert.\n *\n * @returns A specifier of context value defined by provider function.\n *\n * @throws TypeError  On malformed context value specifier.\n */\nexport function contextValueSpec<TCtx extends ContextValues, TValue, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.Explicit<TCtx, TValue, TSrc, TDeps>,\n): ContextValueSpec.ByProvider<TCtx, TSrc> {\n  if (isValueSpecByProvider(spec)) {\n    if (!isValueSpecWithDeps<TCtx, TSrc, TDeps>(spec)) {\n      return spec;\n    }\n\n    const { a, by, with: deps } = spec;\n\n    return {\n      a,\n      by(this: void, context: TCtx) {\n        return by(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n  if (isConstantValueSpec<TSrc>(spec)) {\n\n    const { a, is: value } = spec;\n\n    return {\n      a,\n      by: valueProvider(value),\n    };\n  }\n  if (isValueSpecViaAlias(spec)) {\n\n    const { a, via } = spec;\n\n    return {\n      a,\n      by(ctx: TCtx) {\n        return ctx.get(via);\n      },\n    };\n  }\n  if (isValueSpecAsInstance<TCtx, TSrc, TDeps>(spec)) {\n    if (isSelfInstanceValueSpec<TCtx, TSrc, TDeps>(spec)) {\n      spec = toAsInstance(spec);\n    }\n    if (!isValueSpecWithDeps<TCtx, TSrc, TDeps>(spec)) {\n\n      const { as: Type } = spec;\n\n      return {\n        a: spec.a,\n        by(ctx: TCtx) {\n          return new Type(ctx);\n        },\n      };\n    }\n\n    const { as: DepType, with: deps } = spec;\n\n    return {\n      a: spec.a,\n      by(this: void, context: TCtx) {\n        return new DepType(...deps.map(<T>(dep: ContextRequest<T>) => context.get(dep)) as TDeps);\n      },\n    };\n  }\n\n  throw new TypeError(`Malformed context value specifier: ${JSON.stringify(spec)}`);\n}\n\n/**\n * @internal\n */\nfunction isValueSpecByProvider<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.ByProvider<TCtx, TSrc>\n    | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps> {\n  return 'by' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecAsInstance<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.AsInstance<TCtx, TSrc>\n    | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps> {\n  return 'as' in spec;\n}\n\n/**\n * @internal\n */\nfunction isSelfInstanceValueSpec<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): spec is\n    | ContextValueSpec.SelfInstance<TCtx, TSrc>\n    | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps> {\n  return !('a' in spec);\n}\n\n/**\n * @internal\n */\nfunction toAsInstance<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.SelfInstance<TCtx, TSrc> | ContextValueSpec.SelfInstanceWithDeps<TSrc, TDeps>,\n): ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps> {\n  return {\n    ...spec,\n    a: spec.as,\n  } as ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>;\n}\n\n/**\n * @internal\n */\nfunction isConstantValueSpec<TSrc>(\n    spec: ContextValueSpec<any, unknown, TSrc, any>,\n): spec is ContextValueSpec.IsConstant<TSrc> {\n  return 'is' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecViaAlias<TSrc>(\n    spec: ContextValueSpec<any, unknown, TSrc, any>,\n): spec is ContextValueSpec.ViaAlias<TSrc> {\n  return 'via' in spec;\n}\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.ByProvider<TCtx, TSrc> | ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>,\n): spec is ContextValueSpec.ByProviderWithDeps<TSrc, TDeps>;\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec.AsInstance<TCtx, TSrc> | ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>,\n): spec is ContextValueSpec.AsInstanceWithDeps<TSrc, TDeps>;\n\n/**\n * @internal\n */\nfunction isValueSpecWithDeps<TCtx extends ContextValues, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>,\n): boolean {\n  return 'with' in spec;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { ContextKeyError } from '../context-key-error';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextRequest } from '../context-request';\nimport { ContextValues } from '../context-values';\nimport type { ContextSeeder, ContextValueSetup, ContextValueSlot } from '../key';\nimport { ContextKey, ContextKey__symbol } from '../key';\nimport type { ContextRegistry } from './context-registry';\nimport type { ContextSeeders } from './context-seeders.impl';\n\n/**\n * @internal\n */\nexport function newContextValues<TCtx extends ContextValues>(\n    registry: ContextRegistry<TCtx>,\n    seeders: ContextSeeders<TCtx>,\n): ContextValues {\n\n  const values = new Map<ContextKey<any>, any>();\n\n  class ContextValues$ extends ContextValues {\n\n    get<TValue, TSrc>(\n        this: TCtx,\n        { [ContextKey__symbol]: key }: ContextRef<TValue, TSrc>,\n        opts?: ContextRequest.Opts<TValue>,\n    ): TValue | null | undefined {\n\n      const cached = values.get(key);\n\n      if (cached != null) {\n        return cached;\n      }\n\n      const [constructed, setup] = new ContextValueSlot$(seeders, this, key, opts)._grow();\n\n      if (setup) {\n        values.set(key, constructed);\n        setup({\n          key,\n          context: this,\n          registry: registry as ContextRegistry<any>,\n        });\n      }\n\n      return constructed;\n    }\n\n  }\n\n  return new ContextValues$();\n}\n\n/**\n * @internal\n */\nclass ContextValueSlot$<TCtx extends ContextValues, TValue, TSrc, TSeed>\n    implements ContextValueSlot.Base<TValue, TSrc, TSeed> {\n\n  readonly hasFallback: boolean;\n  readonly seeder: ContextSeeder<TCtx, TSrc, TSeed>;\n  readonly seed: TSeed;\n  private _constructed: TValue | null | undefined = null;\n  private _setup: ContextValueSetup<TValue, TSrc, TSeed> = noop;\n\n  constructor(\n      seeders: ContextSeeders<TCtx>,\n      readonly context: TCtx,\n      readonly key: ContextKey<TValue, TSrc, TSeed>,\n      private readonly _opts: ContextRequest.Opts<TValue> = {},\n  ) {\n\n    const [seeder, seed] = seeders.newSeed<TSrc, TSeed>(context, key);\n\n    this.seeder = seeder;\n    this.seed = seed;\n    this.hasFallback = 'or' in _opts; // Fallback _may_ have `undefined` value.\n  }\n\n  get or(): TValue | null | undefined {\n    return this._opts.or; // Access here, as fallback value accessor may be implemented as getter.\n  }\n\n  insert(value: TValue | null | undefined): void {\n    this._constructed = value;\n  }\n\n  fillBy(grow: (this: void, slot: ContextValueSlot<TValue, TSrc, TSeed>) => void): TValue | null | undefined {\n    grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n    return this._constructed;\n  }\n\n  setup(setup: ContextValueSetup<TValue, TSrc, TSeed>): void {\n\n    const prevSetup = this._setup;\n\n    this._setup = opts => {\n      prevSetup(opts);\n      setup(opts);\n    };\n  }\n\n  _grow(): readonly [value: TValue | null | undefined, setup?: ContextValueSetup<TValue, TSrc, TSeed>] {\n    this.key.grow(this as ContextValueSlot<TValue, TSrc, TSeed>);\n\n    if (this._constructed != null) {\n      return [this._constructed, this._setup];\n    }\n    if (!this.hasFallback) {\n      throw new ContextKeyError(this.key);\n    }\n\n    return [this.or];\n  }\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport type { Supply } from '@proc7ts/supply';\nimport type { ContextValues } from '../context-values';\nimport type { ContextSeedKey } from '../key';\nimport { ContextKey__symbol } from '../key';\nimport { ContextBuilder, ContextBuilder__symbol } from './context-builder';\nimport { ContextSeeders } from './context-seeders.impl';\nimport type { ContextSeeds } from './context-seeds';\nimport { ContextValueSpec, contextValueSpec } from './context-value-spec';\nimport { newContextValues } from './context-values.impl';\n\n/**\n * A registry of context value providers.\n *\n * @typeParam TCtx - Context type.\n */\nexport class ContextRegistry<TCtx extends ContextValues = ContextValues> {\n\n  /** @internal */\n  private readonly _seeders: ContextSeeders<TCtx>;\n\n  /**\n   * Constructs a registry for context value providers.\n   *\n   * It can be chained with another registry by providing an initially known source of known context values.\n   *\n   * @param initial - An optional source of initially known context values. This can be either a function, or\n   * `ContextValues` instance.\n   */\n  constructor(initial?: ContextSeeds<TCtx> | ContextValues) {\n    this._seeders = new ContextSeeders<TCtx>(\n        initial\n            ? (typeof initial === 'function' ? initial : (seedKey => initial.get(seedKey)))\n            : noop,\n    );\n  }\n\n  /**\n   * Provides context value.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   * @param spec - Context value specifier.\n   *\n   * @returns Provider supply instance that removes just added context value provider once cut off.\n   */\n  provide<TSrc, TDeps extends any[]>(spec: ContextValueSpec<TCtx, unknown, TSrc, TDeps>): Supply {\n    if (isContextBuilder(spec)) {\n      return spec[ContextBuilder__symbol](this);\n    }\n\n    const { a: { [ContextKey__symbol]: { seedKey } }, by } = contextValueSpec(spec);\n    const [seeder] = this._seeders.issuer(seedKey);\n\n    return seeder.provide(by);\n  }\n\n  /**\n   * Creates a seed for the given key in target context.\n   *\n   * @param context - Target context.\n   * @param key - Context value seed key.\n   *\n   * @returns New context value seed.\n   */\n  seed<TSrc, TSeed>(context: TCtx, key: ContextSeedKey<TSrc, TSeed>): TSeed {\n\n    const [, factory] = this._seeders.issuer(key);\n\n    return factory(context);\n  }\n\n  /**\n   * Builds context seeds provider originated from this registry.\n   *\n   * @returns Mandatory context seeds provider.\n   */\n  seeds(): ContextSeeds.Mandatory<TCtx> {\n    return (seedKey, context) => this.seed(context, seedKey);\n  }\n\n  /**\n   * Builds context seeds provider that binds seeds to target `context`.\n   *\n   * @param context - Target value context.\n   *\n   * @returns A provider of context value seeds bound to the given `context`.\n   */\n  seedIn(context: TCtx): ContextSeeds.Headless {\n    return this.newValues().get.bind(context);\n  }\n\n  /**\n   * Creates new context values instance consulting this registry for value providers.\n   *\n   * @returns New context values instance which methods expect `this` instance to be a context the values provided for.\n   */\n  newValues(): ContextValues {\n    return newContextValues(this, this._seeders);\n  }\n\n  /**\n   * Appends values provided by another value registry to the ones provided by this one.\n   *\n   * @param other - Another context value registry or context seeds provider.\n   *\n   * @return New context value registry which values provided by both registries.\n   */\n  append(other: ContextRegistry<TCtx> | ContextSeeds<TCtx>): ContextRegistry<TCtx> {\n\n    const otherSeeds: ContextSeeds<TCtx> = typeof other === 'function' ? other : other.seeds();\n\n    return new ContextRegistry(<TSrc, TSeed>(key: ContextSeedKey<TSrc, TSeed>, context: TCtx) => {\n\n      const second = otherSeeds(key, context);\n      const [seeder, factory] = this._seeders.issuer(key);\n      const first = factory(context);\n\n      return second ? seeder.combine(first, second, context) : first;\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nfunction isContextBuilder<TCtx extends ContextValues, TValue, TSrc, TDeps extends any[]>(\n    spec: ContextValueSpec<TCtx, TValue, TSrc, TDeps>,\n): spec is ContextBuilder<TCtx> {\n  return typeof (spec as Partial<ContextBuilder<TCtx>>)[ContextBuilder__symbol] === 'function';\n}\n","import { AmendTarget } from './amend-target';\n\n/**\n * An amendment of some entity.\n *\n * Applies to amended entities, such as {@link AeClass classes} or their {@link AeMember members}.\n *\n * May be represented either by {@link Amender} function or {@link Amendatory} instance. An {@link amenderOf}\n * function can be used to convert any amendment to amender.\n *\n * @typeParam TAmended - Amended entity type.\n */\nexport type Amendment<TAmended> =\n    | Amender<TAmended>\n    | Amendatory<TAmended>;\n\n/**\n * Amendment action (amender) signature.\n *\n * Applies an amendment to the given `target`.\n *\n * @typeParam TAmended - Amended entity type.\n */\nexport type Amender<TAmended> =\n/**\n * @param target - Amendment target.\n */\n    (this: void, target: AmendTarget<TAmended>) => void;\n\n/**\n * Amendatory instance.\n *\n * May be implemented by any object (or function) that is going to serve as an {@link Amendment amendment}.\n *\n * Can be converted to {@link Amender} by {@link amenderOf} function.\n *\n * @typeParam TAmended - Amended entity type.\n */\nexport interface Amendatory<TAmended> {\n\n  /**\n   * Applies an amendment to the given `target`.\n   *\n   * This method does not depend on `this` context.\n   *\n   * @param target - Amendment target.\n   */\n  applyAmendment(this: void, target: AmendTarget<TAmended>): void;\n\n}\n\n\n/**\n * Converts arbitrary amendment to {@link Amender amender}.\n *\n * @typeParam TAmended - Amended entity type.\n * @param amendment - An amendment to convert.\n *\n * @returns Either the `amendment` itself if it is already an amender, or its {@link Amendatory.applyAmendment\n * applyAmendment} method if it is an {@link Amendatory} instance.\n */\nexport function amenderOf<TAmended>(amendment: Amendment<TAmended>): Amender<TAmended> {\n  return isAmendatoryAmendment(amendment) ? amendment.applyAmendment : amendment;\n}\n\n/**\n * Checks if the given amendment is represented by {@link Amendatory} instance.\n *\n * @typeParam TAmended - Amended entity type.\n * @param amendment - An amendment to check.\n *\n * @returns `true` if the given `amendment` has an {@link Amendatory.applyAmendment applyAmendment} method,\n * or `false` otherwise.\n */\nfunction isAmendatoryAmendment<TAmended>(amendment: Amendment<TAmended>): amendment is Amendatory<TAmended> {\n  return typeof (amendment as Partial<Amendatory<TAmended>>).applyAmendment === 'function';\n}\n\n/**\n * Checks whether the given value is an {@link Amendatory} instance.\n *\n * @typeParam TAmended - Amended entity type.\n * @typeParam TOther - Another type the `value` may have.\n * @param value - The value to check.\n *\n * @returns `true` if the given `value` is an object or function with {@link Amendatory.applyAmendment applyAmendment}\n * method, or `false` otherwise.\n */\nexport function isAmendatory<TAmended, TOther = unknown>(\n    value: Amendatory<TAmended> | TOther,\n): value is Amendatory<TAmended> {\n  return !!value\n      && (typeof value === 'object' || typeof value === 'function')\n      && isAmendatoryAmendment(value as Amendment<TAmended>);\n}\n","import { AmendTarget } from './amend-target';\n\n/**\n * An {@link Amender amender} that amends nothing.\n *\n * @param _target - An unused amendment target that remains intact.\n *\n * @returns Itself for convenience.\n */\nexport function noopAmender(_target?: AmendTarget<unknown>): typeof noopAmender {\n  return noopAmender;\n}\n","import { AmendRequest } from './amend-request';\nimport { AmendTarget } from './amend-target';\nimport { Amender, amenderOf, Amendment } from './amendment';\nimport { noopAmender } from './noop-amender';\n\n/**\n * Combines multiple amendments into one amender.\n *\n * The resulting amender performs amendments in order. The subsequent amendments receive the amendment targets modified\n * by preceding ones.\n *\n * @typeParam TAmended - Amended entity type.\n * @param amendments - An iterable of amendments to apply in their application order.\n *\n * @returns A combining amender.\n */\nexport function allAmender<TAmended>(amendments: Iterable<Amendment<TAmended>>): Amender<TAmended> {\n    if (Array.isArray(amendments) && amendments.length < 2) {\n\n        const [amender = noopAmender] = amendments;\n\n        return amenderOf(amender);\n    }\n\n    return target => {\n\n        let amendBy = (\n            amendment: Amendment<TAmended>,\n        ): void => {\n\n            const amend = <TExt>(request?: AmendRequest<TAmended, TExt>): (\n                this: void,\n            ) => AmendTarget<TAmended & TExt> => {\n\n                const result = target.amend<TExt>(request);\n\n                amendBy = (next: Amendment<TAmended>) => {\n\n                    const nextTarget: AmendTarget<TAmended & TExt> = result();\n\n                    amenderOf(next)({\n                        ...nextTarget,\n                        amend,\n                    } as AmendTarget<TAmended>);\n\n                    return nextTarget;\n                };\n\n                return () => ({\n                    ...result(),\n                    amend,\n                }) as AmendTarget<TAmended & TExt>;\n            };\n\n            amenderOf(amendment)({\n                ...target,\n                amend,\n            });\n        };\n\n        for (const amendment of amendments) {\n            amendBy(amendment);\n        }\n    };\n}\n","import { lazyValue, valueProvider } from '@proc7ts/primitives';\nimport { AeNone } from './ae-none';\nimport { AmendRequest } from './amend-request';\n\n/**\n * Amendment target.\n *\n * Passed to {@link Amender amender} for the latter to amend it.\n *\n * Consists of {@link AmendTarget.Core core API} and amended entity (or entities).\n *\n * Custom amendment target can be constructed by {@link newAmendTarget} function.\n *\n * @typeParam TAmended - Amended entity type.\n */\nexport type AmendTarget<TAmended> = TAmended & AmendTarget.Core<TAmended>;\n\nexport namespace AmendTarget {\n\n  /**\n   * A core API of {@link AmendTarget amendment target}.\n   *\n   * Every amendment target implements it. The rest of the target consists of amended entity properties.\n   *\n   * @typeParam TAmended - Amended entity type.\n   */\n  export interface Core<TAmended> {\n\n    /**\n     * Amends the target.\n     *\n     * The returned function can be called to construct the modified amendment target. The latter can be used to chain\n     * amendments.\n     *\n     * This method does not require `this` context. Thus it can be extracted from amendment target e.g. by destructuring\n     * the latter.\n     *\n     * @typeParam TExt - A type of amended entity extension.\n     * @param request - Amendment request. Also serves as modification or extension of this amendment target.\n     *\n     * @returns A function without arguments returning modified amendment target.\n     */\n    amend<TExt = AeNone>(\n        this: void,\n        request?: AmendRequest<TAmended, TExt>,\n    ): (this: void) => AmendTarget<TAmended & TExt>;\n\n  }\n\n  /**\n   * Draft amendment target.\n   *\n   * Contains amended entity. Ignores target's {@link Core core API}.\n   *\n   * @typeParam TAmended - Amended entity type.\n   */\n  export type Draft<TAmended> =\n      & TAmended\n      & { readonly [K in keyof Core<TAmended>]?: unknown };\n\n  /**\n   * Options for {@link newAmendTarget custom amendment target}.\n   *\n   * @typeParam TAmended - Amended entity type.\n   */\n  export interface Options<TAmended> {\n\n    /**\n     * An amended entity the created target will be based on initially.\n     */\n    readonly base: TAmended;\n\n    /**\n     * Amends the target entity.\n     *\n     * Applies the given amendment `request` to the `base` amended entity.\n     *\n     * The returned amendment target draft builder function will be used to build a modified amendment target.\n     *\n     * This method is called at leas once to build the initial amendment target. Then it will be called on each\n     * {@link AmendTarget.Core.amend amendment}, unless overridden by further amendment {@link AmendRequest requests}.\n     *\n     * @typeParam TBase - A type of the entity to amend.\n     * @param base - An entity to amend.\n     * @param request - Amendment request.\n     *\n     * @returns Either a function without arguments that creates a draft of modified amendment target, or nothing to\n     * construct it by objects spread operator. The returned function will be called at most once.\n     */\n    amend<TBase extends TAmended, TExt>(\n        this: void,\n        base: TBase,\n        request?: AmendRequest<TBase, TExt>,\n    ): void | ((this: void) => AmendTarget.Draft<TBase & TExt>);\n\n  }\n\n}\n\n/**\n * Creates custom amendment target.\n *\n * @typeParam TAmended - Amended entity type.\n * @param options - Options for created amendment target.\n *\n * @returns New amendment target instance.\n */\nexport function newAmendTarget<TAmended>(\n    options: AmendTarget.Options<TAmended>,\n): AmendTarget<TAmended> {\n\n  const { base, amend: baseAmend } = options;\n\n  const nextTarget = <TBase extends TAmended, TExt>(\n      createBase: () => AmendTarget.Draft<TBase & TExt>,\n  ): AmendTarget<TBase & TExt> => {\n\n    const nextBase = createBase();\n\n    return {\n      ...nextBase,\n      amend<TNextExt>(nextRequest?: AmendRequest<TBase & TExt, TNextExt>) {\n\n        const modify = lazyValue(\n            baseAmend<TBase & TExt, TNextExt>(nextBase, nextRequest)\n            || (() => AmendTarget$default$modify(nextBase, nextRequest)),\n        );\n\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return () => nextTarget<TBase & TExt, TNextExt>(modify);\n      },\n    };\n  };\n\n  return nextTarget<TAmended, AeNone>(valueProvider<TAmended>(base));\n}\n\nfunction AmendTarget$default$modify<TBase, TExt>(\n    base: TBase,\n    request?: AmendRequest<TBase, TExt>,\n): AmendTarget.Draft<TBase & TExt> {\n  return { ...base, ...request as TExt };\n}\n","import { noop } from '@proc7ts/primitives';\nimport { AmendRequest, AmendTarget, newAmendTarget } from '../base';\nimport { AeClass, DecoratedAeClass } from './ae-class';\nimport { AmendableClass } from './amendable';\n\nexport function AeClass$target<\n    TClass extends AmendableClass,\n    TAmended extends AeClass<TClass>>(\n        base: TAmended,\n    ): AmendTarget<TAmended> {\n  return newAmendTarget({\n    base,\n    amend: AeClass$target$amend(base),\n  });\n}\n\nfunction AeClass$target$amend<TClass extends AmendableClass, TAmended extends AeClass<TClass>>(\n    { amend }: DecoratedAeClass<TClass, TAmended>,\n): AmendTarget.Options<TAmended>['amend'] {\n  if (!amend) {\n    return noop;\n  }\n\n  return <TBase extends TAmended, TExt>(\n      _base: TBase,\n      request?: AmendRequest<TBase, TExt>,\n  ) => amend(request as AmendRequest<TAmended, TExt>) as () => AmendTarget.Draft<TBase & TExt>;\n}\n","import { Class } from '@proc7ts/primitives';\nimport { allAmender, Amendment, AmendTarget } from '../base';\nimport { AeClass$target } from './ae-class.target.impl';\nimport { AmendableClass } from './amendable';\nimport { ClassAmendment } from './class-amendment';\n\n/**\n * An amended entity representing a class to amend.\n *\n * Used by {@link Amendment amendments} to modify the class definition.\n *\n * @typeParam TClass - A type of amended class.\n */\nexport interface AeClass<TClass extends AmendableClass = Class> {\n\n  /**\n   * Amended class constructor.\n   */\n  readonly amendedClass: TClass;\n\n}\n\n/**\n * An amendment target representing a class to amend.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TAmended - A type of the entity representing a class to amend.\n */\nexport type AeClassTarget<\n    TClass extends AmendableClass = Class,\n    TAmended extends AeClass<TClass> = AeClass<TClass>> =\n    AmendTarget<TAmended>;\n\n/**\n * An amended entity representing a class to decorate.\n *\n * Contains a data required for class {@link ClassAmendatory.decorateAmended decoration}.\n *\n * Contains a class to amend, as well as arbitrary amended entity data.\n *\n * When contains an {@link AmendTarget.Core.amend amend} method, the latter will be applied to all amendment requests.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TAmended - A type of the entity representing a class to amend.\n */\nexport type DecoratedAeClass<TClass extends AmendableClass, TAmended extends AeClass<TClass> = AeClass<TClass>> =\n    DecoratedAeClass.ForBase<AeClass<TClass>, TClass, TAmended>;\n\nexport namespace DecoratedAeClass {\n\n  export type ForBase<TBase extends AeClass<TClass>, TClass extends AmendableClass, TAmended extends TBase> = {\n    [K in Exclude<keyof TAmended, keyof TBase>]: TAmended[K];\n  } & {\n    readonly amendedClass: TClass;\n  } & {\n    [K in keyof AmendTarget.Core<TAmended>]?: AmendTarget.Core<TAmended>[K];\n  };\n\n}\n\n/**\n * Creates an amendment (and decorator) for a class.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TAmended - A type of the entity representing a class to amend.\n * @param amendments - Amendments to apply.\n *\n * @returns - New class amendment instance.\n */\nexport function AeClass<TClass extends AmendableClass, TAmended extends AeClass<TClass> = AeClass<TClass>>(\n    ...amendments: Amendment<TAmended>[]\n): ClassAmendment<TClass, TAmended> {\n\n  const amender = allAmender(amendments);\n  const decorateAmended = (base: TAmended): void => amender(AeClass$target(base));\n  const decorator = ((target: TClass): void => {\n    decorateAmended({ amendedClass: target } as TAmended);\n  }) as ClassAmendment<TClass, TAmended>;\n\n  decorator.applyAmendment = amender;\n  decorator.decorateAmended = decorateAmended;\n\n  return decorator;\n}\n","import { hasOwnProperty, superClassOf } from '@proc7ts/primitives';\nimport { AeClass$target } from './ae-class.target.impl';\nimport { AmendableClass } from './amendable';\n\nconst autoAmended = (/*#__PURE__*/ new WeakSet<AmendableClass>());\n\n/**\n * Issues an auto-amendment of the given class.\n *\n * An amendment is done by {@link AmendableClass.autoAmend autoAmend} static method this function calls.\n *\n * A class is auto-amended at most once. The subsequent calls of this function for the same class would do nothing.\n *\n * Auto-amends a super-class prior to amending the given one.\n *\n * @param amendedClass - A class to auto-amend.\n *\n * @returns Amended class instance.\n */\nexport function amend<TClass extends AmendableClass>(amendedClass: TClass): TClass {\n  if (autoAmended.has(amendedClass)) {\n    // Already auto-amended.\n    return amendedClass;\n  }\n\n  autoAmended.add(amendedClass);\n\n  const superClass = superClassOf(amendedClass);\n\n  if (superClass) {\n    // Amend super-class first.\n    amend(superClass);\n  }\n  if (!hasOwnProperty(amendedClass, 'autoAmend')) {\n    return amendedClass;\n  }\n\n  amendedClass.autoAmend!(AeClass$target({ amendedClass }));\n\n  return amendedClass;\n}\n","import { AePropHost } from './ae-prop-host';\nimport { PseudoHost } from './pseudo-host';\n\nexport function AeProp$notReadable(\n    host: AePropHost | PseudoHost,\n    key: string | symbol,\n): (instance: unknown) => never {\n  return _instance => {\n    throw new TypeError(\n        `${host.kind.pName} ${host.cls.name}${AmendProp$accessString(key)} is not readable`,\n    );\n  };\n}\n\nexport function AeProp$notWritable(\n    host: AePropHost | PseudoHost,\n    key: string | symbol,\n): (instance: unknown, update: unknown) => never {\n  return (_instance, _update) => {\n    throw new TypeError(\n        `${host.kind.pName} ${host.cls.name}${AmendProp$accessString(key)} is not writable`,\n    );\n  };\n}\n\nconst AeProp$idPattern = /^[a-z_$][a-z0-9_$]*$/i;\n\nfunction AmendProp$accessString(key: string | symbol): string {\n  if (typeof key === 'string') {\n    return AeProp$idPattern.test(key) ? `.${key}` : `[${JSON.stringify(key)}]`;\n  }\n  return `[${String(key)}]`;\n}\n","import { Class } from '@proc7ts/primitives';\nimport { allAmender, AmendablePropertyDescriptor, Amendatory, Amendment } from '../base';\nimport { AeClass, AmendableClass, DecoratedAeClass } from '../class';\nimport { DecoratedAeMember } from '../member';\nimport { createAePropAccessor } from './ae-prop-accessor';\nimport { AePropDesc, createAePropApplicator } from './ae-prop-applicator';\nimport { AePropHost } from './ae-prop-host';\n\nexport interface AeProp<\n    THost extends object,\n    TValue extends TUpdate,\n    TClass extends AmendableClass = Class,\n    TUpdate = TValue\n    > extends AeClass<TClass>{\n\n  readonly key: string | symbol;\n  readonly enumerable: boolean;\n  readonly configurable: boolean;\n  readonly readable: boolean;\n  readonly writable: boolean;\n  get(this: void, host: THost): TValue;\n  set(this: void, host: THost, update: TUpdate): void;\n\n}\n\nexport type PropAmendment<\n    THost extends object,\n    TValue extends TUpdate,\n    TClass extends AmendableClass,\n    TUpdate,\n    TAmended extends AeProp<THost, TValue, TClass, TUpdate>> =\n    AeProp<THost, any, any, any> extends TAmended\n        ? PropAmendmentDecorator<THost, TValue, TClass, TUpdate, TAmended>\n        : PropAmendatory<THost, TValue, TClass, TUpdate, TAmended>;\n\nexport interface PropAmendatory<\n    THost extends object,\n    TValue extends TUpdate,\n    TClass extends AmendableClass,\n    TUpdate,\n    TAmended extends AeProp<THost, TValue, TClass, TUpdate>>\n    extends Amendatory<TAmended> {\n\n  decorateAmended<TPropValue extends TValue>(\n      this: void,\n      decorated: DecoratedAeMember<TClass, TAmended>,\n      key: string | symbol,\n      descriptor?: AmendablePropertyDescriptor<TPropValue, THost, TUpdate>,\n  ): void | AmendablePropertyDescriptor<TPropValue, THost, TUpdate>;\n\n}\n\nexport interface PropAmendmentDecorator<\n    THost extends object,\n    TValue extends TUpdate,\n    TClass extends AmendableClass,\n    TUpdate,\n    TAmended extends AeProp<THost, TValue, TClass, TUpdate>>\n    extends PropAmendatory<THost, TValue, TClass, TUpdate, TAmended> {\n\n  <TPropValue extends TValue>(\n      this: void,\n      host: THost,\n      propertyKey: string | symbol,\n      descriptor?: AmendablePropertyDescriptor<TPropValue, THost, TUpdate>,\n  ): void | any;\n\n}\n\nexport function AeProp<\n    THost extends object,\n    TValue extends TUpdate,\n    TClass extends AmendableClass,\n    TUpdate,\n    TAmended extends AeProp<THost, TValue, TClass, TUpdate>>(\n    createHost: (decorated: AeClass<TClass>) => AePropHost<THost, TClass>,\n    hostClass: (host: THost) => TClass,\n    amendments: Amendment<TAmended>[],\n): PropAmendment<THost, TValue, TClass, TUpdate, TAmended> {\n\n  const amender = allAmender(amendments);\n  const decorateAmended = <TPropValue extends TValue>(\n      decorated: DecoratedAeMember<TClass, TAmended>,\n      key: string | symbol,\n      descriptor?: AmendablePropertyDescriptor<TPropValue, THost, TUpdate>,\n  ): void | AmendablePropertyDescriptor<TPropValue, THost, TUpdate> => {\n\n    const host = createHost(decorated);\n    const [getValue, setValue, toAccessor] = createAePropAccessor(host, key, descriptor);\n    const init: AePropDesc<THost, TValue, TUpdate> = {\n      enumerable: !descriptor || !!descriptor.enumerable,\n      configurable: !descriptor || !!descriptor.configurable,\n      readable: !descriptor || !!descriptor.get,\n      writable: !descriptor || !!descriptor.set || !!descriptor.writable,\n      get: hostInstance => getValue(hostInstance),\n      set: (hostInstance, update) => setValue(hostInstance, update),\n    };\n\n    const applyAmendment = createAePropApplicator<THost, TValue, TClass, TUpdate, TAmended>(host, amender, key, init);\n    let desc!: AePropDesc<THost, TValue, TUpdate>;\n\n    AeClass<TClass, TAmended>(classTarget => {\n      desc = applyAmendment(classTarget);\n    }).decorateAmended(decorated as DecoratedAeClass<TClass, TAmended>);\n\n    const { enumerable, configurable, get, set } = desc;\n    let newDescriptor: AmendablePropertyDescriptor<TPropValue, THost, TUpdate> | undefined;\n\n    if (set !== init.set || get !== init.get) {\n      newDescriptor = {\n        enumerable,\n        configurable,\n        get(this: THost): TPropValue {\n          return get(this) as TPropValue;\n        },\n        set(this: THost, update: TUpdate): void {\n          set(this, update);\n        },\n      };\n      toAccessor();\n    } else if (enumerable !== init.enumerable || configurable !== init.configurable) {\n      if (descriptor && (descriptor.get || descriptor.set)) {\n        newDescriptor = {\n          ...descriptor,\n          enumerable,\n          configurable,\n        };\n      } else {\n        newDescriptor = {\n          ...descriptor,\n          enumerable,\n          configurable,\n          writable: desc.writable,\n        };\n      }\n\n    }\n\n    if (newDescriptor && !descriptor) {\n      // Decorated field.\n      // Declare accessor.\n      Reflect.defineProperty(host.host, key, newDescriptor);\n    }\n\n    return newDescriptor;\n  };\n  const decorator = (<TPropValue extends TValue>(\n      targetHost: THost,\n      key: string | symbol,\n      descriptor?: AmendablePropertyDescriptor<TPropValue, THost, TUpdate>,\n  ): void | AmendablePropertyDescriptor<TPropValue, THost, TUpdate> => {\n\n    const aeClass: AeClass<TClass> = { amendedClass: hostClass(targetHost) };\n\n    return decorateAmended<TPropValue>(aeClass as DecoratedAeMember<TClass, TAmended>, key, descriptor);\n  }) as PropAmendment<THost, TValue, TClass, TUpdate, TAmended>;\n\n  decorator.decorateAmended = decorateAmended;\n  decorator.applyAmendment = amender;\n\n  return decorator;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { AmendablePropertyDescriptor } from '../base';\nimport { AePropHost } from './ae-prop-host';\nimport { AeProp$notReadable, AeProp$notWritable } from './ae-prop.accessibility';\n\nexport function createAePropAccessor<THost extends object, TValue extends TUpdate, TUpdate>(\n    host: AePropHost<THost>,\n    key: string | symbol,\n    descriptor: AmendablePropertyDescriptor<TValue, THost, TUpdate> | undefined,\n): [\n  getValue: (host: THost) => TValue,\n  setValue: (host: THost, update: TUpdate) => void,\n  toAccessor: () => void,\n] {\n  if (descriptor) {\n\n    const { get, set } = descriptor;\n\n    if (get || set) {\n      return [\n        get\n            ? instance => get.call(instance)\n            : AeProp$notReadable(host, key),\n        set\n            ? (instance, update) => set.call(instance, update as TValue)\n            : AeProp$notWritable(host, key),\n        noop,\n      ];\n    }\n  }\n\n  const valueKey = Symbol(host.kind.vDesc(key));\n\n  type ValueHost = THost & {\n    [valueKey]: TValue;\n  };\n\n  type UpdateHost = THost & {\n    [valueKey]: TUpdate;\n  };\n\n  let getValue = (host: THost): TValue => (host as Record<string, TValue>)[key as string];\n  let setValue = (host: THost, update: TUpdate): void => {\n    (host as Record<string, TUpdate>)[key as string] = update;\n  };\n  const writeValue = (host: THost, update: TUpdate): void => {\n    (host as UpdateHost)[valueKey] = update;\n  };\n  let toAccessor: () => void;\n\n  if (descriptor && ('value' in descriptor || 'writable' in descriptor)) {\n\n    const { value, writable } = descriptor;\n\n    if (writable) {\n      toAccessor = () => {\n        getValue = host => valueKey in host\n            ? (host as ValueHost)[valueKey]\n            : (host as ValueHost)[valueKey] = value as TValue;\n        setValue = writeValue;\n      };\n    } else {\n      setValue = AeProp$notWritable(host, key);\n      toAccessor = noop;\n    }\n  } else {\n    toAccessor = () => {\n\n      const superProto = Reflect.getPrototypeOf(host.host);\n\n      if (superProto != null) {\n        getValue = hostInstance => {\n          if (valueKey in hostInstance) {\n            return (hostInstance as ValueHost)[valueKey];\n          }\n          return (hostInstance as ValueHost)[valueKey] = Reflect.get(superProto, key, hostInstance);\n        };\n      } else {\n        getValue = instance => (instance as ValueHost)[valueKey];\n      }\n\n      setValue = writeValue;\n    };\n  }\n\n  return [\n    instance => getValue(instance),\n    (instance, update) => setValue(instance, update),\n    toAccessor,\n  ];\n}\n","import { Amender, AmendRequest, AmendTarget, newAmendTarget } from '../base';\nimport { AeClassTarget, AmendableClass } from '../class';\nimport { AeProp } from './ae-prop';\nimport { AePropHost } from './ae-prop-host';\nimport { AeProp$notReadable, AeProp$notWritable } from './ae-prop.accessibility';\nimport { PseudoHost } from './pseudo-host';\n\nexport interface AePropDesc<THost, TValue extends TUpdate, TUpdate> {\n  enumerable: boolean;\n  configurable: boolean;\n  readable: boolean;\n  writable: boolean;\n  get(this: void, host: THost): TValue;\n  set(this: void, host: THost, update: TUpdate): void;\n}\n\nexport function createAePropApplicator<\n    THost extends object,\n    TValue extends TUpdate,\n    TClass extends AmendableClass,\n    TUpdate,\n    TAmended extends AeProp<THost, TValue, TClass, TUpdate>>(\n    host: AePropHost<THost, TClass> | PseudoHost<THost, TClass>,\n    amender: Amender<TAmended>,\n    key: string | symbol,\n    init: AePropDesc<THost, TValue, TUpdate>,\n): (\n    baseTarget: AeClassTarget<TClass>,\n) => AePropDesc<THost, TValue, TUpdate> {\n  return (\n      baseTarget: AeClassTarget<TClass>,\n  ): AePropDesc<THost, TValue, TUpdate> => {\n\n    const result = { ...init };\n\n    amender(newAmendTarget({\n      base: {\n        ...baseTarget as unknown as TAmended,\n        key,\n        ...init,\n      },\n      amend<TBase extends TAmended, TExt>(\n          _base: TBase,\n          request = {} as AmendRequest<TBase, TExt>,\n      ): () => AmendTarget.Draft<TBase & TExt> {\n\n        const {\n          key: $key,\n          enumerable = result.enumerable,\n          configurable = result.configurable,\n          readable: $readable,\n          writable: $writable,\n          get: $get,\n          set: $set,\n          ...baseRequest\n        } = request;\n        const createBaseTarget = baseTarget.amend(baseRequest as AmendRequest<TBase>);\n\n        let { get, set } = request;\n        let readable: boolean;\n        let writable: boolean;\n\n        if (!set) {\n          if (get) {\n            set = AeProp$notWritable(host, key);\n            writable = false;\n            readable = true;\n          } else {\n            // Neither get, not set provided.\n            // Accessor remains the same.\n            ({ readable, writable, get, set } = result);\n          }\n        } else if (get) {\n          readable = true;\n          writable = true;\n        } else {\n          get = AeProp$notReadable(host, key);\n          readable = false;\n          writable = true;\n        }\n\n        result.configurable = configurable;\n        result.enumerable = enumerable;\n        result.readable = readable;\n        result.writable = writable;\n        result.get = get;\n        result.set = set;\n\n        return () => ({\n          ...createBaseTarget(),\n          key,\n          enumerable,\n          configurable,\n          readable,\n          writable,\n          get,\n          set,\n        } as AmendTarget.Draft<TBase & TExt>);\n      },\n    }));\n\n    return result;\n  };\n}\n","import { Class } from '@proc7ts/primitives';\nimport { Amendment, AmendTarget } from '../base';\nimport { AeClass, AmendableClass } from '../class';\nimport { AeProp, AePropHost, AePropHostKind } from '../impl';\nimport { MemberAmendment } from './member-amendment';\n\n/**\n * An amended entity representing a class instance member (property) to amend.\n *\n * Used by {@link Amendment amendments} to modify the member definition. I.e. its property descriptor.\n *\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - A type of amended class.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n */\nexport interface AeMember<\n    TValue extends TUpdate,\n    TClass extends AmendableClass = Class,\n    TUpdate = TValue,\n    > extends AeClass<TClass>{\n\n  /**\n   * A key of the instance member.\n   *\n   * Updates to this property are always ignored. The member key can not be changed.\n   */\n  readonly key: string | symbol;\n\n  /**\n   * Whether the member is writable.\n   *\n   * Updates to this property are always ignored.\n   *\n   * Set to `true` when {@link get} property assigned. Set to `false` when {@link set} property assigned, while the\n   * {@ling get} one is not. Remains unchanged when neither {@link get}, nor {@link set} properties assigned.\n   */\n  readonly readable: boolean;\n\n  /**\n   * Whether the member is writable.\n   *\n   * Updates to this property are always ignored.\n   *\n   * Set to `true` when {@link set} property assigned. Set to `false` when {@link get} property assigned, while the\n   * {@ling set} one is not. Remains unchanged when neither {@link get}, nor {@link set} properties assigned.\n   */\n  readonly writable: boolean;\n\n  /**\n   * Whether the member is enumerable.\n   */\n  readonly enumerable: boolean;\n\n  /**\n   * Whether the member is configurable.\n   */\n  readonly configurable: boolean;\n\n  /**\n   * Reads the value of this member in the target `instance`.\n   *\n   * Throws if the member is not {@link readable}.\n   *\n   * @param instance - Target instance.\n   *\n   * @returns Member value.\n   */\n  get(this: void, instance: InstanceType<TClass>): TValue;\n\n  /**\n   * Assigns the value of this member in the target `instance`.\n   *\n   * Throw is the member is not {@link writable}.\n   *\n   * @param instance - Target instance.\n   * @param update - Updated member value.\n   */\n  set(this: void, instance: InstanceType<TClass>, update: TUpdate): void;\n\n}\n\n/**\n * An amendment target representing a class instance member (property) to amend.\n *\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - A type of amended class.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - A type of the entity representing a member to amend.\n */\nexport type AeMemberTarget<\n    TValue extends TUpdate,\n    TClass extends AmendableClass = Class,\n    TUpdate = TValue,\n    TAmended extends AeMember<TValue, TClass, TUpdate> = AeMember<TValue, TClass, TUpdate>> =\n    AmendTarget<TAmended>;\n\n/**\n * An amended entity representing a class containing a member to decorate.\n *\n * Contains a data required for member {@link MemberAmendatory.decorateAmended decoration}.\n *\n * Contains a class to amend, as well as arbitrary amended entity data.\n *\n * When contains an {@link AmendTarget.Core.amend amend} method, the latter will be applied to all amendment requests.\n *\n * @typeParam TClass - A type of amended class.\n * @typeParam TAmended - A type of the entity representing a class to amend.\n */\nexport type DecoratedAeMember<TClass extends AmendableClass, TAmended extends AeClass<TClass> = AeClass<TClass>> =\n    DecoratedAeMember.ForBase<AeClass<TClass>, AeMember<any, TClass>, TClass, TAmended>;\n\nexport namespace DecoratedAeMember {\n\n  export type ForBase<\n      TClassBase extends AeClass<TClass>,\n      TMemberBase extends AeMember<any, TClass>,\n      TClass extends AmendableClass,\n      TAmended extends TClassBase> = {\n    [K in Exclude<keyof TAmended, keyof TMemberBase>]: TAmended[K];\n  } & {\n    readonly amendedClass: TClass;\n  } & {\n    [K in keyof AmendTarget.Core<TAmended>]?: AmendTarget.Core<TAmended>[K];\n  };\n\n}\n\n/**\n * Creates an amendment (and decorator) for the class instance member.\n *\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - A type of amended class.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - A type of the entity representing a member to amend.\n * @param amendments - Amendments to apply.\n *\n * @returns New class member amendment instance.\n */\nexport function AeMember<\n    TValue extends TUpdate,\n    TClass extends AmendableClass = Class,\n    TUpdate = TValue,\n    TAmended extends AeMember<TValue, TClass, TUpdate> = AeMember<TValue, TClass, TUpdate>>(\n    ...amendments: Amendment<TAmended>[]\n): MemberAmendment<TValue, TClass, TUpdate, TAmended> {\n  return AeProp(AeMember$createHost, AeMember$hostClass, amendments);\n}\n\nconst AeMember$HostKind: AePropHostKind = {\n  pName: 'Property',\n  vDesc: key => `valueOf(${String(key)}`,\n};\n\nfunction AeMember$createHost<TClass extends AmendableClass>(\n    { amendedClass }: AeClass<TClass>,\n): AePropHost<InstanceType<TClass>, TClass> {\n  return {\n    kind: AeMember$HostKind,\n    cls: amendedClass,\n    host: amendedClass.prototype,\n  };\n}\n\nfunction AeMember$hostClass<TClass extends AmendableClass>(\n    proto: InstanceType<TClass>,\n): TClass {\n  return proto.constructor;\n}\n","import type { QualifiedName } from './name';\nimport type { NamespaceAliaser } from './namespace-aliaser';\nimport type { NamespaceDef } from './namespace-def';\n\n/**\n * Naming schema is responsible for applying namespace aliases to simple names. E.g. by appending alias as prefix or\n * suffix of the name.\n */\nexport abstract class Naming {\n\n  /**\n   * Applies the given namespace `alias` to the given local `name`.\n   *\n   * @param name Local name to apply namespace alias to.\n   * @param alias Namespace alias to apply.\n   * @param namespace Aliased namespace definition.\n   *\n   * @returns A string containing the `name` with `alias` applied to it.\n   */\n  abstract applyAlias(name: string, alias: string, namespace: NamespaceDef): string;\n\n  /**\n   * Converts the given qualified `name` into simple one accordingly to this naming schema.\n   *\n   * @param name Qualified name to convert.\n   * @param nsAlias Namespace aliaser to use.\n   */\n  name(name: QualifiedName, nsAlias: NamespaceAliaser): string {\n    if (typeof name === 'string') {\n      return name;\n    }\n\n    const [local, ns] = name;\n\n    return ns.name(nsAlias(ns), local, this);\n  }\n\n}\n","import { Naming } from './naming';\n\n/**\n * @internal\n */\nclass DefaultNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}-${name}`;\n  }\n\n}\n\n/**\n * Default naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const default__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * HTML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by dash.\n *\n * The result looks like `<alias>-<name>`.\n */\nexport const html__naming: Naming = (/*#__PURE__*/ new DefaultNaming());\n\n/**\n * @internal\n */\nclass XmlNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${alias}:${name}`;\n  }\n\n}\n\n/**\n * XML elements naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const xml__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * Element identifiers naming schema.\n *\n * Prefixes a name with namespace alias separating them by colon.\n *\n * The result looks like `<alias>:<name>`.\n */\nexport const id__naming: Naming = (/*#__PURE__*/ new XmlNaming());\n\n/**\n * @internal\n */\nclass CssNaming extends Naming {\n\n  applyAlias(name: string, alias: string): string {\n    return `${name}@${alias}`;\n  }\n\n}\n\n/**\n * CSS classes naming scheme.\n *\n * Appends namespace alias as a name suffix separated by `@` sign.\n *\n * The result looks like `<name>@<alias>`.\n */\nexport const css__naming: Naming = (/*#__PURE__*/ new CssNaming());\n","import type { Naming } from './naming';\nimport { default__naming } from './namings';\n\n/**\n * Namespace definition.\n *\n * Namespaces are identified by their URLs.\n */\nexport class NamespaceDef {\n\n  /**\n   * Unique namespace URL.\n   */\n  readonly url: string;\n\n  /**\n   * Preferred namespace aliases.\n   */\n  readonly aliases: readonly string[];\n\n  /**\n   * The most preferred namespace alias.\n   *\n   * By default this is the first preferred alias, or `ns` if there is no preferred aliases.\n   */\n  get alias(): string {\n    return this.aliases[0] || 'ns';\n  }\n\n  /**\n   * Constructs new namespace definition.\n   *\n   * @param url - Unique namespace URL.\n   * @param aliases - Preferred namespace aliases. It is expected that each alias is an ASCII letter followed by\n   * any number of ASCII letters, digits, `-`, or `_` signs. Aliases starting with `xml` are reserved. Empty alias\n   * is reserved for {@link DEFAULT__NS default namespace}.\n   */\n  constructor(url: string, ...aliases: string[]) {\n    this.url = url;\n    this.aliases = aliases;\n  }\n\n  /**\n   * Converts a local `name` belonging to this namespace to simple one according to the given `naming` schema.\n   *\n   * Calls {@link Naming.applyAlias} by default.\n   *\n   * @param alias - Namespace alias to apply to the name.\n   * @param name - A name to convert.\n   * @param naming - Naming schema to use. {@link default__naming default naming schema} is used when omitted.\n   *\n   * @returns A simple name with this namespace alias applied.\n   */\n  name(alias: string, name: string, naming: Naming = default__naming): string {\n    return naming.applyAlias(name, alias, this);\n  }\n\n}\n","import { DEFAULT__NS } from './default.ns';\nimport { NamespaceDef } from './namespace-def';\n\n/**\n * A name qualified with namespace.\n *\n * This can be either:\n * - a simple name string, which means a name in default namespace, or\n * - a name+namespace tuple.\n */\nexport type QualifiedName = string | NameAndNamespace;\n\n/**\n * A local name and namespace tuple.\n *\n * Consists of a local name string and namespace definition this name belongs to.\n */\nexport type NameAndNamespace = readonly [string, NamespaceDef];\n\n/**\n * Checks whether the given `value` is a name+namespace tuple.\n *\n * @param value - A value to check.\n *\n * @returns `true` if the given `value` is an array consisting of exactly two elements, where the first element is a\n * non-empty string, and the second element is an instance of {@link NamespaceDef}. Or `false` otherwise.\n */\nexport function isNameAndNamespace(value: unknown): value is NameAndNamespace {\n  return Array.isArray(value)\n      && value.length === 2\n      && typeof value[0] === 'string'\n      && value[1] instanceof NamespaceDef;\n}\n\n/**\n * Checks whether the given `value` is a qualified name.\n *\n * @param value - A value to check.\n *\n * @returns `true` if the given `value` is a string, or an array consisting of exactly two elements, where the first\n * element is a non-empty string, and the second element is an instance of {@link NamespaceDef}. `false` otherwise.\n */\nexport function isQualifiedName(value: unknown): value is QualifiedName {\n  return typeof value === 'string' || isNameAndNamespace(value);\n}\n\n/**\n * Detects a namespace of the given qualified `name`\n *\n * @param name - Qualified name to detect a namespace of.\n *\n * @returns A namespace if the given `name` has it, or {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function namespaceOf(name: QualifiedName): NamespaceDef {\n  return typeof name !== 'string' ? name[1] : DEFAULT__NS;\n}\n\n/**\n * Converts the given qualified `name` to local name and namespace tuple.\n *\n * @param name - Qualified name to convert.\n *\n * @returns The `name` itself if it has a namespace, or a tuple consisting of `name` and\n * {@link DEFAULT__NS default namespace} otherwise.\n */\nexport function nameAndNamespace(name: QualifiedName): NameAndNamespace {\n  return typeof name !== 'string' ? name : [name, DEFAULT__NS];\n}\n\n/**\n * Checks whether two qualified names are equal to each other.\n *\n * @param first - First qualified name to compare.\n * @param second - Second qualified name to compare.\n *\n * @returns `true` if both names are equal, or `false` otherwise.\n */\nexport function namesEqual(first: QualifiedName, second: QualifiedName): boolean {\n  if (typeof first === 'string') {\n    return typeof second === 'string' ? first === second : !second[1].url && second[0] === first;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    return !firstUrl && firstName === second;\n  }\n\n  return firstName === second[0] && firstUrl === second[1].url;\n}\n\n/**\n * Compares two qualified names.\n *\n * Names in default namespace considered less than other names. Namespaces are compared by their URLs.\n *\n * @param first - First qualified name to compare.\n * @param second - Second qualified name to compare.\n *\n * @returns `-1` if the `first` name is less than the `second` one, `0` if they are equal, or `1` if the `first` name\n * is greater than the `second` one.\n */\nexport function compareNames(first: QualifiedName, second: QualifiedName): -1 | 0 | 1 {\n  if (typeof first === 'string') {\n    if (typeof second === 'string') {\n      return compareStrings(first, second);\n    }\n    if (!second[1].url) {\n      return compareStrings(first, second[0]);\n    }\n    return -1;\n  }\n\n  const [firstName, { url: firstUrl }] = first;\n\n  if (typeof second === 'string') {\n    if (!firstUrl) {\n      return compareStrings(firstName, second);\n    }\n    return 1;\n  }\n\n  return compareStrings(firstUrl, second[1].url) || compareStrings(firstName, second[0]);\n}\n\n/**\n * @internal\n */\nfunction compareStrings(first: string, second: string): -1 | 0 | 1 {\n  return first < second ? -1 : first > second ? 1 : 0;\n}\n","import type { NamespaceDef } from './namespace-def';\n\n/**\n * Namespace aliaser function interface.\n *\n * Maps namespaces to their unique aliases.\n */\nexport type NamespaceAliaser =\n/**\n * @param ns - A definition of namespace to find alias for.\n *\n * @returns Namespace alias.\n */\n    (ns: NamespaceDef) => string;\n\n/**\n * Creates a namespace aliaser.\n *\n * The returned function tries to find a registered alias for the given namespace. If not found then tries to use one\n * of its preferred aliases. If all of them are reserved already for another namespaces, generates a new unique alias.\n *\n * @returns New instance of namespace aliaser.\n */\nexport function newNamespaceAliaser(): NamespaceAliaser {\n\n  const aliasesByNs = new Map<string, string>();\n  const nsNumPerAlias = new Map<string, number>();\n\n  return function nsAlias(ns: NamespaceDef): string {\n\n    const found = aliasesByNs.get(ns.url);\n\n    if (found) {\n      return found;\n    }\n\n    const mostPreferred = ns.alias;\n    let nsNumRegistered = 0;\n\n    for (const preferred of [mostPreferred, ...ns.aliases]) {\n\n      const ids = nsNumPerAlias.get(preferred);\n\n      if (!ids) {\n        aliasesByNs.set(ns.url, preferred);\n        nsNumPerAlias.set(preferred, 1);\n        return preferred;\n      }\n      if (!nsNumRegistered) {\n        // Use the first one\n        nsNumRegistered = ids;\n      }\n    }\n\n    const generated = `${mostPreferred}${++nsNumRegistered}`;\n\n    aliasesByNs.set(ns.url, generated);\n    nsNumPerAlias.set(mostPreferred, nsNumRegistered);\n\n    return generated;\n  };\n}\n","import { AfterEvent } from '../after-event';\n\n/**\n * A key of {@link EventKeeper} method returning its {@link AfterEvent} instance.\n *\n * @category Core\n */\nexport const AfterEvent__symbol = (/*#__PURE__*/ Symbol('after-event'));\n\n/**\n * An event supplier that keeps the last event sent.\n *\n * The registered event receiver would receive the kept event immediately upon registration, and all upcoming events\n * after that.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface EventKeeper<TEvent extends any[]> {\n\n  /**\n   * Returns an {@link AfterEvent} instance of this event keeper.\n   *\n   * @returns {@link AfterEvent} instance registering event receivers sent by this keeper.\n   */\n  [AfterEvent__symbol](): AfterEvent<TEvent>;\n\n}\n\n/**\n * @category Core\n */\nexport namespace EventKeeper {\n\n  /**\n   * A type of events sent by the given event keeper.\n   *\n   * @typeParam TKeeper - Target event keeper.\n   */\n  export type Event<TKeeper extends EventKeeper<any>> = TKeeper extends EventKeeper<infer TEvent> ? TEvent : never;\n\n}\n\n/**\n * Checks whether the given value implements an {@link EventKeeper} interface.\n *\n * @category Core\n * @typeParam TEvent - Expected event type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` contains an {@link AfterEvent__symbol} method, or `false` otherwise.\n */\nexport function isEventKeeper<TEvent extends any[], TOther = unknown>(\n    value: EventKeeper<TEvent> | TOther,\n): value is EventKeeper<TEvent> {\n  return !!value\n      && (typeof value === 'object' || typeof value === 'function')\n      && typeof (value as Partial<EventKeeper<TEvent>>)[AfterEvent__symbol] === 'function';\n}\n","import { Supply } from '@proc7ts/supply';\n\n/**\n * Event receiver is called on each event sent by {@link EventSender} when registered.\n *\n * A receiver may be represented either by {@link EventReceiver.Function function}, or by\n * {@link EventReceiver.Object object}. The former is a simplest form. The latter allows control all aspects of event\n * processing.\n *\n * To register an event receiver just call the event sender's `[OnEvent__symbol]` or event keeper's\n * `[AfterEvent__symbol]` method with this event receiver as argument.\n *\n * A _recurrent event_ is an event sent from inside event receiver and targeted the same receiver. Recurrent event\n * processing is scheduled until after the current event processing finishes. To handle recurrent events in a specific\n * way the event receiver may utilize an {@link EventReceiver.Context event processing context} available as\n * a first parameter of {@link EventReceiver.Object.receive} method.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n */\nexport type EventReceiver<TEvent extends any[]> = EventReceiver.Function<TEvent> | EventReceiver.Object<TEvent>;\n\n/**\n * @category Core\n */\nexport namespace EventReceiver {\n\n  /**\n   * Event receiver function signature.\n   *\n   * It never receives event processing context.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export type Function<TEvent extends any[]> =\n  /**\n   * @param event - An event represented by function call arguments.\n   */\n      (this: void, ...event: TEvent) => void;\n\n  /**\n   * Event receiver object.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Object<TEvent extends any[]> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link Supply.off cut off}.\n     *\n     * When omitted a new supply will be created per receiver registration within event supplier.\n     */\n    readonly supply?: Supply;\n\n    /**\n     * Receives an event.\n     *\n     * @param context - An event processing context.\n     * @param event - An event represented as the rest of arguments.\n     */\n    receive(context: Context<TEvent>, ...event: TEvent): void;\n\n  }\n\n  /**\n   * The most generic event receiver form.\n   *\n   * Any event receiver may be converted to generic form by {@link eventReceiver} function.\n   *\n   * In contrast to {@link EventReceiver.Object} this one always has a supply.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Generic<TEvent extends any[]> extends Object<TEvent> {\n\n    /**\n     * Event supply to this receiver.\n     *\n     * Events will be supplied to this receiver until this supply is {@link Supply.off cut off}.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Receives an event.\n     *\n     * This method does not require a `this` context. So it is possible to deconstruct the event receiver like this:\n     * ```typescript\n     * const { supply, receive } = eventReceiver(receiver);\n     * ```\n     *\n     * @param context - An event processing context.\n     * @param event - An event represented as the rest of arguments.\n     */\n    receive(this: void, context: Context<TEvent>, ...event: TEvent): void;\n\n  }\n\n  /**\n   * Event processing context.\n   *\n   * It is passed to {@link EventReceiver.Object} receivers.\n   *\n   * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n   */\n  export interface Context<TEvent extends any[]> {\n\n    /**\n     * Schedules the given event receiver to be called to process recurrent event(s).\n     *\n     * If called during event processing the recurrent events will be sent to the given `receiver` after current event\n     * processed instead of original one.\n     *\n     * If called multiple times the latest `receiver` will be used.\n     *\n     * If not called the recurrent events will be sent to original event receiver.\n     *\n     * > This method should be called __before__ the recurrent event issued. Otherwise it may happen that recurrent\n     * > event will be ignored in some situations. E.g. when it is issued during receiver registration.\n     *\n     * @param receiver - Recurrent events receiver function.\n     */\n    onRecurrent(receiver: EventReceiver.Function<TEvent>): void;\n\n  }\n\n}\n\n/**\n * Converts arbitrary event receiver to generic form.\n *\n * The returned event receiver would never send events to original receiver after event supply is cut off.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n * @param receiver - An event receiver to convert.\n *\n * @returns Event `receiver` in most generic form.\n */\nexport function eventReceiver<TEvent extends any[]>(receiver: EventReceiver<TEvent>): EventReceiver.Generic<TEvent> {\n\n  let supply: Supply;\n  let receive: (context: EventReceiver.Context<TEvent>, ...event: TEvent) => void;\n\n  if (typeof receiver === 'function') {\n    supply = new Supply();\n    receive = (_context, ...event) => receiver(...event);\n  } else {\n    supply = receiver.supply || new Supply();\n    receive = (context, ...event) => {\n      if (!supply.isOff) {\n        // Supply cut off callback may be called before the receiver disabled.\n        // Such callback may send an event that should not be received.\n        receiver.receive(context, ...event);\n      }\n    };\n  }\n\n  // Disable receiver when event supply is cut off. But see the comment above.\n  // For function receiver this callback is always the first one.\n  supply.whenOff(() => receive = EventReceiver$doDonReceive);\n\n  return {\n    supply,\n    receive: (context, ...event) => receive(context, ...event),\n  };\n}\n\nfunction EventReceiver$doDonReceive<TEvent extends any[]>(\n    _context: EventReceiver.Context<TEvent>,\n    ..._event: TEvent\n): void {\n  // Do not receive event.\n}\n","import { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event receiver function that dispatches events to each of the given event receivers.\n *\n * @internal\n * @param receivers - An iterable of event receivers to dispatch event to.\n *\n * @returns An event receiver function that does not utilize event processing context an thus can be called directly.\n */\nexport function receiveByEach<TEvent extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<TEvent>>,\n): (this: void, ...event: TEvent) => void {\n\n  let send: (this: void, event: TEvent) => void = sendNonRecurrent;\n\n  return (...event) => send(event);\n\n  function sendNonRecurrent(event: TEvent): void {\n\n    let actualReceivers = receivers;\n    const received: TEvent[] = [];\n\n    send = (recurrent: TEvent) => received.push(recurrent);\n\n    try {\n      for (; ;) {\n        actualReceivers = processEvent(actualReceivers, event);\n\n        const recurrent = received.shift();\n\n        if (!recurrent) {\n          break;\n        }\n\n        event = recurrent;\n      }\n    } finally {\n      send = sendNonRecurrent;\n    }\n  }\n}\n\n/**\n * @internal\n */\nfunction processEvent<TEvent extends any[]>(\n    receivers: Iterable<EventReceiver.Generic<TEvent>>,\n    event: TEvent,\n): EventReceiver.Generic<TEvent>[] {\n\n  const recurrentReceivers: EventReceiver.Generic<TEvent>[] = [];\n\n  for (const receiver of receivers) {\n\n    const idx = recurrentReceivers.length;\n\n    recurrentReceivers.push(receiver);\n\n    const context: EventReceiver.Context<TEvent> = {\n      onRecurrent(recurrentReceiver) {\n        recurrentReceivers[idx] = eventReceiver({\n          supply: receiver.supply,\n          receive(_context, ...recurrentEvent) {\n            recurrentReceiver(...recurrentEvent);\n          },\n        });\n      },\n    };\n\n    receiver.receive(context, ...event);\n  }\n\n  return recurrentReceivers;\n}\n","import { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Event notifier can be used to register event receivers and send events to them.\n *\n * It does not implement an {@link EventSender} interface though. Use an {@link EventEmitter} if you need one.\n *\n * Manages a list of registered event receivers, and removes them from the list once their supplies\n * are {@link Supply.off cut off}.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport class EventNotifier<TEvent extends any[]> implements SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _rcs?: Set<EventReceiver.Generic<TEvent>>;\n\n  readonly supply: Supply;\n\n  /**\n   * Sends the given `event` to all registered receivers.\n   *\n   * @param event - An event to send represented by function call arguments.\n   */\n  readonly send: (this: this, ...event: TEvent) => void;\n\n  constructor() {\n\n    const rcs = this._rcs = new Set<EventReceiver.Generic<TEvent>>();\n\n    this.send = receiveByEach(rcs);\n    this.supply = new Supply(() => {\n      rcs.clear();\n      delete this._rcs;\n    });\n  }\n\n  /**\n   * The number of currently registered event receivers.\n   */\n  get size(): number {\n    return this._rcs ? this._rcs.size : 0;\n  }\n\n  /**\n   * Registers an event receiver.\n   *\n   * Receivers registered with this method will receive the {@link send emitted} events.\n   *\n   * @param receiver - A receiver of events to register.\n   *\n   * @returns A supply of events to the given `receiver`.\n   */\n  on(receiver: EventReceiver<TEvent>): Supply {\n\n    const generic = eventReceiver(receiver);\n    const supply = generic.supply.needs(this);\n    const receivers = this._rcs;\n\n    if (receivers && !supply.isOff) {\n      receivers.add(generic);\n      supply.whenOff(() => receivers.delete(generic));\n    }\n\n    return supply;\n  }\n\n}\n","import { OnEvent } from '../on-event';\n\n/**\n * A key of {@link EventSender} method returning its {@link OnEvent} instance.\n *\n * @category Core\n */\nexport const OnEvent__symbol = (/*#__PURE__*/ Symbol('on-event'));\n\n/**\n * A sender of events.\n *\n * Contains an {@link OnEvent} instance registering event receivers.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a tuple of event receiver parameter types.\n */\nexport interface EventSender<TEvent extends any[]> {\n\n  /**\n   * Returns an {@link OnEvent} instance of this event sender.\n   *\n   * @returns {@link OnEvent} instance registering event receivers sent by this sender.\n   */\n  [OnEvent__symbol](): OnEvent<TEvent>;\n\n}\n\n/**\n * @category Core\n */\nexport namespace EventSender {\n\n  /**\n   * A type of events sent by the given event sender.\n   *\n   * @typeParam TSender - Target event sender.\n   */\n  export type Event<TSender extends EventSender<any>> = TSender extends EventSender<infer TEvent> ? TEvent : never;\n\n}\n\n/**\n * Checks whether the given value implements an {@link EventSender} interface.\n *\n * @category Core\n * @typeParam TEvent - Expected event type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` contains an {@link OnEvent__symbol} method, or `false` otherwise.\n */\nexport function isEventSender<TEvent extends any[], TOther = unknown>(\n    value: EventSender<TEvent> | TOther,\n): value is EventSender<TEvent> {\n  return !!value\n      && (typeof value === 'object' || typeof value === 'function')\n      && typeof (value as Partial<EventSender<TEvent>>)[OnEvent__symbol] === 'function';\n}\n","/**\n * An error indicating a failure to receive an expected event.\n *\n * This happens e.g. when receiver registered in {@link EventKeeper event keeper}, but the latter has no events to send.\n * This may happen when no fallback passed to {@link afterEventBy} function, while the given supplier did not send\n * any events.\n *\n * @category Core\n */\nexport class NoEventsError extends TypeError {\n\n  /**\n   * Constructs an error.\n   *\n   * @param message - Error message.\n   */\n  constructor(message = 'No events to send') {\n    super(message);\n  }\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport { receiveByEach } from './event-notifier.impl';\nimport { eventReceiver, EventReceiver } from './event-receiver';\n\n/**\n * Creates an event sender targeted specific receiver.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n *\n * @param receiver - Target event receiver.\n *\n * @returns A function accepting events and sending them to target `receiver`.\n */\nexport function sendEventsTo<TEvent extends any[]>(\n    receiver: EventReceiver<TEvent>,\n): (this: void, ...event: TEvent) => void {\n\n  const generic = eventReceiver(receiver);\n  let send: (...event: TEvent) => void = receiveByEach([generic]);\n\n  generic.supply.whenOff(() => send = noop);\n\n  return (...event) => send(...event);\n}\n","import { NoEventsError } from '../base';\n\n/**\n * @internal\n */\nexport function AfterEvent$noFallback(): never {\n  throw new NoEventsError();\n}\n","import { neverSupply, Supply } from '@proc7ts/supply';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function digEvents<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    input: OnEvent<TInEvent>,\n    extract: (this: void, ...event: TInEvent) => OnEvent<TOutEvent> | void | undefined,\n): (receiver: EventReceiver.Generic<TOutEvent>) => void {\n  return ({ supply, receive }: EventReceiver.Generic<TOutEvent>) => {\n\n    let nestedSupply = neverSupply();\n\n    input({\n\n      supply,\n\n      receive: (_context, ...event: TInEvent) => {\n\n        const prevSupply = nestedSupply;\n        const extracted = extract(...event);\n\n        nestedSupply = extracted\n            ? extracted({\n\n              supply: new Supply(reason => {\n                if (reason !== digEvents) {\n                  supply.off(reason);\n                }\n              }).needs(supply),\n\n              receive,\n\n            })\n            : neverSupply();\n        prevSupply.off(digEvents);\n      },\n    });\n  };\n}\n","import { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function OnEvent$do<TEvent extends any[]>(\n    this: OnEvent<TEvent>,\n    ...processors: ((this: void, arg: any) => any)[]\n): any {\n  return processors.reduce((arg, action) => action(arg), this);\n}\n","import { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function OnEvent$supplier<T extends OnEvent<any>>(this: T): T {\n  return this;\n}\n","import { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function onceEvent<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n  return ({ supply, receive }: EventReceiver.Generic<TEvent>): void => {\n    supplier({\n      supply,\n      receive: (context, ...event) => {\n        receive(context, ...event);\n        supply.off();\n      },\n    });\n  };\n}\n","import { Supply } from '@proc7ts/supply';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\nimport { onceEvent } from './once-event';\n\n/**\n * @internal\n */\nexport function OnEvent$then<TEvent extends any[], TResult1 = TEvent[0], TResult2 = never>(\n    this: OnEvent<TEvent>,\n    onEvent?: ((...value: TEvent) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n): Promise<TResult1 | TResult2> {\n  return new Promise((resolve, reject) => {\n    onceEvent(this)({\n      supply: onCutOff\n          ? new Supply(reason => {\n            try {\n              resolve(onCutOff(reason));\n            } catch (e) {\n              reject(e);\n            }\n          })\n          : new Supply(reject),\n      receive: onEvent\n          ? (_ctx, ...event): void => {\n            try {\n              resolve(onEvent(...event));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          : ((_ctx, event: TEvent[0]) => resolve(event)) as (\n              _ctx: EventReceiver.Context<TEvent>,\n              ...event: TEvent[]\n          ) => void,\n    });\n  });\n}\n","import { Supply } from '@proc7ts/supply';\nimport { EventNotifier, EventReceiver, sendEventsTo } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function shareEvents<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n\n  const sharer = new EventSharer<TEvent>(supplier);\n\n  return sharer.on.bind(sharer);\n}\n\nclass EventSharer<TEvent extends any[]> extends EventNotifier<TEvent> {\n\n  private _on: SharedEventDispatcher<TEvent>;\n\n  constructor(readonly supplier: OnEvent<TEvent>) {\n    super();\n    this._on = this._onInit();\n  }\n\n  on(receiver: EventReceiver.Generic<TEvent>): Supply {\n    this._on.on(receiver);\n    return receiver.supply;\n  }\n\n  /**\n   * Initial dispatcher applied when there are no receivers.\n   */\n  private _onInit(): SharedEventDispatcher<TEvent> {\n    return {\n      on: receiver => {\n\n        const initialEvents: TEvent[] = [];\n        const sharedSupply = new Supply(() => this._on = this._onInit());\n        const onFirst = this._on = this._onFirst(sharedSupply, initialEvents);\n\n        try {\n          onFirst.on(receiver);\n          this.supplier({\n            supply: sharedSupply,\n            receive: (_ctx, ...event) => this._on.dispatch(...event),\n          });\n        } finally {\n          if (this._on === onFirst) {\n            this._on = this._onNext(sharedSupply, initialEvents);\n          }\n        }\n      },\n      dispatch: null!, // Initial dispatcher never dispatches events\n    };\n  }\n\n  /**\n   * A dispatcher applied while the first receiver is still registering, but not registered yet.\n   *\n   * Records emitted events to dispatch them to all receivers.\n   */\n  private _onFirst(sharedSupply: Supply, initialEvents: TEvent[]): SharedEventDispatcher<TEvent> {\n    return {\n      on: receiver => this._addReceiver(receiver, sharedSupply, initialEvents),\n      dispatch: (...event) => {\n        // Record initial event.\n        initialEvents.push(event);\n        this.send(...event);\n      },\n    };\n  }\n\n  /**\n   * A dispatcher applied after the first receiver registered.\n   *\n   * Dispatches initial events to new receivers until new event received.\n   */\n  private _onNext(sharedSupply: Supply, initialEvents: TEvent[]): SharedEventDispatcher<TEvent> {\n    return {\n      on: receiver => this._addReceiver(receiver, sharedSupply, initialEvents),\n      dispatch: (...event) => {\n        // An event received after initial ones.\n        // Stop dispatching initial events.\n        initialEvents.length = 0;\n        this.send(...event);\n      },\n    };\n  }\n\n  private _addReceiver(\n      receiver: EventReceiver.Generic<TEvent>,\n      sharedSupply: Supply,\n      initialEvents: TEvent[],\n  ): void {\n    sharedSupply.cuts(receiver);\n\n    super.on(receiver).whenOff(reason => {\n      if (!this.size) {\n        sharedSupply.off(reason);\n      }\n    });\n\n    if (initialEvents.length) {\n      // Dispatch initial events.\n\n      const dispatch = sendEventsTo(receiver);\n\n      initialEvents.forEach(event => dispatch(...event));\n    }\n  }\n\n}\n\ninterface SharedEventDispatcher<TEvent extends any[]> {\n\n  on(this: void, receiver: EventReceiver.Generic<TEvent>): void;\n\n  dispatch(...event: TEvent): void;\n\n}\n\n","import { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { EventReceiver } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function supplyEvents<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (receiver: EventReceiver.Generic<TEvent>) => void {\n  return (receiver: EventReceiver.Generic<TEvent>): void => {\n    if (dependentSupply) {\n      supplier({\n        supply: new Supply().needs(required).cuts(dependentSupply),\n        receive: receiver.receive,\n      });\n    } else {\n      receiver.supply.needs(required);\n      supplier(receiver);\n    }\n  };\n}\n","import { EventReceiver, sendEventsTo } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * @internal\n */\nexport function translateEvents<TInEvent extends any[], TOutEvent extends any[]>(\n    supplier: OnEvent<TInEvent>,\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (receiver: EventReceiver.Generic<TOutEvent>) => void {\n  return receiver => {\n\n    const dispatch = sendEventsTo(receiver);\n\n    supplier({\n      supply: receiver.supply,\n      receive: (_ctx, ...event: TInEvent) => {\n        translate(dispatch, ...event);\n      },\n    });\n  };\n}\n","import { EventReceiver } from '../event-receiver';\n\n/**\n * @internal\n */\nexport function neverReceiveBecause(reason?: any): (receiver: EventReceiver.Generic<any>) => void {\n  return ({ supply }) => supply.off(reason);\n}\n\n/**\n * @internal\n */\nexport function neverReceive({ supply }: EventReceiver.Generic<any>): void {\n  supply.off();\n}\n","import { Supply } from '@proc7ts/supply';\nimport { eventReceiver, EventReceiver, EventSender, OnEvent__symbol } from './base';\nimport { OnEvent$do, OnEvent$supplier, OnEvent$then } from './impl';\n\n/**\n * Signature of {@link EventSender} implementation able to register event receivers.\n *\n * The registered event receiver starts receiving upcoming events until the returned event supply is cut off.\n *\n * Contains additional event processing methods.\n *\n * May be constructed using {@link onEventBy} function.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface OnEvent<TEvent extends any[]> extends EventSender<TEvent> {\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver - Target receiver of events.\n   *\n   * @returns A supply of events from this sender to the given `receiver`.\n   */\n  (receiver: EventReceiver<TEvent>): Supply;\n\n  [OnEvent__symbol](): this;\n\n  /**\n   * Applies the given processor to events.\n   *\n   * @typeParam TResult - Action result type.\n   * @param processor - An event processor accepting this supplier as its only parameter, and returning application\n   * result.\n   *\n   * @returns Processing result.\n   */\n  do<TResult>(\n      processor: (this: void, supplier: this) => TResult,\n  ): TResult;\n\n  /**\n   * Applies the given processors to events.\n   *\n   * The value returned from each processor application is passed as argument to the next one. The value returned from\n   * the last processor application is the result of this method call.\n   *\n   * @typeParam TResult1 - The first processor application result type.\n   * @typeParam TResult1 - The second processor application result type.\n   * @param processor1 - An event processor accepting this supplier as its only parameter, and returning application\n   * result.\n   * @param processor2 - An event processor accepting the first one's application result as its only parameter, and\n   * returning its own application result.\n   *\n   * @returns The last processor application result.\n   */\n  do<\n      TResult1,\n      TResult2,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n  ): TResult2;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n  ): TResult3;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n  ): TResult4;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n  ): TResult5;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n  ): TResult6;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n  ): TResult7;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n  ): TResult8;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n  ): TResult9;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n  ): TResult10;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n  ): TResult11;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      TResult12,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n      processor12: (this: void, arg: TResult11) => TResult12,\n  ): TResult12;\n\n  do<\n      TResult1,\n      TResult2,\n      TResult3,\n      TResult4,\n      TResult5,\n      TResult6,\n      TResult7,\n      TResult8,\n      TResult9,\n      TResult10,\n      TResult11,\n      TResult12,\n      TResult13,\n      >(\n      processor1: (this: void, supplier: this) => TResult1,\n      processor2: (this: void, arg: TResult1) => TResult2,\n      processor3: (this: void, arg: TResult2) => TResult3,\n      processor4: (this: void, arg: TResult3) => TResult4,\n      processor5: (this: void, arg: TResult4) => TResult5,\n      processor6: (this: void, arg: TResult5) => TResult6,\n      processor7: (this: void, arg: TResult6) => TResult7,\n      processor8: (this: void, arg: TResult7) => TResult8,\n      processor9: (this: void, arg: TResult8) => TResult9,\n      processor10: (this: void, arg: TResult9) => TResult10,\n      processor11: (this: void, arg: TResult10) => TResult11,\n      processor12: (this: void, arg: TResult11) => TResult12,\n      processor13: (this: void, arg: TResult12) => TResult13,\n  ): TResult13;\n\n  /**\n   * Attaches callbacks to the next event and/or supply cut off reason.\n   *\n   * This method makes event sender act as promise-like for the first parameter of the next event. Thus it is possible\n   * e.g. to use it in `await` expression.\n   *\n   * @param onEvent - The callback to execute when next event received.\n   * @param onCutOff - The callback to execute when supply is cut off before the next event received.\n   *\n   * @returns A Promise for the next event.\n   */\n  then<TResult1 = TEvent extends [infer F, ...any[]] ? F : undefined, TResult2 = never>(\n      onEvent?: ((...event: TEvent) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n      onCutOff?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2>;\n\n}\n\n/**\n * Converts a plain event receiver registration function to {@link OnEvent} sender.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param register - Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n *\n * @returns An {@link OnEvent} sender registering event receivers with the given `register` function.\n */\nexport function onEventBy<TEvent extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<TEvent>) => void,\n): OnEvent<TEvent> {\n\n  const onEvent = ((receiver: EventReceiver<TEvent>): Supply => {\n\n    const generic = eventReceiver(receiver);\n    const { supply } = generic;\n\n    if (!supply.isOff) {\n      try {\n        register(generic);\n      } catch (error) {\n        supply.off(error);\n      }\n    }\n\n    return supply;\n  }) as OnEvent<TEvent>;\n\n  onEvent[OnEvent__symbol] = OnEvent$supplier;\n  onEvent.do = OnEvent$do;\n  onEvent.then = OnEvent$then;\n\n  return onEvent;\n}\n\n/**\n * Checks whether the given value is an {@link OnEvent} sender.\n *\n * @category Core\n * @typeParam TEvent - Expected event type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` has been created by {@link onEventBy} function or in compatible way,\n * or `false` otherwise.\n */\nexport function isOnEvent<TEvent extends any[], TOther = unknown>(\n    value: OnEvent<TEvent> | TOther,\n): value is OnEvent<TEvent> {\n  return typeof value === 'function'\n      && (value as Partial<OnEvent<TEvent>>)[OnEvent__symbol] === OnEvent$supplier\n      && (value as Partial<OnEvent<TEvent>>).do === OnEvent$do\n      && (value as Partial<OnEvent<TEvent>>).then === OnEvent$then;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { AfterEvent__symbol, EventKeeper, eventReceiver, EventReceiver, OnEvent__symbol } from './base';\nimport { AfterEvent$noFallback, OnEvent$do, OnEvent$supplier, OnEvent$then } from './impl';\nimport { isOnEvent, OnEvent } from './on-event';\n\n/**\n * Signature of {@link EventKeeper} implementation able to register the receivers of kept and upcoming events.\n *\n * The registered event receiver receives the kept event immediately upon registration, and all upcoming events\n * after that until the returned event supply is cut off.\n *\n * To convert a plain event receiver registration function to {@link AfterEvent} an {@link afterEventBy} function can\n * be used.\n *\n * May be constructed using {@link afterEventBy} function.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport interface AfterEvent<TEvent extends any[]> extends OnEvent<TEvent>, EventKeeper<TEvent> {\n\n  /**\n   * Starts sending events to the given `receiver`.\n   *\n   * @param receiver - Target receiver of events.\n   *\n   * @returns A supply of events from this keeper to the given `receiver`.\n   */\n  (receiver: EventReceiver<TEvent>): Supply;\n\n  [AfterEvent__symbol](): this;\n\n}\n\n/**\n * Converts a plain event receiver registration function to {@link AfterEvent} keeper with a fallback.\n *\n * The event constructed by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param register - Generic event receiver registration function. It will be called on each receiver registration,\n * unless the receiver's {@link EventReceiver.Generic.supply event supply} is cut off already.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n * @param cleanup - A function that will be called once all registered event supplies cut off.\n *\n * @returns An {@link AfterEvent} keeper registering event receivers with the given `register` function.\n */\nexport function afterEventBy<TEvent extends any[]>(\n    register: (this: void, receiver: EventReceiver.Generic<TEvent>) => void,\n    fallback: (this: void) => TEvent = AfterEvent$noFallback,\n    cleanup: (this: void, reason?: unknown) => void = AfterEvent$noCleanup,\n): AfterEvent<TEvent> {\n\n  let lastEvent: TEvent | undefined;\n  let numReceivers = 0;\n\n  const afterEvent = ((receiver: EventReceiver<TEvent>): Supply => {\n\n    let dest: (context: EventReceiver.Context<TEvent>, ...event: TEvent) => void = noop;\n    const generic = eventReceiver(receiver);\n\n    if (generic.supply.isOff) {\n      return generic.supply;\n    }\n\n    const supply = new Supply(noop).needs(generic);\n    let reported = false;\n\n    ++numReceivers;\n    try {\n      register({\n        supply,\n        receive: (context, ...event: TEvent) => {\n          reported = true;\n          lastEvent = event;\n          dest(context, ...event);\n        },\n      });\n    } catch (error) {\n      supply.off(error);\n    }\n\n    if (!supply.isOff || reported) {\n      if (!lastEvent) {\n        try {\n          lastEvent = fallback();\n        } catch (error) {\n          supply.off(error);\n        }\n      }\n      if (lastEvent) {\n        generic.receive(\n            {\n              onRecurrent(recurrent) {\n                dest = (_context, ...event) => recurrent(...event);\n              },\n            },\n            ...lastEvent,\n        );\n        dest = (context, ...event) => generic.receive(context, ...event);\n      }\n    }\n\n    return supply.whenOff(reason => {\n      if (!--numReceivers) {\n        lastEvent = undefined;\n      }\n      generic.supply.off(reason);\n      if (!numReceivers) {\n        cleanup(reason);\n      }\n    });\n  }) as AfterEvent<TEvent>;\n\n  afterEvent[OnEvent__symbol] = OnEvent$supplier;\n  afterEvent.do = OnEvent$do;\n  afterEvent.then = OnEvent$then;\n  afterEvent[AfterEvent__symbol] = OnEvent$supplier;\n\n  return afterEvent;\n}\n\nfunction AfterEvent$noCleanup(_reason: unknown): void {\n  // No-op `AfterEvent` cleanup\n}\n\n/**\n * Checks whether the given value is an {@link AfterEvent} keeper.\n *\n * @category Core\n * @typeParam TEvent - Expected event type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the `value` has been created by {@link afterEventBy} function or in compatible way,\n * or `false` otherwise.\n */\nexport function isAfterEvent<TEvent extends any[], TOther = unknown>(\n    value: AfterEvent<TEvent> | TOther,\n): value is AfterEvent<TEvent> {\n  return isOnEvent(value) && (value as Partial<AfterEvent<TEvent>>)[AfterEvent__symbol] === OnEvent$supplier;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { onceEvent, shareEvents } from '../impl';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by all event keepers in `sources` map.\n *\n * @category Core\n * @typeParam TSrcMap - A type of `sources` map.\n * @param sources - A map of named event keepers the events are originated from.\n *\n * @returns An event keeper sending a map of events received from each source keeper. Each event in this map has the\n * same key as its source keeper in `sources`.\n */\nexport function afterAll<TSrcMap extends { readonly [key: string]: EventKeeper<any> }>(\n    sources: TSrcMap,\n): AfterEvent<[{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }]> {\n\n  const keys = Object.keys(sources);\n\n  const registerReceiver = (\n      receiver: EventReceiver.Generic<[{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }]>,\n  ): void => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result = {} as { [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> };\n\n    keys.forEach(<TSrcKey extends keyof TSrcMap>(key: TSrcKey) => {\n      supply.needs(sources[key][AfterEvent__symbol]()((...event: EventKeeper.Event<TSrcMap[TSrcKey]>) => {\n        result[key] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(result);\n    }\n  };\n\n  const latestEvent = (): [{ readonly [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> }] => {\n\n    const result = {} as { [K in keyof TSrcMap]: EventKeeper.Event<TSrcMap[K]> };\n\n    keys.forEach(\n        <TSrcKey extends keyof TSrcMap>(key: TSrcKey) => onceEvent(sources[key][AfterEvent__symbol]())({\n          supply: new Supply(),\n          receive: (_ctx, ...event: EventKeeper.Event<TSrcMap[TSrcKey]>) => result[key as keyof TSrcMap] = event,\n        }),\n    );\n\n    return [result];\n  };\n\n  return afterEventBy(shareEvents(afterEventBy(registerReceiver, latestEvent)));\n}\n","import { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventReceiver, sendEventsTo } from '../base';\nimport { onceEvent, shareEvents } from '../impl';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by each of the `sources`.\n *\n * @category Core\n * @typeParam TEvent - A type of events sent by each source.\n * @param sources - An array of source event keepers.\n *\n * @returns An event keeper sending events received from each source keeper. Each event item is an event tuple\n * originated from source keeper under its index in `sources` array.\n */\nexport function afterEach<TEvent extends any[]>(...sources: EventKeeper<TEvent>[]): AfterEvent<TEvent[]> {\n\n  const registerReceiver = (receiver: EventReceiver.Generic<TEvent[]>): void => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n    let send: () => void = noop;\n    const result: TEvent[] = [];\n\n    sources.forEach((source, index) => {\n      supply.needs(source[AfterEvent__symbol]()((...event) => {\n        result[index] = event;\n        send();\n      }).needs(supply));\n    });\n\n    if (!supply.isOff) {\n      send = () => dispatch(...result);\n    }\n  };\n\n  const latestEvent = (): TEvent[] => {\n\n    const result: TEvent[] = [];\n\n    sources.forEach(\n        source => onceEvent(source[AfterEvent__symbol]())({\n          supply: new Supply(),\n          receive: (_ctx, ...event) => result.push(event),\n        }),\n    );\n\n    return result;\n  };\n\n  return afterEventBy(shareEvents(afterEventBy(registerReceiver, latestEvent)));\n}\n","import { AfterEvent, afterEventBy } from '../after-event';\nimport { EventSender, OnEvent__symbol } from '../base';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `sender`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `register` function sends\n * one.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param sender - An event sender.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `register` function. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper of events either originated from the given `sender`, or `initial` one.\n */\nexport function afterSent<TEvent extends any[]>(\n    sender: EventSender<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent> {\n  return afterEventBy(receiver => sender[OnEvent__symbol]()(receiver), fallback);\n}\n","import { AfterEvent } from '../after-event';\nimport { AfterEvent__symbol, EventKeeper, EventSupplier, isEventKeeper } from '../base';\nimport { afterSent } from './after-sent';\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `keeper`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param keeper - A keeper of events.\n *\n * @returns An {@link AfterEvent} keeper of events originated from the given `keeper`.\n */\nexport function afterSupplied<TEvent extends any[]>(keeper: EventKeeper<TEvent>): AfterEvent<TEvent>;\n\n/**\n * Builds an {@link AfterEvent} keeper of events sent by the given `supplier`.\n *\n * The event generated by `fallback` will be sent to the registered first receiver, unless `supplier` sends one.\n *\n * This is a synonym of {@link afterSent}, unless `supplier` is an {@link EventKeeper}.\n *\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - An event supplier.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `supplier`. A receiver registration would lead to an error otherwise.\n *\n * @returns An {@link AfterEvent} keeper of events either originated from the given `supplier`, or `initial` one.\n */\nexport function afterSupplied<TEvent extends any[]>(\n    supplier: EventSupplier<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent>;\n\nexport function afterSupplied<TEvent extends any[]>(\n    supplier: EventSupplier<TEvent>,\n    fallback?: (this: void) => TEvent,\n): AfterEvent<TEvent> {\n  return isEventKeeper(supplier) ? supplier[AfterEvent__symbol]() : afterSent(supplier, fallback);\n}\n","import { noop, valueProvider } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\n\n/**\n * Builds an {@link AfterEvent} keeper of the given `event`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param event - An event that will be sent to all receivers upon registration.\n *\n * @returns An {@link AfterEvent} keeper that always sends the given `event`.\n */\nexport function afterThe<TEvent extends any[]>(...event: TEvent): AfterEvent<TEvent> {\n  return afterEventBy(noop, valueProvider(event));\n}\n","import { AfterEvent, isAfterEvent } from '../after-event';\nimport { afterThe } from './after-the';\n\n/**\n * Builds an {@link AfterEvent} keeper of the given `value`.\n *\n * @category Core\n * @typeParam T - Value type.\n * @param value - Either a value that will be sent to all receivers upon registration, or an {@link AfterEvent} keeper\n * of such values.\n *\n * @returns An {@link AfterEvent} keeper that always sends the given `value`, or the `value` itself, when it is already\n * an `AfterEvent` keeper.\n */\nexport function afterValue<T>(value: T | AfterEvent<[T]>): AfterEvent<[T]>;\n\n/**\n * Builds an {@link AfterEvent} keeper of the optional `value`.\n *\n * @category Core\n * @typeParam T - Value type.\n * @param value - Either `undefined`, a value that will be sent to all receivers upon registration, or an\n * {@link AfterEvent} keeper of optional values.\n *\n * @returns An {@link AfterEvent} keeper that always sends the given `value`, or the `value` itself, when it is already\n * an `AfterEvent` keeper.\n */\nexport function afterValue<T>(value: T | AfterEvent<[T?]> | undefined): AfterEvent<[T?]>;\n\nexport function afterValue<T>(value: T | AfterEvent<[T]>): AfterEvent<[T]> {\n  return isAfterEvent(value) ? value : afterThe(value);\n}\n","import { neverSupply, Supply, SupplyPeer } from '@proc7ts/supply';\nimport { OnEvent } from '../on-event';\n\n/**\n * Creates an event processor that consumes incoming events.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming event type. This is a list of consumer function parameter types.\n * @param consume - A function consuming events. This function may return a {@link SupplyPeer peer of event supply},\n * e.g. when registers a nested event receiver. This supply will be cut off on new event, unless returned again.\n *\n * @returns A function accepting incoming event supplier and returning event supply that will stop consuming events once\n * cut off.\n */\nexport function consumeEvents<TEvent extends any[]>(\n    consume: (this: void, ...event: TEvent) => SupplyPeer | void | undefined,\n): (this: void, input: OnEvent<TEvent>) => Supply {\n  return input => {\n\n    let consumerSupply = neverSupply();\n\n    // Do not use `.cuts()` here as `consumerSupply` is mutable\n    const supply = new Supply(reason => consumerSupply.off(reason));\n\n    input({\n      supply,\n      receive(_ctx, ...event: TEvent) {\n\n        const prevSupply = consumerSupply;\n\n        try {\n          consumerSupply = (consume(...event) || neverSupply()).supply;\n        } finally {\n          if (consumerSupply !== prevSupply) {\n            prevSupply.off();\n          }\n        }\n      },\n    });\n\n    return supply;\n  };\n}\n","import { AfterEvent, afterEventBy } from '../after-event';\nimport { shareEvents } from '../impl';\n\n/**\n * A processor of events incoming from {@link AfterEvent} keeper that shares outgoing events supply among all registered\n * receivers.\n *\n * The created keeper receives events from this one and sends to registered receivers. The shared keeper registers\n * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n * event supplies do.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event keeper to share events from.\n *\n * @returns An {@link AfterEvent} keeper sharing a common supply of events.\n */\nexport function shareAfter<TEvent extends any[]>(supplier: AfterEvent<TEvent>): AfterEvent<TEvent> {\n  return afterEventBy(shareEvents(supplier));\n}\n","import { arraysAreEqual, asis, countArgs } from '@proc7ts/primitives';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { shareAfter } from './share-after';\n\nlet deduplicateAfter$default:// eslint-disable-line @typescript-eslint/naming-convention\n    | ((this: void, input: AfterEvent<any>) => AfterEvent<any>)\n    | undefined;\n\n/**\n * Creates an event processor that ensures the same event incoming from `{@link AfterEvent} keeper is not reported\n * twice.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type.\n * @param isDuplicate - A function that checks whether the next incoming event is a duplicate of a previously reported\n * one. Accepts a prior and next event tuples as parameters, and returns a truthy value if they are duplicates.\n * By default, treats event tuples as duplicates if corresponding meaningful arguments are strictly equal.\n *\n * @returns Deduplicating processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function deduplicateAfter<TEvent extends any[]>(\n    isDuplicate?: (this: void, prior: TEvent, next: TEvent) => boolean,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent>;\n\n/**\n * Creates an event processor that similar events incoming from `{@link AfterEvent} keeper are not reported more than\n * once.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type.\n * @typeParam TCue - An event cue type.\n * @param isSimilar - A function that checks whether the next incoming event is similar to previously reported one.\n * Accepts the prior and next event cues as parameters, and returns a truthy value if those are cues of similar events.\n * @param getCue - A function that accepts an event tuple and returns its cue.\n *\n * @returns Deduplicating processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function deduplicateAfter<TEvent extends any[], TCue>(\n    isSimilar: (this: void, prior: TCue, next: TCue) => boolean,\n    getCue: (this: void, value: TEvent) => TCue,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent>;\n\nexport function deduplicateAfter<TEvent extends any[], TCue>(\n    isSimilar?: (this: void, prior: TCue, next: TCue) => boolean,\n    getCue?: (this: void, value: TEvent) => TCue,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent> {\n  return isSimilar || getCue\n      ? deduplicateAfter$create(isSimilar, getCue)\n      : (deduplicateAfter$default || (deduplicateAfter$default = deduplicateAfter$create()));\n}\n\nfunction deduplicateAfter$create<TEvent extends any[], TCue>(\n    isSimilar?: (this: void, prior: TCue, next: TCue) => boolean,\n    getCue?: (this: void, value: TEvent) => TCue,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent> {\n\n  const processor = deduplicateAfter_(isSimilar!, getCue!);\n\n  return input => shareAfter(processor(input));\n}\n\nlet deduplicateAfter_$default:// eslint-disable-line @typescript-eslint/naming-convention\n    | ((this: void, input: AfterEvent<any>) => AfterEvent<any>)\n    | undefined;\n\n/**\n * Creates an event processor that ensures the same event incoming from `{@link AfterEvent} keeper is not reported\n * twice, and does not share the outgoing events supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type.\n * @param isDuplicate - A function that checks whether the next incoming event is a duplicate of a previously reported\n * one. Accepts a prior and next event tuples as parameters, and returns a truthy value if they are duplicates.\n * By default, treats event tuples as duplicates if corresponding meaningful arguments are strictly equal.\n *\n * @returns Deduplicating processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function deduplicateAfter_<TEvent extends any[]>(// eslint-disable-line @typescript-eslint/naming-convention\n    isDuplicate?: (this: void, prior: TEvent, next: TEvent) => boolean,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent>;\n\n/**\n * Creates an event processor that similar events incoming from `{@link AfterEvent} keeper are not reported more than\n * once, and does not share the outgoing events supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type.\n * @typeParam TCue - An event cue type.\n * @param isSimilar - A function that checks whether the next incoming event is similar to previously reported one.\n * Accepts the prior and next event cues as parameters, and returns a truthy value if those are cues of similar events.\n * @param getCue - A function that accepts an event tuple and returns its cue.\n *\n * @returns Deduplicating processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function deduplicateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TEvent extends any[],\n    TCue>(\n    isSimilar: (this: void, prior: TCue, next: TCue) => boolean,\n    getCue: (this: void, value: TEvent) => TCue,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent>;\n\nexport function deduplicateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TEvent extends any[],\n    TCue>(\n    isSimilar?: (this: void, prior: TCue, next: TCue) => boolean,\n    getCue?: (this: void, value: TEvent) => TCue,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent> {\n  return isSimilar || getCue\n      ? deduplicateAfter_$create(isSimilar, getCue)\n      : (deduplicateAfter_$default || (deduplicateAfter_$default = deduplicateAfter_$create())\n      );\n}\n\nconst deduplicateAfter$noPrior = {/* magic value meaning there is no cue */};\n\nfunction deduplicateAfter_$create<// eslint-disable-line @typescript-eslint/naming-convention\n    TEvent extends any[],\n    TCue\n    >(\n    isSimilar = deduplicateAfter$isDuplicate as (this: void, prior: TCue, next: TCue) => boolean,\n    getCue = asis as (this: void, value: TEvent) => TCue,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent> {\n  return input => {\n\n    let prior: TCue | typeof deduplicateAfter$noPrior = deduplicateAfter$noPrior;\n\n    return afterEventBy(\n        ({ supply, receive }) => input({\n          supply,\n          receive(ctx, ...nextEvent) {\n\n            const next = getCue(nextEvent);\n\n            if (prior === deduplicateAfter$noPrior || !isSimilar(prior as TCue, next)) {\n              prior = next;\n              receive(ctx, ...nextEvent);\n            }\n          },\n        }),\n        undefined,\n        _ => prior = deduplicateAfter$noPrior,\n    );\n  };\n}\n\nfunction deduplicateAfter$isDuplicate<TEvent extends any[]>(prior: TEvent, next: TEvent): boolean {\n  return arraysAreEqual(prior, next, Math.max(countArgs(prior), countArgs(next)));\n}\n","import { AfterEvent, afterEventBy } from '../after-event';\nimport { EventKeeper } from '../base';\nimport { digEvents } from '../impl';\nimport { afterSupplied } from '../keepers';\nimport { OnEvent } from '../on-event';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that extracts event keepers from events incoming from `{@link AfterEvent} keeper.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event keeper from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function digAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that extracts event keepers from events incoming from `{@link OnEvent} sender.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event keeper from incoming event. May return `undefined` when\n * nothing extracted.\n * @param fallback - A function creating fallback event.\n *\n * @returns New processor of events incoming from {@link @OnEvent} sender.\n */\nexport function digAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n    fallback: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\nexport function digAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n    fallback?: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const processor = digAfter_(extract, fallback!);\n\n  return input => shareAfter(processor(input));\n}\n\n/**\n * Creates an event processor that extracts event keepers from events incoming from `{@link AfterEvent} keeper,\n * and does not share the outgoing events supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event keeper from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New processor of events incoming from {@link @AfterEvent} keeper.\n */\nexport function digAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that extracts event keepers from events incoming from `{@link OnEvent} sender,\n * and does not share the outgoing events supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event keeper from incoming event. May return `undefined` when\n * nothing extracted.\n * @param fallback - A function creating fallback event.\n *\n * @returns New processor of events incoming from {@link @OnEvent} sender.\n */\nexport function digAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n    fallback: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\nexport function digAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventKeeper<TOutEvent> | void | undefined,\n    fallback?: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const extractKeeper = (...events: TInEvent): AfterEvent<TOutEvent> | void => {\n\n    const extracted = extract(...events);\n\n    return extracted && afterSupplied(extracted);\n  };\n\n  return input => afterEventBy(digEvents(input, extractKeeper), fallback);\n}\n","import { EventNotifier, EventSender, OnEvent__symbol } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Event emitter is a handy implementation of {@link OnEvent} sender.\n *\n * Extends {@link EventNotifier} by making its {@link EventNotifier.on} method implement an {@link OnEvent} interface.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n */\nexport class EventEmitter<TEvent extends any[]> extends EventNotifier<TEvent> implements EventSender<TEvent> {\n\n  /**\n   * {@link OnEvent} sender of {@link send emitted} events.\n   *\n   * The `[OnEvent__symbol]` method is an alias of this one.\n   */\n  readonly on: OnEvent<TEvent> = onEventBy(receiver => super.on(receiver));\n\n  [OnEvent__symbol](): OnEvent<TEvent> {\n    return this.on;\n  }\n\n}\n","import { neverReceive } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * An {@link OnEvent} sender that never sends any events.\n *\n * @category Core\n */\nexport const onNever: OnEvent<any> = (/*#__PURE__*/ onEventBy(neverReceive));\n","import { AfterEvent__symbol, EventSupplier, isEventSender, OnEvent__symbol } from '../base';\nimport { OnEvent } from '../on-event';\n\n/**\n * Builds an {@link OnEvent} sender of events supplied by the given `supplier`.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - An event supplier.\n *\n * @returns An {@link OnEvent} sender of events originated from the given `supplier`.\n */\nexport function onSupplied<TEvent extends any[]>(supplier: EventSupplier<TEvent>): OnEvent<TEvent> {\n  return isEventSender(supplier) ? supplier[OnEvent__symbol]() : supplier[AfterEvent__symbol]();\n}\n","import { Supply } from '@proc7ts/supply';\nimport { EventSupplier } from '../base';\nimport { shareEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onNever } from './on-never';\nimport { onSupplied } from './on-supplied';\n\n/**\n * Builds an {@link OnEvent} sender of events sent by any of the given `suppliers`.\n *\n * The resulting event supply is cut off as soon as all source supplies do.\n *\n * @category Core\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param suppliers - Original event suppliers.\n *\n * @returns An {@link OnEvent} sender of all supplied events.\n */\nexport function onAny<TEvent extends any[]>(...suppliers: EventSupplier<TEvent>[]): OnEvent<TEvent> {\n  if (!suppliers.length) {\n    return onNever as OnEvent<TEvent>;\n  }\n\n  return onEventBy(shareEvents(onEventBy<TEvent>(({ supply, receive }) => {\n\n    let remained = suppliers.length;\n    const removeSupplier = (reason?: any): void => {\n      if (!--remained) {\n        supply.off(reason);\n      }\n    };\n\n    suppliers.forEach(\n        supplier => onSupplied(supplier)({\n          supply: new Supply(removeSupplier).needs(supply),\n          receive,\n        }),\n    );\n  })));\n}\n","import { EventReceiver } from '../base';\nimport { alwaysReceiveValue, neverReceiveBecause } from '../base/impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Represents a promise as event sender.\n *\n * When the `promise` resolves successfully the resolved value is sent to registered event receivers. The events\n * supply is {@link Supply.off cut off} immediately after that without any reason specified.\n *\n * When the `promise` is rejected the events supply is {@link Supply.off cut off} with promise rejection reason.\n *\n * @category Core\n * @typeParam T - A type of value the promise is resolved to.\n * @param promise - The promise to represent as event sender.\n *\n * @returns An {@link OnEvent} sender of the given `promise` settlement event.\n */\nexport function onPromise<T>(promise: Promise<T>): OnEvent<[T]> {\n\n  let receive = (receiver: EventReceiver.Generic<[T]>): void => {\n    promise.then(() => receive(receiver), () => receive(receiver));\n  };\n\n  promise.then(value => {\n    receive = alwaysReceiveValue(value);\n  }).catch(e => {\n    receive = neverReceiveBecause(e);\n  });\n\n  return onEventBy(receiver => receive(receiver));\n}\n","import { EventReceiver } from '../event-receiver';\nimport { sendEventsTo } from '../send-events-to';\n\n/**\n * @internal\n */\nexport function alwaysReceiveValue<T>(value: T): (receiver: EventReceiver.Generic<[T]>) => void {\n  return receiver => {\n    try {\n      sendEventsTo(receiver)(value);\n      receiver.supply.off();\n    } catch (e) {\n      receiver.supply.off(e);\n    }\n  };\n}\n","import { shareEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor of events incoming from {@link OnEvent} sender that shares outgoing events supply among all registered\n * receivers.\n *\n * The created sender receives events from this one and sends to registered receivers. The shared sender registers\n * a receiver in this one only once, when first receiver registered. And cuts off original events supply once all\n * supplies do.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event sender to share events from.\n *\n * @returns An {@link OnEvent} sender sharing a common supply of events.\n */\nexport function shareOn<TEvent extends any[]>(supplier: OnEvent<TEvent>): OnEvent<TEvent> {\n  return onEventBy(shareEvents(supplier));\n}\n","import { EventSupplier } from '../base';\nimport { digEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { onSupplied } from '../senders';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that extracts event senders from incoming events.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event supplier from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New event processor.\n */\nexport function digOn<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventSupplier<TOutEvent> | void | undefined,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const processor = digOn_(extract);\n\n  return input => shareOn(processor(input));\n}\n\n/**\n * Creates an event processor that extracts event senders from incoming events, and does not share the outgoing events\n * supply.\n *\n * The outgoing events supply is cut off once the incoming events supply do.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming events type.\n * @typeParam TOutEvent - Extracted events type.\n * @param extract - A function extracting outgoing event supplier from incoming event. May return `undefined` when\n * nothing extracted.\n *\n * @returns New event processor.\n */\nexport function digOn_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    extract: (this: void, ...event: TInEvent) => EventSupplier<TOutEvent> | void | undefined,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const extractSender = (...event: TInEvent): OnEvent<TOutEvent> | void => {\n\n    const extracted = extract(...event);\n\n    return extracted && onSupplied(extracted);\n  };\n\n  return input => onEventBy(digEvents(input, extractSender));\n}\n","import { translateEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event sender to another one.\n */\nexport function translateOn<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n\n  const mapper = translateOn_(translate);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender, and does not share the\n * outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event sender to another one.\n */\nexport function translateOn_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: OnEvent<TInEvent>) => OnEvent<TOutEvent> {\n  return input => onEventBy(translateEvents(input, translate));\n}\n","import { AfterEvent, afterEventBy } from '../after-event';\nimport { translateEvents } from '../impl';\nimport { OnEvent } from '../on-event';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that converts events incoming from {@link AfterEvent} keeper with the given converter\n * function.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]>;\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function and fallback.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n * @param fallback - A function creating a fallback of outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback: (this: void) => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]>;\n\nexport function mapAfter<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback?: (this: void) => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]> {\n\n  const mapper = mapAfter_(convert, fallback!);\n\n  return input => shareAfter(mapper(input));\n}\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function, and does not share the outgoing events supply.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n *\n * @returns New event mapper.\n */\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<[TResult]>;\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function and fallback, and does not share the outgoing events supply.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n * @param fallback - A function creating a fallback of outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback: (this: void) => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]>;\n\nexport function mapAfter_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n    fallback?: (this: void) => TResult,\n): (this: void, input: OnEvent<TEvent>) => AfterEvent<[TResult]> {\n  return input => afterEventBy(\n      translateEvents(\n          input,\n          (send, ...event) => send(convert(...event)),\n      ),\n      fallback && (() => [fallback()]),\n  );\n}\n","import { translateEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { shareOn } from './share-on';\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns converted outgoing event.\n *\n * @returns New event mapper.\n */\nexport function mapOn<TEvent extends any[], TResult>(\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TResult]> {\n\n  const mapper = mapOn_(convert);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that converts events incoming from {@link OnEvent} sender with the given converter\n * function, and does not share the outgoing events supply.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming events type.\n * @typeParam TResult - Outgoing events type.\n * @param convert - A converter function that accepts incoming event as parameters and returns outgoing event value.\n *\n * @returns New event mapper.\n */\nexport function mapOn_<TEvent extends any[], TResult>(// eslint-disable-line @typescript-eslint/naming-convention\n    convert: (this: void, ...event: TEvent) => TResult,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TResult]> {\n  return input => onEventBy(translateEvents(\n      input,\n      (send, ...event) => send(convert(...event)),\n  ));\n}\n","import { AfterEvent, afterEventBy } from '../after-event';\nimport { onceEvent } from '../impl';\n\n/**\n * A processor of the first event incoming from {@link AfterEvent} keeper.\n *\n * Cuts off the outgoing events supply after sending the first event.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event keeper to receive an event from.\n *\n * @returns New keeper of the first event.\n */\nexport function onceAfter<TEvent extends any[]>(supplier: AfterEvent<TEvent>): AfterEvent<TEvent> {\n  return afterEventBy(onceEvent(supplier));\n}\n","import { AfterEvent } from '../after-event';\nimport { onceEvent } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor of the first event incoming from {@link OnEvent} sender.\n *\n * Cuts off the outgoing event supply after sending the first event.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param supplier - Event sender to receive an event from.\n *\n * @returns New sender of the first event.\n */\nexport function onceOn<TEvent extends any[]>(\n    supplier: OnEvent<TEvent>,\n): OnEvent<TEvent> | AfterEvent<TEvent> {\n  return onEventBy(onceEvent(supplier));\n}\n","import { asis } from '@proc7ts/primitives';\nimport { isAlwaysSupply, Supply, SupplyPeer } from '@proc7ts/supply';\nimport { supplyEvents } from '../impl';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * Creates an event processor that passes events incoming from {@link OnEvent} sender until the `required` supply is\n * cut off.\n *\n * The outgoing events supply will be cut off once incoming event supply does, unless a second supply passed in.\n * In the latter case that supply will be cut off instead.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param required - A peer of required event supply. The returned processor does nothing when `alwaysSupply()`\n * specified.\n * @param dependentSupply - The supply to cut off on cutting off the incoming events supply.\n *\n * @returns New event mapper.\n */\nexport function supplyOn<TEvent extends any[]>(\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<TEvent> {\n  return isAlwaysSupply(required.supply)\n      ? asis\n      : (input: OnEvent<TEvent>) => onEventBy(supplyEvents(input, required, dependentSupply));\n}\n","import { Supply } from '@proc7ts/supply';\nimport { sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\nimport { mapOn } from './map-on';\nimport { resolveOn } from './resolve-on';\nimport { supplyOn } from './supply-on';\n\n/**\n * A processor that asynchronously resolves incoming events and sends them in the order they are received.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved in the same\n * order as they have been received. Mat send events in batches, e.g. when events resolved out of order.\n *\n * The resulting events supply is cut off if some of incoming event promises rejected. In this case the rejection reason\n * is used as a reason to cut off. If incoming events supply is cut off, then the resulting event supply will be cut off\n * too, but only after all incoming events resolved and sent.\n *\n * @category Event Processing\n * @typeParam TEvent - Resolved event type.\n * @param from - A sender of events or promise-like instances resolved to ones.\n *\n * @returns New `OnEvent` sender of resolved events.\n */\nexport function resolveOnOrdered<TEvent>(\n    from: OnEvent<[PromiseLike<TEvent> | TEvent]>,\n): OnEvent<[TEvent, ...TEvent[]]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    const sourceSupply = new Supply();\n    let numInProcess = 0;\n    const source = from.do(\n        supplyOn(supply, sourceSupply),\n        mapOn(event => {\n          ++numInProcess;\n          return event;\n        }),\n    );\n    let received: TEvent[] = [];\n    let numSent = 1;\n    let numReceived = 0;\n\n    sourceSupply.whenOff(reason => {\n      if (!numInProcess) {\n        supply.off(reason);\n      }\n    });\n\n    resolveOn(source)({\n      supply,\n      receive(_ctx, event, index) {\n\n        const i = index - numSent;\n\n        received[i] = event;\n        ++numReceived;\n        if (numReceived > i) {\n\n          let toSend: TEvent[];\n\n          if (numReceived === received.length) {\n            // Can send all received events\n            toSend = received;\n            received = [];\n          } else {\n            // Can send events up to `i`\n            toSend = received.splice(0, i + 1);\n          }\n          numSent += toSend.length;\n          numReceived -= toSend.length;\n          numInProcess -= toSend.length;\n\n          dispatch(...(toSend as [TEvent, ...TEvent[]]));\n          if (!numInProcess && sourceSupply.isOff) {\n            supply.needs(sourceSupply);\n          }\n        }\n      },\n    });\n  });\n}\n","import { sendEventsTo } from '../base';\nimport { OnEvent, onEventBy } from '../on-event';\n\n/**\n * A processor that asynchronously resolves incoming events and sends then in the order of their resolution.\n *\n * Receives events or their promises from the given event sender, and sends them once they are resolved. The original\n * order of events is not preserved. Instead each resolved event is sent along with its index in original order.\n *\n * The resulting events supply is cut off immediately once unresolved events supply is cut off, or some of incoming\n * event promises rejected. In the latter case the rejection reason is used as a reason to cut off.\n *\n * @category Event Processing\n * @typeParam T - A type of values the promises resolve to.\n * @param from - A sender of events or promise-like instances resolved to ones.\n *\n * @returns New `OnEvent` sender of resolved events and their indices in original order starting from `1`.\n */\nexport function resolveOn<T>(from: OnEvent<[PromiseLike<T> | T]>): OnEvent<[T, number]> {\n  return onEventBy(receiver => {\n\n    const { supply } = receiver;\n    const dispatch = sendEventsTo(receiver);\n\n    let lastIndex = 0;\n\n    from({\n      supply,\n      receive(_ctx, promise) {\n\n        const index = ++lastIndex;\n\n        Promise.resolve()\n            .then(() => promise)\n            .then(\n                event => dispatch(event, index),\n                reason => supply.off(reason),\n            );\n      },\n    });\n  });\n}\n","import { asis } from '@proc7ts/primitives';\nimport { isAlwaysSupply, Supply, SupplyPeer } from '@proc7ts/supply';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport { supplyEvents } from '../impl';\n\n/**\n * Creates an event processor that passes events incoming from {@link AfterEvent} keeper until the `required` supply\n * is cut off.\n *\n * The outgoing events supply will be cut off once incoming event supply does, unless a second supply passed in.\n * In the latter case that supply will be cut off instead.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of event receiver parameter types.\n * @param required - A peer of required event supply. The returned processor does nothing when `alwaysSupply()`\n * specified.\n * @param dependentSupply - The supply to cut off on cutting off the incoming events supply.\n *\n * @returns New event mapper.\n */\nexport function supplyAfter<TEvent extends any[]>(\n    required: SupplyPeer,\n    dependentSupply?: Supply,\n): (this: void, input: AfterEvent<TEvent>) => AfterEvent<TEvent> {\n  return isAlwaysSupply(required.supply)\n      ? asis\n      : (input: AfterEvent<TEvent>) => afterEventBy(supplyEvents(\n          input,\n          required,\n          dependentSupply,\n      ));\n}\n","import { AfterEvent, afterEventBy } from '../after-event';\nimport { translateEvents } from '../impl';\nimport { OnEvent } from '../on-event';\nimport { shareAfter } from './share-after';\n\n/**\n * Creates an event processor that translates events incoming from {@link AfterEvent} keeper.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating outgoing event fallback.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\nexport function translateAfter<\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback?: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent> {\n\n  const mapper = translateAfter_(translate, fallback!);\n\n  return input => shareAfter(mapper(input));\n}\n\n/**\n * Creates an event processor that translates events incoming from {@link AfterEvent} keeper, and does not share the\n * outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n): (this: void, input: AfterEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback, and does not\n * share the outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating outgoing event fallback.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent>;\n\n/**\n * Creates an event processor that translates events incoming from {@link OnEvent} sender with fallback, and does not\n * share the outgoing events supply.\n *\n * The translated events expected to be sent by the given `translate` function.\n *\n * The returned mapper does the same as the one created by {@link translateOn_} one, but returns an {@link AfterEvent}\n * keeper instead of {@link OnEvent} sender. This can not be always done without a `fallback`, as not every\n * transformation results to valid {@link EventKeeper}. E.g. when some events filtered out.\n *\n * @category Event Processing\n * @typeParam TInEvent - Incoming event type.\n * @typeParam TOutEvent - Outgoing translated event type.\n * @param translate - Event translation function. Accepts an outgoing event sender function as first parameter,\n * and incoming event as the rest of them.\n * @param fallback - A function creating fallback event. When omitted, the initial event is expected to be sent by\n * `translate` function. A receiver registration would lead to an error otherwise.\n *\n * @returns A mapping function of incoming event keeper to another one.\n */\nexport function translateAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    TInEvent extends any[],\n    TOutEvent extends any[],\n    >(\n    translate: (this: void, send: (...event: TOutEvent) => void, ...event: TInEvent) => void,\n    fallback?: (this: void) => TOutEvent,\n): (this: void, input: OnEvent<TInEvent>) => AfterEvent<TOutEvent> {\n  return input => afterEventBy(translateEvents(input, translate), fallback);\n}\n","import { OnEvent } from '../on-event';\nimport { shareOn } from './share-on';\nimport { translateOn_ } from './translate-on';\n\n/**\n * Creates an event processor that sends the values of incoming events.\n *\n * Events are valued by provided `value` function. The `null`, `undefined`, and `false` values are dropped.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming event type.\n * @typeParam TValue - Event value type.\n * @param valueOf - Event value detector function. Accepts incoming event as parameters and returns either its value,\n * or `false`/`null`/`undefined` to ignore it.\n *\n * @returns New event processor.\n */\nexport function valueOn<TEvent extends any[], TValue>(\n    valueOf: (this: void, ...event: TEvent) => TValue | false | null | undefined,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TValue]> {\n\n  const mapper = valueOn_(valueOf);\n\n  return input => shareOn(mapper(input));\n}\n\n/**\n * Creates an event processor that sends the values of incoming events, and does not share the outgoing events supply.\n *\n * @category Event Processing\n * @typeParam TEvent - Incoming event type.\n * @typeParam TValue - Event value type.\n * @param valueOf - Event value detector function. Accepts incoming event as parameters and returns either its value,\n * or `false`/`null`/`undefined` to ignore it.\n *\n * @returns New event processor.\n */\nexport function valueOn_<TEvent extends any[], TValue>(// eslint-disable-line @typescript-eslint/naming-convention\n    valueOf: (this: void, ...event: TEvent) => TValue | false | null | undefined,\n): (this: void, input: OnEvent<TEvent>) => OnEvent<[TValue]> {\n  return translateOn_((send, ...event) => {\n\n    const value = valueOf(...event);\n\n    if (value != null && value !== false) {\n      send(value);\n    }\n  });\n}\n","/**\n * A path to state or its part. E.g. property value.\n *\n * May consist of one or more property keys.\n *\n * An array consisting of the only one property key is the same as this property key.\n *\n * An empty array is a path to the state itself.\n *\n * @category State Tracking\n */\nexport type StatePath = PropertyKey | StatePath.Normalized;\n\n/**\n * @category State Tracking\n */\nexport namespace StatePath {\n\n  /**\n   * Normalized state path.\n   *\n   * This is always an array of property keys.\n   */\n  export type Normalized = readonly PropertyKey[];\n\n}\n\n/**\n * Normalizes a state path consisting of single key.\n *\n * @category State Tracking\n * @typeParam TKey - A type of path key.\n * @param key - A path key.\n *\n * @return Normalized state path.\n */\nexport function statePath<TKey extends PropertyKey>(key: TKey): readonly [TKey];\n\n/**\n * Normalizes arbitrary state path. I.e. converts it to array.\n *\n * @param path - Arbitrary state path.\n *\n * @return Normalized state path.\n */\nexport function statePath(path: StatePath): StatePath.Normalized;\n\nexport function statePath(path: StatePath): StatePath.Normalized {\n  return (Array.isArray(path) ? path : [path]) as StatePath.Normalized;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { EventSender, OnEvent__symbol } from '../base';\nimport { onEventBy } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { OnStateUpdate } from './on-state-update';\nimport { statePath, StatePath } from './state-path';\nimport { StateUpdateReceiver } from './state-update-receiver';\n\n/**\n * @internal\n */\nclass PathEntry {\n\n  readonly emitter = new EventEmitter<[StatePath.Normalized, any, any]>();\n  private readonly _nested = new Map<PropertyKey, PathEntry>();\n\n  constructor(private readonly _drop: () => void) {\n    this.emitter.on((path, newValue, oldValue) => {\n\n      const key = path[0];\n      const nested = this._nested.get(key);\n\n      if (nested) {\n        nested.emitter.send(path.slice(1), newValue, oldValue);\n      }\n    });\n  }\n\n  on(receiver: StateUpdateReceiver): Supply {\n\n    const supply = this.emitter.on(receiver);\n\n    return new Supply(reason => {\n      supply.off(reason);\n      this._dropIfEmpty();\n    }).needs(supply);\n  }\n\n  nest(key: PropertyKey): PathEntry;\n\n  nest(key: PropertyKey, dontCreateMissing: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined;\n\n  nest(key: PropertyKey, dontCreateMissing?: true): PathEntry | undefined {\n\n    const found = this._nested.get(key);\n\n    if (found || dontCreateMissing) {\n      return found;\n    }\n\n    const created = new PathEntry(() => this._remove(key));\n\n    this._nested.set(key, created);\n\n    return created;\n  }\n\n  done(reason?: unknown): void {\n    for (const nested of this._nested.values()) {\n      nested.done(reason);\n    }\n    this.emitter.supply.off(reason);\n  }\n\n  private _remove(key: PropertyKey): void {\n    this._nested.delete(key);\n    this._dropIfEmpty();\n  }\n\n  private _dropIfEmpty(): void {\n    if (!this._nested.size && this.emitter.size <= 1) {\n      this._drop();\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nclass Trackers {\n\n  private readonly _root = new PathEntry(noop);\n\n  on(path: StatePath.Normalized, receiver: StateUpdateReceiver): Supply {\n    return this._entry(path).on(receiver);\n  }\n\n  send<T>(path: StatePath.Normalized, newValue: T, oldValue: T): void {\n    this._root.emitter.send(path, newValue, oldValue);\n  }\n\n  done(path: StatePath.Normalized, reason?: unknown): void {\n\n    const entry = this._entry(path, true);\n\n    if (entry) {\n      entry.done(reason);\n    }\n  }\n\n  private _entry(path: StatePath.Normalized): PathEntry;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing: true): PathEntry | undefined;\n\n  private _entry(path: StatePath.Normalized, dontCreateMissing?: true): PathEntry | undefined {\n\n    let entry = this._root;\n\n    for (const key of path) {\n\n      const nested = entry.nest(key, dontCreateMissing);\n\n      if (!nested) {\n        return;\n      }\n\n      entry = nested;\n    }\n\n    return entry;\n  }\n\n}\n\n/**\n * @internal\n */\nclass SubStateTracker implements StateTracker {\n\n  readonly update: <T>(\n      this: void,\n      path: StatePath,\n      newValue: T,\n      oldValue: T,\n  ) => void;\n\n  readonly onUpdate: OnStateUpdate = onEventBy<[StatePath.Normalized, any, any]>(\n      receiver => this._trackers.on(this._path, receiver),\n  );\n\n  constructor(private readonly _trackers: Trackers, private readonly _path: StatePath.Normalized) {\n    this.update = <T>(path: StatePath, newValue: T, oldValue: T) => {\n      this._trackers.send([...this._path, ...statePath(path)], newValue, oldValue);\n    };\n  }\n\n  get _tracker(): this {\n    return this;\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  track(path: StatePath): SubStateTracker {\n    path = statePath(path);\n    if (!path.length) {\n      return this; // Path to itself.\n    }\n    return new SubStateTracker(this._trackers, [...this._path, ...path]);\n  }\n\n  done(reason?: unknown): void {\n    this._trackers.done(this._path, reason);\n  }\n\n}\n\n/**\n * State changes tracker.\n *\n * A state is a tree-like structure of sub-states (nodes) available under {@link StatePath}.\n *\n * When node modified a {@link StateTracker.update} should be called. Then all state update receivers registered by\n * {@link StateTracker.onUpdate} will receive this update.\n *\n * @category State Tracking\n */\nexport class StateTracker implements EventSender<[StatePath.Normalized, any, any]> {\n\n  /**\n   * @internal\n   */\n  readonly _tracker: SubStateTracker = new SubStateTracker(new Trackers(), []);\n\n  /**\n   * {@link OnStateUpdate state updates sender}.\n   *\n   * A state update will be sent to it whenever an `update()` function is called.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns State updates sender.\n   */\n  get onUpdate(): OnStateUpdate {\n    return this._tracker.onUpdate;\n  }\n\n  [OnEvent__symbol](): OnStateUpdate {\n    return this.onUpdate;\n  }\n\n  // noinspection JSCommentMatchesSignature\n  /**\n   * Updates the component state.\n   *\n   * All receivers registered with {@link onUpdate} will receive this update.\n   *\n   * @typeParam T - A type of changed value.\n   * @param key - Changed value key.\n   * @param newValue - New value.\n   * @param oldValue - Previous value.\n   */\n  get update(): <T>(\n      this: void,\n      path: StatePath,\n      newValue: T,\n      oldValue: T,\n  ) => void {\n    return this._tracker.update;\n  }\n\n  /**\n   * Starts tracking of partial state under the given path.\n   *\n   * @param path - A path to state part.\n   *\n   * @return New partial state tracker.\n   */\n  track(path: StatePath): StateTracker {\n\n    const subTracker = this._tracker.track(path);\n\n    return subTracker === this._tracker ? this : subTracker;\n  }\n\n  /**\n   * Unregisters updates receivers and cuts off their supplies.\n   *\n   * After this method call the updates receivers of this partial state and all nested states won't receive any updates.\n   *\n   * @param reason - An optional reason to stop tracking.\n   */\n  done(reason?: unknown): void {\n    this._tracker.done(reason);\n  }\n\n}\n","import { neverSupply, Supply, SupplyPeer } from '@proc7ts/supply';\nimport { AfterEvent, afterEventBy } from '../after-event';\nimport {\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupplier,\n  isEventKeeper,\n  OnEvent__symbol,\n} from '../base';\nimport { OnEvent } from '../on-event';\nimport { consumeEvents } from '../processors';\nimport { onSupplied } from '../senders';\n\n/**\n * Value accessor and changes tracker.\n *\n * Implements an {@link EventSender} interface by sending value changes to registered receivers as a pair of new and old\n * values.\n *\n * Implements an {@link EventKeeper} interface by sending current value and its updates.\n *\n * @category Value Tracking\n * @typeParam T - Tracked value type.\n */\nexport abstract class ValueTracker<T> implements EventSender<[T, T]>, EventKeeper<[T]>, SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private _by = neverSupply();\n\n  /**\n   * {@link OnEvent} sender of value changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Value changes sender.\n   */\n  abstract readonly on: OnEvent<[T, T]>;\n\n  /**\n   * {@link AfterEvent} keeper of current value.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns Current value keeper.\n   */\n  readonly read: AfterEvent<[T]> = afterEventBy(\n      receiver => this.on(receiveNewValue(receiver)),\n      () => [this.it],\n  );\n\n  [OnEvent__symbol](): OnEvent<[T, T]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * An event supply of this value tracker.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * The tracked value.\n   */\n  abstract it: T;\n\n  /**\n   * Updates the tracked value by the given value `supplier`.\n   *\n   * If the value is already updated by another supplier, then unbinds from the old one first.\n   *\n   * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @param supplier - The source value sender or keeper.\n   *\n   * @returns `this` instance.\n   */\n  by(supplier: EventSupplier<[T]>): this;\n\n  /**\n   * Updates the tracked value by value suppliers extracted from events sent by the given `supplier`.\n   *\n   * If the value is already updated by another value supplier, then unbinds from the old one first.\n   *\n   * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n   *\n   * Note that explicitly updating the value would override the value received from the `source`.\n   *\n   * @typeParam TSrcEvent - Source event type.\n   * @param supplier - The event supplier to extract value suppliers from.\n   * @param extract - A function extracting value supplier from event received from `supplier`.\n   * May return `undefined` to suspend receiving values.\n   *\n   * @returns `this` instance.\n   */\n  by<TSrcEvent extends any[]>(\n      supplier: EventSupplier<TSrcEvent>,\n      extract: (this: void, ...event: TSrcEvent) => EventSupplier<[T]> | undefined,\n  ): this;\n\n  by<TSrcEvent extends any[]>(\n      supplier: EventSupplier<TSrcEvent> | EventSupplier<[T]>,\n      extract?: (this: void, ...event: TSrcEvent) => EventSupplier<[T]> | undefined,\n  ): this {\n\n    const acceptValuesFrom = (sender: EventSupplier<[T]>): Supply => {\n\n      const onValue = isEventKeeper(sender) ? sender[AfterEvent__symbol]() : sender[OnEvent__symbol]();\n\n      return onValue(value => this.it = value);\n    };\n\n    this.byNone();\n    if (!extract) {\n\n      const sender = supplier as EventSupplier<[T]>;\n\n      this._by = acceptValuesFrom(sender);\n    } else {\n\n      const container = supplier as EventSupplier<TSrcEvent>;\n\n      this._by = onSupplied(container).do(consumeEvents((...event) => {\n\n        const sender = extract(...event);\n\n        if (sender) {\n          return acceptValuesFrom(sender);\n        }\n\n        return;\n      }));\n    }\n\n    this._by.whenOff(() => this._by = neverSupply());\n\n    return this;\n  }\n\n  /**\n   * Unbinds the tracked value from any value supplier this tracker is {@link ValueTracker.by updated by}.\n   *\n   * If the tracker is not bound then does nothing.\n   *\n   * @param reason - Arbitrary reason of unbinding the value.\n   *\n   * @returns `this` instance.\n   */\n  byNone(reason?: any): this {\n    this._by.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction receiveNewValue<T>(\n    valueReceiver: EventReceiver.Generic<[T]>,\n): EventReceiver.Generic<[T, T]> {\n  return {\n    supply: valueReceiver.supply,\n    receive(context, newValue) {\n      valueReceiver.receive(\n          {\n            onRecurrent(recurrentReceiver) {\n              context.onRecurrent(recurrentValue => recurrentReceiver(recurrentValue));\n            },\n          },\n          newValue,\n      );\n    },\n  };\n}\n","import { Supply } from '@proc7ts/supply';\nimport { EventKeeper } from '../base';\nimport { OnEvent } from '../on-event';\nimport { EventEmitter } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * @internal\n */\nclass TrackedValue<T> extends ValueTracker<T> {\n\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  constructor(private _it: T) {\n    super();\n  }\n\n  get supply(): Supply {\n    return this._on.supply;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._on.on;\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const oldValue = this._it;\n\n    if (oldValue !== value) {\n      this._it = value;\n      this._on.send(value, oldValue);\n    }\n  }\n\n}\n\n/**\n * Constructs a value which changes can be tracked.\n *\n * @category Value Tracking\n * @param initial - Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial: T): ValueTracker<T>;\n\n/**\n * Constructs an optional value which changes can be tracked.\n *\n * @param initial - Initial value.\n *\n * @returns Value tracker instance.\n */\nexport function trackValue<T>(initial?: T): ValueTracker<T | undefined>;\n\nexport function trackValue<T>(initial: T): ValueTracker<T> {\n  return new TrackedValue<T>(initial);\n}\n\n/**\n * Constructs a tracked value updated by the given value `supplier`.\n *\n * If the value is already updated by another supplier, then unbinds from the old one first.\n *\n * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @category Value Tracking\n * @param supplier - The source value keeper.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T>(supplier: EventKeeper<[T]>): ValueTracker<T>;\n\n/**\n * Constructs a tracked value updated by value keepers extracted from events sent by the given `supplier`.\n *\n * If the value is already updated by another value supplier, then unbinds from the old one first.\n *\n * Call the {@link ValueTracker.byNone} method to unbind the tracked value from the `source`.\n *\n * Note that explicitly updating the value would override the value received from the `source`.\n *\n * @typeParam TSrc - Source value type.\n * @param supplier - The event keeper to extract value keepers from.\n * @param extract - A function extracting value keeper from event received from `supplier`.\n *\n * @returns `this` instance.\n */\nexport function trackValueBy<T, TSrc extends any[]>(\n    supplier: EventKeeper<TSrc>,\n    extract: (this: void, ...event: TSrc) => EventKeeper<[T]>,\n): ValueTracker<T>;\n\nexport function trackValueBy<T, TSrc extends any[]>(\n    supplier: EventKeeper<TSrc> | EventKeeper<[T]>,\n    extract?: (this: void, ...event: TSrc) => EventKeeper<[T]>,\n): ValueTracker<T> {\n  return (trackValue() as ValueTracker<T>).by(\n      supplier as EventKeeper<TSrc>,\n      extract as (this: void, ...event: TSrc) => EventKeeper<[T]>,\n  );\n}\n","import { Supply } from '@proc7ts/supply';\nimport { EventKeeper, EventSender, EventSupplier, isEventKeeper } from '../base';\nimport { afterSupplied } from '../keepers';\nimport { OnEvent } from '../on-event';\nimport { consumeEvents } from '../processors';\nimport { EventEmitter, onSupplied } from '../senders';\nimport { ValueTracker } from './value-tracker';\n\n/**\n * Synchronizes tracked values with each other.\n *\n * Any change to any of the added tracked values would update all the others.\n *\n * @category Value Tracking\n */\nexport class ValueSync<T> extends ValueTracker<T> {\n\n  /**\n   * @internal\n   */\n  private readonly _on = new EventEmitter<[T, T]>();\n\n  /**\n   * @internal\n   */\n  private _it: T;\n\n  constructor(initial: T) {\n    super();\n    this._it = initial;\n  }\n\n  get on(): OnEvent<[T, T]> {\n    return this._on.on;\n  }\n\n  get supply(): Supply {\n    return this._on.supply;\n  }\n\n  get it(): T {\n    return this._it;\n  }\n\n  set it(value: T) {\n\n    const old = this.it;\n\n    if (old !== value) {\n      this._it = value;\n      this._on.send(value, old);\n    }\n  }\n\n  /**\n   * Synchronizes the tracked value with the others.\n   *\n   * Applies the value from this sync to the given tracker first.\n   *\n   * @param tracker - A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link Supply.off Cut it off} to break synchronization.\n   */\n  sync(tracker: ValueTracker<T>): Supply;\n\n  /**\n   * Synchronizes the tracked value with the others in the given direction.\n   *\n   * @param direction - If set to `\"in\"` the value from the given tracker takes precedence over the one in\n   * {@link ValueSync}. Otherwise the value from the sync is applied to the given tracker first.\n   * @param tracker - A value tracker to keep in sync.\n   *\n   * @returns An event supply. {@link Supply.off Cut it off} to break synchronization.\n   */\n  sync(direction: 'in' | 'out', tracker: ValueTracker<T>): Supply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * Applies the value from this sync to extracted trackers.\n   *\n   * @typeParam TSrcEvent - A type of supplied events to extract value trackers from.\n   * @param supplier - The event supplier to extract value trackers from.\n   * @param extract - A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link Supply.off Cut it off} to break synchronization.\n   */\n  sync<TSrcEvent extends any[]>(\n      supplier: EventSupplier<TSrcEvent>,\n      extract: (this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined,\n  ): Supply;\n\n  /**\n   * Synchronizes the tracked value with the ones extracted from the events sent by the given `supplier`\n   * in the given direction.\n   *\n   * Once next value tracker extracted the previous one becomes out of sync.\n   *\n   * @typeParam TSrcEvent - A type of supplied events to extract value trackers from.\n   * @param direction - If set to `\"in\"` the value from extracted tracker takes precedence over the one in\n   * {@link ValueSync}. Otherwise the value from the sync is applied to extracted trackers first.\n   * @param supplier - The event supplier to extract value trackers from.\n   * @param extract - A function extracting the value tracker to keep in sync from the event received from `supplier`.\n   * May return `undefined` to just break the sync with previous tracker.\n   *\n   * @returns An event supply. {@link Supply.off Cut it off} to break synchronization.\n   */\n  sync<TSrcEvent extends any[]>(\n      direction: 'in' | 'out',\n      supplier: EventSupplier<TSrcEvent>,\n      extract: (this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined,\n  ): Supply;\n\n  sync<TSrcEvent extends any[]>(\n      first: 'in' | 'out' | ValueTracker<T> | EventSupplier<TSrcEvent>,\n      second?: ValueTracker<T>\n          | EventSender<TSrcEvent>\n          | EventKeeper<TSrcEvent>\n          | ((this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined),\n      third?: (this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined,\n  ): Supply {\n\n    let syncWithTracker = (tracker: ValueTracker<T>): Supply => syncTrackers(this, tracker);\n    let source: ValueTracker<T> | EventSupplier<TSrcEvent>;\n    let extract: ((this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined) | undefined;\n\n    if (typeof first === 'string') {\n      if (first === 'in') {\n        syncWithTracker = tracker => syncTrackers(tracker, this);\n      }\n      source = second as ValueTracker<T> | EventSender<TSrcEvent> | EventKeeper<TSrcEvent>;\n      extract = third;\n    } else {\n      source = first;\n      extract = second as (this: void, ...event: TSrcEvent) => ValueTracker<T> | undefined;\n    }\n\n    const extractTracker = extract;\n\n    if (!extractTracker) {\n      return syncWithTracker(source as ValueTracker<T>);\n    }\n\n    const supplier = source as EventSupplier<TSrcEvent>;\n\n    return (isEventKeeper(supplier) ? afterSupplied(supplier) : onSupplied(supplier)).do(consumeEvents(\n        (...event) => {\n\n          const tracker = extractTracker(...event);\n\n          return tracker && syncWithTracker(tracker);\n        },\n    ));\n\n    function syncTrackers(tracker1: ValueTracker<T>, tracker2: ValueTracker<T>): Supply {\n\n      const supply1 = tracker1.read(value => {\n        tracker2.it = value;\n      });\n      const supply2 = tracker2.on(value => {\n        tracker1.it = value;\n      });\n\n      return new Supply(reason => {\n        supply2.off(reason);\n        supply1.off(reason);\n      }).needs(supply1).needs(supply2);\n    }\n  }\n\n}\n","import { eventReceiver, EventReceiver, OnEvent, OnEvent__symbol, onEventBy } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport type { Supply } from '@proc7ts/supply';\n\n/**\n * DOM event listener.\n *\n * DOM events are never recurrent.\n *\n * May be constructed using {@link onDomEventBy} function.\n *\n * @typeParam TEvent - Supported DOM event type.\n */\nexport type DomEventListener<TEvent extends Event> = EventReceiver<[TEvent]>;\n\n/**\n * Signature of {@link EventSender} implementation able to register DOM event listeners.\n *\n * @typeParam TEvent - Supported DOM event type.\n */\nexport interface OnDomEvent<TEvent extends Event> extends OnEvent<[TEvent]> {\n\n  /**\n   * Starts sending DOM events to the given `listener`.\n   *\n   * @param listener - Target listener of DOM events.\n   * @param opts - DOM event listener options to pass to `EventTarget.addEventListener()`.\n   *\n   * @returns A supply of DOM events from this sender to the given `listener`.\n   */\n  (listener: DomEventListener<TEvent>, opts?: AddEventListenerOptions | boolean): Supply;\n\n}\n\n/**\n * @internal\n * @hidden\n */\nconst OnDomEvent$sample = (/*#__PURE__*/ onEventBy<any>(noop));\n\n/**\n * Converts a plain DOM event listener registration function to {@link OnDomEvent} sender.\n *\n * @typeParam TEvent - Supported DOM event type.\n * @param register - A generic DOM event listener registration function.\n *\n * @returns An {@link OnDomEvent} sender registering event listeners with the given `register` function.\n */\nexport function onDomEventBy<TEvent extends Event>(\n    register: (\n        this: void,\n        listener: EventReceiver.Generic<[TEvent]>,\n        opts?: AddEventListenerOptions | boolean,\n    ) => void,\n): OnDomEvent<TEvent> {\n\n  const onDomEvent = ((listener: DomEventListener<TEvent>, opts?: AddEventListenerOptions | boolean): Supply => {\n\n    const receiver = eventReceiver(listener);\n    const { supply } = receiver;\n\n    if (!supply.isOff) {\n      register(receiver, opts);\n    }\n\n    return supply;\n  }) as OnDomEvent<TEvent>;\n\n  onDomEvent[OnEvent__symbol] = OnDomEvent$sample[OnEvent__symbol];\n  onDomEvent.do = OnDomEvent$sample.do;\n  onDomEvent.then = OnDomEvent$sample.then;\n\n  return onDomEvent;\n}\n","import type { EventReceiver } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { OnDomEvent, onDomEventBy } from './on-dom-event';\n\n/**\n * @internal\n * @hidden\n */\nconst OnDomEvent$context: EventReceiver.Context<any> = {\n  onRecurrent: noop,\n};\n\n/**\n * DOM event dispatcher can be used to register event listeners of particular event types and dispatch events.\n */\nexport class DomEventDispatcher implements SupplyPeer {\n\n  readonly supply: Supply = new Supply();\n\n  /**\n   * @internal\n   */\n  private readonly _target: EventTarget;\n\n  /**\n   * Constructs DOM event dispatcher for the given event target.\n   *\n   * @param target - Event target to construct event dispatcher for.\n   */\n  constructor(target: EventTarget) {\n    this._target = target;\n  }\n\n  /**\n   * Returns a sender of DOM events of the given `type`.\n   *\n   * The returned DOM event sender calls an `EventTarget.addEventListener()` to register listeners.\n   * But, in contrast, it allows to register the same listener many times.\n   *\n   * The {@link Supply event supply} returned upon event listener registration unregisters it with\n   * `EventTarget.removeEventListener()` once {@link Supply.off cut off}.\n   *\n   * @typeParam TEvent - Supported DOM event type.\n   * @param type - DOM event type name.\n   *\n   * @returns {@link OnDomEvent} sender of DOM events of the given `type`.\n   */\n  on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n    return onDomEventBy<TEvent>((listener, opts) => {\n\n      const { supply } = listener;\n\n      supply.needs(this);\n\n      if (!supply.isOff) {\n\n        // Create unique DOM listener instance\n        const domListener: EventListener = event => listener.receive(OnDomEvent$context, event as TEvent);\n\n        this._target.addEventListener(type, domListener, opts);\n        listener.supply.whenOff(() => this._target.removeEventListener(type, domListener));\n      }\n    });\n  }\n\n  /**\n   * Dispatches the given DOM event to event target.\n   *\n   * Calls `EventTarget.dispatchEvent()` method.\n   *\n   * @param event - An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise. Also returns `false` when {@link supply} is cut off.\n   */\n  dispatch(event: Event): boolean {\n    return !this.supply.isOff && this._target.dispatchEvent(event);\n  }\n\n}\n","/**\n * Creates a function that throws a context destruction reason.\n *\n * This may be handy when {@link ContextSupply context supply} is cut off.\n *\n * @param reason - Context destruction reason.\n */\nexport function contextDestroyed(reason: unknown = new TypeError('Context destroyed')): () => never {\n  return () => {\n    throw reason;\n  };\n}\n","import {\n  afterEach,\n  AfterEvent,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  isAfterEvent,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { itsElements, mapIt, overElementsOf, overIterator } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport type { ContextRef } from '../context-ref';\nimport type { ContextValues } from '../context-values';\nimport { ContextSupply } from '../conventional';\nimport type { ContextSeeder, ContextValueSlot } from '../key';\nimport { ContextKey, ContextKey__symbol, ContextSeedKey } from '../key';\nimport type { ContextValueProvider } from '../registry';\n\n/**\n * @internal\n */\nconst flatUpSources: <TSrc>(this: void, input: AfterEvent<TSrc[][]>) => AfterEvent<TSrc[]> = (\n    /*#__PURE__*/ translateAfter((send, ...sources) => send(...itsElements(overElementsOf(...sources))))\n);\n\n/**\n * @internal\n */\nclass ContextUpSeeder<TCtx extends ContextValues, TSrc>\n    implements ContextSeeder<TCtx, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n\n  private readonly _providers = trackValue<[Map<Supply, ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>>]>(\n      [new Map()],\n  );\n\n  provide(provider: ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>): Supply {\n\n    const [providers] = this._providers.it;\n    const supply = new Supply();\n\n    providers.set(supply, provider);\n    this._providers.it = [providers];\n\n    return supply.whenOff(() => {\n\n      const [providers] = this._providers.it;\n\n      providers.delete(supply);\n\n      this._providers.it = [providers];\n    });\n  }\n\n  seed(context: TCtx, initial: AfterEvent<TSrc[]> = afterThe<TSrc[]>()): AfterEvent<TSrc[]> {\n    return this.combine(initial, upSrcKeepers(context, this._providers));\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  combine(first: AfterEvent<TSrc[]>, second: AfterEvent<TSrc[]>): AfterEvent<TSrc[]> {\n    return afterEach(first, second).do(flatUpSources);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction upSrcKeepers<TCtx extends ContextValues, TSrc>(\n    context: TCtx,\n    providersTracker: ValueTracker<[Map<Supply, ContextValueProvider<ContextUpKey.Source<TSrc>, TCtx>>]>,\n): AfterEvent<TSrc[]> {\n  return providersTracker.read.do(\n      digAfter_(\n          ([providers]): AfterEvent<TSrc[][]> => !providers.size\n              ? afterThe()\n              : afterEach(\n                  ...mapIt(\n                      mapIt(\n                          overIterator(() => providers.values()),\n                          prov => prov(context),\n                      ),\n                      toUpSrcKeeper,\n                  ),\n              ),\n      ),\n      flatUpSources,\n  );\n}\n\n/**\n * @internal\n */\nfunction toUpSrcKeeper<TSrc>(src: null | undefined | ContextUpKey.Source<TSrc>): AfterEvent<TSrc[]> {\n  return isAfterEvent(src)\n      ? src\n      : (src != null ? afterThe(src) : afterThe());\n}\n\n/**\n * @internal\n */\nclass ContextSeed$UpKey<TSrc>\n    extends ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SeedKey<TSrc> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  seeder<TCtx extends ContextValues>(): ContextSeeder<TCtx, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n    return new ContextUpSeeder();\n  }\n\n}\n\n/**\n * Updatable context value reference.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport interface ContextUpRef<TValue, TSrc> extends ContextRef<TValue, ContextUpKey.Source<TSrc>> {\n\n  readonly [ContextKey__symbol]: ContextUpKey<TValue, TSrc>;\n\n}\n\n/**\n * @internal\n */\nclass ContextUpKey$UpKey<TUpdate extends any[], TSrc>\n    extends ContextKey<AfterEvent<TUpdate>, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpKey.SimpleUpKey<TUpdate, TSrc> {\n\n  readonly grow: (\n      slot: ContextValueSlot<\n          AfterEvent<TUpdate>,\n          ContextUpKey.Source<TSrc>,\n          AfterEvent<TSrc[]>>,\n  ) => void;\n\n  get seedKey(): ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n    return this._key.seedKey;\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor(\n      private readonly _key: ContextUpKey<unknown, TSrc>,\n      grow: (\n          slot: ContextValueSlot<\n              AfterEvent<TUpdate>,\n              ContextUpKey.Source<TSrc>,\n              AfterEvent<TSrc[]>>,\n      ) => void,\n  ) {\n    super(_key.name + ':up');\n    this.grow = slot => {\n\n      const value: AfterEvent<TUpdate> | null | undefined = slot.fillBy(grow);\n\n      if (value != null) {\n        slot.insert(value.do(\n            supplyAfter(slot.context.get(ContextSupply)),\n        ));\n      }\n    };\n  }\n\n}\n\n/**\n * Abstract implementation of updatable context value key.\n *\n * Accepts a {@link ContextUpKey.Source} instances as source values.\n *\n * Collects value sources into `AfterEvent` keeper of source values.\n *\n * @typeParam TValue - Context value type.\n * @typeParam TSrc - Source value type.\n */\nexport abstract class ContextUpKey<TValue, TSrc>\n    extends ContextKey<TValue, ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>>\n    implements ContextUpRef<TValue, TSrc>, ContextUpKey.Base<TValue, TSrc> {\n\n  readonly seedKey: ContextUpKey.SeedKey<TSrc>;\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updates keeper} of this key value.\n   *\n   * It is expected to report any updates to this key's value.\n   *\n   * The value of updates key is constructed by {@link grow} function out of the same seed.\n   */\n  abstract readonly upKey: ContextUpKey.UpKey<TValue, TSrc>;\n\n  /**\n   * Constructs simple context value key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<TSrc>;\n      } = {},\n  ) {\n    super(name);\n    this.seedKey = seedKey || new ContextSeed$UpKey<TSrc>(this);\n  }\n\n  /**\n   * Creates a key of context value containing an `AfterEvent` keeper of updates to the value of this key.\n   *\n   * @typeParam TUpdate - Context value update type.\n   * @param grow - A function that grows an updates keeper of context value out of its seed.\n   *\n   * @returns New updates keeper key.\n   */\n  protected createUpKey<TUpdate extends any[]>(\n      grow: (\n          slot: ContextValueSlot<\n              AfterEvent<TUpdate>,\n              ContextUpKey.Source<TSrc>,\n              AfterEvent<TSrc[]>>,\n      ) => void,\n  ): ContextUpKey.SimpleUpKey<TUpdate, TSrc> {\n    return new ContextUpKey$UpKey(this, grow);\n  }\n\n}\n\nexport namespace ContextUpKey {\n\n  /**\n   * A source value accepted by {@link ContextUpKey updatable context key}.\n   *\n   * Either a single source value, or an `AfterEvent` keeper of source values.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export type Source<TSrc> = TSrc | AfterEvent<TSrc[]>;\n\n  /**\n   * A type of context value updates tracker.\n   *\n   * It is the same as a type of original value if the value itself is an event keeper, or an `AfterEvent` keeper\n   * of original value otherwise.\n   *\n   * @typeParam TValue - Original context value type.\n   */\n  export type Up<TValue> = TValue extends EventKeeper<any> ? TValue : AfterEvent<[TValue]>;\n\n  /**\n   * Base interface of updatable context value key.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface Base<TValue, TSrc> extends ContextKey<TValue, ContextUpKey.Source<TSrc>> {\n\n    /**\n     * A key of context value containing an {@link ContextUpKey.Up updatable value tracker}.\n     *\n     * It is expected to report any updates to this key's value.\n     *\n     * The value of updates key is constructed by {@link grow} function out of the same seed.\n     */\n    readonly upKey: UpKey<TValue, TSrc>;\n\n  }\n\n  /**\n   * A key of context value containing an {@link ContextUpKey.Up updatable value tracker}.\n   *\n   * @typeParam TValue - Context value type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface UpKey<TValue, TSrc> extends ContextKey<ContextUpKey.Up<TValue>, ContextUpKey.Source<TSrc>> {\n\n    /**\n     * A reference to this key.\n     *\n     * Indicates that this key is updatable too.\n     */\n    readonly upKey: this;\n\n  }\n\n  /**\n   * A key of context value containing an `AfterEvent` keeper of updates of {@link ContextUpKey updatable value}.\n   *\n   * @typeParam TUpdate - Context value update type.\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SimpleUpKey<TUpdate extends any[], TSrc> extends Base<AfterEvent<TUpdate>, TSrc> {\n\n    readonly upKey: this;\n\n  }\n\n  /**\n   * Updatable context value seed key.\n   *\n   * @typeParam TSrc - Source value type.\n   */\n  export interface SeedKey<TSrc> extends ContextSeedKey<ContextUpKey.Source<TSrc>, AfterEvent<TSrc[]>> {\n\n    /**\n     * A key of context value containing an {@link Up updates keeper} of the seed. Always equal to this key.\n     */\n    readonly upKey: this;\n\n  }\n\n}\n","import type { AfterEvent } from '@proc7ts/fun-events';\nimport { shareAfter, translateAfter_ } from '@proc7ts/fun-events';\nimport { isPresent } from '@proc7ts/primitives';\nimport { filterIt, mapIt } from '@proc7ts/push-iterator';\nimport type { ContextValues } from '../../context-values';\nimport type { Contextual } from '../../conventional';\nimport { Contextual__symbol, isContextual } from '../../conventional';\n\n/**\n * Creates an event processor that {@link applyContextTo} applies context to values and their {@link Contextual\n * contextual references} incoming from {@link AfterEvent} keeper.\n *\n * This function is applicable to updatable context value {@link ContextUpKey.Source sources} potentially containing\n * contextual references.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param context - A context to apply.\n *\n * @returns A mapping function of `AfterEvent` keeper of values, their contextual references, or `null`/`undefined`\n * elements to `AfterEvent` keeper of resolved values.\n */\nexport function applyContextAfter<T, TCtx extends ContextValues = ContextValues>(\n    context: TCtx,\n): (this: void, source: AfterEvent<(T | Contextual<T, TCtx> | null | undefined)[]>) => AfterEvent<T[]> {\n\n  const processor = applyContextAfter_<T, TCtx>(context);\n\n  return source => shareAfter(processor(source));\n}\n\n/**\n * Creates an event processor that {@link applyContextTo} applies context to values and their {@link Contextual\n * contextual references} incoming from {@link AfterEvent} keeper, and does not share the outgoing events supply.\n *\n * This function is applicable to updatable context value {@link ContextUpKey.Source sources} potentially containing\n * contextual references to resolve the latter before providing to context.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param context - A context to apply.\n *\n * @returns A mapping function of `AfterEvent` keeper of values, their contextual references, or `null`/`undefined`\n * elements to `AfterEvent` keeper of resolved values.\n */\nexport function applyContextAfter_<// eslint-disable-line @typescript-eslint/naming-convention\n    T,\n    TCtx extends ContextValues = ContextValues>(\n    context: TCtx,\n): (this: void, source: AfterEvent<(T | Contextual<T, TCtx> | null | undefined)[]>) => AfterEvent<T[]> {\n  return translateAfter_((send, ...values) => send(\n      ...filterIt<T | null | undefined, T>(\n          mapIt(\n              values,\n              (value): T | null | undefined => isContextual(value)\n                  ? value[Contextual__symbol](context)\n                  : value,\n          ),\n          isPresent,\n      ),\n  ));\n}\n","import { AfterEvent, afterThe, digAfter } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ContextKeyError } from '../context-key-error';\nimport type { ContextValues } from '../context-values';\nimport type { ContextKeyDefault, ContextValueSlot } from '../key';\nimport { contextDestroyed } from './context-destroyed';\nimport { ContextUpKey, ContextUpRef } from './context-up-key';\n\n/**\n * A reference to updatable context function value.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport type FnContextRef<TArgs extends any[], TRet = void> =\n    ContextUpRef<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>;\n\n/**\n * A key of updatable context function value.\n *\n * The value associated with this key is a function that delegates to the last provided function. The target function\n * may be updated.\n *\n * The value is always present. But if the function to delegate is not provided, and no default/fallback function\n * provided, an attempt to call the delegate would throw an {@link ContextKeyError}.\n *\n * It is an error to provide a `null` or `undefined` {@link ContextRequest.Opts.or fallback value} when requesting\n * an associated value. Use an `afterThe()` result as a fallback instead.\n *\n * @typeParam TArgs - Function arguments tuple type.\n * @typeParam TRet - Function return value type.\n */\nexport class FnContextKey<TArgs extends any[], TRet = void>\n    extends ContextUpKey<(this: void, ...args: TArgs) => TRet, (this: void, ...args: TArgs) => TRet>\n    implements FnContextRef<TArgs, TRet> {\n\n  /**\n   * Constructs a function that will be called unless fallback provided.\n   */\n  readonly byDefault: (this: void, context: ContextValues, key: FnContextKey<TArgs, TRet>) =>\n      (this: void, ...args: TArgs) => TRet;\n\n  readonly upKey: ContextUpKey.SimpleUpKey<\n      [(this: void, ...args: TArgs) => TRet],\n      (this: void, ...args: TArgs) => TRet>;\n\n  /**\n   * Constructs updatable context function key.\n   *\n   * @param name - Human-readable key name.\n   * @param seedKey - Value seed key. A new one will be constructed when omitted.\n   * @param byDefault - Constructs a default function to call. If unspecified then the default function would raise\n   * an error.\n   */\n  constructor(\n      name: string,\n      {\n        seedKey,\n        byDefault = noop,\n      }: {\n        seedKey?: ContextUpKey.SeedKey<((this: void, ...args: TArgs) => TRet)>;\n        byDefault?: ContextKeyDefault<(this: void, ...args: TArgs) => TRet, FnContextKey<TArgs, TRet>>;\n      } = {},\n  ) {\n    super(name, seedKey);\n    this.byDefault = (context, key) => byDefault(context, key)\n        || (() => {\n          throw new ContextKeyError(this);\n        });\n    this.upKey = this.createUpKey(slot => slot.insert(slot.seed.do(\n        digAfter((...fns): AfterEvent<[(this: void, ...args: TArgs) => TRet]> => {\n          if (fns.length) {\n            return afterThe(fns[fns.length - 1]);\n          }\n\n          if (slot.hasFallback && slot.or) {\n            return slot.or;\n          }\n\n          return afterThe(this.byDefault(slot.context, this));\n        }),\n    )));\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          (this: void, ...args: TArgs) => TRet,\n          ContextUpKey.Source<(this: void, ...args: TArgs) => TRet>,\n          AfterEvent<((this: void, ...args: TArgs) => TRet)[]>>,\n  ): void {\n\n    let delegated: (this: void, ...args: TArgs) => TRet;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        fn => delegated = fn,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n","import type { ContextModule } from './context-module';\n\n/**\n * An error indicating context module dependency load failure.\n */\nexport class ContextModuleDependencyError extends Error {\n\n  /**\n   * Constructs context module dependency load error.\n   *\n   * @param module - A module failed to load.\n   * @param reasons - An array of dependency/reason pairs caused the load failure.\n   * @param message - An error message.\n   */\n  constructor(\n      readonly module: ContextModule,\n      readonly reasons: readonly (readonly [ContextModule, unknown?])[] = [],\n      readonly message: string = contextModuleDependencyErrorMessage(module, reasons),\n  ) {\n    super(message);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction contextModuleDependencyErrorMessage(\n    module: ContextModule,\n    dependencies: readonly (readonly [ContextModule, unknown?])[],\n): string {\n\n  const reasons = dependencies.reduce(\n      (out, [dep, reason]) => {\n        if (out) {\n          out += ', ';\n        } else {\n          out = ': ';\n        }\n        if (reason !== undefined) {\n          out += `${dep} failed to load (${reason})`;\n        } else {\n          out += `${dep} not loaded`;\n        }\n\n        return out;\n      },\n      '',\n  );\n\n  return `Failed to load ${module}${reasons}`;\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  mapAfter_,\n  OnEvent,\n  onEventBy,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { noop, valueProvider } from '@proc7ts/primitives';\nimport { neverSupply, Supply, SupplyPeer } from '@proc7ts/supply';\nimport type { ContextRequest } from '../../context-request';\nimport type { ContextValues } from '../../context-values';\nimport { ContextSupply } from '../../conventional';\nimport type { ContextRegistry } from '../../registry';\nimport type { ContextModule } from './context-module';\n\n/**\n * @internal\n */\nexport class ContextModuleUsage {\n\n  private readonly _impl: ValueTracker<ContextModule | undefined>;\n  private readonly _rev: ValueTracker<ContextModuleRev>;\n  private _useCounter = 0;\n\n  private _setup!: () => void;\n\n  constructor(context: ContextValues, readonly module: ContextModule) {\n    this._impl = trackValue();\n    this._rev = trackValue({\n      status: {\n        module: this.module,\n        provided: false,\n        used: false,\n        settled: false,\n        ready: false,\n      },\n      supply: neverSupply(),\n    });\n\n    const contextSupply = context.get(ContextSupply);\n\n    contextSupply.cuts(this._impl);\n    contextSupply.cuts(this._rev);\n\n    this._impl.read(module => {\n\n      const prevSupply = this._rev.it.supply;\n\n      if (module) {\n        this._load(module);\n      }\n\n      prevSupply.off();\n    });\n  }\n\n  createHandle(): ContextModule.Handle {\n\n    const read: AfterEvent<[ContextModule.Status]> = this._rev.read.do(\n        mapAfter_(({ status }) => status),\n    );\n\n    const handle: ContextModule.Handle = {\n      read,\n      [AfterEvent__symbol]: valueProvider(read),\n      use: (user?: SupplyPeer) => this._use(handle, user),\n    };\n\n    return handle;\n  }\n\n  setup(context: ContextValues, registry: ContextRegistry): void {\n    this._setup = () => {\n\n      const rev = this._rev.it;\n      const { status: { module }, supply } = rev;\n\n      if (module !== this.module) {\n        // Load implementation module instead.\n        // The implementation module expected to be provided already.\n        context.get(module).use(supply).read({\n          supply,\n          receive: (_ctx, { settled, ready, error }) => {\n            this._updateStatus(rev, settled, ready, error);\n          },\n        });\n      } else {\n        loadContextModule(context, registry, rev)\n            .then(({ whenReady }) => {\n              this._updateStatus(rev, true, false);\n              return whenReady;\n            })\n            .then(() => this._updateStatus(rev, true, true))\n            .catch(error => rev.supply.off(error));\n      }\n    };\n  }\n\n  implementBy(impl: AfterEvent<[ContextModule?]>): void {\n    this._impl.by(impl);\n  }\n\n  private _updateStatus(\n      rev: ContextModuleRev,\n      settled: boolean,\n      ready: boolean,\n      error?: unknown,\n  ): void {\n    // Ensure updating the correct revision.\n    if (this._rev.it.supply !== rev.supply) {\n      // If revision changed, then drop the obsolete one.\n      rev.supply.off();\n    } else {\n      this._rev.it = rev = {\n        status: {\n          module: rev.status.module,\n          provided: rev.status.provided,\n          used: true,\n          settled,\n          ready,\n          error,\n        },\n        supply: rev.supply,\n      };\n    }\n  }\n\n  private _load(module: ContextModule): void {\n\n    const supply = new Supply(noop).needs(this._rev).whenOff(error => {\n\n      const rev = this._rev.it;\n\n      if (rev.supply === supply) {\n        this._rev.it = {\n          status: {\n            ...this._rev.it.status,\n            provided: false,\n            settled: false,\n            ready: false,\n            error,\n          },\n          supply,\n        };\n      }\n    });\n\n    const used = !!this._useCounter;\n\n    this._rev.it = {\n      status: {\n        module,\n        provided: true,\n        used,\n        settled: false,\n        ready: false,\n      },\n      supply,\n    };\n\n    if (used) {\n      this._setup();\n    }\n  }\n\n  private _use(handle: ContextModule.Handle, user?: SupplyPeer): ContextModule.Use {\n\n    const supply = new Supply(noop);\n\n    if (user) {\n      supply.needs(user);\n    }\n\n    const read = handle.read.do(supplyAfter(supply));\n    const use: ContextModule.Use = {\n      ...handle,\n      read,\n      whenSettled: ContextModule$Use$when(read, isContextModuleSettled),\n      whenReady: ContextModule$Use$when(read, isContextModuleReady),\n      supply,\n    };\n\n    if (!supply.isOff) {\n      supply.whenOff(error => {\n        if (!--this._useCounter) {\n\n          const rev = this._rev.it;\n\n          this._rev.it = {\n            status: {\n              ...rev.status,\n              used: false,\n              settled: false,\n              ready: false,\n              error,\n            },\n            supply: new Supply(noop).off(error),\n          };\n\n          rev.supply.off(error);\n        }\n      });\n\n      if (!this._useCounter++) {\n        // Mark the module used and set it up.\n\n        const rev = this._rev.it;\n\n        this._rev.it = {\n          status: {\n            ...rev.status,\n            used: true,\n          },\n          supply: rev.supply,\n        };\n\n        this._setup();\n      }\n    }\n\n    return use;\n  }\n\n}\n\n/**\n * @internal\n */\ninterface ContextModuleRev {\n\n  readonly status: ContextModule.Status;\n  readonly supply: Supply;\n\n}\n\n/**\n * @internal\n */\nasync function loadContextModule(\n    context: ContextValues,\n    registry: ContextRegistry,\n    { status: { module }, supply }: ContextModuleRev,\n): Promise<ContextModuleInit> {\n\n  const moduleInit = new ContextModuleInit(module);\n\n  await module.setup({\n\n    module,\n    supply,\n\n    get(request: ContextRequest<any>) {\n      return context.get(request);\n    },\n\n    provide(spec): Supply {\n      return registry.provide(spec).needs(supply);\n    },\n\n    initBy(init: (this: void) => (void | PromiseLike<unknown>)) {\n      moduleInit.initBy(init);\n    },\n\n  });\n\n  return moduleInit;\n}\n\nclass ContextModuleInit {\n\n  readonly whenReady: Promise<unknown>;\n  private _whenDone: Promise<unknown> = Promise.resolve();\n  private _ready!: (result?: PromiseLike<unknown>) => void;\n\n  constructor(private readonly _module: ContextModule) {\n    this.whenReady = new Promise(resolve => this._ready = resolve);\n  }\n\n  initBy(init: (this: void) => void | PromiseLike<unknown>): void {\n\n    const rev: Promise<unknown> = this._whenDone = this._whenDone\n        .then(init)\n        .finally(() => this._done(rev));\n\n  }\n\n  private _done(rev: Promise<unknown>): void {\n    if (this._whenDone === rev) {\n      this._ready(rev);\n      this.initBy = _init => {\n        throw new TypeError(`${this._module} initialized already, and does not accept new initializers`);\n      };\n    }\n  }\n\n}\n\nfunction ContextModule$Use$when(\n    status: AfterEvent<[ContextModule.Status]>,\n    test: (status: ContextModule.Status) => boolean,\n): OnEvent<[ContextModule.Status]> {\n  return onEventBy(receiver => status({\n    supply: receiver.supply,\n    receive: (context, status) => {\n      if (test(status)) {\n        receiver.receive(context, status);\n        receiver.supply.off();\n      } else if (status.error) {\n        receiver.supply.off(status.error);\n      }\n    },\n  }));\n}\n\nfunction isContextModuleSettled({ settled }: ContextModule.Status): boolean {\n  return settled;\n}\n\nfunction isContextModuleReady({ ready }: ContextModule.Status): boolean {\n  return ready;\n}\n","import type { AfterEvent } from '@proc7ts/fun-events';\nimport { mapAfter_ } from '@proc7ts/fun-events';\nimport type { ContextValueSlot } from '../../key';\nimport { ContextUpKey } from '../context-up-key';\nimport type { ContextModule } from './context-module';\nimport { ContextModuleUsage } from './context-module-usage.impl';\n\n/**\n * @internal\n */\nexport class ContextModuleKey extends ContextUpKey<ContextModule.Handle, ContextModule> {\n\n  constructor(name: string, private readonly _module: ContextModule) {\n    super(name);\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          ContextModule.Handle,\n          ContextUpKey.Source<ContextModule>,\n          AfterEvent<ContextModule[]>>,\n  ): void {\n\n    const usage = new ContextModuleUsage(slot.context, this._module);\n\n    slot.insert(usage.createHandle());\n    slot.setup(({ context, registry }) => usage.setup(context, registry));\n\n    usage.implementBy(implementContextModule(this._module, slot.seed));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction implementContextModule(\n    module: ContextModule,\n    impls: AfterEvent<[ContextModule]>,\n): AfterEvent<[ContextModule | undefined]> {\n  return impls.do(\n      mapAfter_((...candidates) => {\n\n        let impl: ContextModule | undefined;\n\n        for (let i = candidates.length - 1; i >= 0; --i) {\n          impl = candidates[i];\n          if (impl !== module) {\n            break;\n          }\n        }\n\n        return impl;\n      }),\n  );\n}\n","import type { OnEvent } from '@proc7ts/fun-events';\nimport { isDefined, noop, setOfElements, valueProvider } from '@proc7ts/primitives';\nimport { itsElements, valueIt } from '@proc7ts/push-iterator';\nimport type { Supply } from '@proc7ts/supply';\nimport type { ContextRegistry } from '../../registry';\nimport type { ContextUpKey } from '../context-up-key';\nimport type { ContextModule } from './context-module';\nimport { ContextModuleDependencyError } from './context-module-dependency-error';\nimport { ContextModuleKey } from './context-module-key.impl';\n\n/**\n * @internal\n */\nexport const ContextModule$impl__symbol = (/*#__PURE__*/ Symbol('ContextModule.impl'));\n\n/**\n * @internal\n */\nexport class ContextModule$ {\n\n  readonly key: ContextUpKey<ContextModule.Handle, ContextModule>;\n  readonly has: ReadonlySet<ContextModule>;\n  readonly needs: ReadonlySet<ContextModule>;\n\n  private readonly _setup: (\n      this: void,\n      setup: ContextModule.Setup,\n  ) => void | PromiseLike<unknown>;\n\n  constructor(module: ContextModule, readonly name: string, readonly options: ContextModule.Options) {\n    this.key = new ContextModuleKey(`${name}:module`, module);\n\n    const { needs, has, setup } = options;\n\n    this.has = setOfElements(has).add(module);\n    this.needs = setOfElements(needs);\n    this._setup = setup ? setup.bind(options) : noop;\n  }\n\n  replace(\n      module: ContextModule,\n      registry: ContextRegistry,\n      supply: Supply,\n  ): void {\n    for (const replaced of module.has) {\n      if (replaced !== module) {\n        registry.provide({ a: replaced, is: module }).needs(supply);\n      }\n    }\n  }\n\n  async setup(setup: ContextModule.Setup): Promise<void> {\n\n    const deps = contextModuleDeps(setup);\n\n    // Await for module dependencies to be settled.\n    if (!await loadContextModuleDeps(setup, deps, whenContextModuleSettled)) {\n      return;\n    }\n\n    setup.initBy(async () => {\n      // Initialize module dependencies.\n      await loadContextModuleDeps(setup, deps, whenContextModuleReady);\n    });\n\n    await this._setup(setup);\n  }\n\n}\n\ninterface ContextModuleDep {\n  readonly dep: ContextModule;\n  readonly use: ContextModule.Use;\n}\n\nfunction contextModuleDeps(setup: ContextModule.Setup): readonly ContextModuleDep[] {\n\n  const { module, supply } = setup;\n\n  return itsElements(\n      valueIt(\n          module.needs,\n          dep => dep !== module\n              && setup.provide(dep).needs(supply)\n              && {\n                dep,\n                use: setup.get(dep).use(setup),\n              },\n      ),\n  );\n}\n\nfunction loadContextModuleDeps(\n    setup: ContextModule.Setup,\n    deps: readonly ContextModuleDep[],\n    whenLoaded: (use: ContextModule.Use) => OnEvent<[ContextModule.Status]>,\n): Promise<boolean> {\n\n  const { module, supply } = setup;\n  const notLoaded = valueProvider(false);\n  const whenDone = supply.whenDone().then(notLoaded, notLoaded);\n\n  return Promise.race([\n    whenDone,\n    Promise\n        .all(\n            deps\n                .map(\n                    ({ dep, use }) => whenLoaded(use).then(\n                        noop,\n                        error => [dep, error] as const,\n                    ),\n                ),\n        )\n        .then(\n            (results): true | ContextModuleDependencyError => {\n\n              const failures = results.filter<readonly [ContextModule, unknown]>(isDefined);\n\n              return failures.length\n                  ? new ContextModuleDependencyError(module, failures) // Prevent unhandled promise rejection\n                  : true as const;\n            },\n        ),\n  ]).then(\n      result => {\n        if (typeof result !== 'boolean') {\n          // Fail to load module if at leas one of its dependencies failed.\n          return Promise.reject(result);\n        }\n\n        return result;\n      },\n  );\n}\n\nfunction whenContextModuleSettled(use: ContextModule.Use): OnEvent<[ContextModule.Status]> {\n  return use.whenSettled;\n}\n\nfunction whenContextModuleReady(use: ContextModule.Use): OnEvent<[ContextModule.Status]> {\n  return use.whenReady;\n}\n","import type { AfterEvent, EventKeeper, OnEvent } from '@proc7ts/fun-events';\nimport type { Supply, SupplyPeer } from '@proc7ts/supply';\nimport type { ContextValues } from '../../context-values';\nimport { ContextKey__symbol } from '../../key';\nimport type { ContextRegistry, ContextValueSpec } from '../../registry';\nimport { ContextBuilder, ContextBuilder__symbol } from '../../registry';\nimport type { ContextUpKey, ContextUpRef } from '../context-up-key';\nimport { ContextModule$, ContextModule$impl__symbol } from './context-module.impl';\n\n/**\n * Context module.\n *\n * Modules intended to extend the context dynamically.\n *\n * The module is a context value reference that can be used to provide module instance and access its\n * {@link ContextModule.Handle handle}.\n *\n * Usage example:\n * ```typescript\n * // Construct new module.\n * const myModule = new ContextModule('my module', {\n *   setup(setup) {\n *     // Provide the values\n *     setup.provide({ a: Foo, is: 'foo' });\n *   },\n * });\n *\n * // Load the module\n * const myModuleSupply = contextRegistry.provide(myModule);\n *\n * // Start using the module\n * const myModuleUse = await context.get(myModule).use();\n *\n * // Await for the module to load\n * await myModuleUse.whenReady;\n *\n * // Access the value provided by module.\n * console.log(context.get(Foo));\n *\n * // Stop using the module\n * myModuleUse.supply.off();\n *\n * // Unload the module declaration.\n * myModuleSupply.off();\n * ```\n */\nexport class ContextModule implements ContextUpRef<ContextModule.Handle, ContextModule>, ContextBuilder {\n\n  /**\n   * @internal\n   */\n  private readonly [ContextModule$impl__symbol]: ContextModule$;\n\n  /**\n   * Constructs context module.\n   *\n   * @param name - Human-readable module name.\n   * @param options - Module construction options.\n   */\n  constructor(name: string, options: ContextModule.Options = {}) {\n    this[ContextModule$impl__symbol] = new ContextModule$(this, name, options);\n  }\n\n  /**\n   * A key of context module.\n   */\n  get [ContextKey__symbol](): ContextUpKey<ContextModule.Handle, ContextModule> {\n    return this[ContextModule$impl__symbol].key;\n  }\n\n  /**\n   * Human-readable module name.\n   */\n  get name(): string {\n    return this[ContextModule$impl__symbol].name;\n  }\n\n  /**\n   * The modules this one requires.\n   *\n   * Assigned by {@link ContextModule.Options.needs} option.\n   */\n  get needs(): ReadonlySet<ContextModule> {\n    return this[ContextModule$impl__symbol].needs;\n  }\n\n  /**\n   * The modules this one provides.\n   *\n   * Assigned by {@link ContextModule.Options.has} option.\n   *\n   * Always contains the module itself.\n   */\n  get has(): ReadonlySet<ContextModule> {\n    return this[ContextModule$impl__symbol].has;\n  }\n\n  /**\n   * Provides this module and {@link has module replacements}.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry): Supply {\n\n    const supply = registry.provide({ a: this, is: this });\n\n    this[ContextModule$impl__symbol].replace(this, registry, supply);\n\n    return supply;\n  }\n\n  /**\n   * Sets up the module.\n   *\n   * This method is called when loading the module. It is used e.g. to provide more values for the context.\n   *\n   * By default:\n   *\n   * 1. Satisfies module {@link needs dependencies} by setting them up.\n   *\n   *    The dependency considered satisfied when it is {@link ContextModule.Status.settled settled}.\n   *\n   * 2. {@link ContextModule.Setup.initBy Initializes} the module by initializing the dependencies.\n   *\n   *    The dependency considered initialized when it is {@link ContextModule.Status.ready ready for use}.\n   *\n   * 3. Performs the module setup by invoking the {@link ContextModule.Options.setup} method.\n   *\n   * @param setup - Context module setup.\n   *\n   * @returns A promise resolved when the module is set up asynchronously.\n   */\n  setup(setup: ContextModule.Setup): Promise<void> {\n    return this[ContextModule$impl__symbol].setup(setup);\n  }\n\n  toString(): string {\n    return `ContextModule(${this.name})`;\n  }\n\n}\n\nexport namespace ContextModule {\n\n  /**\n   * Context module construction options.\n   */\n  export interface Options {\n\n    /**\n     * A module or modules the constructed one requires.\n     *\n     * The listed modules will be loaded prior to loading the constructed one.\n     */\n    readonly needs?: ContextModule | readonly ContextModule[];\n\n    /**\n     * A module or modules the constructed one provides.\n     *\n     * When specified, the constructed module will be loaded _instead_ of the listed ones.\n     *\n     * The module always provides itself.\n     */\n    readonly has?: ContextModule | readonly ContextModule[];\n\n    /**\n     * Sets up constructed module.\n     *\n     * This method is called when loading the module. It is used e.g. to provide more values for the context.\n     *\n     * @param setup - Context module setup.\n     *\n     * @returns Either nothing to set up the module synchronously, or a promise-like instance resolved when the module\n     * is set up asynchronously.\n     */\n    setup?(setup: ContextModule.Setup): void | PromiseLike<unknown>;\n\n  }\n\n  /**\n   * Context module setup.\n   *\n   * Passed to {@link ContextModule.setup module setup method} in order to access and provide the necessary values.\n   *\n   * @typeParam TCtx - Target context type.\n   */\n  export interface Setup extends ContextValues, SupplyPeer {\n\n    /**\n     * The module to set up.\n     */\n    readonly module: ContextModule;\n\n    /**\n     * Module supply.\n     *\n     * This supply will be cut off once the module is unloaded.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Provides context value.\n     *\n     * The value provider will be removed automatically once the module is unloaded.\n     *\n     * @typeParam TSrc - Source value type.\n     * @typeParam TDeps - Dependencies tuple type.\n     * @param spec - Context value specifier.\n     *\n     * @returns Provider supply instance that removes just added context value provider once cut off.\n     */\n    provide<TSrc, TDeps extends any[]>(\n        spec: ContextValueSpec<ContextValues, unknown, TSrc, TDeps>,\n    ): Supply;\n\n    /**\n     * Registers the module initializer.\n     *\n     * The module initializer registration is only valid during its {@link ContextModule.setup setup}.\n     *\n     * The registered initializers executed after successful module {@link ContextModule.setup}. The modules\n     * is considered {@link ContextModule.Status.ready ready for use} only when all registered initializers succeed.\n     *\n     * The registered initializers executed serially. I.e. then next one does not start until the previous one succeeds.\n     *\n     * It is an error calling this method when the module initialized already.\n     *\n     * @param init - The module initialization function, that returns nothing when the module initialization\n     * completed synchronously, or a promise-like instance resolved when the module initialization completed\n     * asynchronously.\n     */\n    initBy(init: (this: void) => void | PromiseLike<unknown>): void;\n\n  }\n\n  /**\n   * A handle of dynamically loaded context module.\n   *\n   * This value is available in {@link ContextValues.get returned from context} under the module instance used as a key.\n   *\n   * Implements an `EventKeeper` interface by sending a {@link ContextModule.Status module load status} updates.\n   */\n  export interface Handle extends EventKeeper<[ContextModule.Status]> {\n\n    /**\n     * An `AfterEvent` keeper of module load status.\n     *\n     * The `[AfterEvent__symbol]` property is an alias of this one.\n     */\n    readonly read: AfterEvent<[ContextModule.Status]>;\n\n    /**\n     * Initiate the module use.\n     *\n     * @param user - Module user. Contains a supply required by {@link Use.supply module use supply}. The module use\n     * stops once the user supply is cut off.\n     *\n     * @returns A module usage instance.\n     */\n    use(user?: SupplyPeer): Use;\n\n  }\n\n  /**\n   * An instance of the module use.\n   *\n   * The module is active while it is in use. I.e. at least one `Use` instance exists and active.\n   *\n   * The use is active util its {@link supply} is cut off.\n   *\n   * The module use instance can be used as its handle too.\n   */\n  export interface Use extends Handle, SupplyPeer {\n\n    /**\n     * An `AfterEvent` keeper of module load status.\n     *\n     * The `[AfterEvent__symbol]` property is an alias of this one.\n     *\n     * Cuts off the supply when context module no longer {@link supply used}.\n     */\n    readonly read: AfterEvent<[ContextModule.Status]>;\n\n    /**\n     * An `OnEvent` sender of the module settlement event.\n     *\n     * Sends the {@link ContextModule.Status loaded module status} when it is {@link ContextModule.Status.settled\n     * settled}, but possibly before it is {@link ContextModule.Status.ready ready}.\n     *\n     * Cuts off the supply when context module {@link ContextModule.Status.error failed to load} or no longer\n     * {@link supply used}.\n     */\n    readonly whenSettled: OnEvent<[ContextModule.Status]>;\n\n    /**\n     * An `OnEvent` sender of the module readiness event.\n     *\n     * Sends the {@link ContextModule.Status loaded module status} when it is {@link ContextModule.Status.ready ready\n     * for use}.\n     *\n     * Cuts off the supply when context module {@link ContextModule.Status.error failed to load} or no longer\n     * {@link supply used}.\n     */\n    readonly whenReady: OnEvent<[ContextModule.Status]>;\n\n    /**\n     * Module use supply.\n     *\n     * The module use stops once this supply is cut off.\n     */\n    readonly supply: Supply;\n\n  }\n\n  /**\n   * Context module load status.\n   *\n   * This status is reported by {@link ContextModule.Handle loaded module handle}.\n   */\n  export interface Status {\n\n    /**\n     * Loaded module.\n     *\n     * Note that it may differ from the one requested to load. E.g. when another module {@link ContextModule.Options.has\n     * provides} it.\n     */\n    readonly module: ContextModule;\n\n    /**\n     * Whether the module implementation is provided.\n     */\n    readonly provided: boolean;\n\n    /**\n     * Whether the module is {@link Handle.use used} at least once.\n     */\n    readonly used: boolean;\n\n    /**\n     * Whether the module is settled.\n     *\n     * The module is settled when its {@link ContextModule.setup set up} is complete.\n     */\n    readonly settled: boolean;\n\n    /**\n     * Whether the module is loaded and ready for use.\n     *\n     * The module is ready when it is {@link settled}, and all of its {@link ContextModule.Setup.initBy initializers}\n     * succeed.\n     */\n    readonly ready: boolean;\n\n    /**\n     * Error occurred while loading the module.\n     */\n    readonly error?: unknown;\n\n  }\n\n}\n","/**\n * Returns a document of the given DOM node.\n *\n * @param node - Source node.\n *\n * @returns Either an `ownerDocument`, or a node itself if it is a document.\n */\nexport function nodeDocument(node: Node): Document {\n  return node.ownerDocument || (node as Document);\n}\n","/**\n * Checks whether the given DOM node is an [element](https://developer.mozilla.org/en-US/docs/Web/API/Element).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Element`, or `false` everything else.\n */\nexport function isElementNode(node: Node): node is Element {\n  return node.nodeType === 1/* Node.ELEMENT_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is an [attribute](https://developer.mozilla.org/en-US/docs/Web/API/Attr).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Attr`, or `false` everything else.\n */\nexport function isAttributeNode(node: Node): node is Attr {\n  return node.nodeType === 2/* Node.ATTRIBUTE_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is a [text](https://developer.mozilla.org/en-US/docs/Web/API/Text).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Text`, or `false` everything else.\n */\nexport function isTextNode(node: Node): node is Text {\n  return node.nodeType === 3/* Node.TEXT_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is a [CDATA section](https://developer.mozilla.org/en-US/docs/Web/API/CDATASection).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `CDATASection`, or `false` everything else.\n */\nexport function isCDATASectionNode(node: Node): node is CDATASection {\n  return node.nodeType === 4/* Node.CDATA_SECTION_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is a [processing instruction](https://developer.mozilla.org/en-US/docs/Web/API/ProcessingInstruction).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `ProcessingInstruction`, or `false` everything else.\n */\nexport function isProcessingInstructionNode(node: Node): node is ProcessingInstruction {\n  return node.nodeType === 7/* Node.PROCESSING_INSTRUCTION_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is a [comment](https://developer.mozilla.org/en-US/docs/Web/API/Comment).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Comment`, or `false` everything else.\n */\nexport function isCommentNode(node: Node): node is Comment {\n  return node.nodeType === 8/* Node.COMMENT_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is a [document](https://developer.mozilla.org/en-US/docs/Web/API/Document).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `Document`, or `false` everything else.\n */\nexport function isDocumentNode(node: Node): node is Document {\n  return node.nodeType === 9/* Node.DOCUMENT_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is a [document type](https://developer.mozilla.org/en-US/docs/Web/API/DocumentType).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `DocumentType`, or `false` everything else.\n */\nexport function isDocumentTypeNode(node: Node): node is DocumentType {\n  return node.nodeType === 10/* Node.DOCUMENT_TYPE_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is a [document fragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment).\n *\n * @param node - A node to check.\n *\n * @returns `true` for `DocumentFragment`, or `false` everything else.\n */\nexport function isDocumentFragmentNode(node: Node): node is DocumentFragment {\n  return node.nodeType === 11/* Node.DOCUMENT_FRAGMENT_NODE */;\n}\n\n/**\n * Checks whether the given DOM node is a [shadow root](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot).\n *\n * Note that shadow root is a kind of {@link isDocumentFragmentNode document fragment}.\n *\n * @param node - A node to check.\n *\n * @returns `true` for `ShadowRoot`, or `false` everything else.\n */\nexport function isShadowRootNode(node: Node): node is ShadowRoot {\n  return isDocumentFragmentNode(node) && !!(node as Partial<ShadowRoot>).host;\n}\n","import { nodeDocument } from './node-document';\nimport { isElementNode } from './node-types';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @typeParam TNode - DOM node type.\n * @param from - The node to import.\n * @param to - The node to append imported node to.\n * @param importContent - A function that imports nodes nested in parent element. {@link importNodeContent} by default.\n *\n * @returns Imported node.\n */\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    importContent?: (this: void, from: TNode, to: TNode) => void,\n): TNode;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @typeParam TNode - DOM node type.\n * @param from - The node to import.\n * @param to - The node to append imported node to.\n * @param before - The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent - A function that imports nodes nested in parent element. {@link importNodeContent} by default.\n *\n * @returns Imported node.\n */\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: TNode, to: TNode) => void,\n): TNode;\n\nexport function importNode<TNode extends Node>(\n    from: TNode,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: TNode, to: TNode) => void),\n    importContent: (this: void, from: TNode, to: TNode) => void = importNodeContent,\n): TNode {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = nodeDocument(to);\n\n  if (isElementNode(from)) {\n\n    const elementClone = doc.createElement(from.tagName.toLowerCase()) as Node as (Element & TNode);\n\n    from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)!));\n    importContent(from, elementClone);\n    to.insertBefore(elementClone, before);\n\n    return elementClone;\n  }\n\n  const nodeClone = doc.importNode(from, false);\n\n  to.insertBefore(nodeClone, before);\n\n  return nodeClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from - The node which contents to import.\n * @param to - The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < from.childNodes.length; ++i) {\n    importNode(from.childNodes[i], to);\n  }\n}\n","import { isElementNode } from './node-types';\n\n/**\n * Finds a host element of the given DOM node. I.e. an enclosing element.\n *\n * Crosses shadow DOM bounds.\n *\n * @param node - Target DOM node.\n *\n * @returns Either parent element of the given node, or `undefined` when not found.\n */\nexport function nodeHost(node: Node): Element | undefined {\n\n  const { parentNode } = node;\n\n  return parentNode && isElementNode(parentNode) && parentNode\n      || (node.getRootNode() as Partial<ShadowRoot>).host// Inside shadow DOM?\n      || undefined;\n}\n","import { nodeWindow } from '@frontmeans/dom-primitives';\nimport type { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Render schedule signature.\n *\n * This function accepts a {@link RenderShot render shot} to schedule. All scheduled render shots are meant to update\n * the same rendering target. If multiple render shots scheduled before execution starts, only the last one will be\n * executed to limit rendering rate.\n *\n * The render shot execution may fail. This should not prevent other scheduled or postponed render shots from being\n * executed. The render shot execution failure reason is expected to be reported with {@link RenderScheduleConfig.error}\n * method.\n *\n * Render schedules are constructed by {@link RenderScheduler render schedulers}, or by {@link newRenderSchedule}\n * function that uses the {@link setRenderScheduler default scheduler} for that.\n *\n * @typeParam TExecution - A type of supported render shot execution context.\n */\nexport type RenderSchedule<TExecution extends RenderExecution = RenderExecution> =\n/**\n * @param shot - A render shot to schedule.\n */\n    (this: void, shot: RenderShot<TExecution>) => void;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link RenderScheduler render scheduler} when constructing new {@link RenderSchedule schedule}.\n *\n * A {@link RenderScheduleConfig render configuration} can be constructed based on the options with\n * {@link RenderScheduleConfig.by} function.\n */\nexport interface RenderScheduleOptions {\n\n  /**\n   * A window for constructed schedule.\n   *\n   * Detected by {@link nodeWindow} by default, if {@link node} is specified. Falls back to current `window`.\n   *\n   * The schedulers that don't need a window never access this option value.\n   */\n  window?: Window;\n\n  /**\n   * A DOM node for constructed schedule.\n   *\n   * Used to detect missing {@link window} option.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * Reports errors with `console.error()` by default.\n   *\n   * @param messages - Error messages to report.\n   */\n  error?(this: void, ...messages: any[]): void;\n\n}\n\n/**\n * Render schedule configuration.\n *\n * This is based on {@link RenderScheduleOptions render options}, but has all properties present.\n *\n * The configuration ought to be constructed out of render options by {@link RenderScheduleConfig.by} function.\n */\nexport interface RenderScheduleConfig {\n\n  /**\n   * A window the schedule is constructed for.\n   *\n   * The schedulers that don't need a window should never access this option value.\n   */\n  window: Window;\n\n  /**\n   * A DOM node the schedule is constructed for.\n   */\n  node?: Node;\n\n  /**\n   * Reports an error. E.g. a render shot execution failure.\n   *\n   * @param messages - Error messages to report.\n   */\n  error(this: void, ...messages: any[]): void;\n\n}\n\nexport const RenderScheduleConfig = {\n\n  /**\n   * Constructs a configuration of render schedule by its options.\n   *\n   * @param options - Render scheduler options the configuration should be base on.\n   *\n   * @returns Render schedule configuration.\n   */\n  by(this: void, options: RenderScheduleOptions = {}): RenderScheduleConfig {\n\n    let win: Window | undefined;\n    const { error = console.error } = options;\n\n    return {\n      get node(): Node | undefined {\n        return options.node;\n      },\n      get window(): Window {\n        return win || (win = options.window || (options.node ? nodeWindow(options.node) : window));\n      },\n      error,\n    };\n  },\n\n};\n","import { nodeDocument } from './node-document';\n\n/**\n * Returns an owner window of the given DOM node.\n *\n * @param node - Source node.\n *\n * @returns Either a `defaultView` of the {@link nodeDocument node document}, or `window` instance if there is no one.\n */\nexport function nodeWindow(node: Node): Window {\n  return nodeDocument(node).defaultView || window;\n}\n","import type { RenderQueue } from './render-queue';\nimport { RenderSchedule, RenderScheduleConfig, RenderScheduleOptions } from './render-schedule';\nimport type { RenderScheduler } from './render-scheduler';\nimport type { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Custom render scheduler options.\n *\n * This is passed to {@link customRenderScheduler} function to construct new custom scheduler.\n */\nexport interface CustomRenderSchedulerOptions {\n\n  /**\n   * Obtains a queue for render schedule.\n   *\n   * This is called once per render schedule.\n   *\n   * Render schedules may share the queue.\n   *\n   * @param config - Render schedule configuration.\n   *\n   * @returns  A queue of scheduled render shots.\n   */\n  newQueue(config: RenderScheduleConfig): RenderQueue;\n\n}\n\nconst RenderQ__symbol = (/*#__PURE__*/ Symbol('render-q'));\n\ninterface RenderQueue$Internal extends RenderQueue {\n  [RenderQ__symbol]?: RenderQ;\n}\n\nclass RenderQ {\n\n  readonly ref: RenderQ$Ref;\n  schedule: (this: RenderQ, config: RenderScheduleConfig) => void;\n  private scheduled?: RenderScheduleConfig;\n  private readonly execute: (\n      this: this,\n      execution: RenderExecution,\n      done: () => void,\n  ) => void;\n\n  static by(queue: RenderQueue$Internal, ref?: RenderQ$Ref): RenderQ {\n    return queue[RenderQ__symbol]\n        || (queue[RenderQ__symbol] = new RenderQ(queue, ref));\n  }\n\n  private constructor(readonly q: RenderQueue, ref?: [RenderQ, RenderQ]) {\n    this.schedule = this.doSchedule;\n    this.ref = ref || [this, this];\n    this.execute = q.recur ? this.execRecurring : this.execNonRecurring;\n  }\n\n  add(shot: RenderShot): void {\n    this.q.add(shot);\n  }\n\n  private doSchedule(config: RenderScheduleConfig): void {\n    // At most one execution at a time.\n    this.schedule = RenderQ$doNotSchedule;\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.unshift(shot);\n      },\n    };\n\n    this.q.schedule(() => {\n\n      const next = this.reset();\n      const done = (): void => {\n\n        // Activate next queue.\n        this.ref[1] = this.ref[0];\n        // Schedule postponed shots (in reverse order).\n        postponed.forEach(shot => this.q.add(shot));\n        // Recurrently postponed shots are executed immediately after their initiators.\n        execution.postpone = shot => this.q.post(shot);\n        // Execute postponed shots.\n        this.exec(execution);\n\n        next.resume();\n      };\n\n      next.suspend();\n\n      this.execute(execution, done);\n    });\n  }\n\n  private exec(execution: RenderExecution): void {\n    for (; ;) {\n\n      const shot = this.q.pull();\n\n      if (!shot) {\n        break;\n      }\n\n      shot(execution);\n    }\n  }\n\n  private execNonRecurring(execution: RenderExecution, done: () => void): void {\n    this.exec(execution);\n    done();\n  }\n\n  private execRecurring(execution: RenderExecution, done: () => void): void {\n\n    const execute = (): void => {\n      this.exec(execution);\n      if (!this.q.recur!(execute)) {\n        done();\n      }\n    };\n\n    execute();\n  }\n\n  private reset(): RenderQ {\n    // Update next queue. Current queue remains active\n    return this.ref[0] = RenderQ.by(this.q.reset(), this.ref);\n  }\n\n  private suspend(): void {\n    this.schedule = config => {\n      // Remember execution to schedule.\n      // It will be scheduled on resume.\n      this.scheduled = config;\n\n      // No need to remember more than one execution to schedule.\n      this.schedule = RenderQ$doNotSchedule;\n    };\n  }\n\n  private resume(): void {\n    if (this.scheduled) {\n      // There is an execution to schedule.\n      this.doSchedule(this.scheduled);\n    } else {\n      // Resume normal execution scheduling.\n      this.schedule = this.doSchedule;\n    }\n  }\n\n}\n\ntype RenderQ$Ref = [next: RenderQ, active: RenderQ];\n\nfunction RenderQ$doNotSchedule(_config: RenderScheduleConfig): void {\n  // Do not schedule.\n}\n\n/**\n * Builds custom render scheduler.\n *\n * @param options - Render scheduler options.\n *\n * @returns New render scheduler.\n */\nexport function customRenderScheduler(\n    options: CustomRenderSchedulerOptions,\n): RenderScheduler {\n  return (scheduleOptions?: RenderScheduleOptions): RenderSchedule => {\n\n    const config = RenderScheduleConfig.by(scheduleOptions);\n    const queueRef: Readonly<RenderQ$Ref> = RenderQ.by(options.newQueue(config)).ref;\n    let enqueued: [RenderQ, RenderShot, true?] | [] = [];\n\n    return (shot: RenderShot): void => {\n\n      const [lastQueue,, executed] = enqueued;\n      const [nextQueue, activeQueue] = queueRef;\n      let queue = lastQueue || activeQueue;\n\n      if ((lastQueue === activeQueue && !executed) || lastQueue === nextQueue) {\n        // Replace the shot in active queue, unless executed already.\n        // Replace the shot in the next queue unconditionally.\n        enqueued[1] = shot;\n      } else {\n\n        // Add to active queue if no shot executed in this schedule yet, or the queue recurrent.\n        // Add to the next queue otherwise.\n        const nextEnqueued: [RenderQ, RenderShot, true?] = enqueued = [\n          queue = !executed || queue.q.recur ? activeQueue : nextQueue,\n          shot,\n        ];\n\n        queue.add((execution: RenderExecution) => {\n          nextEnqueued[2] = true; // Switch to the next queue.\n          try {\n            nextEnqueued[1]({\n              get config() {\n                return config;\n              },\n              postpone(postponed) {\n                execution.postpone(postponed);\n              },\n            });\n          } catch (e) {\n            config.error(e);\n          }\n        });\n      }\n\n      queue.schedule(config);\n    };\n  };\n}\n","import type { RenderShot } from './render-shot';\n\n/**\n * A queue of scheduled render shots.\n *\n * Utilized by render scheduler in order to collect render shots and schedule their execution.\n *\n * The default implementation may be constructed using {@link RenderQueue.by} function.\n */\nexport interface RenderQueue {\n\n  /**\n   * Adds a render shot to this queue.\n   *\n   * @param shot - Scheduled render shot to add.\n   */\n  add(shot: RenderShot): void;\n\n  /**\n   * Adds a render shot to the head of this queue.\n   *\n   * @param shot - Scheduled render shot to add.\n   */\n  post(shot: RenderShot): void;\n\n  /**\n   * Retrieves the first added render shot and removes it from the queue.\n   *\n   * @returns  Either pulled out render shot, or `undefined` when there is no more render shots.\n   */\n  pull(): RenderShot | undefined;\n\n  /**\n   * Schedules queued render shots execution.\n   *\n   * @param task - A function that performs render shots execution.\n   */\n  schedule(task: (this: void) => void): void;\n\n  /**\n   * Schedules recurrent render shots execution.\n   *\n   * When defined, this method is responsible for execution of render shots scheduled during preceding render shots\n   * execution.\n   *\n   * When not defined, it is expected that {@link schedule} executes all scheduled render shots, including recurrent\n   * ones.\n   *\n   * @param task - A function that performs render shots execution. Should not be executed if there is no recurrent\n   * shots.\n   *\n   * @returns `true` if recurrent shots scheduled, or `false` if there is no recurrent shots.\n   */\n  recur?(task: (this: void) => void): boolean;\n\n  /**\n   * Resets the queue for the next execution.\n   *\n   * @returns  Another (empty) queue that will collect scheduled render shots from now on.\n   */\n  reset(): RenderQueue;\n\n}\n\nexport namespace RenderQueue {\n\n  /**\n   * Options for the {@link RenderQueue.by default implementation} of {@link RenderQueue}.\n   */\n  export interface Options {\n\n    /**\n     * Schedules queued render shots execution.\n     *\n     * This is an implementation of {@link RenderQueue.schedule} method.\n     *\n     * @param task - A function that performs render shots execution.\n     */\n    schedule(this: void, task: (this: void) => void): void;\n\n    /**\n     * Schedules recurrent render shots execution.\n     *\n     * This is an implementation of {@link RenderQueue.recur} method.\n     *\n     * @param task - A function that performs render shots execution. Will not be executed if there is no recurrent\n     * shots.\n     */\n    recur?(this: void, task: (this: void) => void): void;\n\n    /**\n     * Called right after {@link RenderQueue.reset} method in order to inform on the queue that collects scheduled\n     * render shots from now.\n     *\n     * @param replacement - A queue instance that collects scheduled render shots from now on.\n     */\n    replace?(this: void, replacement: RenderQueue): void;\n\n  }\n\n}\n\nexport const RenderQueue = {\n\n  /**\n   * Builds the default implementation of render queue.\n   *\n   * @param options - Render queue options.\n   *\n   * @returns New render queue.\n   */\n  by(\n      this: void,\n      options: RenderQueue.Options,\n  ): RenderQueue {\n\n    const { schedule, recur } = options;\n    let { replace = RenderQueue$doNotReplace } = options;\n\n    let scheduled: RenderShot[] = [];\n    let executed: RenderShot[] = scheduled;\n\n    let scheduleRecurrent: ((task: (this: void) => void) => boolean) | undefined;\n\n    if (recur) {\n      scheduleRecurrent = task => {\n        if (!scheduled.length) {\n          // No recurrent shots.\n          // The upcoming shots are non-recurrent.\n          scheduled = executed;\n          return false;\n        }\n\n        executed = scheduled;\n        scheduled = [];\n        recur(task);\n\n        return true;\n      };\n\n      const replaceQueue = replace;\n\n      replace = next => {\n        scheduled = [];\n        replaceQueue(next);\n      };\n    }\n\n    return {\n      add(shot: RenderShot): void {\n        scheduled.push(shot);\n      },\n      post(shot: RenderShot): void {\n        scheduled.unshift(shot);\n      },\n      pull(): RenderShot | undefined {\n        return executed.shift();\n      },\n      schedule,\n      recur: scheduleRecurrent,\n      reset() {\n\n        const next = RenderQueue.by(options);\n\n        replace(next);\n\n        return next;\n      },\n    };\n  },\n\n};\n\nfunction RenderQueue$doNotReplace(_replacement: RenderQueue): void {\n  // Do not replace queue\n}\n","import { customRenderScheduler } from './custom-render-scheduler';\nimport { RenderQueue } from './render-queue';\nimport type { RenderScheduler } from './render-scheduler';\n\n/**\n * @internal\n */\nconst animationRenderQueues = (/*#__PURE__*/ new WeakMap<Window, RenderQueue>());\n\n/**\n * A render scheduler that executes scheduled render shots within animation frame.\n *\n * Utilizes [requestAnimationFrame()] function for that.\n *\n * The render shots scheduled by different schedules created for the same window are all executed in the same animation\n * frame. The {@link RenderExecution.postpone postponed} render shots are executed only after all scheduled ones\n * complete.\n *\n * [requestAnimationFrame()]: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n */\nexport const animationRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue({ window }) {\n\n    const existing = animationRenderQueues.get(window);\n\n    if (existing) {\n      return existing;\n    }\n\n    const newQueue = RenderQueue.by({\n      schedule: task => window.requestAnimationFrame(task),\n      replace: replacement => animationRenderQueues.set(window, replacement),\n    });\n\n    animationRenderQueues.set(window, newQueue);\n\n    return newQueue;\n  },\n}));\n","import { customRenderScheduler } from './custom-render-scheduler';\nimport { RenderQueue } from './render-queue';\nimport type { RenderScheduler } from './render-scheduler';\n\nfunction asyncRenderQueue$schedule(task: () => void): void {\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  Promise.resolve().then(task);\n}\n\nlet asyncRenderQueue = (/*#__PURE__*/ RenderQueue.by({\n  schedule: asyncRenderQueue$schedule,\n  recur: asyncRenderQueue$schedule,\n  replace: replacement => asyncRenderQueue = replacement,\n}));\n\n/**\n * A render scheduler that executes scheduled render shots asynchronously.\n *\n * Recurrent render shots are also executed asynchronously.\n */\nexport const asyncRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue: () => asyncRenderQueue,\n}));\n","import { RenderSchedule, RenderScheduleConfig, RenderScheduleOptions } from './render-schedule';\nimport type { RenderScheduler } from './render-scheduler';\nimport type { RenderExecution, RenderShot } from './render-shot';\n\n/**\n * Render scheduler that executes render shots immediately.\n *\n * @param options\n */\nexport const immediateRenderScheduler: RenderScheduler = (options?: RenderScheduleOptions): RenderSchedule => {\n\n  const config = RenderScheduleConfig.by(options);\n\n  return (shot: RenderShot): void => {\n\n    const postponed: RenderShot[] = [];\n    const execution: RenderExecution = {\n      get config() {\n        return config;\n      },\n      postpone(shot) {\n        postponed.push(shot);\n      },\n    };\n\n    execute(shot);\n    for (; ;) {\n\n      const last = postponed.pop();\n\n      if (!last) {\n        break;\n      }\n\n      execute(last);\n    }\n\n    function execute(shot: RenderShot): void {\n      try {\n        shot(execution);\n      } catch (e) {\n        config.error(e);\n      }\n    }\n  };\n};\n","import { customRenderScheduler } from './custom-render-scheduler';\nimport { RenderQueue } from './render-queue';\nimport type { RenderScheduler } from './render-scheduler';\n\n/**\n * @internal\n */\nlet immediateRenderQueue = (/*#__PURE__*/ RenderQueue.by({\n  schedule: task => task(),\n  replace: replacement => immediateRenderQueue = replacement,\n}));\n\n/**\n * A render scheduler that schedules render shots for immediate execution.\n *\n * In contrast to {@link immediateRenderScheduler} this one utilizes {@link RenderQueue render queue}. So it acts\n * similarly to other schedulers, such as {@link animationRenderScheduler}. In particular, it adds recurrent\n * render shots to render queue instead of executing them immediately.\n */\nexport const queuedRenderScheduler: RenderScheduler = (/*#__PURE__*/ customRenderScheduler({\n  newQueue: () => immediateRenderQueue,\n}));\n","import { animationRenderScheduler } from './animation-render-scheduler';\nimport type { RenderSchedule, RenderScheduleOptions } from './render-schedule';\nimport type { RenderExecution } from './render-shot';\n\n/**\n * Render scheduler signature.\n *\n * This function creates a {@link RenderSchedule render schedule} according to the given options.\n *\n * The default render scheduler is always available as {@link newRenderSchedule} function.\n *\n * There are several scheduler implementations exist:\n * - {@link animationRenderScheduler} (used by default),\n * - {@link asyncRenderScheduler},\n * - {@link immediateRenderScheduler},\n * - {@link queuedRenderScheduler},\n * - {@link ManualRenderScheduler},\n * - {@link noopRenderScheduler}.\n *\n * Custom scheduler implementations could be created using {@link customRenderScheduler} function.\n *\n * @typeParam TExecution - A type of supported render shot execution context.\n * @typeParam TOptions - A type of accepted render schedule options.\n */\nexport type RenderScheduler<\n    TExecution extends RenderExecution = RenderExecution,\n    TOptions extends RenderScheduleOptions = RenderScheduleOptions> =\n/**\n * @param options - Created render schedule options.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: TOptions) => RenderSchedule<TExecution>;\n\n/**\n * @internal\n */\nlet defaultRenderScheduler = animationRenderScheduler;\n\n/**\n * Assigns or resets the default render scheduler.\n *\n * An {@link animationRenderScheduler animation frame render scheduler} is used bu default.\n *\n * @param scheduler - New default render scheduler. {@link animationRenderScheduler animation frame render scheduler}\n * will be used if `null`, `undefined`, or omitted.\n *\n * @returns New default render scheduler.\n */\nexport function setRenderScheduler(\n    scheduler?: RenderScheduler | null,\n): RenderScheduler {\n  return defaultRenderScheduler = scheduler || animationRenderScheduler;\n}\n\n/**\n * Constructs {@link RenderSchedule render schedule} using {@link setRenderScheduler default render scheduler}.\n *\n * @param options - Options of constructed render schedule.\n *\n * @returns New render schedule.\n */\nexport function newRenderSchedule(options?: RenderScheduleOptions): RenderSchedule {\n  return defaultRenderScheduler(options);\n}\n","import { DrekContext } from './context';\n\n/**\n * @internal\n */\nexport type DrekContext$Registrar = (this: void, context: DrekContext) => void;\n\nlet DrekContext$registrar = DrekContext$autoRegister;\n\n/**\n * @internal\n */\nexport function DrekContext$register(context: DrekContext): void {\n  DrekContext$registrar(context);\n}\n\n/**\n * @internal\n */\nexport function DrekContext$setRegistrar(registrar: DrekContext$Registrar): () => DrekContext$Registrar {\n\n  const priorRegistrar = DrekContext$registrar;\n\n  DrekContext$registrar = registrar;\n\n  return priorRegistrar === DrekContext$autoRegister\n      ? () => {\n        DrekContext$registrar = priorRegistrar;\n        return DrekContext$dontRegister;\n      }\n      : () => DrekContext$registrar = priorRegistrar;\n}\n\nfunction DrekContext$dontRegister(_context: DrekContext): void {\n  // Do not auto-register the context already failed to lift.\n}\n\nlet DrekContext$autoRegistrar = DrekContext$autoRegisterFirst;\n\nfunction DrekContext$autoRegister(context: DrekContext): void {\n  DrekContext$autoRegistrar(context);\n}\n\nfunction DrekContext$autoRegisterFirst(context: DrekContext): void {\n\n  const registered: DrekContext[] = [context];\n\n  DrekContext$autoRegistrar = DrekContext$createAutoRegistrar(registered);\n  Promise.resolve().then(() => {\n    DrekContext$autoRegistrar = DrekContext$autoRegisterFirst;\n    for (const context of registered) {\n      context.lift();\n    }\n  }).catch(console.error);\n}\n\nfunction DrekContext$createAutoRegistrar(registered: DrekContext[]): (context: DrekContext) => void {\n  return context => registered.push(context);\n}\n","import { DrekContext } from '../context';\nimport { DrekContext$setRegistrar } from '../context.registrar.impl';\n\n/**\n * Executes a DOM builder function and then {@link DrekContext.lift lifts} all unrooted rendering contexts created by\n * it.\n *\n * This helps to track a {@link DrekContext.whenConnected document connection} or {@link DrekContext.whenSettled\n * settlement} of any unrooted rendering contexts that created before its node added to document or\n * {@link DrekFragment rendered fragment}. This may happen e.g. when the rendering context {@link drekContextOf\n * accessed} from inside a custom element constructor when calling `document.createElement('custom-element')`.\n *\n * @typeParam TResult - DOM builder result type.\n * @param builder - A DOM builder function to call.\n *\n * @returns The value returned from DOM `builder` function.\n */\nexport function drekBuild<TResult>(builder: (this: void) => TResult): TResult {\n\n  const registered: DrekContext[] = [];\n  const resetRegistrar = DrekContext$setRegistrar(context => registered.push(context));\n\n  try {\n    return builder();\n  } finally {\n\n    const registrar = resetRegistrar();\n\n    for (const context of registered) {\n\n      const lifted = context.lift();\n\n      if (lifted === context) {\n        // Not lifted.\n        // Try next time.\n        registrar(context);\n      }\n    }\n  }\n}\n","import { AfterEvent, onceOn, OnEvent, onEventBy } from '@proc7ts/fun-events';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { DrekContentStatus } from './content-status';\nimport { DrekPlacement } from './placement';\n\n/**\n * @internal\n */\nexport const DrekPlacement$Status__symbol = (/*#__PURE__*/ Symbol('DrekPlacement.status'));\n\n/**\n * @internal\n */\nexport class DrekPlacement$Status<TStatus extends [DrekContentStatus]> {\n\n  constructor(readonly placement: DrekPlacement<TStatus>) {\n  }\n\n  onceConnected(): OnEvent<TStatus> {\n    return (this.onceConnected = valueProvider(this.placement.readStatus.do(\n        DrekPlacement$once<TStatus>(({ connected }) => connected),\n    )))();\n  }\n\n  whenConnected(): OnEvent<TStatus> {\n    return (this.whenConnected = valueProvider(this.onceConnected().do(\n        onceOn,\n    )))();\n  }\n\n}\n\nfunction DrekPlacement$once<TStatus extends [DrekContentStatus]>(\n    test: (...status: TStatus) => boolean,\n): (input: AfterEvent<TStatus>) => OnEvent<TStatus> {\n  return input => onEventBy(receiver => {\n\n    let value = false;\n\n    input({\n      supply: receiver.supply,\n      receive(eventCtx, ...status) {\n\n        const newValue = test(...status);\n\n        if (newValue || value !== newValue) {\n          value = newValue;\n          receiver.receive(eventCtx, ...status);\n        }\n      },\n    });\n  });\n}\n","import { AfterEvent, AfterEvent__symbol, EventKeeper, OnEvent } from '@proc7ts/fun-events';\nimport { DrekContentStatus } from './content-status';\nimport { DrekFragment } from './fragment';\nimport { DrekPlacement$Status, DrekPlacement$Status__symbol } from './placement.status.impl';\n\n/**\n * A rendered content placement.\n *\n * @typeParam TStatus - A type of the tuple containing a rendered content status as its first element.\n */\nexport abstract class DrekPlacement<TStatus extends [DrekContentStatus] = [DrekContentStatus]>\n    implements EventKeeper<TStatus> {\n\n  /**\n   * An `AfterEvent` keeper of content placement status.\n   */\n  abstract readonly readStatus: AfterEvent<TStatus>;\n\n  /**\n   * @internal\n   */\n  private readonly [DrekPlacement$Status__symbol]: DrekPlacement$Status<TStatus>;\n\n  constructor() {\n    this[DrekPlacement$Status__symbol] = new DrekPlacement$Status(this);\n  }\n\n  /**\n   * A {@link DrekFragment fragment} the content is placed to, if any.\n   */\n  abstract readonly fragment: DrekFragment | undefined;\n\n  /**\n   * An alias of {@link readStatus}.\n   *\n   * @returns An `AfterEvent` keeper of content placement status.\n   */\n  [AfterEvent__symbol](): AfterEvent<TStatus> {\n    return this.readStatus;\n  }\n\n  /**\n   * An `OnEvent` sender of placed content connection event.\n   *\n   * The registered receiver is called when placed content is {@link DrekContentStatus.connected connected}.\n   * If connected already the receiver is called immediately.\n   */\n  get onceConnected(): OnEvent<TStatus> {\n    return this[DrekPlacement$Status__symbol].onceConnected();\n  }\n\n  /**\n   * An `OnEvent` sender of single placed content connection event.\n   *\n   * The registered receiver is called when placed content is {@link DrekContentStatus.connected connected}.\n   * If connected already the receiver is called immediately.\n   *\n   * In contrast to {@link onceConnected}, cuts off the event supply after sending the first event.\n   */\n  get whenConnected(): OnEvent<TStatus> {\n    return this[DrekPlacement$Status__symbol].whenConnected();\n  }\n\n}\n","import type { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport type { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { DrekContentStatus } from './content-status';\nimport { DrekFragment } from './fragment';\nimport { DrekPlacement } from './placement';\n\n/**\n * Document rendering context.\n *\n * Can be obtained by {@link drekContextOf} function, or {@link DrekFragment.innerContext provided} by rendered\n * fragment.\n *\n * There are three kinds of rendering contexts:\n *\n * 1. Document rendering context.\n *\n *    Such context is always available in document and returned by {@link drekContextOf} function for any DOM node\n *    connected to the document.\n *\n * 2. Fragment content rendering context.\n *\n *    It is created for each rendered fragment and is available via {@link DrekFragment.innerContext} property.\n *    The {@link drekContextOf} function returns this context for fragment's {@link DrekContext.content content},\n *    as well as for each DOM node added to it.\n *\n * 3. Unrooted rendering context.\n *\n *    When a DOM node is neither connected to a document, nor part of a rendered fragment's {@link DrekFragment.content\n *    content}, the {@link drekContextOf} function creates an unrooted context for the [root node] of that node.\n *\n *    Unrooted context tracks a {@link whenConnected document connection} and {@link whenSettled settlement}\n *    semi-automatically. A {@link lift} method can be used to forcibly update them.\n *\n *    Semi-automatic tracking means that each time an unrooted context {@link drekContextOf created}, it is registered\n *    for automatic lifting. The lifting happens either asynchronously, or synchronously right before the\n *    {@link drekBuild} function exit.\n *\n *    Alternatively, a {@link drekLift} function can be used to lift a context of the [root node] after adding it to\n *    another one.\n *\n * [root node]: https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode\n *\n * @typeParam TStatus - A type of the tuple containing a context content status as its first element.\n */\nexport abstract class DrekContext<TStatus extends [DrekContentStatus] = [DrekContentStatus]>\n    extends DrekPlacement<TStatus> {\n\n  /**\n   * A rendered {@link DrekFragment fragment} this context is provided by, if any.\n   */\n  abstract readonly fragment: DrekFragment | undefined;\n\n  /**\n   * The window this context belongs to.\n   */\n  abstract readonly window: Window;\n\n  /**\n   * The document this context belongs to.\n   */\n  abstract readonly document: Document;\n\n  /**\n   * Namespace aliaser to use.\n   */\n  abstract readonly nsAlias: NamespaceAliaser;\n\n  /**\n   * Render scheduler to use.\n   */\n  abstract readonly scheduler: RenderScheduler;\n\n  /**\n   * An `OnEvent` sender of a settlement event.\n   *\n   * Such event can be sent by {@link DrekFragment.settle rendered fragment}.\n   *\n   * The same as {@link whenConnected} by default.\n   *\n   * Cuts off the event supply after sending the first event.\n   */\n  get whenSettled(): OnEvent<TStatus> {\n    return this.whenConnected;\n  }\n\n  /**\n   * Tries to lift this rendering context to enclosing one.\n   *\n   * Tries to find a new root node. If the new root differs from current one, then {@link drekContextOf finds} a context\n   * of that new root and connects the status of this context to the found one. After successful lifting the context\n   * becomes a proxy accessor of the context it is lifted to, so the latter can be used instead.\n   *\n   * This has effect for unrooted contexts only.\n   *\n   * @returns Either a rendering context of the new root node, or this one.\n   */\n  abstract lift(): DrekContext;\n\n}\n\nexport namespace DrekContext {\n\n  /**\n   * Updatable document rendering context.\n   */\n  export interface Updatable extends DrekContext {\n\n    /**\n     * Updates this context.\n     *\n     * @param update - An update to apply to this context.\n     *\n     * @returns `this` instance.\n     */\n    update(update?: Update): this;\n\n  }\n\n  /**\n   * An update to rendering context.\n   */\n  export interface Update {\n\n    /**\n     * Namespace aliaser to use.\n     *\n     * The aliaser is not updated when omitted.\n     */\n    readonly nsAlias?: NamespaceAliaser;\n\n    /**\n     * Render scheduler to use.\n     *\n     * The scheduler is not updated when omitted.\n     */\n    readonly scheduler?: RenderScheduler;\n\n  }\n\n}\n","import { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { DrekContext } from './context';\n\n/**\n * @internal\n */\nexport const DrekContext__symbol = (/*#__PURE__*/ Symbol('DrekContext'));\n\n/**\n * @internal\n */\nexport type DrekContext$Holder<T> = T & {\n\n  [DrekContext__symbol]?: DrekContext;\n\n};\n\n/**\n * @internal\n */\nexport class DrekContext$State {\n\n  _nsAlias: NamespaceAliaser;\n  readonly nsAlias: NamespaceAliaser;\n\n  _scheduler: RenderScheduler;\n  readonly scheduler: RenderScheduler;\n\n  constructor({ nsAlias, scheduler }: Required<DrekContext.Update>) {\n    this._nsAlias = nsAlias;\n    this.nsAlias = ns => this._nsAlias(ns);\n\n    this._scheduler = scheduler;\n    this.scheduler = options => {\n\n      let scheduler = this._scheduler;\n      let schedule = scheduler(options);\n\n      return shot => {\n        if (scheduler !== this._scheduler) {\n          scheduler = this._scheduler;\n          schedule = scheduler(options);\n        }\n        return schedule(shot);\n      };\n    };\n  }\n\n  set({ nsAlias, scheduler }: Required<DrekContext.Update>): void {\n    this._nsAlias = nsAlias;\n    this._scheduler = scheduler;\n  }\n\n}\n","import { NamespaceAliaser, newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport {\n  newRenderSchedule,\n  RenderSchedule,\n  RenderScheduleOptions,\n  RenderScheduler,\n} from '@frontmeans/render-scheduler';\nimport { AfterEvent, afterThe } from '@proc7ts/fun-events';\nimport { DrekContentStatus } from './content-status';\nimport { DrekContext } from './context';\nimport { DrekContext$Holder, DrekContext$State, DrekContext__symbol } from './context.impl';\n\n/**\n * @internal\n */\nexport function DrekContext$ofDocument(document: DrekContext$Holder<Document>): DrekContext.Updatable {\n\n  const existing = document[DrekContext__symbol] as DrekContext$OfDocument | undefined;\n\n  if (existing) {\n    return existing;\n  }\n\n  const state = new DrekContext$State({\n    nsAlias: newNamespaceAliaser(),\n    scheduler: newRenderSchedule,\n  });\n\n  const view = document.defaultView || window;\n  const scheduler = (\n      options?: RenderScheduleOptions,\n  ): RenderSchedule => state.scheduler({\n    window: view,\n    ...options,\n  });\n  const readStatus = afterThe<[DrekContentStatus]>({ connected: true });\n\n  class DrekContext$OfDocument extends DrekContext implements DrekContext.Updatable {\n\n    get fragment(): undefined {\n      return;\n    }\n\n    get window(): Window {\n      return view;\n    }\n\n    get document(): Document {\n      return document;\n    }\n\n    get nsAlias(): NamespaceAliaser {\n      return state.nsAlias;\n    }\n\n    get scheduler(): RenderScheduler {\n      return scheduler;\n    }\n\n    get readStatus(): AfterEvent<[DrekContentStatus]> {\n      return readStatus;\n    }\n\n    lift(): this {\n      return this;\n    }\n\n    update(\n        {\n          nsAlias = state._nsAlias,\n          scheduler = state._scheduler,\n        }: DrekContext.Update,\n    ): this {\n      state.set({ nsAlias, scheduler });\n      return this;\n    }\n\n  }\n\n  return document[DrekContext__symbol] = new DrekContext$OfDocument();\n}\n","import { isDocumentNode } from '@frontmeans/dom-primitives';\nimport { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { AfterEvent, EventEmitter, OnEvent, trackValue } from '@proc7ts/fun-events';\nimport { DrekContentStatus } from './content-status';\nimport { DrekContext } from './context';\nimport { DrekContext$Holder, DrekContext$State, DrekContext__symbol } from './context.impl';\nimport { DrekContext$ofDocument } from './context.of-document.impl';\nimport { DrekContext$register } from './context.registrar.impl';\nimport { DrekFragment } from './fragment';\n\n/**\n * @internal\n */\nexport function DrekContext$ofRootNode(root: DrekContext$Holder<Node>): DrekContext {\n  return isDocumentNode(root) ? DrekContext$ofDocument(root) : DrekContext$unrooted(root);\n}\n\nfunction DrekContext$unrooted(root: DrekContext$Holder<Node>): DrekContext {\n\n  const existing = root[DrekContext__symbol];\n\n  if (existing) {\n    return existing.lift();\n  }\n\n  const status = trackValue<DrekContentStatus>({ connected: false });\n  const settled = new EventEmitter<[DrekContentStatus]>();\n  let derivedCtx: DrekContext = DrekContext$ofDocument(\n      root.ownerDocument! /* Not a document, so `ownerDocument` is set */,\n  );\n  const scheduler = new DrekContext$State(derivedCtx);\n  let getFragment = (): DrekFragment | undefined => derivedCtx.fragment;\n  let lift = (ctx: DrekContext): DrekContext => {\n\n    const newRoot = root.getRootNode({ composed: true });\n\n    if (newRoot === root) {\n      return ctx;\n    }\n\n    const lifted = DrekContext$ofRootNode(newRoot);\n\n    root[DrekContext__symbol] = undefined;\n    getFragment = () => lifted.fragment;\n    scheduler.set(lifted);\n    lifted.whenSettled(status => settled.send(status)).cuts(settled);\n    status.by(lifted);\n    lift = _ctx => lifted;\n    derivedCtx = lifted;\n\n    return lifted;\n  };\n\n  class DrekContext$Unrooted extends DrekContext {\n\n    get fragment(): DrekFragment | undefined {\n      return getFragment();\n    }\n\n    get window(): Window {\n      return derivedCtx.window;\n    }\n\n    get document(): Document {\n      return derivedCtx.document;\n    }\n\n    get nsAlias(): NamespaceAliaser {\n      return derivedCtx.nsAlias;\n    }\n\n    get scheduler(): RenderScheduler {\n      return scheduler.scheduler;\n    }\n\n    get readStatus(): AfterEvent<[DrekContentStatus]> {\n      return status.read;\n    }\n\n    get whenSettled(): OnEvent<[DrekContentStatus]> {\n      return settled.on;\n    }\n\n    lift(): DrekContext {\n      return lift(this);\n    }\n\n  }\n\n  const context = root[DrekContext__symbol] = new DrekContext$Unrooted();\n\n  DrekContext$register(context);\n\n  return context;\n}\n","import { DrekContext } from './context';\nimport { DrekContext$ofRootNode } from './context.of-root-node.impl';\n\n/**\n * Obtains an updatable rendering context of the given document.\n *\n * @param document - Target document.\n *\n * @returns Updatable document rendering context.\n */\nexport function drekContextOf(document: Document): DrekContext.Updatable;\n\n/**\n * Obtains a rendering context of the given node.\n *\n * If the node is connected to document, then the rendering context of that document is returned. Otherwise, if the node\n * belongs to the {@link DrekFragment.content content} of the rendered fragment, then the context\n * {@link DrekFragment.innerContext provided} by that fragment is returned. Otherwise, an unrooted context is created\n * and attached to the [root node] of the target `node`.\n *\n * [root node]: https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode\n *\n * @param node - Target node.\n *\n * @returns Target node rendering context.\n */\nexport function drekContextOf(node: Node): DrekContext;\n\nexport function drekContextOf(node: Node): DrekContext {\n  for (;;) {\n\n    const root = node.getRootNode({ composed: true });\n\n    if (root === node) {\n      return DrekContext$ofRootNode(node);\n    }\n\n    node = root;\n  }\n}\n\n\n","import { css__naming, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { DrekContext } from '../context';\nimport { drekContextOf } from '../context-of';\n\n/**\n * An accessor to CSS classes of some element.\n *\n * Can be obtained by {@link drekCssClassesOf} function.\n */\nexport interface DrekCssClasses {\n\n  /**\n   * Adds CSS class to target element.\n   *\n   * The same CSS class can be supplied multiple times. In this case the class would be removed when no more suppliers\n   * left.\n   *\n   * Utilizes a {@link DrekContext.nsAlias namespace aliaser} of element rendering context for resolving class names.\n   *\n   * {@link DrekContext.scheduler Schedules} element CSS updates via element rendering context.\n   *\n   * @param className - CSS class name to add. Either a string or qualified one.\n   * @param user - A supply peer of the CSS class. When specified, its supply us returned from the method call.\n   *\n   * @returns Added CSS class supply that removes the class once cut off, unless there are other supplies of the same\n   * class.\n   */\n  add(className: QualifiedName, user?: SupplyPeer): Supply;\n\n  /**\n   * Checks whether the target element has the given CSS class.\n   *\n   * @param className - CSS class name to check. Either a string or qualified one.\n   *\n   * @returns `true` if the target element has this class, or `false` otherwise.\n   */\n  has(className: QualifiedName): boolean;\n\n  /**\n   * Obtains CSS classes accessor using different rendering context.,\n   *\n   * @param context - A rendering context to use instead of the {@link drekContextOf default one}.\n   *\n   * @returns Either new CSS classes accessor instance, or `this` one if context is the same.\n   */\n  renderIn(context: DrekContext): DrekCssClasses;\n\n}\n\nconst DrekCssClasses__symbol = (/*#__PURE__*/ Symbol('DrekCssClasses'));\n\ninterface DrekCssClasses$Holder extends Element {\n  [DrekCssClasses__symbol]?: DrekCssClasses$;\n}\n\n/**\n * Obtains CSS classes of the given element.\n *\n * @param element - Target element.\n *\n * @returns CSS classes accessor, either already existing or newly created one.\n */\nexport function drekCssClassesOf(element: Element): DrekCssClasses;\n\nexport function drekCssClassesOf(element: DrekCssClasses$Holder): DrekCssClasses {\n  return element[DrekCssClasses__symbol]\n      || (element[DrekCssClasses__symbol] = new DrekCssClasses$(element));\n}\n\nclass DrekCssClasses$ implements DrekCssClasses {\n\n  private readonly _context: DrekContext;\n  private readonly _uses = new Map<string, DrekCssClasses$Use>();\n\n  constructor(private readonly _element: Element) {\n    this._context = drekContextOf(_element);\n  }\n\n  add(className: QualifiedName, user?: SupplyPeer): Supply {\n    return this._add(this._context, className, user);\n  }\n\n  private _add(\n      {\n        nsAlias,\n        scheduler,\n      }: DrekContext,\n      className: QualifiedName,\n      user?: SupplyPeer,\n  ): Supply {\n\n    const supply = user ? user.supply : new Supply();\n\n    if (supply.isOff) {\n      return supply;\n    }\n\n    const name = css__naming.name(className, nsAlias);\n    const schedule = scheduler({ node: this._element });\n    const use = this._use(name);\n\n    const render = (): void => {\n      if (use.n) {\n        if (!use.s) {\n          this._element.classList.add(name);\n          use.s = 1;\n        }\n      } else {\n        if (use.s && !use.i) { // Do not remove the class if it present initially.\n          this._element.classList.remove(name);\n          use.s = 0;\n        }\n        this._uses.delete(name);\n      }\n    };\n\n    if (use.n === 1) {\n      schedule(render);\n    }\n\n    return supply.whenOff(() => {\n      if (!--use.n) {\n        schedule(render);\n      }\n    });\n  }\n\n  private _use(name: string): DrekCssClasses$Use {\n\n    let use = this._uses.get(name);\n\n    if (use) {\n      ++use.n;\n    } else {\n      if (this._element.classList.contains(name)) {\n        use = {\n          i: 1,\n          n: 1,\n          s: 1,\n        };\n      } else {\n        use = {\n          i: 0,\n          n: 1,\n          s: 0,\n        };\n      }\n      this._uses.set(name, use);\n    }\n\n    return use;\n  }\n\n  has(className: QualifiedName): boolean {\n    return this._has(this._context, className);\n  }\n\n  private _has({ nsAlias }: DrekContext, className: QualifiedName): boolean {\n\n    const name = css__naming.name(className, nsAlias);\n    const use = this._uses.get(name);\n\n    return use\n        ? !!use.n || !!use.i\n        : this._element.classList.contains(name);\n  }\n\n  renderIn(context: DrekContext): DrekCssClasses {\n    return context !== this._context\n        ? {\n          add: className => this._add(context, className),\n          has: className => this._has(context, className),\n          renderIn: newContext => this.renderIn(newContext),\n        }\n        : this;\n  }\n\n}\n\ninterface DrekCssClasses$Use {\n  readonly i: 0 | 1; // initially set\n  n: number;         // number of uses\n  s: 0 | 1;          // actually set\n}\n","import { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport {\n  queuedRenderScheduler,\n  RenderExecution,\n  RenderSchedule,\n  RenderScheduleOptions,\n  RenderScheduler,\n} from '@frontmeans/render-scheduler';\nimport { AfterEvent, afterThe, EventEmitter, onceOn, OnEvent, trackValue, translateAfter_ } from '@proc7ts/fun-events';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { DrekContentStatus } from '../content-status';\nimport { DrekContext } from '../context';\nimport { DrekContext$Holder, DrekContext$State, DrekContext__symbol } from '../context.impl';\nimport { DrekPlacement } from '../placement';\nimport { DrekTarget } from '../target';\nimport { DrekFragment } from './fragment';\nimport { DrekFragmentRenderExecution, DrekFragmentRenderScheduler } from './fragment-scheduler';\n\n/**\n * @internal\n */\nexport const DrekFragment$Context__symbol = (/*#__PURE__*/ Symbol('DrekFragment.context'));\n\n/**\n * @internal\n */\nexport class DrekFragment$Context<TStatus extends [DrekContentStatus]>\n    extends DrekContext<DrekFragment.Status<TStatus>>\n    implements DrekFragment.InnerContext<TStatus> {\n\n  static attach<TStatus extends [DrekContentStatus]>(\n      fragment: DrekFragment<TStatus>,\n      target: DrekTarget<TStatus>,\n      {\n        nsAlias = target.context.nsAlias,\n        scheduler = queuedRenderScheduler,\n        content,\n      }: DrekFragment$Options,\n  ): DrekFragment$Context<TStatus> {\n    if (!content) {\n      content = target.context.document.createDocumentFragment();\n    } else if (content.getRootNode({ composed: true }) !== content) {\n      throw new TypeError('Not a standalone DocumentFragment');\n    } else if (content[DrekContext__symbol]) {\n      throw new TypeError('Can not render content of another fragment');\n    }\n\n    return content[DrekContext__symbol] = new DrekFragment$Context(\n        fragment,\n        target,\n        content,\n        nsAlias,\n        scheduler,\n    );\n  }\n\n  readonly scheduler: DrekFragmentRenderScheduler<TStatus>;\n  readonly readStatus: AfterEvent<DrekFragment.Status<TStatus>>;\n  private readonly _status = trackValue<DrekFragment.Status<TStatus>>([{ connected: false, withinFragment: 'added' }]);\n  private readonly _state: DrekContext$State;\n  private readonly _settled = new EventEmitter<DrekFragment.Status<TStatus>>();\n  private _getFragment: () => DrekFragment | undefined;\n  private _lift: DrekContext;\n  private _whenSettled?: OnEvent<DrekFragment.Status<TStatus>>;\n  private readonly _rendered = new EventEmitter<[DrekPlacement<TStatus>]>();\n\n  private constructor(\n      readonly _fragment: DrekFragment<TStatus>,\n      readonly _target: DrekTarget<TStatus>,\n      readonly _content: DrekContext$Holder<DocumentFragment>,\n      nsAlias: NamespaceAliaser,\n      scheduler: RenderScheduler,\n  ) {\n    super();\n    this._getFragment = () => _fragment as DrekFragment<any>;\n    this._lift = this;\n    this.readStatus = this._status.read.do(\n        translateAfter_((send, status) => send(...status)),\n    );\n    this._state = new DrekContext$State({ nsAlias, scheduler });\n    this.scheduler = this._createSchedule.bind(this);\n\n    this.whenConnected((...status) => {\n      // `whenSettled` is the same as `whenConnected` now.\n      this._whenSettled = this.whenConnected;\n      // Send a settlement event one last time.\n      this._settled.send(...status);\n    });\n  }\n\n  get fragment(): DrekFragment<any> | undefined {\n    return this._getFragment();\n  }\n\n  get window(): Window {\n    return this._target.context.window;\n  }\n\n  get document(): Document {\n    return this._target.context.document;\n  }\n\n  get nsAlias(): NamespaceAliaser {\n    return this._state.nsAlias;\n  }\n\n  get whenSettled(): OnEvent<DrekFragment.Status<TStatus>> {\n    return this._whenSettled || (this._whenSettled = this._settled.on.do(\n        onceOn,\n    ));\n  }\n\n  lift(): DrekContext {\n    return this._lift;\n  }\n\n  _settle(): void {\n    this.scheduler()(_ => {\n      this._settled.send(...this._status.it);\n    });\n  }\n\n  _render(): this {\n    // Make the `.lift()` method return the target context.\n    this._lift = this._target.context;\n\n    // Signal the rendering started.\n    this._status.it = [{ connected: false, withinFragment: 'rendered' }];\n\n    const schedule = this._state._scheduler();\n\n    this._state.set(this._target.context);\n\n    schedule(({ postpone }) => {\n      // Await for all scheduled shots to render.\n      postpone(() => {\n        this._target.context.scheduler()(() => {\n          // Place the rendered content within target's scheduler.\n\n          const placement = this._target.placeContent(this._content);\n\n          // Update target fragment.\n          this._getFragment = () => placement.fragment;\n\n          // Reset the inner context.\n          this._content[DrekContext__symbol] = this._fragment[DrekFragment$Context__symbol] = new DrekFragment$Context(\n              this._fragment,\n              this._target,\n              this._content,\n              this.nsAlias,\n              this.scheduler,\n          );\n\n          // Derive the status from the target context.\n          this._status.by(placement, (...status) => afterThe(status));\n\n          // Send `whenRendered` event.\n          this._rendered.send(placement);\n        });\n      });\n    });\n    return this;\n  }\n\n  _whenRendered(): OnEvent<[DrekPlacement<TStatus>]> {\n    return (this._whenRendered = valueProvider(this._rendered.on.do(\n        onceOn,\n    )))();\n  }\n\n  private _createSchedule(\n      options: RenderScheduleOptions = {},\n  ): RenderSchedule<DrekFragmentRenderExecution<TStatus>> {\n\n    const schedule = this._state.scheduler({\n      ...options,\n      window: this.window,\n    });\n\n    return shot => schedule(execution => shot(this._createExecution(execution)));\n  }\n\n  private _createExecution(execution: RenderExecution): DrekFragmentRenderExecution<TStatus> {\n\n    const fragmentExecution: DrekFragmentRenderExecution<TStatus> = {\n      ...execution,\n      fragment: this._fragment,\n      content: this._content,\n      postpone(postponed) {\n        execution.postpone(_execution => postponed(fragmentExecution));\n      },\n    };\n\n    return fragmentExecution;\n  }\n\n}\n\ninterface DrekFragment$Options extends DrekFragment.Options {\n\n  readonly content?: DrekContext$Holder<DocumentFragment>;\n\n}\n","import { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { DrekContentStatus } from '../content-status';\nimport { DrekContext } from '../context';\nimport { DrekPlacement } from '../placement';\nimport { DrekTarget } from '../target';\nimport { DrekFragmentRenderScheduler } from './fragment-scheduler';\nimport { DrekFragment$Context, DrekFragment$Context__symbol } from './fragment.context.impl';\n\n/**\n * A fragment of DOM tree, which content is to be {@link DrekTarget.placeContent placed} to the document once rendered.\n *\n * Provides separate {@link DrekContext rendering context} for its nodes.\n *\n * @typeParam TStatus - A type of the tuple containing a rendered content status as its first element.\n */\nexport class DrekFragment<TStatus extends [DrekContentStatus] = [DrekContentStatus]> {\n\n  /**\n   * @internal\n   */\n  [DrekFragment$Context__symbol]: DrekFragment$Context<TStatus>;\n\n  /**\n   * Rendering target.\n   *\n   * When the fragment is {@link render rendered}, the rendered content is placed to this target.\n   */\n  get target(): DrekTarget {\n    return this[DrekFragment$Context__symbol]._target;\n  }\n\n  /**\n   * Inner rendering context of the fragment.\n   *\n   * This context as available to the {@link content} nodes.\n   *\n   * This context updated each time the fragment is {@link render rendered}.\n   */\n  get innerContext(): DrekFragment.InnerContext<TStatus> {\n    return this[DrekFragment$Context__symbol];\n  }\n\n  /**\n   * The content of the fragment.\n   */\n  get content(): DocumentFragment {\n    return this[DrekFragment$Context__symbol]._content;\n  }\n\n  /**\n   * An `OnEvent` sender of fragment rendering event.\n   *\n   * Sends a fragment content {@link DrekTarget.placeContent placement} to {@link target} when the fragment is actually\n   * {@link render rendered}.\n   *\n   * Cuts off the event supply after sending the first event.\n   */\n  get whenRendered(): OnEvent<[DrekPlacement<DrekFragment.Status<TStatus>>]> {\n    return this[DrekFragment$Context__symbol]._whenRendered();\n  }\n\n  /**\n   * Construct rendered fragment.\n   *\n   * @param target - Rendering target to place the\n   * @param options - Fragment rendering options.\n   */\n  constructor(target: DrekTarget<TStatus>, options: DrekFragment.Options = {}) {\n    this[DrekFragment$Context__symbol] = DrekFragment$Context.attach(this, target, options);\n  }\n\n  /**\n   * Settles previously rendered content.\n   *\n   * A {@link whenSettled} event sender notifies its receivers once settled.\n   *\n   * @returns `this` instance.\n   */\n  settle(): this {\n    this[DrekFragment$Context__symbol]._settle();\n    return this;\n  }\n\n  /**\n   * Renders this fragment by {@link DrekTarget.placeContent placing} its {@link DrekFragmentRenderExecution.content\n   * content} to {@link target rendering target}.\n   *\n   * Once rendered the fragment {@link content} becomes empty and can be reused. Its rendering context is updated.\n   *\n   * @returns Content {@link DrekTarget.placeContent placement} to {@link target}.\n   */\n  render(): DrekPlacement<DrekFragment.Status<TStatus>> {\n    return this[DrekFragment$Context__symbol]._render();\n  }\n\n}\n\nexport namespace DrekFragment {\n\n  /**\n   * Rendering context provided by fragment to its content nodes.\n   *\n   * @typeParam TStatus - A type of the tuple containing a rendered content status as its first element.\n   */\n  export interface InnerContext<TStatus extends [DrekContentStatus]> extends DrekContext<Status<TStatus>> {\n\n    readonly scheduler: DrekFragmentRenderScheduler<TStatus>;\n\n    /**\n     * Tries to lift this rendering context to {@link target} one.\n     *\n     * @returns The {@link target} context when the fragment is rendered, or `this` instance otherwise.\n     */\n    lift(): DrekContext;\n\n  }\n\n  /**\n   * A status of rendered fragment content.\n   */\n  export type Status<TStatus extends [DrekContentStatus]> =\n      | [OwnStatus]\n      | TStatus;\n\n  /**\n   * A status of rendered fragment content.\n   *\n   * This status is replaced by the target one\n   */\n  export interface OwnStatus extends DrekContentStatus {\n\n    readonly connected: false;\n\n    /**\n     * A status of the content within a fragment.\n     *\n     * Can be one of:\n     *\n     * - `'added'` - when the content is added to the fragment, but not yet rendered.\n     * - `'rendered'` - while the content is being rendered, but not yet placed to {@link DrekFragment.target target}.\n     */\n    readonly withinFragment: 'added' | 'rendered';\n\n  }\n\n  /**\n   * Rendered fragment construction options.\n   */\n  export interface Options {\n\n    /**\n     * Namespace aliaser to use by content nodes.\n     *\n     * The one from the {@link DrekFragment.target.context target context} is used when omitted.\n     */\n    readonly nsAlias?: NamespaceAliaser;\n\n    /**\n     * Render scheduler to use by content nodes.\n     *\n     * A `queuedRenderScheduler` is used when omitted.\n     */\n    readonly scheduler?: RenderScheduler;\n\n    /**\n     * The content of constructed fragment.\n     *\n     * A new document fragment will be created when omitted.\n     */\n    readonly content?: DocumentFragment;\n\n  }\n\n}\n","import { DrekContext } from '../context';\nimport { drekContextOf } from '../context-of';\nimport { DrekTarget } from './target';\n\n/**\n * Creates a rendering target that appends content to parent node.\n *\n * @param host - A node to append content to.\n * @param context - Custom rendering context. Defaults to `host` node context.\n *\n * @returns Rendering target.\n */\nexport function drekAppender(host: Node, context: DrekContext = drekContextOf(host)): DrekTarget {\n  return {\n    context,\n    host,\n    placeContent(content: Node) {\n      host.appendChild(content);\n      return context;\n    }\n  };\n}\n","import { DrekContentStatus } from '../content-status';\nimport { DrekPlacement } from '../placement';\nimport { DrekTarget } from './target';\n\n/**\n * Creates a rendering target that charges rendered content prior to placing it to another target.\n *\n * @typeParam TStatus - A tuple type reflecting a content {@link DrekContentStatus placement status}.\n * @param target - Rendering target of charged content.\n * @param spec - Content charging options.\n *\n * @returns Rendering target.\n */\nexport function drekCharger<TStatus extends [DrekContentStatus] = [DrekContentStatus]>(\n    target: DrekTarget<TStatus>,\n    spec?: DrekCharger.Spec<TStatus>,\n): DrekTarget {\n\n  const charger = DrekCharger$custom(target, spec);\n\n  return {\n    context: target.context,\n    host: target.host,\n    placeContent(content: Node): DrekPlacement {\n      return charger.charge(content, target);\n    },\n  }\n}\n\nexport namespace DrekCharger {\n\n  /**\n   * Rendered content charger specifier.\n   *\n   * Can be one of:\n   *\n   * - An arbitrary string containing a text for enclosing comments.\n   * - A {@link Custom custom charger}.\n   * - A {@link Factory charger factory} function.\n   * - `null`/`undefined` to enclose the rendered contents in comments with random text.\n   *\n   *  @typeParam TStatus - A tuple type reflecting a content {@link DrekContentStatus placement status}.\n   */\n  export type Spec<TStatus extends [DrekContentStatus] = [DrekContentStatus]> =\n      | string\n      | Custom\n      | Factory<TStatus>\n      | null\n      | undefined;\n\n  /**\n   * Custom rendered content charger.\n   */\n  export interface Custom {\n\n    /**\n     * Charges rendered content by representing it as another DOM node.\n     *\n     * @typeParam TStatus - A tuple type reflecting a content {@link DrekContentStatus placement status}.\n     * @param content - Rendered content to charge.\n     * @param target - Rendering target to place the charged content to.\n     *\n     * @returns Charged content placement status.\n     */\n    charge<TStatus extends [DrekContentStatus]>(content: Node, target: DrekTarget<TStatus>): DrekPlacement<TStatus>;\n\n  }\n\n  /**\n   * Rendered content charger factory signature.\n   *\n   * @typeParam TStatus - A tuple type reflecting a content {@link DrekContentStatus placement status}.\n   */\n  export type Factory<TStatus extends [DrekContentStatus] = [DrekContentStatus]> =\n  /**\n   * @param target - A target to render the charged content to.\n   *\n   * @returns Rendered content charger specifier.\n   */\n      (this: void, target: DrekTarget<TStatus>) => Spec;\n\n}\n\nfunction DrekCharger$custom<TStatus extends [DrekContentStatus]>(\n    target: DrekTarget<TStatus>,\n    spec: DrekCharger.Spec<TStatus>,\n): DrekCharger.Custom {\n  if (typeof spec === 'function') {\n    return DrekCharger$custom(target, spec(target));\n  }\n  if (typeof spec === 'string') {\n    return DrekCharger$commentWrapper(target, spec);\n  }\n  if (spec) {\n    return spec;\n  }\n\n  return DrekCharger$commentWrapper(target, Math.random().toString(32).substr(2));\n}\n\nfunction DrekCharger$commentWrapper(\n    { context: { document } }: DrekTarget,\n    rem: string,\n): DrekCharger.Custom {\n\n  let wrapContent = <TStatus extends [DrekContentStatus]>(\n      content: Node,\n      target: DrekTarget<TStatus>,\n  ): DrekPlacement<TStatus> => {\n\n    const start = document.createComment(` [[ ${rem} [[ `);\n    const end = document.createComment(` ]] ${rem} ]] `)\n    let placement: DrekPlacement<TStatus>;\n\n    wrapContent = (content, _target) => {\n\n      const range = document.createRange();\n\n      range.setStartAfter(start);\n      range.setEndBefore(end);\n      range.deleteContents();\n      range.insertNode(content);\n\n      return placement;\n    };\n\n    const fragment = document.createDocumentFragment();\n\n    fragment.append(start, content, end);\n\n    return placement = target.placeContent(fragment)\n  };\n\n  return {\n    charge: (content, target) => wrapContent(content, target),\n  };\n}\n","import type { Workload } from './workload';\n\n/**\n * An error indicating the work is already done.\n */\nexport class WorkDoneError<TWork = unknown> extends TypeError {\n\n  /**\n   * Constructs a work done error.\n   *\n   * @param workload - A workload the work is done for.\n   * @param work - The work already done, if any.\n   * @param reason - The reason of work failure, or `undefined` if the work completed successfully.\n   * @param message - Custom error message.\n   */\n  constructor(\n      readonly workload: Workload<TWork>,\n      readonly work: TWork | undefined,\n      readonly reason: unknown,\n      message = workload.workName(work) + (reason !== undefined\n          ? ` already terminated (${reason})`\n          : ' already done'),\n  ) {\n    super(message);\n  }\n\n}\n","import type { Supply, SupplyPeer } from '@proc7ts/supply';\nimport type { Workbench } from './workbench';\n\n/**\n * A workload able to perform a work within a workbench.\n *\n * The work specific to workload is represented by work instances. Such instances are available in {@link Workbench.work\n * workbench} and can be used e.g. to run workload-specific tasks.\n *\n * The same workload instance can be used in different workbenches.\n *\n * @typeParam TWork - A work type performed by this workload.\n */\nexport class Workload<TWork> {\n\n  /**\n   * Human-readable workload name.\n   */\n  readonly name: string;\n\n  /**\n   * Work allocator.\n   */\n  readonly allocator: Workload.Allocator<TWork>;\n\n  /**\n   * Constructs a workload.\n   *\n   * @param name - Human-readable workload name.\n   * @param allocator - A work allocator specific to constructed workload.\n   */\n  constructor(name: string, allocator: Workload.Allocator<TWork>) {\n    this.name = name;\n    this.allocator = allocator;\n  }\n\n  /**\n   * Builds a human-readable name of the work performed by this workload.\n   *\n   * This is used e.g. to construct a default error message for {@link WorkDoneError}.\n   *\n   * @param _work - Target work.\n   *\n   * @returns A string containing work name.\n   */\n  workName(_work?: TWork): string {\n    return `The work of ${this.name}`;\n  }\n\n  toString(): string {\n    return `Workload(${this.name})`;\n  }\n\n}\n\nexport namespace Workload {\n\n  /**\n   * Work allocator.\n   *\n   * Responsible for the work allocation for particular workload.\n   *\n   * @typeParam TWork - A work type performed by target workload.\n   */\n  export interface Allocator<TWork> {\n\n    /**\n     * Starts the work.\n     *\n     * @param allotment - Work allotment.\n     */\n    start(allotment: Allotment<TWork>): TWork;\n\n  }\n\n  /**\n   * Work allotment.\n   *\n   * Provided by workbench to {@link Allocator workload allocator} to allocate the work.\n   *\n   * @typeParam TWork - A work type performed by target workload.\n   */\n  export interface Allotment<TWork> extends SupplyPeer {\n\n    /**\n     * A workbench the work is allocated within.\n     */\n    readonly workbench: Workbench;\n\n    /**\n     * A workload to allocate the work for.\n     */\n    readonly workload: Workload<TWork>;\n\n    /**\n     * The work allotment supply.\n     *\n     * Once cut off the work is disposed. No more tasks would be accepted after that, while pending ones would\n     * fail.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Runs the task as part of the work.\n     *\n     * @typeParam TResult - A type of task result.\n     * @param task - A task to run.\n     *\n     * @returns A promise resolved to task result, or rejected if the work is {@link supply disposed} already.\n     */\n    run<TResult>(task: Workbench.Task<TResult>): Promise<TResult>;\n\n  }\n\n}\n","import type { Workbench } from '../workbench';\nimport type { Workload } from '../workload';\n\n/**\n * @internal\n */\nexport class OrderedTasks {\n\n  private readonly _queues = new Map<Workload<unknown>, TaskQueue>();\n\n  constructor(private readonly _allotment: Workload.Allotment<OrderedTasks>) {\n  }\n\n  runAfter<TResult>(workload: Workload<unknown>, task: Workbench.Task<TResult>): Promise<TResult> {\n\n    let queue = this._queues.get(workload);\n\n    if (!queue) {\n      queue = new TaskQueue(this._allotment);\n      this._queues.set(workload, queue);\n    }\n\n    return queue.enqueue(task);\n  }\n\n}\n\nclass TaskQueue {\n\n  /**\n   * Enqueued tasks.\n   *\n   * The subsequent tasks are waiting for preceding ones. The very first one is always running.\n   */\n  private readonly _tasks: TaskQueueEntry<unknown>[] = [];\n\n  constructor(readonly _allotment: Workload.Allotment<OrderedTasks>) {\n  }\n\n  enqueue<TResult>(task: Workbench.Task<TResult>): Promise<TResult> {\n    return new Promise(resolve => {\n\n      const entry: TaskQueueEntry<TResult> = {\n        task,\n        run: () => {\n          resolve(this._allotment.run(task).finally(() => {\n            // Remove from the queue.\n            this._tasks.shift();\n            // Run next.\n            this._runNext();\n          }));\n        },\n      };\n\n      this._tasks.push(entry);\n\n      if (this._tasks.length === 1) {\n        // The first task is just enqueued.\n        // Run it immediately, as there is nothing to wait for.\n        this._runNext();\n      }\n    });\n  }\n\n  private _runNext(): void {\n\n    const [first] = this._tasks;\n\n    if (first) {\n      first.run();\n    }\n  }\n\n}\n\ninterface TaskQueueEntry<TResult> {\n  readonly task: Workbench.Task<TResult>;\n  run(): void;\n}\n","import { Workload } from '../workload';\nimport { OrderedTasks } from './ordered-tasks.impl';\n\n/**\n * @internal\n */\nexport class WorkOrdering extends Workload<OrderedTasks> {\n\n  static readonly $ = new WorkOrdering();\n\n  private constructor() {\n    super('ordering', {\n      start(allotment: Workload.Allotment<OrderedTasks>): OrderedTasks {\n        return new OrderedTasks(allotment);\n      },\n    });\n  }\n\n}\n","import { noop, valueProvider } from '@proc7ts/primitives';\nimport type { Supply } from '@proc7ts/supply';\nimport { WorkDoneError } from '../work-done-error';\nimport type { Workbench } from '../workbench';\nimport { Workload } from '../workload';\nimport { WorkOrdering } from './work-ordering.impl';\n\nexport class WorkStage extends Workload<WorkStage.Work> {\n\n  constructor(name: string, allocator: WorkStage.Allocator = {}) {\n    super(\n        name,\n        {\n          start(allotment: Workload.Allotment<WorkStage.Work>): WorkStage.Work {\n\n            const { workbench, workload, supply } = allotment;\n            const runner = new WorkStageRunner(allotment, allocator);\n\n            return {\n\n              workbench,\n              stage: workload,\n              supply,\n\n              async run(task) {\n                return await runner.run(this, task);\n              },\n\n            };\n          },\n        },\n    );\n  }\n\n  workName(_work?: WorkStage.Work): string {\n    return `The ${this.name} stage`;\n  }\n\n  toString(): string {\n    return `WorkStage(${this.name})`;\n  }\n\n}\n\nexport namespace WorkStage {\n\n  export interface Allocator {\n\n    readonly after?: WorkStage;\n\n    start?(work: Work): void | PromiseLike<unknown>;\n\n  }\n\n  export interface Work {\n\n    readonly workbench: Workbench;\n\n    readonly stage: WorkStage;\n\n    readonly supply: Supply;\n\n    run<TResult>(task: Workbench.Task<TResult>): Promise<TResult>;\n\n  }\n\n}\n\nclass WorkStageRunner {\n\n  private readonly _whenAllDone: Promise<unknown>;\n  private _whenTaskDone: Promise<unknown> = Promise.resolve();\n  private _end!: (result?: PromiseLike<unknown>) => void;\n\n  constructor(\n      readonly allotment: Workload.Allotment<WorkStage.Work>,\n      readonly allocator: WorkStage.Allocator,\n  ) {\n\n    const { supply } = allotment;\n\n    this._whenAllDone = new Promise<unknown>(resolve => this._end = resolve)\n        .then(() => supply.off())\n        .catch(error => supply.off(error));\n\n    supply.whenOff(reason => {\n      if (reason === undefined) {\n        this._end();\n      } else {\n        this._end(Promise.reject(reason));\n      }\n\n      // Stop accepting new tasks.\n      this.run = (work, _task) => Promise.reject(\n          new WorkDoneError(allotment.workload, work, reason),\n      );\n    });\n  }\n\n  run<TResult>(work: WorkStage.Work, task: Workbench.Task<TResult>): Promise<TResult> {\n\n    const promise = this._start(work).then(() => this.allotment.run(task));\n\n    this._addTask(promise);\n\n    return promise;\n  }\n\n  private _addTask(taskPromise: Promise<unknown>): void {\n\n    const taskDone = this._whenTaskDone = Promise.all([\n      this._whenTaskDone,\n      taskPromise.catch(noop),\n    ]);\n\n    taskDone.finally(() => {\n      if (taskDone === this._whenTaskDone) {\n        this._end(taskDone);\n      }\n    });\n  }\n\n  private _start(work: WorkStage.Work): Promise<unknown> {\n\n    let whenStarted = this._awaitDeps();\n\n    if (this.allocator.start) {\n      whenStarted = whenStarted.then(async () => {\n        await this.allocator.start!(work);\n      });\n    }\n\n    // Start only once!\n    this._start = valueProvider(whenStarted);\n    this._addTask(whenStarted);\n\n    return whenStarted;\n  }\n\n  private _awaitDeps(): Promise<unknown> {\n\n    const deps: Promise<void>[] = [];\n    const addDep = (dep: WorkStage): void => {\n      deps.push(new Promise(resolve => {\n        this.allotment\n            .workbench\n            .work(WorkOrdering.$)\n            .runAfter(\n                dep,\n                () => {\n                  resolve();\n                  return this._whenAllDone;\n                },\n            )\n            .catch(noop);\n      }));\n    };\n\n    const { after } = this.allocator;\n\n    if (after) {\n      addDep(after);\n    }\n    addDep(this.allotment.workload);\n\n    return Promise.all(deps);\n  }\n\n}\n","import { noop } from '@proc7ts/primitives';\nimport { alwaysSupply, Supply, SupplyPeer } from '@proc7ts/supply';\nimport { WorkDoneError } from './work-done-error';\nimport type { Workbench } from './workbench';\nimport type { Workload } from './workload';\n\n/**\n * @internal\n */\nexport const Workbench$impl__symbol = (/*#__PURE__*/ Symbol('Workbench.impl'));\n\n/**\n * @internal\n */\nexport class Workbench$ implements SupplyPeer {\n\n  readonly supply: Supply;\n  private readonly _works = new Map<Workload<unknown>, unknown>();\n  private readonly _run: Required<Workbench.Options>['run'];\n\n  constructor(readonly workbench: Workbench, options: Workbench.Options) {\n\n    const { supply = alwaysSupply(), run } = options;\n\n    this.supply = new Supply(reason => {\n      // Reject new work.\n      this.work = workload => {\n        throw new WorkDoneError(workload, undefined, reason, 'The workbench is stopped');\n      };\n    }).as(supply);\n\n    this._run = run ? run.bind(options) : Workbench$run;\n  }\n\n  work<TWork>(workload: Workload<TWork>): TWork {\n    if (this._works.has(workload)) {\n      return this._works.get(workload) as TWork;\n    }\n\n    let ensureWorking: () => void = noop;\n    const runWorkTask = async <TResult>(\n        work: TWork,\n        task: Workbench.Task<TResult>,\n    ): Promise<TResult> => {\n\n      const result = await this._run(task, work, workload);\n\n      ensureWorking();\n\n      return result;\n    };\n    const supply = new Supply().needs(this.supply);\n\n    let setWork!: (work: TWork) => TWork;\n    let work: TWork | undefined;\n    let runTask: <TResult>(task: Workbench.Task<TResult>) => Promise<TResult>;\n\n    const whenWork = new Promise<TWork>(resolve => {\n      setWork = newWork => {\n        work = newWork;\n\n        this._works.set(workload, newWork);\n        runTask = async task => await runWorkTask(newWork, task);\n\n        resolve(newWork);\n\n        return newWork;\n      };\n    });\n\n    runTask = async task => await runWorkTask(await whenWork, task);\n\n    supply.whenOff(reason => {\n      runTask = ensureWorking = () => {\n        throw new WorkDoneError(workload, work, reason);\n      };\n      this._works.delete(workload);\n    });\n\n    return setWork(workload.allocator.start({\n      workbench: this.workbench,\n      workload,\n      supply,\n      async run<TResult>(task: Workbench.Task<TResult>) {\n        return await runTask(task);\n      },\n    }));\n  }\n\n}\n\nasync function Workbench$run<TResult, TWork>(\n    task: Workbench.Task<TResult>,\n    _work: TWork,\n    _workload: Workload<TWork>,\n): Promise<TResult> {\n  return await task();\n}\n","import type { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { Workbench$, Workbench$impl__symbol } from './workbench.impl';\nimport type { Workload } from './workload';\n\n/**\n * A workbench for coordinated {@link Workload workloads}.\n *\n * Performs a work by running tasks specific to each kind of workload.\n */\nexport class Workbench implements SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private readonly [Workbench$impl__symbol]: Workbench$;\n\n  /**\n   * Constructs a workbench.\n   *\n   * @param options - Constructed workbench options.\n   */\n  constructor(options: Workbench.Options = {}) {\n    this[Workbench$impl__symbol] = new Workbench$(this, options);\n  }\n\n  /**\n   * Workbench supply.\n   *\n   * Once cut off the workbench terminates all current works, and no longer accepts new ones.\n   */\n  get supply(): Supply {\n    return this[Workbench$impl__symbol].supply;\n  }\n\n  /**\n   * Obtains a work of the given workload.\n   *\n   * Caches the work previously obtained work of the same workload, until the work is {@link Workload.Allotment.supply\n   * disposed}. Creates a new work instance after that.\n   *\n   * @typeParam TWork - A work type.\n   * @param workload - Target workload.\n   *\n   * @returns A work instance.\n   */\n  work<TWork>(workload: Workload<TWork>): TWork {\n    return this[Workbench$impl__symbol].work(workload);\n  }\n\n}\n\nexport namespace Workbench {\n\n  /**\n   * A task to run by workbench.\n   *\n   * @typeParam TResult - A type of task result.\n   */\n  export type Task<TResult> =\n  /**\n   * @returns A task result evaluated synchronously, or a promise-like instance resolved to asynchronously evaluated\n   * result.\n   */\n      (this: void) => TResult | PromiseLike<TResult>;\n\n  /**\n   * Workbench construction options.\n   */\n  export interface Options {\n\n    /**\n     * Workbench supply to use.\n     *\n     * Once cut off the workbench terminates all current works, and no longer accepts new ones.\n     *\n     * A new one will be created when omitted.\n     */\n    readonly supply?: Supply;\n\n    /**\n     * Runs the given task.\n     *\n     * The default runner implementation will be used when omitted.\n     *\n     * @typeParam TResult - A type of task result.\n     * @typeParam TWork - A type of the work the task is part of.\n     * @param task - The task to run.\n     * @param work - The work instance the task is part of.\n     * @param workload - The workload the task is part of.\n     */\n    run?<TResult, TWork>(task: Task<TResult>, work: TWork, workload: Workload<TWork>): Promise<TResult>;\n\n  }\n\n}\n","/**\n * Escapes CSS identifier accordingly to the rules defined for [CSS.escape()](https://drafts.csswg.org/cssom/#the-css.escape%28%29-method)\n * utility method.\n *\n * Can be applied to CSS values as well, although it escapes characters that don't strictly need to be escaped.\n * A {@link escapeCSSVal} is a better alternative for that.\n *\n * @param text - A text to escape.\n *\n * @returns A string safe to be used as CSS identifier, e.g. as CSS selector.\n */\nexport function escapeCSS(text: string): string {\n\n  const len = text.length;\n  const first = text.charCodeAt(0);\n  let out = '';\n  let i = 0;\n\n  if (first === 0x2d) {\n    // If the first character is a \"-\" (U+002D)\n\n    const second = text.charCodeAt(1);\n\n    // ... and the second character is in the range [0-9] (U+0030 to U+0039).\n    if (second > 0x2f && second < 0x3a) {\n      // then '-' followed by the character escaped as code point.\n      out += `-\\\\${second.toString(16)} `;\n      i = 2;\n    } else {\n      out = '-';\n      i = 1;\n    }\n\n    if (len === 1) {\n      // ... and there is no second character, then the escaped character.\n      return '\\\\-';\n    }\n  } else if (first > 0x2f && first < 0x3a) {\n    // If the first character is in the range [0-9] (U+0030 to U+0039),\n    // then the character escaped as code point.\n    out += `\\\\${first.toString(16)} `;\n    i = 1;\n  }\n\n  for (; i < len; ++i) {\n\n    const c = text.charCodeAt(i);\n\n    if (\n        // Is in range [a-z] (U+0061 to U+007A),\n        (c > 0x60 && c < 0x7b)\n        // or is \"-\" (U+002D),\n        || c === 0x2d\n        // or is \"_\" (U+005F)\n        || c === 0x5f\n        // or is in range [0-9] (U+0030 to U+0039),\n        || (c > 0x2f && c < 0x3a)\n        // or is in range [A-Z] (U+0041 to U+005A)\n        || (c > 0x40 && c < 0x5b)\n    ) {\n      // then the character itself.\n      out += text[i];\n    } else if (c > 0x7e) {\n      out += c === 0x7f\n          // If the character is U+007F\n          // then the character escaped as code point.\n          ? `\\\\${c.toString(16)} `\n          // If the character is greater than or equal to U+0080,\n          // then the character itself\n          : text[i];\n    } else if (c < 0x20) {\n      out += c\n          // If the character is in the range [\\1-\\1f] (U+0001 to U+001F)\n          // then the character escaped as code point.\n          ? `\\\\${c.toString(16)} `\n          // If the character is NULL (U+0000)\n          // then the REPLACEMENT CHARACTER (U+FFFD).\n          : '\\uFFFD';\n    } else {\n      // Otherwise, the escaped character.\n      out += `\\\\${text[i]}`;\n    }\n  }\n\n  return out;\n}\n","/**\n * Escapes CSS value to be included into CSS string.\n *\n * Escapes accordingly to [serialize a string] algorithm.\n *\n * [serialize a string]: https://drafts.csswg.org/cssom/#serialize-a-string\n *\n * @param text - A text to escape.\n *\n * @returns A string safe to be included into CSS value, e.g. within CSS string.\n */\nexport function escapeCSSVal(text: string): string {\n\n  let out = '';\n  const len = text.length;\n\n  for (let i = 0; i < len; ++i) {\n\n    const c = text.charCodeAt(i);\n\n    out += c < 0x20 || c === 0x7f\n        ? (c\n                // If the character is in the range [\\1-\\1f] (U+0001 to U+001F),\n                // the character escaped as code point.\n                ? `\\\\${c.toString(16)} `\n                // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).;\n                : '\\uFFFD'\n        )\n        : (c === 0x22 || c === 0x5c\n                // If the character is '\"' (U+0022) or \"\\\" (U+005C),\n                // the escaped character.\n                ? `\\\\${text[i]}`\n                // Otherwise, the character itself.\n                : text[i]\n        );\n  }\n\n  return out;\n}\n","/**\n * @internal\n */\nexport const uppercasePattern = /[A-Z]+/g;\n\n/**\n * @internal\n */\nexport function toHyphenLower(letters: string, offset: number, str: string): string {\n\n  const lowerCase = letters.toLowerCase();\n\n  if ((lowerCase.length > 1) && (offset + lowerCase.length < str.length)) {\n    // More than one subsequent upper-case letters, unless at the end of the string.\n    return `-${lowerCase.slice(0, -1)}-${lowerCase.slice(-1)}`;\n  }\n\n  return '-' + lowerCase;\n}\n\n/**\n * @internal\n */\nexport const hyphenateCSSName$cache = (/*#__PURE__*/ new Map<string, string>());\n","import { hyphenateCSSName$cache, toHyphenLower, uppercasePattern } from './hyphenate.impl';\n\n/**\n * Hyphenates a camel-cased name.\n *\n * Applicable to CSS property names.\n *\n * Converts:\n *\n * - `backgroundColor` to `background-color`.\n *\n *    Uppercase letters converted to lower case and prepended by hyphen,\n *\n * - `MozTransition` to `-moz-transition`.\n *\n *   The very first uppercase letter is prepended by hyphen too.\n *\n * - `MSTransition` to `-ms-transition`.\n *\n *   Subsequent upper-case letters converted to lower case. The first and the last ones prepended by hyphen.\n *\n * - `someURL` to `some-url`\n *\n *   Subsequent upper-case letters in the very end of the string converted to lower case and prepended by hyphen.\n *\n * - `color` to `color`.\n *\n *   All lower-case names remain as is.\n *\n * - `padding-left` to `padding-left`\n *\n *   Hyphens remain in place.\n *\n * @param name - Camel-cased name to hyphenate.\n *\n * @returns Hyphenated name.\n */\nexport function hyphenateName(name: string): string {\n  return name.replace(uppercasePattern, toHyphenLower);\n}\n\n/**\n * De-capitalizes a camel-cased name and hyphenates it.\n *\n * Calls {@link hyphenateName}, then removes the leading hyphen.\n *\n * Thus, e.g. `MozTransition` would be converted to `moz-transition` rather to `-moz-transition`.\n *\n * @param name - Camel-cased name to hyphenate.\n *\n * @returns Hyphenated name.\n */\nexport function hyphenateDecapName(name: string): string {\n\n  const hyphenated = hyphenateName(name);\n\n  return hyphenated.startsWith('-') ? hyphenated.substr(1) : hyphenated;\n}\n\n/**\n * Hyphenates a camel-cased CSS property key.\n *\n * Applicable to the names of `HTMLElement.style` properties, including vendor-specific ones.\n *\n * Calls {@link hyphenateName}, then replaces `ms-` prefix with `-ms-` one. Other vendor-specific prefixes are\n * capitalized, so the hyphen prefix is added already.\n *\n * Caches hyphenated names for the sake of speed.\n *\n * @param name - Camel-cased CSS property name to hyphenate.\n *\n * @returns Hyphenated CSS property name.\n */\nexport function hyphenateCSSName(name: string): string {\n\n  const found = hyphenateCSSName$cache.get(name);\n\n  if (found) {\n    return found;\n  }\n\n  let hyphenated = hyphenateName(name);\n\n  if (hyphenated.startsWith('ms-')) {\n    hyphenated = '-' + hyphenated;\n  }\n\n  hyphenateCSSName$cache.set(name, hyphenated);\n\n  return hyphenated;\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = (/*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context'));\n","import { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { SupplyPeer } from '@proc7ts/supply';\nimport { ComponentClass, DefinitionContext } from '../component/definition';\nimport { FeatureRef } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to {@link FeatureDef.init} method so that the feature can configure\n * itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * An `OnEvent` sender of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[BootstrapContext]>;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Component class constructor.\n   *\n   * @return An `OnEvent` sender of definition context sent when the given `componentType` is registered.\n   */\n  abstract whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]>;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * @param feature - The feature to load.\n   * @param user - The user of the feature. The feature reference will be dismissed once the user's supply is cut off.\n   *\n   * @returns  Loaded feature reference.\n   */\n  abstract load(feature: Class, user?: SupplyPeer): FeatureRef;\n\n}\n","import { ContextKey, ContextKeyDefault } from '@proc7ts/context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @typeParam TValue - Context value type.\n * @typeParam TKey - Context key type.\n * @param provide - A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<TValue, TKey extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: TKey) => TValue | null | undefined,\n): ContextKeyDefault<TValue, TKey> {\n  return (context, key): TValue | null | undefined => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext\n        ? provide(bootstrapContext, key)\n        : bootstrapContext.get(key) as TValue;\n  };\n}\n","import { AbstractClass, Class, hasOwnProperty, superClassOf } from '@proc7ts/primitives';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<TMeta, TSrc = TMeta> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  own(type: AbstractClass, receiver?: AbstractClass): TMeta | undefined {\n    return hasOwnProperty(type, this.symbol)\n        ? Reflect.get(type, this.symbol, receiver)\n        : undefined;\n  }\n\n  of(type: AbstractClass, receiver: AbstractClass = type): TMeta | undefined {\n\n    const ownDef: TMeta | undefined = this.own(type, receiver);\n    const superType = superClassOf(type);\n    const superDef = superType && this.of(superType, receiver);\n\n    return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n  }\n\n  define<TClass extends Class>(type: TClass, metas: readonly (TMeta | TSrc)[]): TClass {\n\n    const prevMeta = this.own(type);\n    const newMeta: TMeta = this.merge(prevMeta ? [prevMeta, ...metas] : metas);\n\n    Reflect.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: newMeta,\n        },\n    );\n\n    return type;\n  }\n\n  abstract merge(metas: readonly (TMeta | TSrc)[]): TMeta;\n\n}\n","/**\n * @internal\n */\nexport type InitMethod<TTarget, TArgs extends any[]> =\n    (this: TTarget, ...args: TArgs) => void | PromiseLike<unknown>;\n\n/**\n * @internal\n */\nexport function mergeInitMethods<TTarget, TArgs extends any[]>(\n    target1: TTarget,\n    method1: InitMethod<TTarget, TArgs> | undefined,\n    target2: TTarget,\n    method2: InitMethod<TTarget, TArgs> | undefined,\n): InitMethod<void, TArgs> | undefined {\n\n  const m1 = method1 && (method1 as () => void | PromiseLike<undefined>).bind(target1) as InitMethod<void, TArgs>;\n  const m2 = method2 && (method2 as () => void | PromiseLike<undefined>).bind(target2) as InitMethod<void, TArgs>;\n\n  if (!m2) {\n    return m1;\n  }\n  if (!m1) {\n    return m2;\n  }\n\n  return async (...args) => {\n    await m1(...args);\n    await m2(...args);\n  };\n}\n","import { amend } from '@proc7ts/amend';\nimport { Class, elementOrArray, extendSetOfElements, setOfElements } from '@proc7ts/primitives';\nimport { BootstrapSetup } from '../boot';\nimport { MetaAccessor } from '../common';\nimport { FeatureContext } from './feature-context';\nimport { mergeInitMethods } from './init-method.impl';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = (/*#__PURE__*/ Symbol('FeatureDef'));\n\n/**\n * Feature definition.\n *\n * @category Core\n */\nexport interface FeatureDef {\n\n  /**\n   * Features this one requires.\n   */\n  readonly needs?: Class | readonly Class[];\n\n  /**\n   * Features this one provides.\n   *\n   * The feature always provides itself.\n   */\n  readonly has?: Class | readonly Class[];\n\n  /**\n   * Sets up bootstrap.\n   *\n   * This method is called before bootstrap context created.\n   *\n   * @param setup - Bootstrap setup.\n   *\n   * @returns Either nothing when setup completed synchronously, or a promise-like instance resolved when setup\n   * completed asynchronously.\n   */\n  setup?(setup: BootstrapSetup): void | PromiseLike<unknown>;\n\n  /**\n   * Initializes this feature by calling the given bootstrap context constructed.\n   *\n   * @param context - Feature initialization context.\n   *\n   * @returns Either nothing when initialization completed synchronously, or a promise-like instance resolved when\n   * initialization completed asynchronously.\n   */\n  init?(context: FeatureContext): void | PromiseLike<unknown>;\n\n}\n\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor<FeatureDef, FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(defs: readonly FeatureDef[]): FeatureDef {\n    return defs.reduce<FeatureDef>(\n        (prev, def) => ({\n          needs: elementOrArray(extendSetOfElements(setOfElements(prev.needs), def.needs)),\n          has: elementOrArray(extendSetOfElements(setOfElements(prev.has), def.has)),\n          setup: mergeInitMethods(prev, prev.setup, def, def.setup),\n          init: mergeInitMethods(prev, prev.init, def, def.init),\n        }),\n        {},\n    );\n  }\n\n}\n\n/**\n * @internal\n */\nconst featureMeta = (/*#__PURE__*/ new FeatureMeta());\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts feature definition options from its type.\n   *\n   * @param featureType - Target feature class constructor.\n   *\n   * @returns Feature definition options. May be empty when there is no feature definition found in the given\n   * `featureType`.\n   */\n  of(this: void, featureType: Class): FeatureDef {\n    return featureMeta.of(amend(featureType)) || {};\n  },\n\n  /**\n   * Merges multiple feature definition options.\n   *\n   * @param defs - Feature definition options to merge.\n   *\n   * @returns Merged feature definition options.\n   */\n  merge(this: void, ...defs: readonly FeatureDef[]): FeatureDef {\n    return featureMeta.merge(defs);\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeParam TClass - Feature type.\n   * @param featureType - Feature class constructor.\n   * @param defs - Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<TClass extends Class>(this: void, featureType: TClass, ...defs: readonly FeatureDef[]): TClass {\n    return featureMeta.define(featureType, defs);\n  },\n\n};\n","import {\n  AeClass,\n  allAmender,\n  Amender,\n  Amendment,\n  AmendRequest,\n  AmendTarget,\n  ClassAmendment,\n  isAmendatory,\n  newAmendTarget,\n} from '@proc7ts/amend';\nimport { Class } from '@proc7ts/primitives';\nimport { FeatureDef } from './feature-def';\n\n/**\n * An amended entity representing a feature class to amend.\n *\n * @category Core\n * @typeParam TClass - Amended feature class type.\n */\nexport interface AeFeature<TClass extends Class = Class> extends AeClass<TClass> {\n\n  /**\n   * Amended feature definition options.\n   */\n  readonly featureDef: FeatureDef;\n\n}\n\n/**\n * An amendment target representing a feature class to amend.\n *\n * @category Core\n * @typeParam TClass - Amended feature class type.\n * @typeParam TAmended - Amended feature entity type.\n */\nexport type AeFeatureTarget<\n    TClass extends Class = Class,\n    TAmended extends AeFeature<TClass> = AeFeature<TClass>\n    > = AmendTarget<TAmended>;\n\n/**\n * Feature amendment.\n *\n * Constructed by {@link Feature} function.\n *\n * @category Core\n * @typeParam TClass - Amended feature class type.\n * @typeParam TAmended - Amended feature entity type.\n */\nexport type FeatureAmendment<TClass extends Class, TAmended extends AeFeature<TClass>> =\n    ClassAmendment.ForBase<AeFeature<TClass>, TClass, TAmended>;\n\n/**\n * Creates a feature class amendment (and decorator).\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to {@link bootstrapComponents} function or referenced by other features.\n *\n * This is an alternative to direct call to {@link FeatureDef.define} method.\n *\n * @category Core\n * @typeParam TClass - Amended feature class type.\n * @typeParam TAmended - Amended feature entity type.\n * @param amendments - Feature definitions or amendments to apply.\n *\n * @returns Feature class amendment and decorator.\n */\nexport function Feature<TClass extends Class = Class, TAmended extends AeFeature<TClass> = AeFeature<TClass>>(\n    ...amendments: (FeatureDef | Amendment<TAmended>)[]\n): FeatureAmendment<TClass, TAmended> {\n\n  const amender = Feature$toAmender(amendments);\n\n  return AeClass<TClass, TAmended>(baseTarget => {\n\n    let result: FeatureDef = {};\n\n    amender(newAmendTarget({\n      base: {\n        ...baseTarget as unknown as TAmended,\n        featureDef: {},\n      },\n      amend<TBase extends TAmended, TExt>(\n          _base: TBase,\n          request = {} as AmendRequest<TBase, TExt>,\n      ): () => AmendTarget.Draft<TBase & TExt> {\n\n        const { featureDef: defRequest = {}, ...baseRequest } = request;\n        const createBaseTarget = baseTarget.amend(baseRequest as AmendRequest<any>);\n        const featureDef = result = FeatureDef.merge(result, defRequest);\n\n        return () => ({\n          ...createBaseTarget(),\n          featureDef,\n        } as AmendTarget.Draft<TBase & TExt>);\n      },\n    }));\n\n    FeatureDef.define(baseTarget.amendedClass, result);\n  }) as FeatureAmendment<TClass, TAmended>;\n}\n\nfunction Feature$toAmender<TClass extends Class, TAmended extends AeFeature<TClass>>(\n    amendments: (FeatureDef | Amendment<TAmended>)[],\n): Amender<TAmended> {\n\n  const featureDefs: FeatureDef[] = [];\n  const featureAmendments: Amendment<TAmended>[] = [];\n\n  for (const amendment of amendments) {\n    if (isFeatureAmendment<TClass, TAmended>(amendment)) {\n      featureAmendments.push(amendment);\n    } else {\n      featureDefs.push(amendment);\n    }\n  }\n\n  if (featureDefs.length) {\n    featureAmendments.push(FeatureDef$toAmender(featureDefs));\n  }\n\n  return allAmender(featureAmendments);\n}\n\nfunction isFeatureAmendment<TClass extends Class, TAmended extends AeFeature<TClass>>(\n    amendment: FeatureDef | Amendment<TAmended>,\n): amendment is Amendment<TAmended> {\n  return typeof amendment === 'function' || isAmendatory(amendment);\n}\n\nfunction FeatureDef$toAmender<TClass extends Class, TAmended extends AeFeature<TClass>>(\n    defs: FeatureDef[],\n): Amender<TAmended> {\n  return ({ amend }: AeFeatureTarget<TClass>) => amend({\n    featureDef: FeatureDef.merge(...defs),\n  });\n}\n","import { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { BootstrapContext, BootstrapSetup } from '../boot';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../component/definition';\nimport { FeatureRef } from './feature-ref';\n\n/**\n * @internal\n */\nconst FeatureContext__key = (/*#__PURE__*/ new SingleContextKey<FeatureContext>('feature-context'));\n\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nexport abstract class FeatureContext\n    extends BootstrapContext\n    implements BootstrapSetup, SupplyPeer {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext__key;\n  }\n\n  /**\n   * Feature class this context is created for.\n   */\n  abstract readonly feature: Class;\n\n  /**\n   * An `OnEvent` sender of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[FeatureContext]>;\n\n  /**\n   * An `OnEvent` sender of component definition events.\n   *\n   * The registered receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   */\n  abstract readonly onDefinition: OnEvent<[DefinitionContext]>;\n\n  /**\n   * An `OnEvent` sender of component construction events.\n   *\n   * The registered receiver will be notified right before component is constructed.\n   */\n  abstract readonly onComponent: OnEvent<[ComponentContext]>;\n\n  /**\n   * Feature supply.\n   *\n   * Cut off once feature unloaded.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * Provides bootstrap context value.\n   *\n   * Note that this happens when bootstrap context already exists. To provide a value before bootstrap context created\n   * a {@link BootstrapSetup.provide} method can be used.\n   *\n   * @typeParam TSrc - Source value type.\n   * @typeParam TDeps - Dependencies tuple type.\n   * @param spec - Context value specifier.\n   *\n   * @returns A value supply that removes the given context value specifier once cut off.\n   */\n  abstract provide<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<BootstrapContext, unknown, TSrc, TDeps>,\n  ): Supply;\n\n  abstract perDefinition<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<DefinitionContext, unknown, TSrc, TDeps>,\n  ): Supply;\n\n  abstract perComponent<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<ComponentContext, unknown, TSrc, TDeps>,\n  ): Supply;\n\n  abstract setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]>;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  load(feature: Class, user?: SupplyPeer): FeatureRef {\n    return this.get(BootstrapContext).load(\n        feature,\n        user ? new Supply().needs(this).needs(user) : this,\n    );\n  }\n\n}\n","import { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { Workbench, WorkStage } from '@proc7ts/workbench';\nimport { bootstrapDefault } from '../../boot';\n\n/**\n * @internal\n */\nexport type BootstrapWorkbench = Workbench;\n\n/**\n * @internal\n */\nexport const BootstrapWorkbench: ContextRef<BootstrapWorkbench> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-workbench',\n    {\n      byDefault: bootstrapDefault(() => new Workbench()),\n    },\n));\n\n/**\n * @internal\n */\nexport const featureSetupStage = (/*#__PURE__*/ new WorkStage('feature setup'));\n\n/**\n * @internal\n */\nexport const featureInitStage = (/*#__PURE__*/ new WorkStage('feature init', { after: featureSetupStage }));\n\n/**\n * @internal\n */\nexport const componentDefStage = (/*#__PURE__*/ new WorkStage('component definition', { after: featureInitStage }));\n\n","import { isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { amend } from '@proc7ts/amend';\nimport { mergeFunctions } from '@proc7ts/primitives';\nimport { MetaAccessor } from '../common';\nimport { FeatureDef } from '../feature';\nimport { ComponentClass, DefinitionContext, DefinitionSetup, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = (/*#__PURE__*/ Symbol('ComponentDef'));\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport interface ComponentDef<T extends object = any> {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend?: ElementDef.Extend;\n\n  /**\n   * Additional feature definition options.\n   */\n  readonly feature?: FeatureDef;\n\n  /**\n   * Sets up component definition.\n   *\n   * This method is called before component definition context constructed.\n   *\n   * @param setup - Component definition setup.\n   */\n  setup?(setup: DefinitionSetup<T>): void;\n\n  /**\n   * Defines this component by calling the given component definition context methods.\n   *\n   * This function is called before the custom element is defined.\n   *\n   * @param defContext - Component definition context.\n   */\n  define?(defContext: DefinitionContext<T>): void;\n\n}\n\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor<ComponentDef, ComponentDef | QualifiedName> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(defs: readonly (ComponentDef<T> | QualifiedName)[]): ComponentDef<T> {\n    return defs.reduce<ComponentDef>(\n        (prev, meta) => {\n\n          const def = this.meta(meta);\n\n          return ({\n            ...prev,\n            ...def,\n            setup: mergeFunctions(prev.setup, def.setup),\n            define: mergeFunctions(prev.define, def.define),\n            feature: prev.feature\n                ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n                : def.feature,\n          });\n        },\n        {},\n    );\n  }\n\n  meta<T extends object>(source: ComponentDef<T> | QualifiedName): ComponentDef<T> {\n    if (isQualifiedName(source)) {\n      return { name: source };\n    }\n    return source;\n  }\n\n}\n\n/**\n * @internal\n */\nconst componentMeta = (/*#__PURE__*/ new ComponentMeta());\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts component definition options from its type.\n   *\n   * @typeParam T - A type of component.\n   * @param componentType - Target component class constructor.\n   *\n   * @returns Component definition options. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(this: void, componentType: ComponentClass<T>): ComponentDef<T> {\n    return componentMeta.of(amend(componentType)) || {};\n  },\n\n  /**\n   * Merges multiple component definition options.\n   *\n   * @typeParam T - A type of component.\n   * @param defs - Component definition options to merge.\n   *\n   * @returns Merged component definition options.\n   */\n  merge<T extends object>(this: void, ...defs: (ComponentDef<T> | QualifiedName)[]): ComponentDef<T> {\n    return componentMeta.merge(defs);\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends existing component definition and stores it under {@link ComponentDef__symbol} key.\n   *\n   * Each component can be passed directly to {@link bootstrapComponents} function or added as a requirement\n   * of another feature.\n   *\n   * @typeParam TClass - A type of component class.\n   * @param componentType - Component class constructor.\n   * @param defs - Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<TClass extends ComponentClass>(\n      this: void,\n      componentType: TClass,\n      ...defs: (ComponentDef<InstanceType<TClass>> | QualifiedName)[]\n  ): TClass {\n    return componentMeta.define(componentType, defs);\n  },\n\n};\n","import { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport {\n  allAmender,\n  Amender,\n  Amendment,\n  AmendRequest,\n  AmendTarget,\n  ClassAmendment,\n  isAmendatory,\n  newAmendTarget,\n} from '@proc7ts/amend';\nimport { Class } from '@proc7ts/primitives';\nimport { AeFeature, Feature } from '../feature';\nimport { ComponentDef } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * An amended entity representing a component class to amend.\n *\n * @category Core\n * @typeParam TClass - Amended component class type.\n */\nexport interface AeComponent<TClass extends ComponentClass = Class> extends AeFeature<TClass> {\n\n  /**\n   * Amended component definition.\n   */\n  readonly componentDef: ComponentDef;\n\n}\n\n/**\n * An amendment target representing a component class to amend.\n *\n * @category Core\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component entity type.\n */\nexport type AeComponentTarget<\n    TClass extends ComponentClass = Class,\n    TAmended extends AeComponent<TClass> = AeComponent<TClass>\n    > = AmendTarget<TAmended>;\n\n/**\n * Component amendment.\n *\n * Constructed by {@link Component} function.\n *\n * @category Core\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component entity type.\n */\nexport type ComponentAmendment<\n    TClass extends ComponentClass = Class,\n    TAmended extends AeComponent<TClass> = AeComponent<TClass>> =\n    ClassAmendment.ForBase<AeComponent<TClass>, TClass, TAmended>;\n\n/**\n * Creates a component class amendment (and decorator).\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with {@link FeatureContext.define} method or used as a feature, e.g. passed to\n * {@link bootstrapComponents} function, or added to {@link FeatureDef.needs} property of another feature.\n *\n * This is an alternative to direct call to {@link ComponentDef.define} method.\n *\n * @category Core\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component entity type.\n * @param amendments - Component definitions, qualified name od component's element, or amendments to apply.\n *\n * @returns Component class amendment and decorator.\n */\nexport function Component<\n    TClass extends ComponentClass = Class,\n    TAmended extends AeComponent<TClass> = AeComponent<TClass>>(\n    ...amendments: (ComponentDef<InstanceType<TClass>> | QualifiedName | Amendment<TAmended>)[]\n): ComponentAmendment<TClass, TAmended> {\n\n  const amender = Component$toAmender(amendments);\n\n  return Feature<TClass, TAmended>(baseTarget => {\n\n    let result: ComponentDef = {};\n\n    amender(newAmendTarget({\n      base: {\n        ...baseTarget as unknown as TAmended,\n        componentDef: {},\n      },\n      amend<TBase extends TAmended, TExt>(\n          _base: TBase,\n          request = {} as AmendRequest<TBase, TExt>,\n      ): () => AmendTarget.Draft<TBase & TExt> {\n\n        const { componentDef: defRequest = {}, ...baseRequest } = request;\n        const createBaseTarget = baseTarget.amend(baseRequest as AmendRequest<any>);\n        const componentDef = result = ComponentDef.merge(result, defRequest);\n\n        return () => ({\n          ...createBaseTarget(),\n          componentDef,\n        } as AmendTarget.Draft<TBase & TExt>);\n      },\n    }));\n\n    ComponentDef.define(baseTarget.amendedClass, result);\n  }) as ComponentAmendment<TClass, TAmended>;\n}\n\nfunction Component$toAmender<TClass extends ComponentClass, TAmended extends AeComponent<TClass>>(\n    amendments: (ComponentDef<InstanceType<TClass>> | QualifiedName | Amendment<TAmended>)[],\n): Amender<TAmended> {\n\n  const componentDefs: (ComponentDef | QualifiedName)[] = [];\n  const componentAmendments: Amendment<TAmended>[] = [];\n\n  for (const amendment of amendments) {\n    if (isComponentAmendment<TClass, TAmended>(amendment)) {\n      componentAmendments.push(amendment);\n    } else {\n      componentDefs.push(amendment);\n    }\n  }\n\n  if (componentDefs.length) {\n    componentAmendments.push(ComponentDef$toAmender(componentDefs));\n  }\n\n  return allAmender(componentAmendments);\n}\n\nfunction isComponentAmendment<TClass extends ComponentClass, TAmended extends AeComponent<TClass>>(\n    amendment: ComponentDef | QualifiedName | Amendment<TAmended>,\n): amendment is Amendment<TAmended> {\n  return typeof amendment === 'function' || isAmendatory(amendment);\n}\n\nfunction ComponentDef$toAmender<TClass extends ComponentClass, TAmended extends AeComponent<TClass>>(\n    defs: (ComponentDef | QualifiedName)[],\n): Amender<TAmended> {\n  return ({ amend }: AeComponentTarget<TClass>) => amend({\n    componentDef: ComponentDef.merge(...defs),\n  });\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = (/*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context'));\n","import { DomEventDispatcher, OnDomEvent } from '@frontmeans/dom-events';\nimport { SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher } from './component-event-dispatcher';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = (/*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault(values) {\n\n        const context = values.get(ComponentContext__key);\n        const dispatcher = new DomEventDispatcher(context.element);\n\n        dispatcher.supply.needs(context);\n\n        return {\n          dispatch(event: Event): boolean {\n            return dispatcher.dispatch(event);\n          },\n          on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n));\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * Either element itself, or its shadow root.\n *\n * @category Core\n */\nexport type ContentRoot = Element | ShadowRoot;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = (/*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx): ContentRoot {\n        return ctx.get(ComponentContext__key).element as ContentRoot;\n      },\n    },\n));\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, statePath, StatePath } from '@proc7ts/fun-events';\nimport { mergeFunctions, noop } from '@proc7ts/primitives';\n\n/**\n * Component state updater signature.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeParam TValue - Updated value type\n * @param path - Updated state node path.\n * @param newValue - New value.\n * @param oldValue - Replaced value.\n */\n    <TValue>(this: void, path: StatePath, newValue: TValue, oldValue: TValue) => void;\n\n/**\n * @category Core\n */\nexport namespace StateUpdater {\n\n  /**\n   * Normalized component state updater signature.\n   *\n   * Accepts normalized state path.\n   */\n  export type Normalized =\n  /**\n   * @typeParam TValue - Updated value type\n   * @param path - Normalized path of updated state node.\n   * @param newValue - New value.\n   * @param oldValue - Replaced value.\n   */\n      <TValue>(this: void, path: StatePath.Normalized, newValue: TValue, oldValue: TValue) => void;\n\n}\n\n/**\n * @internal\n */\nclass StateUpdaterKey extends ContextUpKey<StateUpdater, StateUpdater.Normalized> {\n\n  readonly upKey: ContextUpKey.UpKey<StateUpdater, StateUpdater.Normalized>;\n\n  constructor() {\n    super('state-updater');\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...fns) => {\n              if (fns.length) {\n\n                const combined: StateUpdater.Normalized = fns.reduce(\n                    (prev, fn) => mergeFunctions(fn, prev),\n                    noop,\n                );\n\n                return afterThe((path, newValue, oldValue) => combined(statePath(path), newValue, oldValue));\n              }\n\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n\n              return afterThe(noop);\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          StateUpdater,\n          ContextUpKey.Source<StateUpdater.Normalized>,\n          AfterEvent<StateUpdater.Normalized[]>>,\n  ): void {\n\n    let delegated: StateUpdater;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        fn => delegated = fn,\n    ).whenOff(\n        () => delegated = noop,\n    );\n\n    slot.insert((path, newValue, oldValue) => delegated(path, newValue, oldValue));\n  }\n\n}\n\n/**\n * A key of component context value containing a component {@link StateUpdater state updater} function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Does nothing by default and after component destruction.\n *\n * When multiple state updaters provided, they all will be called on each state update, in reverse order.\n *\n * @category Core\n */\nexport const StateUpdater: ContextUpRef<StateUpdater, StateUpdater.Normalized> = (/*#__PURE__*/ new StateUpdaterKey());\n","import { OnDomEvent } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, ContextValues } from '@proc7ts/context-values';\nimport { AfterEvent, OnEvent, StatePath } from '@proc7ts/fun-events';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event-dispatcher.key.impl';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of component instance method returning its component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = (/*#__PURE__*/ Symbol('ComponentContext'));\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * {@link BootstrapSetup.perComponent} and {@link DefinitionSetup.perComponent} methods.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues implements SupplyPeer {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Extracts component context from the given component instance.\n   *\n   * @param component - Target component instance.\n   *\n   * @return Component context reference returned by {@link ComponentContext__symbol} method.\n   *\n   * @throws TypeError  When the given `component` does not contain component context reference.\n   */\n  static of<T extends object>(component: ComponentInstance<T>): ComponentContext<T> {\n    if (typeof component[ComponentContext__symbol] !== 'function') {\n      throw new TypeError(`No component context found in ${String(component)}`);\n    }\n    return component[ComponentContext__symbol]!();\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.whenComponent component instantiation event} receiver. A {@link whenReady} callback\n   * can be used to work this around.\n   */\n  abstract readonly component: ComponentInstance<T>;\n\n  /**\n   * Whether the component is {@link DefinitionContext.mountTo mounted} to element.\n   */\n  abstract readonly mounted: boolean;\n\n  /**\n   * Whether the component is ready.\n   *\n   * Set to `true` when {@link component} is available.\n   */\n  abstract readonly ready: boolean;\n\n  /**\n   * An `OnEvent` sender of component readiness event.\n   *\n   * The component is constructed shortly after context. So the component may not exist when requested inside component\n   * constructor or {@link DefinitionContext.whenComponent component instantiation event} receiver. The registered\n   * receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly onceReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of single component readiness event.\n   *\n   * The component is constructed shortly after context. So the component may not exist when requested inside component\n   * constructor or {@link DefinitionContext.whenComponent component instantiation event} receiver. The registered\n   * receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   *\n   * In contrast to {@link onceReady}, cuts off the event supply after sending the first event.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * Whether the component is settled.\n   *\n   * Component settlement happens:\n   * - when {@link settle} method is called,\n   * - when component is {@link DefinitionContext.mountTo mounted} to element, or\n   * - when component's element is {@link connected}.\n   *\n   * It is guaranteed that component settlement won't happen inside custom element's constructor. So the settlement\n   * event may be used e.g. to start DOM manipulations, as it is prohibited inside custom element constructor.\n   *\n   * This becomes `true` right before {@link whenSettled} event is sent.\n   */\n  abstract readonly settled: boolean;\n\n  /**\n   * An `OnEvent` sender of component settlement event.\n   *\n   * The registered receiver is called when component is {@link settled}. If settled already the receiver is called\n   * immediately.\n   */\n  abstract readonly onceSettled: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of single component settlement event.\n   *\n   * The registered receiver is called when component is {@link settled}. If settled already the receiver is called\n   * immediately.\n   *\n   * In contrast to {@link onceSettled}, cuts off the event supply after sending the first event.\n   */\n  abstract readonly whenSettled: OnEvent<[this]>;\n\n  /**\n   * Whether the component's element is connected.\n   *\n   * This becomes `true` right before {@link whenConnected} event is sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An `OnEvent` sender of component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. E.g. when custom element's\n   * `connectedCallback()` method is called.\n   *\n   * If connected already the receiver is called immediately.\n   */\n  abstract readonly onceConnected: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of single component's element connection event.\n   *\n   * The registered receiver is called when component's element is connected. E.g. when custom element's\n   * `connectedCallback()` method is called.\n   *\n   * If connected already the receiver is called immediately.\n   *\n   * In contrast to {@link onceConnected}, cuts off the event supply after sending the first event.\n   */\n  abstract readonly whenConnected: OnEvent<[this]>;\n\n  /**\n   * An `AfterEvent` keeper of component status.\n   *\n   * Sends this context instance each time the component status changes.\n   */\n  abstract readonly readStatus: AfterEvent<[this]>;\n\n  /**\n   * An event supply that disposes component and its context when cut off.\n   *\n   * Unmounts the {@link mounted} component.\n   *\n   * For custom element the component may be reconstructed when element is connected to document or settled again.\n   */\n  abstract readonly supply: Supply;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * @typeParam TValue - A type of changed value.\n   * @param key - Changed value key.\n   * @param newValue - New value.\n   * @param oldValue - Previous value.\n   */\n  readonly updateState: StateUpdater;\n\n  constructor() {\n    super();\n    this.updateState = <TValue>(key: StatePath, newValue: TValue, oldValue: TValue): void => {\n      this.get(StateUpdater)(key, newValue, oldValue);\n    };\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): ContentRoot {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Settles component.\n   *\n   * Calling this method has no effect if component is {@link settled} already, when component is not\n   * {@link whenReady ready} yet, or custom element's constructor is not exited.\n   *\n   * Calling this method may trigger DOM manipulations (the latter is prohibited inside custom element's constructor).\n   * This may be desired for rendering optimizations. E.g. to render element's content _before_ adding it to document.\n   *\n   * This method is called automatically when {@link DefinitionContext.mountTo mounting} component to element.\n   */\n  abstract settle(): void;\n\n  /**\n   * Returns DOM event producer for the given event type.\n   *\n   * Retrieves an event producer from {@link ComponentEventDispatcher component event dispatcher} available in this\n   * context.\n   *\n   * @typeParam TEvent - DOM event type.\n   * @param type - An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<TEvent extends Event>(type: string): OnDomEvent<TEvent> {\n    return this.get(ComponentEventDispatcher__key).on(type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * Dispatches using a {@link ComponentEventDispatcher component event dispatcher} available in this context.\n   *\n   * @param event - An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(ComponentEventDispatcher__key).dispatch(event);\n  }\n\n}\n\n/**\n * A component instance.\n *\n * @category Core\n */\nexport type ComponentInstance<T extends object = any> = T & {\n\n  /**\n   * @returns Component context.\n   */\n  [ComponentContext__symbol]?(): ComponentContext<T>;\n\n};\n","import { AeClass, AeMember, allAmender, Amendment, AmendTarget, MemberAmendment } from '@proc7ts/amend';\nimport { Class } from '@proc7ts/primitives';\nimport { AeComponent, Component } from './component.amendment';\nimport { ComponentClass } from './definition';\n\n/**\n * An amended entity representing a component member to amend.\n *\n * @category Core\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n */\nexport interface AeComponentMember<\n    TValue extends TUpdate,\n    TClass extends ComponentClass = Class,\n    TUpdate = TValue,\n    > extends AeComponent<TClass>, AeMember<TValue, TClass, TUpdate> {\n}\n\n/**\n * An amendment target representing a component member to amend.\n *\n * @category Core\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - Amended component member entity type.\n */\nexport type AeComponentMemberTarget<\n    TValue extends TUpdate,\n    TClass extends ComponentClass = Class,\n    TUpdate = TValue,\n    TAmended extends AeComponentMember<TValue, TClass, TUpdate> =\n        AeComponentMember<TValue, TClass, TUpdate>\n    > = AmendTarget<TAmended>;\n\n/**\n * Component member amendment.\n *\n * Constructed by {@link ComponentMember} function.\n *\n * @category Core\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - Amended component member entity type.\n */\nexport type ComponentMemberAmendment<\n    TValue extends TUpdate,\n    TClass extends ComponentClass = Class,\n    TUpdate = TValue,\n    TAmended extends AeComponentMember<TValue, TClass, TUpdate> = AeComponentMember<TValue, TClass, TUpdate>> =\n    MemberAmendment.ForBase<\n        AeClass<TClass>,\n        AeComponentMember<TValue, TClass, TUpdate>,\n        TValue,\n        TClass,\n        TUpdate,\n        TAmended>;\n\n/**\n * Creates an amendment (and decorator) for the component instance member.\n *\n * @category Core\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TUpdate - Amended member update type accepted by its setter.\n * @typeParam TAmended - Amended component member entity type.\n * @param amendments - Amendments to apply.\n *\n * @returns New component member amendment instance.\n */\nexport function ComponentMember<\n    TValue extends TUpdate,\n    TClass extends ComponentClass = Class,\n    TUpdate = TValue,\n    TAmended extends AeComponentMember<TValue, TClass, TUpdate> = AeComponentMember<TValue, TClass, TUpdate>>(\n    ...amendments: Amendment<TAmended>[]\n): ComponentMemberAmendment<TValue, TClass, TUpdate, TAmended> {\n  return AeMember<TValue, TClass, TUpdate, TAmended>(\n      Component<TClass, TAmended>(\n          allAmender(amendments),\n      ),\n  ) as ComponentMemberAmendment<TValue, TClass, TUpdate, TAmended>;\n}\n","import { AfterEvent, AfterEvent__symbol, digOn_, mapAfter, onceOn, OnEvent, trackValue } from '@proc7ts/fun-events';\nimport { noop, valueProvider } from '@proc7ts/primitives';\nimport { neverSupply, Supply } from '@proc7ts/supply';\nimport { ComponentContext } from './component-context';\nimport { ComponentSlot } from './component-slot';\n\ninterface ComponentSlot$Provider<T extends object> {\n  get(): ComponentContext<T> | undefined;\n  unbind(): void;\n  rebind(): ComponentContext<T> | undefined;\n  drop(): void;\n}\n\nconst ComponentSlot$empty: ComponentSlot$Provider<any> = {\n  get: noop,\n  unbind: noop,\n  rebind: noop,\n  drop: noop,\n};\n\n/**\n * @internal\n */\nexport class ComponentSlot$<T extends object> implements ComponentSlot<T> {\n\n  readonly _provider = trackValue<ComponentSlot$Provider<T>>(ComponentSlot$empty);\n  readonly read: AfterEvent<[ComponentContext<T>?]>;\n  readonly whenReady: OnEvent<[ComponentContext<T>]>;\n\n  constructor() {\n    this.read = this._provider.read.do(\n        mapAfter(provider => provider.get()),\n    );\n    this.whenReady = this.read.do(\n        digOn_(ctx => ctx && ctx.whenReady),\n        onceOn,\n    );\n  }\n\n  get context(): ComponentContext<T> | undefined {\n    return this._provider.it.get();\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[ComponentContext<T>?]> {\n    return this.read;\n  }\n\n  bind(context: ComponentContext<T>): void {\n    this._provider.it.drop();\n    this._provider.it = ComponentSlot$known(this, context);\n  }\n\n  bindBy(binder: ComponentSlot.Binder<T>): void {\n    this._provider.it.drop();\n    this._provider.it = ComponentSlot$bound(this, binder);\n  }\n\n  unbind(): void {\n    this._provider.it.unbind();\n  }\n\n  rebind(): ComponentContext<T> | undefined {\n    return this.context || this._provider.it.rebind();\n  }\n\n}\n\nfunction ComponentSlot$known<T extends object>(\n    slot: ComponentSlot$<T>,\n    context: ComponentContext<T>,\n): ComponentSlot$Provider<T> {\n  context.supply.whenOff(() => {\n    if (slot.context === context) {\n      slot.unbind();\n    }\n  });\n\n  const get = (): ComponentContext<T> | undefined => context;\n\n  return {\n    get,\n    unbind() {\n      slot._provider.it = ComponentSlot$empty;\n    },\n    rebind: get,\n    drop: noop,\n  };\n}\n\nfunction ComponentSlot$bound<T extends object>(\n    slot: ComponentSlot$<T>,\n    binder: ComponentSlot.Binder<T>,\n): ComponentSlot$Provider<T> {\n\n  let supply = neverSupply();\n  let getContext: () => ComponentContext<T> | undefined = noop;\n  const get = (): ComponentContext<T> | undefined => getContext();\n  const newSupply = (): Supply => supply = new Supply(() => {\n    getContext = noop;\n  });\n  let bind = (context: ComponentContext<T>): Supply => {\n    getContext = valueProvider(context);\n    context.supply.whenOff(() => {\n      if (slot.context === context) {\n        slot.unbind();\n      }\n    });\n    return newSupply();\n  };\n  const drop = (): void => {\n    bind = _ => neverSupply();\n    supply.off();\n  };\n  const unbind = (): void => {\n    supply.off();\n    slot._provider.it = {\n      get,\n      unbind,\n      rebind, // eslint-disable-line @typescript-eslint/no-use-before-define\n      drop,\n    };\n  };\n\n  const bindContext = (): void => binder({\n    bind: context => bind(context),\n  });\n\n  getContext = () => {\n    bindContext();\n\n    // Subsequent bind calls update the component provider\n    bind = context => {\n      supply.off();\n      getContext = valueProvider(context);\n      slot._provider.it = {\n        get,\n        unbind,\n        rebind, // eslint-disable-line @typescript-eslint/no-use-before-define\n        drop,\n      };\n      return newSupply();\n    };\n\n    return getContext();\n  };\n\n  const rebind = (): ComponentContext<T> | undefined => {\n    bindContext();\n    return getContext();\n  };\n\n  return {\n    get,\n    unbind,\n    rebind,\n    drop,\n  };\n}\n","import { AfterEvent, EventKeeper, OnEvent } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext } from './component-context';\nimport { ComponentSlot$ } from './component-slot.impl';\n\n/**\n * A component slot.\n *\n * It is added to {@link ComponentElement component element} and contains a bound component context.\n *\n * Notifies on component binding.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport interface ComponentSlot<T extends object = any> extends EventKeeper<[ComponentContext<T>?]> {\n\n  /**\n   * A context of the bound component.\n   */\n  readonly context: ComponentContext<T> | undefined;\n\n  /**\n   * An `AfterEvent` keeper of the bound component context.\n   */\n  readonly read: AfterEvent<[ComponentContext<T>?]>;\n\n  /**\n   * An `OnEvent` sender of the bound component {@link ComponentContext.whenReady readiness} event.\n   */\n  readonly whenReady: OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Binds a component to element.\n   *\n   * This method is not typically used by client code.\n   *\n   * @param context - The bound component context.\n   */\n  bind(context: ComponentContext<T>): void;\n\n  /**\n   * Binds a component to element by the give `binder`.\n   *\n   * @param binder - Component slot binder.\n   */\n  bindBy(binder: ComponentSlot.Binder<T>): void;\n\n  /**\n   * Unbinds component from element.\n   *\n   * This method is not typically used by client code.\n   *\n   * After this method call the component may be reconstructed again by its {@link bindBy binder}.\n   */\n  unbind(): void;\n\n  /**\n   * Tries to re-bind component context by its {@link bindBy binder}.\n   *\n   * Does nothing if component is bound already.\n   *\n   * @returns Either a bound component context, or `undefined` if component can not be bound.\n   */\n  rebind(): ComponentContext<T> | undefined;\n\n}\n\n/**\n * A key of component element property containing a reference to component slot.\n *\n * @category Core\n */\nexport const ComponentSlot__symbol = (/*#__PURE__*/ Symbol('ComponentSlot'));\n\n/**\n * An element the component can be bound to.\n *\n * Such element may contain a {@link ComponentSlot component slot} containing a bound component context.\n *\n * @category Core\n * @typeParam T - A type of the bound component.\n */\nexport interface ComponentElement<T extends object = any> extends Element {\n\n  /**\n   * A component slot instance.\n   *\n   * A {@link ComponentSlot.of} function may be used to access the slot instance, or construct it when necessary.\n   */\n  [ComponentSlot__symbol]?: ComponentSlot<T>;\n\n}\n\n/**\n * @category Core\n */\nexport namespace ComponentSlot {\n\n  /**\n   * A binding of component to element.\n   *\n   * This is passed to {@link Binder component binder}. The latter can use it to assign the bound component.\n   *\n   * @typeParam T - A type of component.\n   */\n  export interface Binding<T extends object> {\n\n    /**\n     * Assigns a context of the component bound to target element.\n     *\n     * @param context - Bound component context.\n     *\n     * @returns Binding supply. Cut off once the component {@link ComponentSlot.unbind unbound}.\n     */\n    bind(this: void, context: ComponentContext<T>): Supply;\n\n  }\n\n  /**\n   * A binder of component to element.\n   *\n   * Controls component construction and binding to element.\n   *\n   * @typeParam T - A type of component.\n   */\n  export type Binder<T extends object> =\n  /**\n   * @param binding - Component binding to element.\n   */\n      (this: void, binding: Binding<T>) => void;\n\n}\n\n/**\n * @category Core\n */\nexport const ComponentSlot = {\n\n  /**\n   * Accesses a component slot of the given element. Attaches a new slot if necessary.\n   *\n   * @param element - Target element.\n   *\n   * @returns A component slot instance attached to the element.\n   */\n  of<T extends object>(this: void, element: ComponentElement<T>): ComponentSlot<T> {\n\n    const found = element[ComponentSlot__symbol];\n\n    if (found) {\n      return found;\n    }\n\n    return element[ComponentSlot__symbol] = new ComponentSlot$();\n  },\n\n};\n","import {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  SingleContextKey,\n} from '@proc7ts/context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapContextRegistry__key = (\n    /*#__PURE__*/ new SingleContextKey<BootstrapContextRegistry>('bootstrap-context-registry')\n);\n\n/**\n * @internal\n */\nexport class BootstrapContextRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapContextRegistry> {\n    return BootstrapContextRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapContextRegistry {\n    return new BootstrapContextRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapContextRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextRef, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nexport type PerComponentRegistry = ComponentContextRegistry;\n\nexport const PerComponentRegistry: ContextRef<PerComponentRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentContextRegistry>(\n    'per-component-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n    },\n));\n\n/**\n * @internal\n */\nexport class ComponentContextRegistry extends ContextRegistry<ComponentContext> {\n}\n","import { ContextRef, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\n/**\n * @internal\n */\nexport type PerDefinitionRegistry = DefinitionContextRegistry;\n\n/**\n * @internal\n */\nexport const PerDefinitionRegistry: ContextRef<PerDefinitionRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<DefinitionContextRegistry>(\n    'per-definition-registry',\n    {\n      byDefault: bootstrapDefault(bsContext => new DefinitionContextRegistry(bsContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class DefinitionContextRegistry extends ContextRegistry<DefinitionContext> {\n}\n","import { EventEmitter, onAny, OnEvent, onEventBy, supplyOn, trackValue, valueOn } from '@proc7ts/fun-events';\nimport { AbstractClass, asis, hasOwnProperty, superClassOf } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentDef__symbol } from '../../component';\nimport { ComponentClass, DefinitionSetup } from '../../component/definition';\n\n/**\n * @internal\n */\nexport function onPostDefSetup(\n    componentType: ComponentClass,\n    supply: Supply,\n): OnEvent<[DefinitionSetup]> {\n\n  const { on } = postDefSetup(componentType);\n\n  return onEventBy(receiver => {\n    on({\n      supply: receiver.supply.needs(supply),\n      receive(ctx, setup) {\n\n        const whenReady = setup.whenReady.do(supplyOn(supply));\n        const whenComponent = setup.whenComponent.do(supplyOn(supply));\n\n        receiver.receive(ctx, {\n          get componentType() {\n            return setup.componentType;\n          },\n          get whenReady() {\n            return whenReady;\n          },\n          get whenComponent() {\n            return whenComponent;\n          },\n          perDefinition(spec) {\n            return setup.perDefinition(spec).needs(supply);\n          },\n          perComponent(spec) {\n            return setup.perComponent(spec).needs(supply);\n          },\n        });\n      },\n    });\n  });\n}\n\n/**\n * @internal\n */\nexport interface PostDefSetup<T extends object = any> {\n  readonly on: OnEvent<[DefinitionSetup<T>]>;\n  send(setup: DefinitionSetup): void;\n  setup(setup: DefinitionSetup<T>): void;\n}\n\nconst PostDefSetup__symbol = (/*#__PURE__*/ Symbol('PostDefSetup'));\n\ninterface PostDefComponentClass<T extends object> extends AbstractClass<T> {\n  [PostDefSetup__symbol]?: PostDefSetup<T>;\n}\n\n/**\n * @internal\n */\nexport function postDefSetup<T extends object>(componentType: PostDefComponentClass<T>): PostDefSetup<T> {\n  if (hasOwnProperty(componentType, PostDefSetup__symbol)) {\n    return componentType[PostDefSetup__symbol] as PostDefSetup<T>;\n  }\n\n  const tracker = trackValue<DefinitionSetup<T>>();\n  const emitter = new EventEmitter<[DefinitionSetup]>();\n  const onSetup: OnEvent<[DefinitionSetup<T>]> = tracker.read.do(valueOn(asis));\n  const on = onAny(onSetup, emitter);\n  const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n\n  if (superType) {\n\n    const superPostDefSetup = postDefSetup(superType);\n\n    on(setup => superPostDefSetup.send(setup));\n  }\n\n  const result: PostDefSetup<T> = {\n    on,\n    send(setup) {\n      emitter.send(setup);\n    },\n    setup(setup) {\n      tracker.it = setup;\n    },\n  };\n\n  Reflect.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n\n  return result;\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window & typeof globalThis;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = (/*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n));\n","import { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> = (\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser')\n);\n","import { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { ContextValues, ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter } from '@proc7ts/fun-events';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * @internal\n */\nexport class RenderScheduler$Key extends ContextUpKey<RenderScheduler, RenderScheduler> {\n\n  readonly upKey: ContextUpKey.UpKey<RenderScheduler, RenderScheduler>;\n\n  constructor(name: string, byDefault: RenderScheduler) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...fns) => {\n              if (fns.length) {\n                return afterThe(RenderScheduler$adopt(slot.context, fns[fns.length - 1]));\n              }\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n              return afterThe(RenderScheduler$adopt(slot.context, byDefault));\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          RenderScheduler,\n          ContextUpKey.Source<RenderScheduler>,\n          AfterEvent<RenderScheduler[]>>,\n  ): void {\n\n    const { context } = slot;\n    const bsContext = context.get(BootstrapContext);\n\n    if (context !== bsContext) {\n      return slot.insert(bsContext.get(this, slot.hasFallback ? slot : undefined));\n    }\n\n    let delegated: RenderScheduler;\n\n    context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        scheduler => delegated = RenderScheduler$adopt(context, scheduler),\n    );\n\n    slot.insert((...args) => delegated(...args));\n  }\n\n}\n\nfunction RenderScheduler$adopt(context: ContextValues, scheduler: RenderScheduler): RenderScheduler {\n  return (options = {}) => scheduler({\n    ...options,\n    window: options.window || context.get(BootstrapWindow),\n  });\n}\n","import { asyncRenderScheduler, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { RenderScheduler$Key } from './render-scheduler.key.impl';\n\n/**\n * Default pre-rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultPreRenderScheduler = RenderScheduler;\n\n/**\n * A key of bootstrap context value containing {@link DefaultPreRenderScheduler} instance.\n *\n * Uses asynchronous `RenderScheduler` (`asyncRenderScheduler`) for {@link BootstrapWindow bootstrap window} by default.\n *\n * @category Core\n */\nexport const DefaultPreRenderScheduler: ContextUpRef<DefaultPreRenderScheduler, RenderScheduler> = (\n    /*#__PURE__*/ new RenderScheduler$Key('default-pre-render-scheduler', asyncRenderScheduler)\n);\n","import { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { RenderScheduler$Key } from './render-scheduler.key.impl';\n\n/**\n * Default rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultRenderScheduler = RenderScheduler;\n\n/**\n * A key of bootstrap context value containing {@link DefaultRenderScheduler} instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window} by default.\n *\n * @category Core\n */\nexport const DefaultRenderScheduler: ContextUpRef<DefaultRenderScheduler, RenderScheduler> = (\n    /*#__PURE__*/ new RenderScheduler$Key('default-render-scheduler', newRenderSchedule)\n);\n","import { nodeDocument } from '@frontmeans/dom-primitives';\nimport { DrekContext, drekContextOf } from '@frontmeans/drek';\nimport { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { DefaultNamespaceAliaser } from './default-namespace-aliaser';\nimport { DefaultRenderScheduler } from './default-render-scheduler';\n\n/**\n * A document render kit instance.\n *\n * A [Drek] API accessor used by Wesib internally.\n *\n * [Drek]: https://www.npmjs.com/package/@frontmeans/drek\n *\n * @category Core\n */\nexport interface DocumentRenderKit {\n\n  /**\n   * Obtains a rendering context of the given DOM node.\n   *\n   * Does the same as `drekContextOf()` function, and also makes sure that the rendering context for the document\n   * is initialized with {@link DefaultRenderScheduler} and {@link DefaultNamespaceAliaser}.\n   *\n   * @param node - Target DOM node.\n   *\n   * @returns Target node rendering context.\n   */\n  contextOf(node: Node): DrekContext;\n\n}\n\n/**\n * A key of bootstrap context value containing {@link DocumentRenderKit} instance.\n *\n * @category Core\n */\nexport const DocumentRenderKit: ContextRef<DocumentRenderKit> = (\n    /*#__PURE__*/ new SingleContextKey<DocumentRenderKit>(\n        'document-render-kit',\n        {\n          byDefault: bootstrapDefault(DocumentRenderKit$create),\n        },\n    )\n);\n\nfunction DocumentRenderKit$create(bsContext: BootstrapContext): DocumentRenderKit {\n\n  const docs = new WeakMap<Document, 1>();\n  const initDoc = (doc: Document): void => {\n    if (!docs.get(doc)) {\n      docs.set(doc, 1);\n      drekContextOf(doc).update({\n        nsAlias: bsContext.get(DefaultNamespaceAliaser),\n        scheduler: bsContext.get(DefaultRenderScheduler),\n      });\n    }\n  };\n\n  return {\n    contextOf(node: Node): DrekContext {\n      initDoc(nodeDocument(node));\n      return drekContextOf(node);\n    },\n  };\n}\n","import { hasOwnProperty } from '@proc7ts/primitives';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const DefinitionContext__symbol = (/*#__PURE__*/ Symbol('DefinitionContext'));\n\n/**\n * @internal\n */\nexport interface ComponentDefinitionClass<T extends object> extends ComponentClass<T> {\n  [DefinitionContext__symbol]?: DefinitionContext<T>;\n}\n\n/**\n * @internal\n */\nexport function definitionContextOf<T extends object>(\n    componentType: ComponentDefinitionClass<T>,\n): DefinitionContext<T> {\n  if (!hasOwnProperty(componentType, DefinitionContext__symbol)) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n  return componentType[DefinitionContext__symbol] as DefinitionContext<T>;\n}\n","import { html__naming, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { Class, hasOwnProperty, newPromiseResolver, PromiseResolver } from '@proc7ts/primitives';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { definitionContextOf } from '../../boot/impl/definition-context.symbol.impl';\nimport { ComponentClass } from './component-class';\n\n/**\n * @internal\n */\nconst CustomElements__key = (/*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: bootstrapDefault(createCustomElements),\n    },\n));\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName - A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType - A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName - Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\n/**\n * @internal\n */\nfunction createCustomElements(bsContext: BootstrapContext): CustomElements {\n\n  const customElements: CustomElementRegistry = bsContext.get(BootstrapWindow).customElements;\n  const nsAlias = bsContext.get(DefaultNamespaceAliaser);\n\n  class CustomElements$ extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { tagName, extend } = defContext.elementDef;\n\n      if (!tagName) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            tagName,\n            elementType,\n            {\n              extends: extend.name,\n            },\n        );\n      } else {\n        customElements.define(tagName, elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const defContext = definitionContextOf(componentTypeOrName);\n      const { name } = defContext.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise();\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new CustomElements$();\n}\n\n/**\n * @internal\n */\nconst ComponentResolver__symbol = (/*#__PURE__*/ Symbol('ComponentResolver'));\n\n/**\n * @internal\n */\ninterface CustomComponentClass<T extends object = any> extends ComponentClass<T> {\n  [ComponentResolver__symbol]?: PromiseResolver;\n}\n\n/**\n * @internal\n */\nfunction componentResolver(componentType: CustomComponentClass): PromiseResolver {\n  if (hasOwnProperty(componentType, ComponentResolver__symbol)) {\n    return componentType[ComponentResolver__symbol] as PromiseResolver;\n  }\n  return componentType[ComponentResolver__symbol] = newPromiseResolver();\n}\n","import { noop } from '../fn';\nimport { lazyValue } from '../value';\n\n/**\n * A resolver of promise that can be created later or not created at all.\n *\n * Creates the promise only on demand.\n *\n * The methods of this object do not require `this` context and can be called as functions.\n */\nexport interface PromiseResolver<T = void> {\n\n  /**\n   * Resolves the promise.\n   *\n   * Has no effect when the promised is already settled.\n   *\n   * Can be called before the promise constructed.\n   *\n   * @param resolution - Either a promise value, or a promise-like instance resolving to one.\n   */\n  resolve(this: void, resolution: T | PromiseLike<T>): void;\n\n  /**\n   * Rejects the promise.\n   *\n   * Has no effect when the promised is already settled.\n   *\n   * Can be called before the promise constructed.\n   *\n   * @param reason - Promise rejection reason.\n   */\n  reject(this: void, reason?: any): void;\n\n  /**\n   * Creates a promise resolved by {@link resolve}, or rejected by {@link reject}.\n   *\n   * The subsequent calls to this method return the same promise instance.\n   *\n   * @returns Created promise.\n   */\n  promise(this: void): Promise<T>;\n\n}\n\n/**\n * Creates a promise resolver.\n *\n * @returns New promise resolver.\n */\nexport function newPromiseResolver<T = void>(): PromiseResolver<T> {\n\n  let resolvePromise: (value: T | PromiseLike<T>) => void;\n  let rejectPromise: (reason?: any) => void;\n  let buildPromise = lazyValue(() => new Promise<T>((resolve, reject) => {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n  }));\n  const settle = (resolution: () => Promise<T>): void => {\n    buildPromise = lazyValue(resolution);\n    resolvePromise = noop;\n    rejectPromise = noop;\n  };\n\n  resolvePromise = value => {\n    settle(() => Promise.resolve(value));\n  };\n  rejectPromise = error => {\n    settle(() => Promise.reject(error));\n  };\n\n  return {\n    resolve(value?) {\n      resolvePromise(value);\n    },\n    reject(reason) {\n      rejectPromise(reason);\n    },\n    promise() {\n      return buildPromise();\n    },\n  };\n}\n","import { SingleContextKey } from '@proc7ts/context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context'));\n","import { html__naming, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name: QualifiedName | undefined;\n\n  /**\n   * Resolved custom HTML element's tag name, if any.\n   *\n   * In contrast to {@link name} this one is always a string.\n   */\n  readonly tagName: string | undefined;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n *\n * @category Core\n */\nexport const ElementDef: SingleContextRef<ElementDef> = (/*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n        let tagName: string | undefined;\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || values.get(BootstrapWindow).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get tagName() {\n            return tagName || (name && (tagName = html__naming.name(name, values.get(DefaultNamespaceAliaser))));\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n));\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext } from '../component-context';\nimport { ComponentElement } from '../component-slot';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * {@link BootstrapSetup.perDefinition} and {@link DefinitionSetup.perDefinition} methods. All {@link BootstrapContext}\n * values are available too.\n *\n * @category Core\n * @typeParam T - A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * {@link ComponentDef.define} function. In such case you may wish to add a `whenReady()` callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * An `OnEvent` sender of component definition context upon its readiness.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   */\n  abstract readonly whenReady: OnEvent<[this]>;\n\n  /**\n   * An `OnEvent` sender of component context upon its instantiation.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenConnected connected}. This is to prevent resource\n   * leaks on destroyed components.\n   */\n  abstract readonly whenComponent: OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a {@link ComponentContext.mounted} flag\n   * to check whether the component is mounted or constructed in a standard way.\n   *\n   * The constructed component connection state is maintained by {@link DocumentRenderKit document render kit}.\n   *\n   * @param element - Target element to mount new component to.\n   *\n   * @returns Mounted component context.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: ComponentElement<T>): ComponentContext<T>;\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeParam TSrc - The type of context value sources.\n   * @typeParam TDeps - A type of dependencies.\n   * @param spec - Component context value specifier.\n   *\n   * @returns A value supply that removes the given context value specifier once cut off.\n   */\n  abstract perComponent<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<ComponentContext<T>, unknown, TSrc, TDeps>,\n  ): Supply;\n\n}\n","import { ComponentContext, ComponentContext__symbol } from '../component-context';\nimport { ComponentClass } from './component-class';\n\nconst ComponentConstructor__symbol = (/*#__PURE__*/ Symbol('newComponent'));\n\ntype ComponentConstructor<T extends object> = (this: ComponentType<T>, context: ComponentContext<T>) => T;\n\ninterface ComponentType<T extends object> extends ComponentClass<T> {\n\n  [ComponentConstructor__symbol]?: ComponentConstructor<T>;\n\n}\n\n/**\n * @internal\n */\nexport function newComponent<T extends object>(context: ComponentContext<T>): T {\n\n  const componentType = context.componentType as ComponentType<T>;\n\n  if (!componentType[ComponentConstructor__symbol]) {\n    componentType[ComponentConstructor__symbol] = newComponentConstructor(componentType);\n  }\n\n  return componentType[ComponentConstructor__symbol]!(context);\n}\n\nfunction newComponentConstructor<T extends object>(componentType: ComponentType<T>): ComponentConstructor<T> {\n\n  // Component context reference specific to component class.\n  const context__symbol = Symbol('ComponentContext');\n\n  type ComponentInstance = T & {\n    [context__symbol]?: ComponentContext<T>;\n  };\n\n  let defaultContext: ComponentContext<T> | undefined;\n\n  componentType.prototype[ComponentContext__symbol] = function (\n      this: ComponentInstance,\n  ): ComponentContext<T> {\n    return this[context__symbol] || (this[context__symbol] = defaultContext)!;\n  };\n\n  return function (this: ComponentType<T>, context: ComponentContext<T>): T {\n\n    const prevContext = defaultContext;\n\n    // Ensure the component context is available in component constructor.\n    defaultContext = context;\n    try {\n\n      const component = new this(context) as ComponentInstance;\n\n      component[context__symbol] = context;\n\n      return component;\n    } finally {\n      defaultContext = prevContext;\n    }\n  };\n}\n","import { AfterEvent, filterOn_, mapAfter_, onceOn, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext } from '../../component';\n\nconst enum ComponentStatusValue {\n  Building,\n  Ready,\n  Settled,\n  Connected,\n}\n\n/**\n * @internal\n */\nexport class ComponentStatus<TCtx extends ComponentContext> {\n\n  private readonly _val = trackValue<ComponentStatusValue>(ComponentStatusValue.Building);\n  private _canSettle: 0 | 1 = 0;\n\n  constructor(private readonly _ctx: TCtx) {\n  }\n\n  get supply(): Supply {\n    return this._val.supply;\n  }\n\n  read(): AfterEvent<[TCtx]> {\n    return (this.read = valueProvider(this._val.read.do(\n        mapAfter_(valueProvider(this._ctx)),\n    )))();\n  }\n\n  isReady(): boolean {\n    return !!this._val.it && !this._val.supply.isOff;\n  }\n\n  onceReady(): OnEvent<[TCtx]> {\n    return (this.onceReady = valueProvider(this.read().do(\n        ComponentStatus$once(({ ready }) => ready),\n    )))();\n  }\n\n  whenReady(): OnEvent<[TCtx]> {\n    return (this.whenReady = valueProvider(this.onceReady().do(\n        onceOn,\n    )))();\n  }\n\n  isSettled(): boolean {\n    return this._val.it >= ComponentStatusValue.Settled && !this._val.supply.isOff;\n  }\n\n  onceSettled(): OnEvent<[TCtx]> {\n    return (this.onceSettled = valueProvider(this.read().do(\n        ComponentStatus$once(({ settled }) => settled),\n    )))();\n  }\n\n  whenSettled(): OnEvent<[TCtx]> {\n    return (this.whenSettled = valueProvider(this.onceSettled().do(\n        onceOn,\n    )))();\n  }\n\n  isConnected(): boolean {\n    return this._val.it >= ComponentStatusValue.Connected && !this._val.supply.isOff;\n  }\n\n  onceConnected(): OnEvent<[TCtx]> {\n    return (this.onceConnected = valueProvider(this.read().do(\n        // Filtering is enough, as there is no status after \"connected\"\n        filterOn_(({ connected }) => connected),\n    )))();\n  }\n\n  whenConnected(): OnEvent<[TCtx]> {\n    return (this.whenConnected = valueProvider(this.onceConnected().do(\n        onceOn,\n    )))();\n  }\n\n  ready(): void {\n    this._val.it = ComponentStatusValue.Ready;\n  }\n\n  settle(): void {\n    if (this._canSettle && this._val.it < ComponentStatusValue.Settled) {\n      // Prevent settling until exiting custom element constructor\n      this._val.it = ComponentStatusValue.Settled;\n    }\n  }\n\n  connect(): void {\n    this._val.it = ComponentStatusValue.Connected;\n  }\n\n  create(): void {\n    this._canSettle = 1; // Can settle now\n  }\n\n}\n\nfunction ComponentStatus$once<TCtx extends ComponentContext>(\n    test: (context: TCtx) => boolean,\n): (input: OnEvent<[TCtx]>) => OnEvent<[TCtx]> {\n  return input => onEventBy(receiver => {\n\n      let value = false;\n\n      input({\n        supply: receiver.supply,\n        receive(eventCtx, componentCtx) {\n\n          const newValue = test(componentCtx);\n\n          if (newValue && !value) {\n            value = newValue;\n            receiver.receive(eventCtx, componentCtx);\n          }\n        },\n      });\n    });\n}\n","import { OnEvent } from '../on-event';\nimport { shareOn } from './share-on';\nimport { translateOn_ } from './translate-on';\n\n/**\n * Creates an event processor that passes incoming events implementing the given type only.\n *\n * @category Event Processing\n * @typeParam TValue - Incoming value type. This is a list of the test function parameter types.\n * @typeParam TMatch - Required value type.\n * @param test - Test function accepting incoming event as its only parameter, and returning truthy value if the value\n * implements the given type, or falsy one otherwise.\n *\n * @returns {@link OnEvent} sender mapper function.\n */\nexport function filterOn<TValue, TMatch extends TValue>(\n    test: (this: void, event: TValue) => event is TMatch,\n): (this: void, supplier: OnEvent<[TValue]>) => OnEvent<[TMatch]>;\n\n/**\n * Creates an event processor that passes incoming events matching the given condition only.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of the test function parameter types.\n * @param test - Test function accepting incoming event as its parameters, and returning truthy value for matching\n * events, or falsy one otherwise.\n *\n * @returns {@link OnEvent} sender mapper function.\n */\nexport function filterOn<TEvent extends any[]>(\n    test: (this: void, ...event: TEvent) => boolean,\n): (this: void, supplier: OnEvent<TEvent>) => OnEvent<TEvent>;\n\nexport function filterOn<TEvent extends any[]>(\n    test: (this: void, ...event: TEvent) => boolean,\n): (this: void, supplier: OnEvent<TEvent>) => OnEvent<TEvent> {\n\n  const map = filterOn_(test);\n\n  return supplier => shareOn(map(supplier));\n}\n\n/**\n * Creates an event processor that passes incoming events implementing the given type only, and does not share\n * the outgoing events supply.\n *\n * @category Event Processing\n * @typeParam TValue - Incoming value type. This is a list of the test function parameter types.\n * @typeParam TMatch - Required value type.\n * @param test - Test function accepting incoming event as its only parameter, and returning truthy value if the value\n * implements the given type, or falsy one otherwise.\n *\n * @returns {@link OnEvent} sender mapper function.\n */\nexport function filterOn_<TValue, TMatch extends TValue>(// eslint-disable-line @typescript-eslint/naming-convention\n    test: (this: void, event: TValue) => event is TMatch,\n): (this: void, supplier: OnEvent<[TValue]>) => OnEvent<[TMatch]>;\n\n/**\n * Creates an event processor that passes incoming events matching the given condition only, and does not share\n * the outgoing events supply.\n *\n * @category Event Processing\n * @typeParam TEvent - An event type. This is a list of the test function parameter types.\n * @param test - Test function accepting incoming event as its parameters, and returning truthy value for matching\n * events, or falsy one otherwise.\n *\n * @returns {@link OnEvent} sender mapper function.\n */\nexport function filterOn_<TEvent extends any[]>(// eslint-disable-line @typescript-eslint/naming-convention\n    test: (this: void, ...event: TEvent) => boolean,\n): (this: void, supplier: OnEvent<TEvent>) => OnEvent<TEvent>;\n\nexport function filterOn_<TEvent extends any[]>(// eslint-disable-line @typescript-eslint/naming-convention\n    test: (this: void, ...event: TEvent) => boolean,\n): (this: void, supplier: OnEvent<TEvent>) => OnEvent<TEvent> {\n  return translateOn_((send, ...event) => test(...event) && send(...event));\n}\n","import { AfterEvent, onceOn, OnEvent } from '@proc7ts/fun-events';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext, ComponentContext__symbol, ComponentInstance } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { newComponent } from '../../component/definition/component.impl';\nimport { ComponentStatus } from './component-status.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\n/**\n * @internal\n */\nexport abstract class ComponentContext$<T extends object> extends ComponentContext<T> {\n\n  readonly get: ComponentContext<T>['get'];\n  private readonly _status: ComponentStatus<this>;\n\n  constructor(\n      readonly _definitionContext: DefinitionContext$<T>,\n      readonly element: any,\n  ) {\n    super();\n\n    const registry = _definitionContext._newComponentRegistry();\n\n    registry.provide({ a: ComponentContext, is: this });\n    this.get = registry.newValues().get;\n    this._status = new ComponentStatus(this);\n    this.supply.whenOff(() => {\n      delete this.component[ComponentContext__symbol];\n      this._component = componentDestroyed;\n    });\n  }\n\n  get componentType(): ComponentClass<T> {\n    return this._definitionContext.componentType;\n  }\n\n  get component(): ComponentInstance<T> {\n    return this._component();\n  }\n\n  get supply(): Supply {\n    return this._status.supply;\n  }\n\n  get ready(): boolean {\n    return this._status.isReady();\n  }\n\n  get onceReady(): OnEvent<[this]> {\n    return this._status.onceReady();\n  }\n\n  get whenReady(): OnEvent<[this]> {\n    return this._status.whenReady();\n  }\n\n  get settled(): boolean {\n    return this._status.isSettled();\n  }\n\n  get onceSettled(): OnEvent<[this]> {\n    return this._status.onceSettled();\n  }\n\n  get whenSettled(): OnEvent<[this]> {\n    return this._status.whenSettled();\n  }\n\n  get connected(): boolean {\n    return this._status.isConnected();\n  }\n\n  get onceConnected(): OnEvent<[this]> {\n    return this._status.onceConnected();\n  }\n\n  get whenConnected(): OnEvent<[this]> {\n    return this._status.whenConnected();\n  }\n\n  get readStatus(): AfterEvent<[this]> {\n    return this._status.read();\n  }\n\n  _component(): T {\n    throw new TypeError('Component is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  settle(): void {\n    this._status.settle();\n  }\n\n  _createComponent(): this {\n\n    const whenComponent = this._definitionContext._whenComponent;\n\n    let lastRev = 0;\n\n    whenComponent.readNotifier.do(onceOn)(notifier => lastRev = notifier(this, lastRev));\n    this.whenConnected(() => {\n      whenComponent.readNotifier({\n        supply: new Supply().needs(this),\n        receive: (_, notifier) => {\n          lastRev = notifier(this, lastRev);\n        },\n      });\n    });\n    this._definitionContext._elementBuilder.components.send(this);\n\n    const component = newComponent(this);\n\n    this._component = valueProvider(component);\n    this._status.ready();\n\n    return this;\n  }\n\n  _connect(): void {\n    this._status.connect();\n  }\n\n  _created(): void {\n    this._status.create();\n  }\n\n}\n\n/**\n * @internal\n */\nexport class ComponentContext$Mounted<T extends object> extends ComponentContext$<T> {\n\n  get mounted(): true {\n    return true;\n  }\n\n}\n\nfunction componentDestroyed(): never {\n  throw new TypeError('Component destroyed already');\n}\n","import { CustomHTMLElementClass } from '@frontmeans/dom-primitives';\nimport { Class, noop } from '@proc7ts/primitives';\nimport { ComponentElement, ComponentSlot } from '../../component';\nimport { DocumentRenderKit } from '../globals';\nimport { ComponentContext$ } from './component-context.impl';\nimport { DefinitionContext$ } from './definition-context.impl';\n\nclass ComponentContext$Custom<T extends object> extends ComponentContext$<T> {\n\n  get mounted(): false {\n    return false;\n  }\n\n}\n\n/**\n * @internal\n */\nexport function customElementType<T extends object>(\n    defContext: DefinitionContext$<T>,\n): Class {\n\n  const { elementDef } = defContext;\n  const renderKit = defContext.get(DocumentRenderKit);\n\n  class CustomElement$ extends (elementDef.extend.type as CustomHTMLElementClass) implements ComponentElement {\n\n    constructor() {\n      super();\n\n      const slot = ComponentSlot.of<T>(this);\n\n      // Ignore immediate settlement, as is typically leads to DOM manipulations prohibited inside constructor.\n      let settle: () => unknown = noop;\n\n      slot.bindBy(({ bind }) => {\n\n        const context = new ComponentContext$Custom(defContext, this);\n        const supply = bind(context);\n\n        context._createComponent();\n        context._created();\n\n        context.supply.needs(supply).whenOff(() => {\n          renderKit.contextOf(this).whenSettled(_ => settle());\n        });\n      });\n\n      renderKit.contextOf(this).whenSettled(_ => settle());\n\n      // Assume settlement happens after constructor completion.\n      settle = () => slot.rebind()!.settle();\n    }\n\n    connectedCallback(): void {\n      super.connectedCallback?.();\n      (ComponentSlot.of<T>(this).rebind() as ComponentContext$Custom<T>)._connect();\n    }\n\n    disconnectedCallback(): void {\n      (ComponentSlot.of<T>(this).context as ComponentContext$Custom<T>).supply.off();\n      super.disconnectedCallback?.();\n    }\n\n  }\n\n  return CustomElement$;\n}\n","import { AfterEvent, EventEmitter, mapAfter_, OnEvent, onEventBy, trackValue } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\n\nexport class WhenComponent<T extends object> {\n\n  readonly onCreated: OnEvent<[ComponentContext<T>]>;\n  readonly readNotifier: AfterEvent<[ComponentNotifier<T>]>;\n\n  constructor() {\n\n    const currentRev = trackValue(0);\n    const created = new EventEmitter<[ComponentContext<T>, number]>();\n\n    this.onCreated = onEventBy(receiver => {\n\n      const receiverRev = currentRev.it + 1;\n\n      created.on({\n        supply: receiver.supply,\n        receive: (eventContext, componentContext, notifiedRev) => {\n          if (notifiedRev < receiverRev) {\n            // Notify only receivers added after the last notification\n            receiver.receive(\n                {\n                  onRecurrent(recurrentReceiver) {\n                    eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                  },\n                },\n                componentContext,\n            );\n          }\n        },\n      });\n\n      ++currentRev.it;\n    });\n    this.readNotifier = currentRev.read.do(\n        mapAfter_(\n            rev => (context, notifiedRev) => {\n              created.send(context, notifiedRev);\n              return rev;\n            },\n        ),\n    );\n  }\n\n}\n\nexport type ComponentNotifier<T extends object> = (\n    this: void,\n    context: ComponentContext<T>,\n    notifiedRev: number,\n) => number;\n","import { ContextValues, ContextValueSpec } from '@proc7ts/context-values';\nimport { mapOn_, onceOn, OnEvent, trackValue, translateOn, ValueTracker } from '@proc7ts/fun-events';\nimport { Class, valueProvider } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext, ComponentDef, ComponentElement, ComponentSlot } from '../../component';\nimport { DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DocumentRenderKit } from '../globals';\nimport { ComponentContextRegistry, PerComponentRegistry } from './component-context-registry.impl';\nimport { ComponentContext$Mounted } from './component-context.impl';\nimport { customElementType } from './custom-element.impl';\nimport { DefinitionContextRegistry, PerDefinitionRegistry } from './definition-context-registry.impl';\nimport { ComponentDefinitionClass, DefinitionContext__symbol } from './definition-context.symbol.impl';\nimport { ElementBuilder } from './element-builder.impl';\nimport { postDefSetup } from './post-def-setup.impl';\nimport { WhenComponent } from './when-component.impl';\n\n/**\n * @internal\n */\nexport class DefinitionContext$<T extends object> extends DefinitionContext<T> {\n\n  readonly whenReady: OnEvent<[this]>;\n  readonly get: ContextValues['get'];\n  private readonly _def: ComponentDef<T>;\n  readonly _whenComponent = new WhenComponent<T>();\n  private readonly _ready: ValueTracker<boolean>;\n  private readonly _whenReady: OnEvent<[]>;\n  private readonly _perComponentRegistry: ComponentContextRegistry;\n\n  constructor(\n      readonly _bsContext: BootstrapContext,\n      readonly _elementBuilder: ElementBuilder,\n      readonly componentType: ComponentDefinitionClass<T>,\n  ) {\n    super();\n    this._ready = trackValue(false);\n    this._whenReady = this._ready.read.do(translateOn((send, ready) => ready && send()));\n    this._def = ComponentDef.of(componentType);\n\n    const definitionContextRegistry = new DefinitionContextRegistry(_bsContext.get(PerDefinitionRegistry).seeds());\n\n    definitionContextRegistry.provide({ a: DefinitionContext, is: this });\n\n    this.get = definitionContextRegistry.newValues().get;\n\n    const parentPerComponentRegistry = _bsContext.get(PerComponentRegistry).append(seedKey => this.get(seedKey));\n    this._perComponentRegistry = new ComponentContextRegistry(parentPerComponentRegistry.seeds());\n\n    this.whenReady = this._whenReady.do(mapOn_(valueProvider(this)), onceOn);\n\n    const definitionSetup: DefinitionSetup<T> = {\n      get componentType() {\n        return componentType;\n      },\n      whenReady: this.whenReady,\n      whenComponent: this.whenComponent,\n      perDefinition: spec => definitionContextRegistry.provide(spec),\n      perComponent: spec => this._perComponentRegistry.provide(spec),\n    };\n\n    this._def.setup?.(definitionSetup);\n    postDefSetup(componentType).setup(definitionSetup);\n  }\n\n  get elementType(): Class {\n    return this._elementType();\n  }\n\n  get whenComponent(): OnEvent<[ComponentContext<T>]> {\n    return this._whenComponent.onCreated;\n  }\n\n  mountTo(element: ComponentElement<T>): ComponentContext<T> {\n\n    const context = new ComponentContext$Mounted(this, element);\n\n    ComponentSlot.of<T>(element).bind(context);\n    context._createComponent();\n\n    const drekContext = context.get(DocumentRenderKit).contextOf(element);\n\n    drekContext.whenSettled(_ => context.settle()).needs(context);\n    drekContext.whenConnected(_ => context._connect()).needs(context);\n    context._created();\n\n    return context;\n  }\n\n  perComponent<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<ComponentContext<T>, unknown, TSrc, TDeps>,\n  ): Supply {\n    return this._perComponentRegistry.provide(spec);\n  }\n\n  _newComponentRegistry(): ComponentContextRegistry {\n    return new ComponentContextRegistry(this._perComponentRegistry.seeds());\n  }\n\n  _elementType(): Class {\n    throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n  }\n\n  _define(): void {\n    this._def.define?.(this);\n    this._elementBuilder.definitions.send(this);\n    this._elementType = valueProvider(customElementType(this));\n    this.componentType[DefinitionContext__symbol] = this;\n    this._ready.it = true;\n  }\n\n}\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { EventEmitter } from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { DefinitionContext$ } from './definition-context.impl';\n\n/**\n * @internal\n */\nexport interface ElementBuilder {\n  readonly definitions: EventEmitter<[DefinitionContext]>;\n  readonly components: EventEmitter<[ComponentContext]>;\n  buildElement<T extends object>(this: void, componentType: ComponentClass<T>): DefinitionContext<T>;\n}\n\n/**\n * @internal\n */\nexport const ElementBuilder: SingleContextRef<ElementBuilder> = (/*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(newElementBuilder),\n    },\n));\n\nfunction newElementBuilder(bsContext: BootstrapContext): ElementBuilder {\n  return {\n    definitions: new EventEmitter<[DefinitionContext]>(),\n    components: new EventEmitter<[ComponentContext]>(),\n    buildElement<T extends object>(componentType: ComponentClass<T>) {\n\n      const definitionContext = new DefinitionContext$(bsContext, this, componentType);\n\n      definitionContext._define();\n\n      return definitionContext;\n    },\n  };\n\n}\n","import { ContextModule } from '@proc7ts/context-values/updatable';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { ElementBuilder } from '../../boot/impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { BootstrapWorkbench, componentDefStage } from './bootstrap-workbench.impl';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _components?: ComponentClass[] = undefined;\n\n  constructor(private readonly _setup: ContextModule.Setup) {\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    if (this._components) {\n      this._components.push(componentType);\n    } else {\n      this._components = [componentType];\n      this._defineAll(this._components);\n    }\n  }\n\n  private _defineAll(components: readonly ComponentClass[]): void {\n\n    const workbench = this._setup.get(BootstrapWorkbench);\n    const whenDefined = workbench.work(componentDefStage).run(() => {\n\n      const customElements = this._setup.get(CustomElements);\n      const elementBuilder = this._setup.get(ElementBuilder);\n\n      components.forEach(componentType => {\n\n        const defContext = elementBuilder.buildElement(componentType);\n\n        customElements.define(componentType, defContext.elementType);\n      });\n\n      this._components = undefined;\n    });\n\n    this._setup.initBy(valueProvider(whenDefined));\n  }\n\n}\n","import { ContextRegistry, ContextValueSpec } from '@proc7ts/context-values';\nimport { ContextModule } from '@proc7ts/context-values/updatable';\nimport { onceOn, OnEvent, supplyOn, valueOn_ } from '@proc7ts/fun-events';\nimport { Class } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { BootstrapContext } from '../../boot';\nimport {\n  BootstrapContextRegistry,\n  ElementBuilder,\n  onPostDefSetup,\n  PerComponentRegistry,\n  PerDefinitionRegistry,\n} from '../../boot/impl';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\n\n/**\n * @internal\n */\nexport class FeatureContext$ extends FeatureContext {\n\n  readonly whenReady: OnEvent<[FeatureContext]>;\n  private _onDefinition?: OnEvent<[DefinitionContext]>;\n  private _onComponent?: OnEvent<[ComponentContext]>;\n  readonly get: FeatureContext['get'];\n  private readonly _bsContext: BootstrapContext;\n  private readonly _componentRegistry: ComponentRegistry;\n\n  constructor(readonly feature: Class, private readonly _setup: ContextModule.Setup) {\n    super();\n\n    this._bsContext = _setup.get(BootstrapContext);\n\n    const handle = _setup.get(_setup.module);\n    const registry = new ContextRegistry<FeatureContext>(this._bsContext);\n\n    registry.provide({ a: FeatureContext, is: this });\n    this.get = registry.newValues().get;\n\n    this.whenReady = handle.read.do(\n        valueOn_(({ ready }) => ready && this),\n        onceOn,\n    );\n\n    this._componentRegistry = new ComponentRegistry(this._setup);\n  }\n\n  get supply(): Supply {\n    return this._setup.supply;\n  }\n\n  get onDefinition(): OnEvent<[DefinitionContext]> {\n    return this._onDefinition\n        || (this._onDefinition = this._setup.get(ElementBuilder).definitions.on.do(supplyOn(this)));\n  }\n\n  get onComponent(): OnEvent<[ComponentContext]> {\n    return this._onComponent\n        || (this._onComponent = this._setup.get(ElementBuilder).components.on.do(supplyOn(this)));\n  }\n\n  provide<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<BootstrapContext, unknown, TSrc, TDeps>,\n  ): Supply {\n    return this._bsContext.get(BootstrapContextRegistry).provide(spec).needs(this);\n  }\n\n  perDefinition<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<DefinitionContext, unknown, TSrc, TDeps>,\n  ): Supply {\n    return this._bsContext.get(PerDefinitionRegistry).provide(spec).needs(this);\n  }\n\n  perComponent<TSrc, TDeps extends any[]>(\n      spec: ContextValueSpec<ComponentContext, unknown, TSrc, TDeps>,\n  ): Supply {\n    return this._bsContext.get(PerComponentRegistry).provide(spec).needs(this);\n  }\n\n  setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]> {\n    return onPostDefSetup(componentType, this.supply);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._componentRegistry.define(componentType);\n  }\n\n}\n","import { ContextModule } from '@proc7ts/context-values/updatable';\nimport { Class, hasOwnProperty, setOfElements, valueProvider } from '@proc7ts/primitives';\nimport { ComponentDef, ComponentDef__symbol } from '../../component';\nimport { FeatureDef } from '../feature-def';\nimport { BootstrapWorkbench, featureInitStage, featureSetupStage } from './bootstrap-workbench.impl';\nimport { FeatureContext$ } from './feature-context.impl';\n\nconst FeatureModule__symbol = (/*#__PURE__*/ Symbol('FeatureModule'));\n\ninterface FeatureClass extends Class {\n\n  [FeatureModule__symbol]?: FeatureModule;\n\n}\n\n/**\n * @internal\n */\nexport class FeatureModule extends ContextModule {\n\n  static of(feature: FeatureClass): FeatureModule {\n    if (hasOwnProperty(feature, FeatureModule__symbol)) {\n      return feature[FeatureModule__symbol]!;\n    }\n    return feature[FeatureModule__symbol] = new FeatureModule(feature);\n  }\n\n  private constructor(readonly feature: Class) {\n    super(feature.name, FeatureModule$options(feature));\n  }\n\n  async setup(setup: ContextModule.Setup): Promise<void> {\n\n    const workbench = setup.get(BootstrapWorkbench);\n\n    await workbench.work(featureSetupStage).run(() => super.setup(setup));\n  }\n\n}\n\nfunction FeatureModule$options(feature: Class): ContextModule.Options {\n\n  const def = featureDef(feature);\n  const has: FeatureModule[] = [];\n  const needs: FeatureModule[] = [];\n\n  for (const replaced of setOfElements(def.has)) {\n    has.push(FeatureModule.of(replaced));\n  }\n  for (const required of setOfElements(def.needs)) {\n    needs.push(FeatureModule.of(required));\n  }\n\n  return {\n    needs,\n    has,\n    async setup(setup) {\n\n      const workbench = setup.get(BootstrapWorkbench);\n      const featureContext = new FeatureContext$(feature, setup);\n\n      if (def.init) {\n\n        const whenInit = workbench.work(featureInitStage).run(async () => {\n          await def.init!(featureContext);\n        });\n\n        setup.initBy(valueProvider(whenInit));\n      }\n\n      await def.setup?.(featureContext);\n    },\n  };\n}\n\nfunction featureDef(featureType: Class): FeatureDef {\n\n  let def = FeatureDef.of(featureType);\n\n  if (ComponentDef__symbol in featureType) {\n    def = FeatureDef.merge(\n        def,\n        {\n          init(context) {\n            context.define(featureType);\n          },\n        },\n    );\n\n    const { feature } = ComponentDef.of(featureType);\n\n    if (feature) {\n      def = FeatureDef.merge(def, feature);\n    }\n\n  }\n\n  return def;\n}\n","import { OnEvent, onPromise } from '@proc7ts/fun-events';\nimport { hasOwnProperty } from '@proc7ts/primitives';\nimport { ComponentClass, CustomElements, DefinitionContext } from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { definitionContextOf } from './definition-context.symbol.impl';\n\n/**\n * @internal\n */\nexport const WhenDefined__symbol = (/*#__PURE__*/ Symbol('WhenDefined'));\n\ninterface WhenDefinedComponentClass<T extends object> extends ComponentClass<T> {\n  [WhenDefined__symbol]?: OnEvent<[DefinitionContext<T>]>;\n}\n\n/**\n * @internal\n */\nexport function whenDefined<T extends object>(\n    bsContext: BootstrapContext,\n    componentType: WhenDefinedComponentClass<T>,\n): OnEvent<[DefinitionContext<T>]> {\n  if (hasOwnProperty(componentType, WhenDefined__symbol)) {\n    return componentType[WhenDefined__symbol] as OnEvent<[DefinitionContext<T>]>;\n  }\n\n  const result: OnEvent<[DefinitionContext<T>]> = onPromise(\n      Promise.resolve(bsContext.whenReady)\n          .then(() => bsContext.get(CustomElements).whenDefined(componentType))\n          .then(() => definitionContextOf(componentType)),\n  );\n\n  return componentType[WhenDefined__symbol] = result;\n}\n","/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nexport const AttributePath__root = (/*#__PURE__*/ Symbol('attribute'));\n\n/**\n * A path to the named attribute state.\n *\n * @category Feature\n */\nexport type AttributePath = readonly [keyof AttributePath.RootKeys, string];\n\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name - Target attribute name.\n *\n * @return Attribute state path.\n */\nexport function attributePathTo(name: string): AttributePath {\n  return [AttributePath__root, name];\n}\n\n/**\n * @category Feature\n */\nexport namespace AttributePath {\n  export interface RootKeys {\n    [AttributePath__root]: true;\n  }\n}\n","import { StatePath } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ComponentContext } from '../../component';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeChangedCallback } from './attribute-descriptor';\nimport { attributePathTo } from './attribute-path';\n\n/**\n * @internal\n */\nexport function attributeStateUpdate<T extends object>(\n    name: string,\n    updateState: boolean | AttributeUpdateReceiver<T> | StatePath = true,\n): AttributeChangedCallback<T> {\n  if (updateState === false) {\n    return noop;\n  }\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = attributePathTo(name);\n    const update: AttributeUpdateReceiver<T> = updateState === true ? updateAttributeState : updateState;\n\n    return (component: T, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component: T, newValue, oldValue) => updateAttributeState(\n      component,\n      updateState,\n      newValue,\n      oldValue,\n  );\n}\n\nfunction updateAttributeState<T extends object>(\n    component: T,\n    path: StatePath,\n    newValue: string | null,\n    oldValue: string | null,\n): void {\n  ComponentContext.of(component).updateState(path, newValue, oldValue);\n}\n","import { CustomHTMLElementClass } from '@frontmeans/dom-primitives';\nimport { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { mergeFunctions } from '@proc7ts/primitives';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { ComponentContext, ComponentElement, ComponentSlot } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\n\n/**\n * A registry of component's element attributes.\n *\n * @category Feature\n */\nexport interface AttributeRegistry {\n\n  /**\n   * Declares component element's attribute.\n   *\n   * @param descriptor - Attribute descriptor.\n   */\n  declareAttribute(descriptor: AttributeDescriptor): void;\n\n}\n\n/**\n * A key of component definition context value containing {@link AttributeRegistry attribute registry}.\n *\n * @category Feature\n */\nexport const AttributeRegistry: ContextRef<AttributeRegistry> = (\n    /*#__PURE__*/ new SingleContextKey<AttributeRegistry>(\n        'attribute-registry',\n        {\n          byDefault(context) {\n            return new AttributeRegistry$(context.get(DefinitionContext));\n          },\n        },\n    )\n);\n\n/**\n * @internal\n */\nclass AttributeRegistry$ implements AttributeRegistry {\n\n  private readonly attrs = new Map<string, AttributeChangedCallback<any>>();\n\n  constructor(private readonly _context: DefinitionContext) {\n    _context.whenReady(({ elementType }) => this.define(elementType as CustomHTMLElementClass));\n    _context.whenComponent(context => {\n      if (context.mounted) {\n        // Mount element attributes\n        this.mount(context);\n      }\n    });\n  }\n\n  declareAttribute({ name, change }: AttributeDescriptor): void {\n    this.attrs.set(name, mergeFunctions(this.attrs.get(name), change));\n  }\n\n  private define(elementType: CustomHTMLElementClass): void {\n\n    const { attrs } = this;\n\n    if (!attrs.size) {\n      return; // No attributes defined\n    }\n\n    Reflect.defineProperty(elementType, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      value: observedAttributes(elementType, [...attrs.keys()]),\n    });\n    Reflect.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n      configurable: true,\n      enumerable: true,\n      value: attributeChangedCallback(elementType, attrs),\n    });\n  }\n\n  private mount(context: ComponentContext): void {\n\n    const { element } = context as { element: ComponentElement };\n    const { attrs } = this;\n    const attributeFilter = [...attrs.keys()];\n\n    if (!attributeFilter.length) {\n      return; // No attributes defined\n    }\n\n    const MutationObserver = this._context.get(BootstrapWindow).MutationObserver;\n    const observer = new MutationObserver(\n        records => records.forEach(\n            record => {\n\n              const attributeName = record.attributeName as string;\n\n              return attrs.get(attributeName)!(\n                  context.component,\n                  element.getAttribute(attributeName),\n                  record.oldValue,\n              );\n            },\n        ),\n    );\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter,\n      attributeOldValue: true,\n    });\n  }\n\n}\n\n/**\n * @internal\n */\ntype ElementAttributeChanged = (\n    this: any,\n    name: string,\n    oldValue: string | null,\n    newValue: string | null,\n) => void;\n\n/**\n * @internal\n */\nfunction observedAttributes(\n    elementType: CustomHTMLElementClass,\n    attrs: readonly string[],\n): readonly string[] {\n\n  const alreadyObserved = elementType.observedAttributes;\n\n  if (Array.isArray(alreadyObserved)) {\n\n    const newAttrs = new Set<string>(alreadyObserved);\n\n    attrs.forEach(attr => newAttrs.add(attr));\n\n    attrs = [...newAttrs];\n  }\n\n  return attrs;\n}\n\n/**\n * @internal\n */\nfunction attributeChangedCallback<T extends object>(\n    elementType: CustomHTMLElementClass,\n    attrs: Map<string, AttributeChangedCallback<T>>,\n): ElementAttributeChanged {\n\n  const prevCallback = elementType.prototype.attributeChangedCallback;\n\n  if (!prevCallback) {\n    return function (this: ComponentElement<T>, name, oldValue, newValue) {\n      ComponentSlot.of(this).whenReady(({ component }) => {\n        attrs.get(name)!(component, newValue, oldValue);\n      });\n    };\n  }\n\n  return function (this: ComponentElement<T>, name, oldValue, newValue) {\n\n    const attrChanged = attrs.get(name);\n\n    if (attrChanged) {\n      ComponentSlot.of(this).whenReady(({ component }) => attrChanged(component, newValue, oldValue));\n    } else {\n      prevCallback.call(this, name, oldValue, newValue);\n    }\n  };\n}\n","import {\n  AeComponentMember,\n  AeComponentMemberTarget,\n  ComponentContext,\n  ComponentMember,\n  ComponentMemberAmendment,\n} from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributeRegistry } from './attribute-registry';\n\n/**\n * Creates an amendment (and decorator) of component property that accesses custom element's attribute.\n *\n * The amended property accesses corresponding attribute on read, and updates it on setting. `null` value corresponds\n * to absent attribute. Setting to `null` or `undefined` removes corresponding attribute.\n *\n * @category Feature\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Attribute definition or just an attribute name (either _camelCase_ or _dash-style_).\n *\n * @return New component property amendment.\n */\nexport function Attribute<\n    TClass extends ComponentClass,\n    TAmended extends AeComponentMember<string | null | undefined, TClass> =\n        AeComponentMember<string | null | undefined, TClass>>(\n    def?: AttributeDef<InstanceType<TClass>> | string,\n): ComponentMemberAmendment<string | null | undefined, TClass, string | null | undefined, TAmended> {\n  return ComponentMember<\n      string | null | undefined,\n      TClass,\n      string | null | undefined,\n      TAmended>((\n      {\n        amendedClass,\n        key,\n        set: setValue,\n        amend,\n      }: AeComponentMemberTarget<string | null | undefined, TClass>,\n  ) => {\n\n    const { name, change } = parseAttributeDescriptor(amendedClass.prototype, key, def);\n\n    amend({\n      componentDef: {\n        define(defContext) {\n          defContext.get(AttributeRegistry).declareAttribute({\n            name,\n            change(component, newValue, oldValue) {\n              setValue(component, newValue);\n              change(component, newValue, oldValue);\n            },\n          });\n        },\n      },\n      get(component: InstanceType<TClass>): string | null {\n        return (ComponentContext.of(component).element as Element).getAttribute(name);\n      },\n      set(component: InstanceType<TClass>, newValue: string | null) {\n\n        const { element } = ComponentContext.of(component) as { element: Element };\n\n        if (newValue != null) {\n          element.setAttribute(name, newValue);\n        } else {\n          element.removeAttribute(name);\n        }\n\n        setValue(component, newValue);\n      },\n    });\n  });\n}\n","import { hyphenateDecapName } from '@frontmeans/httongue';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\n\n/**\n * @internal\n */\nexport function parseAttributeDescriptor<T extends object>(\n    target: T,\n    propertyKey: string | symbol,\n    def?: AttributeDef<T> | string,\n): AttributeDescriptor<T> {\n\n  let name: string;\n  let change: AttributeChangedCallback<T>;\n\n  if (typeof def === 'string') {\n    name = hyphenateDecapName(def);\n    change = attributeStateUpdate(name);\n  } else {\n    if (def && def.name) {\n      name = hyphenateDecapName(def.name);\n    } else if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n          'Attribute name is required as property key is not a string: '\n          + `${target.constructor.name}.prototype.${String(propertyKey)}`,\n      );\n    } else {\n      name = hyphenateDecapName(propertyKey);\n    }\n\n    change = attributeStateUpdate(name, def && def.updateState);\n  }\n\n  return { name, change };\n}\n","import { ContextKey, ContextKey__symbol, ContextValueSlot, SimpleContextKey } from '@proc7ts/context-values';\nimport { StateTracker } from '@proc7ts/fun-events';\nimport { ComponentContext, StateUpdater } from '../../component';\n\nclass ComponentStateKey extends SimpleContextKey<ComponentState> {\n\n  constructor() {\n    super('component-state');\n  }\n\n  grow(\n      slot: ContextValueSlot<ComponentState, ComponentState, SimpleContextKey.Seed<ComponentState>>,\n  ): void {\n\n    const provided = slot.seed();\n    let state: ComponentState;\n\n    if (provided != null) {\n      state = provided;\n      slot.insert(state);\n    } else if (slot.hasFallback) {\n      return;\n    } else {\n      state = new ComponentState();\n      slot.context.get(ComponentContext).supply.whenOff(reason => state.done(reason));\n      slot.insert(state);\n    }\n\n    slot.setup(({ registry }) => {\n      registry.provide({ a: StateUpdater, is: state.update });\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nconst ComponentState__key = (/*#__PURE__*/ new ComponentStateKey());\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","import { OnEvent, StatePath, supplyOn, translateOn, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { attributePathTo } from './attribute-path';\n\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly on: OnEvent<[string | null, string | null]>;\n  readonly supply = new Supply();\n\n  constructor(\n      private readonly _context: ComponentContext,\n      private readonly _name: string,\n      path: StatePath,\n  ) {\n    super();\n    this.on = this._context.get(ComponentState).track(path).onUpdate.do(\n        translateOn((send, _path, newValue, oldValue) => send(newValue, oldValue)),\n        supplyOn(this),\n    );\n  }\n\n  get it(): string | null {\n    return (this._context.element as Element).getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (!this.supply.isOff) {\n      if (value == null) {\n        (this._context.element as Element).removeAttribute(this._name);\n      } else {\n        (this._context.element as Element).setAttribute(this._name, value);\n      }\n    }\n  }\n\n}\n\n/**\n * Creates a tracker of custom element's attribute value.\n *\n * Requires attribute to be defined. E.g. with {@link Attribute @Attribute}, {@link AttributeChanged @AttributeChanged},\n * or {@link Attributes @Attributes} decorator.\n *\n * @category Feature\n * @param context - Target component context.\n * @param name - Attribute name.\n * @param path - Custom attribute state path.\n *\n * @returns New attribute value tracker.\n */\nexport function trackAttribute(\n    context: ComponentContext,\n    name: string,\n    path: StatePath = attributePathTo(name),\n): ValueTracker<string | null> {\n  return new AttributeTracker(context, name, path);\n}\n","import {\n  EventSender,\n  isEventSender,\n  OnEvent,\n  onSupplied,\n  StatePath,\n  supplyOn,\n  translateOn_,\n} from '@proc7ts/fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { ComponentPreRendererExecution } from './component-pre-renderer-execution';\nimport { ComponentRendererExecution } from './component-renderer-execution';\n\n/**\n * Component rendering definition.\n *\n * This is either a {@link RenderDef.Spec rendering specifier}, or its {@link RenderDef.Provider provider function}.\n *\n * @category Feature\n */\nexport type RenderDef =\n    | RenderDef.Spec\n    | RenderDef.Provider;\n\n/**\n * @category Feature\n */\nexport namespace RenderDef {\n\n  /**\n   * Component render method signature.\n   */\n  export type Method =\n  /**\n   * @param execution - Component renderer execution context.\n   */\n      (execution: ComponentRendererExecution) => void;\n\n  /**\n   * Component pre-render method signature.\n   */\n  export type PreMethod =\n  /**\n   * @param execution - Component pre-renderer execution context.\n   */\n      (execution: ComponentPreRendererExecution) => void;\n\n  /**\n   * Rendering options.\n   */\n  export interface Options {\n\n    /**\n     * When to start the rendering.\n     *\n     * One of:\n     * - `settled` (the default) - start rendering when component is {@link ComponentContext.settled settled}.\n     * - `connected` - start rendering when component's element is {@link ComponentContext.connected connected}\n     *   to document.\n     */\n    readonly when?: 'settled' | 'connected';\n\n    /**\n     * Reports rendering error. E.g. a render shot execution failure.\n     *\n     * @param messages - Error messages to report.\n     */\n    error?(this: void, ...messages: any[]): void;\n\n  }\n\n  /**\n   * Component rendering specifier.\n   */\n  export interface Spec extends Options {\n\n    /**\n     * A trigger that issues rendering.\n     *\n     * This can be useful e.g. when component has multiple independent sub-views.\n     *\n     * This can be one of the following:\n     * - A path to component state part the renderer should track. The rendering would trigger only when the target\n     *   state part is updated.\n     * - Arbitrary event sender. The rendering would be triggered on any event from this sender.\n     *\n     * A root state path is tracked when omitted.\n     *\n     * When trigger is a root path (the default value), then the rendering will be triggered by any state update.\n     * Except for updates of sub-states inside {@link RenderPath__root}.\n     */\n    readonly on?: StatePath | EventSender<[]>;\n\n  }\n\n  /**\n   * Component rendering provider signature.\n   *\n   * @typeParam TSpec - Provided rendering specifier type.\n   */\n  export type Provider<TSpec extends Spec = Spec> =\n  /**\n   * @param context - A context of component to render.\n   *\n   * @returns Rendering specifier.\n   */\n      (\n          this: void,\n          context: ComponentContext,\n      ) => TSpec;\n\n}\n\n/**\n * A root path to sub-states updates to which will be ignored by default.\n *\n * This can be used to create sub-states that won't trigger rendering occasionally, but only when requested explicitly.\n *\n * @category Feature\n */\nexport const RenderPath__root = (/*#__PURE__*/ Symbol('render'));\n\n/**\n * @category Feature\n */\nexport const RenderDef = {\n\n  /**\n   * Builds a trigger issuing rendering updates.\n   *\n   * @param context - Rendered component context.\n   * @param spec - Rendering specifier.\n   *\n   * @returns `OnEvent` sender that sends an event each time the rendering required.\n   */\n  trigger(\n      this: void,\n      context: ComponentContext,\n      spec: RenderDef.Spec = {},\n  ): OnEvent<[]> {\n\n    const { on = [] } = spec;\n\n    if ((typeof on === 'object' || typeof on === 'function') && isEventSender(on)) {\n      return onSupplied(on).do(supplyOn(context));\n    }\n\n    const trigger = context\n        .get(ComponentState)\n        .track(on)\n        .onUpdate.do(\n            supplyOn(context),\n        );\n\n    if (Array.isArray(on) && !on.length) {\n      return trigger.do(translateOn_(\n          (send, path: StatePath.Normalized) => path[0] !== RenderPath__root && send(),\n      ));\n    }\n\n    return trigger;\n  },\n\n};\n","import { drekBuild } from '@frontmeans/drek';\nimport { RenderExecution, RenderSchedule, RenderScheduler, RenderShot } from '@frontmeans/render-scheduler';\nimport { noop, valueByRecipe } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { DefaultPreRenderScheduler, DocumentRenderKit } from '../../boot/globals';\nimport { ComponentContext } from '../../component';\nimport { ComponentPreRenderer } from './component-pre-renderer';\nimport { ComponentPreRendererExecution } from './component-pre-renderer-execution';\nimport { ComponentRenderCtl } from './component-render-ctl';\nimport { ComponentRenderer } from './component-renderer';\nimport { ComponentRendererExecution } from './component-renderer-execution';\nimport { RenderDef } from './render-def';\n\n/**\n * @internal\n */\nexport class ComponentRenderCtl$ implements ComponentRenderCtl {\n\n  readonly _scheduler: RenderScheduler;\n\n  constructor(readonly _context: ComponentContext) {\n\n    const { element }: { element: Element } = _context;\n\n    this._scheduler = _context.get(DocumentRenderKit).contextOf(element).scheduler;\n  }\n\n  renderBy(renderer: ComponentRenderer, def?: RenderDef): Supply {\n    return new ComponentRenderer$State(this, renderer, def).render();\n  }\n\n  preRenderBy(preRenderer: ComponentPreRenderer, def?: RenderDef): Supply {\n    return new ComponentPreRenderer$State(this, preRenderer, def).render();\n  }\n\n}\n\nconst enum RenderStatus {\n  Cancelled = -1,\n  Complete = 0,\n  Pending = 1,\n  Scheduled = 2,\n}\n\nabstract class ComponentRenderer$BaseState<TExecution extends RenderExecution> {\n\n  protected _supply!: Supply;\n  private _status: RenderStatus = RenderStatus.Pending;\n  protected _spec: RenderDef.Spec;\n\n  constructor(\n      protected readonly _ctl: ComponentRenderCtl$,\n      protected _renderer: RenderShot<TExecution>,\n      def: RenderDef = {},\n  ) {\n    this._spec = valueByRecipe(def, _ctl._context);\n  }\n\n  render(): Supply {\n\n    const context = this._ctl._context;\n    const trigger = RenderDef.trigger(context, this._spec);\n    let schedule: RenderSchedule = shot => {\n      schedule = this._createSchedule();\n      schedule(shot);\n    };\n    const whenConnected = this._spec.when === 'connected';\n    const startRendering = (): 0 | void => this._status /* there is an update to render */\n        && this._scheduleRenderer(schedule);\n    const onUpdate = whenConnected\n        ? () => context.connected && this._scheduleRenderer(schedule)\n        : () => context.settled && this._scheduleRenderer(schedule);\n    this._supply = trigger(onUpdate)\n        .needs(context)\n        .whenOff(() => this._cancel(schedule));\n\n    (whenConnected ? context.whenConnected : context.whenSettled)(startRendering);\n\n    return this._supply;\n  }\n\n  private _scheduleRenderer(schedule: RenderSchedule): void {\n    this._status = RenderStatus.Scheduled;\n    schedule(execution => this._render(execution));\n  }\n\n  protected _createSchedule(): RenderSchedule {\n    return this._scheduleBy(this._ctl._scheduler);\n  }\n\n  protected _scheduleBy(scheduler: RenderScheduler): RenderSchedule {\n\n    const node: Element = this._ctl._context.element;\n    const schedule = scheduler({ ...this._spec, node });\n\n    return shot => schedule(execution => drekBuild(() => shot(execution)));\n  }\n\n  private _render(execution: RenderExecution): void {\n\n    const rendererExecution = this._createExecution(execution);\n\n    this._status = RenderStatus.Complete;\n    do {\n\n      const currentRenderer = this._renderer;\n\n      currentRenderer(rendererExecution);\n      if (this._renderer === currentRenderer) {\n        this._over();\n        break; // The renderer is not updated. Current renderer execution is over.\n      }\n    } while (this._status >= 0); // The rendering could be cancelled by the renderer itself.\n  }\n\n  protected _over(): void {\n    // Renderer execution is over.\n  }\n\n  private _cancel(schedule: RenderSchedule): void {\n    if (this._status === RenderStatus.Scheduled) { // Scheduled, but not rendered yet.\n      schedule(noop);\n    }\n    this._status = RenderStatus.Cancelled;\n  }\n\n  protected abstract _createExecution(execution: RenderExecution): TExecution;\n\n}\n\nclass ComponentRenderer$State extends ComponentRenderer$BaseState<ComponentRendererExecution> {\n\n  protected _createExecution(execution: RenderExecution): ComponentRendererExecution {\n\n    const rendererExecution: ComponentRendererExecution = {\n      ...execution,\n      postpone(postponed) {\n        execution.postpone(() => postponed(rendererExecution));\n      },\n      supply: this._supply,\n      renderBy: (renderer: ComponentRenderer) => {\n        this._renderer = renderer;\n      },\n    };\n\n    return rendererExecution;\n  }\n\n}\n\nconst ComponentPreRenderer$done = {};\n\nclass ComponentPreRenderer$State extends ComponentRenderer$BaseState<ComponentPreRendererExecution> {\n\n  private _nextRenderer: ComponentRenderer | null = null;\n  private _preSupply!: Supply;\n\n  render(): Supply {\n    this._preSupply = new Supply();\n\n    super.render().needs(this._preSupply).whenOff(reason => {\n      if (reason === ComponentPreRenderer$done) {\n        // Pre-rendering is over.\n        // Delegate to component renderer.\n        this._preSupply.as(this._ctl.renderBy(this._nextRenderer!));\n      } else {\n        // Pre-rendering aborted.\n        this._preSupply.off(reason);\n      }\n    });\n\n    return this._preSupply;\n  }\n\n  protected _createSchedule(): RenderSchedule {\n\n    const preScheduler = this._ctl._context.get(DefaultPreRenderScheduler);\n\n    return this._scheduleBy(preScheduler);\n  }\n\n  protected _over(): void {\n    if (this._nextRenderer) {\n      // Signal the pre-rendering is over.\n      this._supply.off(ComponentPreRenderer$done);\n    }\n  }\n\n  protected _createExecution(execution: RenderExecution): ComponentPreRendererExecution {\n\n    const preRendererExecution: ComponentPreRendererExecution = {\n      ...execution,\n      postpone: postponed => {\n        execution.postpone(() => {\n          postponed(preRendererExecution);\n          this._over();\n        });\n      },\n      supply: this._preSupply,\n      renderBy: (renderer: ComponentRenderer) => {\n        this._renderer = renderer;\n        this._nextRenderer = renderer;\n      },\n      preRenderBy: (preRenderer: ComponentPreRenderer) => {\n        this._renderer = preRenderer;\n      },\n    };\n\n    return preRendererExecution;\n  }\n\n}\n","import { ContextRef, SingleContextKey } from '@proc7ts/context-values';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext } from '../../component';\nimport { ComponentPreRenderer } from './component-pre-renderer';\nimport { ComponentRenderCtl$ } from './component-render-ctl.impl';\nimport { ComponentRenderer } from './component-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A render control of component.\n *\n * Controls rendering by {@link ComponentRenderer component renderers}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport interface ComponentRenderCtl {\n\n  /**\n   * Enables component rendering by the given `renderer`.\n   *\n   * A `renderer` call will be scheduled by {@link DocumentRenderKit document render kit} once component state updated.\n   *\n   * The unrooted rendering contexts created during the renderer execution are lifted when execution completes.\n   *\n   * @param renderer - Component renderer function.\n   * @param def - Optional component rendering definition.\n   *\n   * @returns Renderer supply. The rendering would stop once this supply is cut off.\n   */\n  renderBy(renderer: ComponentRenderer, def?: RenderDef): Supply;\n\n  /**\n   * Enables component pre-rendering by the given pre-renderer.\n   *\n   * A pre-renderer call will be scheduled by {@link DefaultPreRenderScheduler default pre-render scheduler} once\n   * component state updated.\n   *\n   * The unrooted rendering contexts created during the pre-renderer execution are lifted when execution completes.\n   *\n   * @param preRenderer - Component pre-renderer function.\n   * @param def - Optional component pre-rendering definition.\n   *\n   * @returns Pre-renderer supply. Pre-rendering would stop once this supply is cut off.\n   */\n  preRenderBy(preRenderer: ComponentPreRenderer, def?: RenderDef): Supply;\n\n}\n\n/**\n * A key of component context value containing {@link ComponentRenderCtl component render control}.\n *\n * @category Feature\n */\nexport const ComponentRenderCtl: ContextRef<ComponentRenderCtl> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentRenderCtl>(\n        'component-render-ctl',\n        {\n          byDefault(values) {\n\n            const context = values.get(ComponentContext);\n\n            return new ComponentRenderCtl$(context);\n          },\n        },\n    )\n);\n","import { RenderSchedule, RenderScheduleOptions, RenderShot } from '@frontmeans/render-scheduler';\nimport { ContextRef, ContextValues, SingleContextKey } from '@proc7ts/context-values';\nimport { trackValue } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { ComponentRenderCtl } from './component-render-ctl';\nimport { ComponentRenderer } from './component-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * A signature of component render scheduler.\n *\n * Schedules render shots to be executed by {@link ComponentRenderCtl component render control}.\n *\n * Available in component context.\n *\n * @category Feature\n */\nexport type ComponentRenderScheduler =\n/**\n * @param options - Options of constructed component render schedule.\n *\n * @returns New render schedule.\n */\n    (this: void, options?: ComponentRenderScheduleOptions) => RenderSchedule;\n\n/**\n * Options for render schedule.\n *\n * This is passed to {@link ComponentRenderScheduler component render scheduler} when constructing new render schedule.\n *\n * Generic `RenderSchedule` options are ignored.\n *\n * @category Feature\n */\nexport interface ComponentRenderScheduleOptions extends RenderScheduleOptions, RenderDef.Options {\n\n  /**\n   * When to start the rendering.\n   *\n   * One of:\n   * - `settled` - start rendering when component is {@link ComponentContext.settled settled}.\n   * - `connected` (the default) - start rendering when component's element is {@link ComponentContext.connected\n   *   connected} to document.\n   */\n  readonly when?: 'settled' | 'connected';\n\n  /**\n   * Reports rendering error. E.g. a render shot execution failure.\n   *\n   * @param messages - Error messages to report.\n   */\n  error?(...messages: any[]): void;\n\n}\n\n/**\n * @internal\n */\nfunction ComponentRenderScheduler$create(context: ContextValues): ComponentRenderScheduler {\n\n  const renderCtl = context.get(ComponentRenderCtl);\n\n  return (opts = {}): RenderSchedule => {\n\n    const recentShot = trackValue<RenderShot>(noop);\n    const renderer: ComponentRenderer = execution => {\n      recentShot.it(execution);\n    };\n\n    renderCtl.renderBy(renderer, { ...opts, on: recentShot.on });\n\n    return (shot: RenderShot): void => {\n      recentShot.it = execution => shot(execution); // Ensure render shot always updated\n    };\n  };\n}\n\n/**\n * A key of component context value containing {@link ComponentRenderScheduler component render scheduler}.\n *\n * @category Feature\n */\nexport const ComponentRenderScheduler: ContextRef<ComponentRenderScheduler> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentRenderScheduler>(\n        'component-render-scheduler',\n        {\n          byDefault: ComponentRenderScheduler$create,\n        },\n    )\n);\n","import { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\n\n/**\n * Component shadow content root.\n *\n * @category Feature\n */\nexport type ShadowContentRoot = ShadowRoot;\n\n/**\n * A key of component context value containing a shadow content root instance.\n *\n * This is only available when the component is decorated with {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Feature\n */\nexport const ShadowContentRoot: SingleContextRef<ShadowContentRoot> = (\n    /*#__PURE__*/ new SingleContextKey<ShadowContentRoot>('shadow-content-root')\n);\n","import { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { ComponentContext } from '../../component';\nimport { ShadowContentDef } from './attach-shadow.amendment';\n\n/**\n * Shadow root builder function type.\n *\n * An instance of this function is available in component context and is used by {@link AttachShadow @AttachShadow}\n * decorator to attach shadow root to decorated component's custom element.\n *\n * By default, if shadow root already exists for the component's element, it uses one.\n *\n * Dispatches a `wesib:shadowAttached` event for the found or attached shadow root.\n *\n * @category Feature\n */\nexport type ShadowRootBuilder =\n/**\n * @param context - Target component context.\n * @param init - Shadow root initialization options.\n *\n * @returns A shadow root instance for target component, or `null`/`undefined` if one can not be attached.\n */\n    (context: ComponentContext, init: ShadowContentDef) => ShadowRoot | null | undefined;\n\n/**\n * A key of component context value containing a shadow root builder instance.\n *\n * @category Feature\n */\nexport const ShadowRootBuilder: FnContextRef<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>>(\n        'shadow-root-builder',\n        {\n          byDefault() {\n            return attachShadow;\n          },\n        },\n    )\n);\n\nfunction attachShadow(context: ComponentContext, init: ShadowRootInit): ShadowRoot | undefined {\n  return shadowRootOf(context.element as Element, init);\n}\n\nfunction shadowRootOf(element: Element, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const existing = element.shadowRoot;\n\n  if (existing) {\n    // Shadow root already attached. Using it.\n    return existing;\n  }\n  if ('attachShadow' in element) {\n    return element.attachShadow(init);\n  }\n\n  return; // Unable to attach shadow root.\n}\n\n","import { Class } from '@proc7ts/primitives';\nimport { AeComponent, Component, ComponentAmendment, ComponentContext, ContentRoot } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ShadowContentRoot } from './shadow-content-root';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * @internal\n */\nconst defaultShadowContentDef: ShadowContentDef = { mode: 'open' };\n\n/**\n * Shadow content root definition.\n *\n * This is a readonly component shadow root initialization options.\n *\n * @category Feature\n */\nexport type ShadowContentDef = Readonly<ShadowRootInit>;\n\n/**\n * Creates a component amendment (and decorator) that attaches shadow root to decorated component instance.\n *\n * @category Feature\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component entity type.\n * @param def - Shadow content root definition. Uses `mode: 'open'` by default.\n *\n * @returns New component amendment and decorator.\n */\nexport function AttachShadow<\n    TClass extends ComponentClass = Class,\n    TAmended extends AeComponent<TClass> = AeComponent<TClass>>(\n    def: ShadowContentDef = defaultShadowContentDef,\n): ComponentAmendment<TClass, TAmended> {\n  return Component({\n    setup(setup) {\n      setup.perComponent(\n          {\n            a: ShadowContentRoot,\n            by(ctx: ComponentContext<InstanceType<TClass>>) {\n              return ctx.get(ShadowRootBuilder)(ctx, def);\n            },\n          },\n      );\n      setup.perComponent({ // Content root is an alias of shadow root when present.\n        a: ContentRoot,\n        by(context: ComponentContext<InstanceType<TClass>>) {\n          return context.get(ShadowContentRoot, { or: null });\n        },\n      });\n    },\n  });\n}\n","import { NamespaceDef } from '@frontmeans/namespace-aliaser';\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nexport const Wesib__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns',\n    'b',\n    'wesib',\n));\n","import type { ReadonlyDeltaSet } from './readonly-delta-set';\n\n/**\n * A `Set` implementation that keeps a delta of changes made to it.\n *\n * @typeParam T - A type of elements of delta set.\n */\nexport class DeltaSet<T> extends Set<T> implements ReadonlyDeltaSet<T> {\n\n  /** @internal */\n  private readonly _added: Set<T>;\n\n  /** @internal */\n  private readonly _removed: Set<T>;\n\n  /**\n   * Constructs new delta set.\n   *\n   * @param values - An iterable of elements be add to constructed delta set. Or `null` to add nothing.\n   */\n  constructor(values?: Iterable<T> | null) {\n    super();\n    this._added = new Set<T>(values);\n    this._removed = new Set<T>();\n    this._added.forEach(value => this.add(value));\n  }\n\n  /**\n   * Appends a new element with a specified value to the end of this delta set. Unless the set contains this element\n   * already.\n   *\n   * Records element addition and forgets its removal unless the set contains it already.\n   *\n   * @param value - The value of the element to add.\n   *\n   * @returns `this` delta set.\n   */\n  add(value: T): this {\n    if (!this.has(value)) {\n      this._added.add(value);\n      this._removed.delete(value);\n      super.add(value);\n    }\n    return this;\n  }\n\n  /**\n   * Removes the specified element from this delta set.\n   *\n   * Records element removal and forgets its addition if removal succeed.\n   *\n   * @param value - The value of the element to remove.\n   *\n   * @returns `true` if element removed successfully; or `false` if this set did not contain the element.\n   */\n  delete(value: T): boolean {\n    if (super.delete(value)) {\n      this._added.delete(value);\n      this._removed.add(value);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all elements from this delta set.\n   *\n   * Records all elements removal and forgets all elements additions.\n   */\n  clear(): void {\n    this._added.clear();\n    this.forEach(value => this._removed.add(value));\n    super.clear();\n  }\n\n  /**\n   * Applies changes to this delta set.\n   *\n   * First removes elements to `remove`. Then appends elements to `add`.\n   *\n   * Records all changes made.\n   *\n   * @param add - An iterable of elements to add.\n   * @param remove - An iterable of elements to remove.\n   *\n   * @returns `this` delta set.\n   */\n  delta(add: Iterable<T>, remove: Iterable<T> = []): this {\n    deltaSetDeltaReceiver(this)(add, remove);\n    return this;\n  }\n\n  /**\n   * Replays the changes made to this set in target receiver.\n   *\n   * @param receiver - A receiver of changes delta. E.g. another `Set`.\n   *\n   * @returns `this` delta set.\n   */\n  redelta(receiver: DeltaSet.DeltaReceiver<T>): this {\n\n    const receive = typeof receiver === 'function' ? receiver : deltaSetDeltaReceiver(receiver);\n\n    receive([...this._added], [...this._removed]);\n\n    return this;\n  }\n\n  /**\n   * Forgets all changes made to this set.\n   *\n   * Does not alter the set contents.\n   *\n   * @returns `this` delta set.\n   */\n  undelta(): this {\n    this._added.clear();\n    this._removed.clear();\n    return this;\n  }\n\n}\n\nexport namespace DeltaSet {\n\n  /**\n   * A delta set changes receiver.\n   *\n   * This can be either an {@link DeltaReceiverObject object}, or a {@link DeltaReceiverFunction function}.\n   *\n   * @typeParam T - A type of elements of delta set.\n   */\n  export type DeltaReceiver<T> =\n      | DeltaReceiverFunction<T>\n      | DeltaReceiverObject<T>;\n\n  /**\n   * A delta set changes receiver function.\n   *\n   * @typeParam T - A type of elements of delta set.\n   */\n  export type DeltaReceiverFunction<T> =\n  /**\n   * @param added - An array of added elements.\n   * @param removed - An array of removed elements.\n   */\n      (this: void, added: T[], removed: T[]) => void;\n\n  /**\n   * A delta set changes receiver object.\n   *\n   * A `Set` class implements this interface.\n   *\n   * @typeParam T - A type of elements of delta set.\n   */\n  export interface DeltaReceiverObject<T> {\n\n    /**\n     * Receives an element that has been added to delta set.\n     *\n     * @param value - The value of the added element.\n     */\n    add(value: T): void;\n\n    /**\n     * Receives an element that has been remove from delta set.\n     *\n     * @param value - The value of the removed element.\n     */\n    delete(value: T): void;\n\n  }\n\n}\n\n/**\n * @internal\n */\nfunction deltaSetDeltaReceiver<T>(\n    receiver: DeltaSet.DeltaReceiverObject<T>,\n): (this: void, add: Iterable<T>, remove: Iterable<T>) => void {\n  return (add, remove) => {\n    for (const removed of remove) {\n      receiver.delete(removed);\n    }\n    for (const added of add) {\n      receiver.add(added);\n    }\n  };\n}\n","import { noop, valueProvider } from '@proc7ts/primitives';\nimport { InAspect } from './aspect';\nimport { InControl } from './control';\n\nconst nullInAspect$: InAspect.Applied<any, any> = {\n  instance: null,\n  convertTo: noop,\n};\n\n/**\n * Creates an aspect applied to control with `null` instance value.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n *\n * @returns Applied input aspect.\n */\nexport function nullInAspect<TValue, TInstance>(): InAspect.Applied<TValue, TInstance | null> {\n  return nullInAspect$;\n}\n\n/**\n * Creates an aspect applied to control with known instance.\n *\n * An instance remains as is when converted to another control.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam instance - Known aspect instance type.\n *\n * @returns Applied input aspect.\n */\nexport function knownInAspect<TValue, TInstance>(instance: TInstance): InAspect.Applied<TValue, TInstance> {\n  return {\n    instance,\n    convertTo(_target) {\n      return this as InAspect.Applied<any, TInstance>;\n    },\n  };\n}\n\n/**\n * Creates an aspect applied to control with known inconvertible instance.\n *\n * When converted to another control with the same value, an aspect instance remains as is.\n *\n * When converted to another control with another value, an aspect instance replaced by `null`.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n * @param control - Target control to apply an aspect to.\n * @param aspectKey - Applied aspect key.\n * @param instance - Known aspect instance type. Defaults to `null`.\n *\n * @returns Applied input aspect.\n */\nexport function inconvertibleInAspect<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance | null, TKind>,\n    instance: TInstance | null = null,\n): InAspect.Applied<TValue, TInstance | null> {\n  return builtInAspect$(control, aspectKey, valueProvider(null), instance);\n}\n\n/**\n * Creates an aspect applied to control with built instance.\n *\n * When converted to another control with the same value, an aspect instance remains as is.\n *\n * When converted to another control with another value, an aspect instance is built again with original control\n * passed to the builder as a second parameter.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n * @param control - Target control to apply an aspect to.\n * @param aspectKey - Applied aspect key.\n * @param build - Aspect instance builder function. Accepts target control and optionally an original one as parameters.\n *\n * @returns Applied input aspect.\n */\nexport function builtInAspect<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance, TKind>,\n    build: <TValue>(this: void, control: InControl<TValue>, origin?: InControl<any>) => TInstance,\n): InAspect.Applied<TValue, TInstance> {\n  return builtInAspect$(control, aspectKey, build);\n}\n\nfunction builtInAspect$<TValue, TInstance, TKind extends InAspect.Application.Kind>(\n    control: InControl<TValue>,\n    aspectKey: InAspect.Key<TInstance, TKind>,\n    build: <TValue>(this: void, control: InControl<TValue>, origin?: InControl<any>) => TInstance,\n    instance?: TInstance,\n    origin?: InControl<any>,\n): InAspect.Applied<TValue, TInstance> {\n  if (instance === undefined) {\n    instance = build(control, origin);\n  }\n\n  return {\n    instance,\n    convertTo<TTo>(target: InControl<TTo>): InAspect.Applied<TTo, TInstance> {\n      return builtInAspect$<TTo, TInstance, TKind>(\n          target,\n          aspectKey,\n          build,\n          undefined,\n          control,\n      );\n    },\n    attachTo(target: InControl<TValue>): InAspect.Applied<TValue, TInstance> | undefined {\n      return builtInAspect$(\n          target,\n          aspectKey,\n          build,\n          (control.aspect(aspectKey) as TInstance | undefined) || build(target),\n      );\n    },\n  };\n}\n","import { InControl } from './control';\n\n/**\n * Some aspect of the user input. Such as input focus or validity.\n *\n * An aspect is applied to input control first. This creates an aspect instance bound to that control. All\n * aspect-related operations are performed by that instance.\n *\n * @category Aspect\n * @typeParam TInstance - Aspect instance type.\n * @typeParam TKind - Aspect application kind.\n */\nexport interface InAspect<TInstance, TKind extends InAspect.Application.Kind = 'default'> {\n\n  /**\n   * Applies this aspect to the given input `control`.\n   *\n   * This method is called at most once per control when requested aspect is not applied to the control yet.\n   *\n   * @typeParam TValue - Input value type.\n   * @param control - Input control to apply aspect to.\n   *\n   * @returns An aspect applied to the given `control`.\n   */\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, TInstance>;\n\n}\n\n/**\n * A symbol of aspect key property containing a reference to aspect.\n *\n * @category Aspect\n */\nexport const InAspect__symbol = (/*#__PURE__*/ Symbol('in-aspect'));\n\n/**\n * @category Aspect\n */\nexport namespace InAspect {\n\n  /**\n   * A key of the aspect of user input.\n   *\n   * It is passed to `InControl.aspect()` method in order to apply target aspect to that control.\n   *\n   * This interface is typically implemented by aspect instance class object. I.e. by its static methods.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   */\n  export interface Key<TInstance, TKind extends Application.Kind = 'default'> {\n\n    /**\n     * A referenced aspect of user input.\n     */\n    [InAspect__symbol]: InAspect<TInstance, TKind>;\n\n  }\n\n  /**\n   * An input aspect applied to control.\n   *\n   * This is what returned from `InAspect.applyTo()` method. Contains aspect instance and its manipulation methods.\n   *\n   * @typeParam TValue - Input value type.\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TConvertedInstance - A type of aspect instance applied to converted control.\n   * The same as `Instance` by default.\n   */\n  export interface Applied<TValue, TInstance, TConvertedInstance extends TInstance = TInstance> {\n\n    /**\n     * Input aspect instance.\n     */\n    readonly instance: TInstance;\n\n    /**\n     * Converts an aspect to another value type.\n     *\n     * This method is called by input control created by {@link InControl.convert} method.\n     *\n     * @typeParam TTargetValue - Converted input value type.\n     * @param target - Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    convertTo<TTargetValue>(target: InControl<TTargetValue>): Applied<TTargetValue, TConvertedInstance> | undefined;\n\n    /**\n     * Converts an aspect to the same value type.\n     *\n     * When defined, this method is called instead of {@link convertTo} when converting aspect for converted control\n     * with the same value. I.e. when {@link InConverter.Aspect aspect-only converters} used for conversion.\n     *\n     * @param target - Target input control.\n     *\n     * @returns The same aspect applied to `target` control, or `undefined` if aspect can not be converted.\n     */\n    attachTo?(target: InControl<TValue>): Applied<TValue, TInstance> | undefined;\n\n  }\n\n  export namespace Application {\n\n    /**\n     * A kind of input aspect application.\n     *\n     * This is a key of `InAspect.Application.Map` type.\n     */\n    export type Kind = keyof Map<unknown, unknown>;\n\n    /**\n     * A type of input aspect application result of the given application kind and input value type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     * @typeParam TKind - Aspect application kind.\n     */\n    export type Result<TInstance, TValue, TKind extends Kind> =\n        Applied<TValue, Instance<TInstance, TValue, TKind>>;\n\n    /**\n     * A type of applied aspect instance of the given application kind and input value type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     * @typeParam TKind - Aspect application kind.\n     */\n    export type Instance<TInstance, TValue, TKind extends Kind> =\n        ReturnType<Map<TInstance, TValue>[TKind]>;\n\n    /**\n     * A map implementing application result detection algorithms.\n     *\n     * Each method name here is a kind of aspect application, while the return value of this method is an aspect\n     * instance type.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TValue - Input value type.\n     */\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Default aspect application type. Just an aspect instance type.\n       */\n      default(): TInstance;\n\n    }\n\n  }\n\n}\n","import { NamespaceAliaser, NamespaceDef, newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { knownInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InConverter } from '../converter';\n\n/**\n * Namespace aliaser aspect.\n *\n * Used by other aspect to generate unique names.\n *\n * Creates new namespace aliaser and reuses it across converted controls unless overridden e.g. by\n * {@link InNamespaceAliaser.to} converter.\n *\n * @category Aspect\n */\nexport type InNamespaceAliaser = NamespaceAliaser;\n\n/**\n * Default input-aspects namespace definition.\n *\n * @category Aspect\n */\nexport const InputAspects__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://surol.github.io/input-aspects/ns',\n    'inasp',\n    'input-aspects',\n));\n\n/**\n * @internal\n */\nconst InNamespaceAliaser__aspect: InAspect<InNamespaceAliaser> = {\n\n  applyTo() {\n    return knownInAspect(newNamespaceAliaser());\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InNamespaceAliaser = {\n\n  get [InAspect__symbol](): InAspect<InNamespaceAliaser> {\n    return InNamespaceAliaser__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given namespace aliaser to converted control.\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param nsAlias - Target namespace aliaser.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(nsAlias: InNamespaceAliaser): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InNamespaceAliaser__aspect\n            ? knownInAspect(nsAlias) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { knownInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InConverter } from '../converter';\n\n/**\n * Input elements render scheduler.\n *\n * It is used e.g. to schedule CSS updates. The control values and attributes are updated instantly.\n *\n * Uses the default render scheduler unless overridden e.g. by {@link InRenderScheduler.to} converter.\n *\n * @category Aspect\n */\nexport type InRenderScheduler = RenderScheduler;\n\n/**\n * @internal\n */\nconst InRenderScheduler__aspect: InAspect<InRenderScheduler> = {\n\n  applyTo() {\n    return knownInAspect(newRenderSchedule);\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InRenderScheduler = {\n\n  get [InAspect__symbol](): InAspect<InRenderScheduler> {\n    return InRenderScheduler__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given render scheduler to converted control.\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param scheduler - Target DOM render scheduler.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(scheduler: InRenderScheduler): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InRenderScheduler__aspect\n            ? knownInAspect(scheduler) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { AfterEvent, AfterEvent__symbol, EventKeeper, mapAfter_, trackValue } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\n\nconst InRole__aspect: InAspect<InRole<any>, 'role'> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InRole<TValue>> {\n    return {\n      instance: new InControlRole<TValue>(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * A role of input control.\n *\n * Contains arbitrary named roles. A special role `'default'` considered active when no other roles activated.\n *\n * Roles may be used to conditionally activate other input aspects of the control.\n *\n * @typeParam TValue - Input value type.\n */\nexport abstract class InRole<TValue> implements EventKeeper<[InRole.Active]> {\n\n  static get [InAspect__symbol](): InAspect<InRole<any>, 'role'> {\n    return InRole__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of active roles.\n   *\n   * The `[AfterEvent__symbol]` method returns this value.\n   */\n  abstract readonly read: AfterEvent<[InRole.Active]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InRole.Active]> {\n    return this.read;\n  }\n\n  /**\n   * Adds named role to control.\n   *\n   * The named role becomes activate. To deactivate it the returned supply has to be cut off.\n   *\n   * The same role may be added multiple times. In that case the role will be deactivated once all role supplies cut\n   * off.\n   *\n   * @param role - A name of the role to add.\n   *\n   * @returns A role supply. Removes the added role once cut off.\n   */\n  abstract add(role: string): Supply;\n\n  /**\n   * Registers an activator of the given role.\n   *\n   * The given activator would be issued once the given role {@link add activated}. A supply instance returned\n   * by activator call will be cut off once the role deactivated.\n   *\n   * @param role - Target role name.\n   * @param activator - Role activator.\n   *\n   * @returns Activator supply. Removes the registered activator once cut off.\n   */\n  abstract when(role: string, activator: InRole.Activator<TValue>): Supply;\n\n}\n\nexport namespace InRole {\n\n  /**\n   * An activator signature of input control role.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export type Activator<TValue> =\n  /**\n   * @param control - A control the role is activate for.\n   * @param role - Activated role name.\n   * @param active - Active control role.\n   *\n   * @returns Activation supply peer. Its supply will be cut off once the role deactivated or activator removed. It is\n   * expected that this supply performs deactivation once cut off.\n   */\n      (\n          this: void,\n          control: InControl<TValue>,\n          role: string,\n          active: Active,\n      ) => SupplyPeer;\n\n  /**\n   * Active input control role.\n   *\n   * Contains all roles {@link InRole.add added} to control.\n   *\n   * Implements an `Iterable` interface by iterating over all active role names.\n   */\n  export interface Active extends Iterable<string> {\n\n    /**\n     * Checks whether the given role is active.\n     *\n     * @param role - Target role name.\n     *\n     * @returns `true` if the given role is {@link InRole.add added} to controller, or `false` otherwise.\n     */\n    has(role: string): boolean;\n\n  }\n\n}\n\nclass InRole$Active {\n\n  static create(): InRole$Active {\n\n    const result = new InRole$Active(new Map());\n\n    result.add('default', true);\n\n    return result;\n  }\n\n  readonly active: InRole.Active;\n  private _activate: (this: void) => void = noop;\n  private _defaultSupply!: Supply;\n\n  private constructor(\n      readonly roles: Map<string, InRole$Named>,\n  ) {\n    this.active = {\n      [Symbol.iterator]() {\n        return roles.keys();\n      },\n      has(role: string) {\n        return roles.has(role);\n      },\n    };\n  }\n\n  modify(): InRole$Active {\n\n    const result = new InRole$Active(this.roles);\n\n    result._defaultSupply = this._defaultSupply;\n\n    return result;\n  }\n\n  add(role: string, isDefault: boolean): Supply | undefined {\n\n    const named = this.roles.get(role);\n\n    if (named) {\n      // Already active.\n      ++named.active;\n      return;\n    }\n\n    const supply = new Supply();\n\n    this.roles.set(\n        role,\n        {\n          active: 1,\n          supply,\n        },\n    );\n\n    if (isDefault) {\n      this._defaultSupply = supply.whenOff(() => {\n\n        const toRemove = this.roles.get(role)!;\n\n        if (!--toRemove.active) {\n          this.roles.delete(role);\n        }\n      });\n    } else {\n\n      const defaultSupply = this._defaultSupply;\n\n      this.activateBy(() => defaultSupply.off());\n    }\n\n    return supply;\n  }\n\n  remove(role: string, reason: unknown): void {\n\n    const named = this.roles.get(role)!;\n\n    if (--named.active) {\n      // Still active.\n      return;\n    }\n\n    this.roles.delete(role);\n    this.activateBy(() => named.supply.off(reason));\n  }\n\n  activateBy(activator: () => void): void {\n\n    const prevActivator = this._activate;\n\n    this._activate = () => {\n      prevActivator();\n      activator();\n    };\n  }\n\n  activate(): void {\n\n    const activator = this._activate;\n\n    this._activate = noop;\n\n    activator();\n  }\n\n}\n\ninterface InRole$Named {\n  active: number;\n  readonly supply: Supply;\n}\n\nclass InControlRole<TValue> extends InRole<TValue> {\n\n  private readonly _active = trackValue<InRole$Active>(InRole$Active.create());\n  private readonly _activators = new Map<string, Map<Supply, InRole.Activator<TValue>>>();\n  readonly read: AfterEvent<[InRole.Active]>;\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n    this._active.on(active => active.activate());\n    this._active.supply.needs(_control);\n    this.read = this._active.read.do(mapAfter_(({ active }) => active));\n  }\n\n  add(role: string): Supply {\n\n    const active = this._active.it.modify();\n\n    this._add(active, role);\n    this._active.it = active;\n\n    return new Supply(reason => {\n\n      const active = this._active.it.modify();\n\n      active.remove(role, reason);\n      if (!active.roles.size) {\n        // No more active roles left.\n        // Enable `default` role.\n        this._add(active, 'default', true);\n      }\n\n      this._active.it = active;\n    });\n  }\n\n  when(role: string, activator: InRole.Activator<TValue>): Supply {\n\n    let activators = this._activators.get(role);\n\n    if (!activators) {\n      activators = new Map();\n      this._activators.set(role, activators);\n    }\n\n    const supply = new Supply().needs(this._control);\n\n    activators.set(\n        supply,\n        (control, role, active) => activator(control, role, active).supply.needs(supply),\n    );\n    supply.whenOff(() => {\n      activators!.delete(supply);\n      if (!activators!.size) {\n        this._activators.delete(role);\n      }\n    });\n\n    const named = this._active.it.roles.get(role);\n\n    if (named) {\n      // The role already active.\n      // Issue activator immediately.\n      named.supply.cuts(activator(this._control, role, this._active.it.active));\n    }\n\n    return supply;\n  }\n\n  private _add(active: InRole$Active, role: string, isDefault = false): void {\n\n    const activatedSupply = active.add(role, isDefault);\n\n    if (activatedSupply) {\n      // Role activated\n\n      const activators = this._activators.get(role);\n\n      if (activators) {\n        // Issue activators\n        for (const activator of activators.values()) {\n          activatedSupply.cuts(activator(this._control, role, this._active.it.active));\n        }\n      }\n    }\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input role application type.\n       */\n      role(): InRole<TValue>;\n\n    }\n\n  }\n\n}\n","import { InAspect, InAspect__symbol } from './aspect';\n\n/**\n * @internal\n */\nexport function isAspectKey<TInstance, TKind extends InAspect.Application.Kind>(\n    value: any,\n): value is InAspect.Key<TInstance, TKind> {\n  return InAspect__symbol in value;\n}\n","import type { InConverter } from './converter';\n\n/**\n * @internal\n */\nexport const noopInConversion: InConverter.Aspect.Conversion<any> = {\n  applyAspect(_aspect): undefined {\n    return;\n  },\n};\n\n/**\n * @internal\n */\nexport function noopInConverter(): InConverter.Aspect.Conversion<any> {\n  return noopInConversion;\n}\n","import { arrayOfElements, isPresent, noop, valueProvider } from '@proc7ts/primitives';\nimport { filterArray, itsReduction, overElementsOf } from '@proc7ts/push-iterator';\nimport type { InAspect } from './aspect';\nimport type { InControl } from './control';\nimport { noopInConverter } from './noop-converter.impl';\n\n/**\n * Input control converter. Either aspect-only, or value one.\n *\n * Either a {@link InConverter.Conversion control conversion}, or a {@link InConverter.Factory conversion factory}.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n */\nexport type InConverter<TFrom, TTo> =\n    | InConverter.Conversion<TFrom, TTo>\n    | InConverter.Factory<TFrom, TTo>;\n\n/**\n * @category Converter\n */\nexport namespace InConverter {\n\n  /**\n   * Input control conversion factory signature. Either aspect-only, or value one.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo> = (\n      this: void,\n      from: InControl<TFrom>,\n      to: InControl<TTo>,\n  ) => Conversion<TFrom, TTo>;\n\n  /**\n   * Input control conversion. Either aspect-only, or full one.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Conversion<TFrom, TTo> =\n      | InConverter.Value.Conversion<TFrom, TTo>\n      | InConverter.Aspect.Conversion<TTo>;\n\n  /**\n   * Input control value converter.\n   *\n   * Either a {@link InConverter.Value.Conversion control value conversion}, or a {@link InConverter.Value.Factory\n   * value conversion factory}.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Value<TFrom, TTo> =\n      | InConverter.Value.Factory<TFrom, TTo>\n      | InConverter.Value.Conversion<TFrom, TTo>;\n\n  /**\n   * Input control aspect converter.\n   *\n   * Either an {@link InConverter.Aspect.Conversion control aspect conversion}, or {@link InConverter.Aspect.Factory\n   * aspect conversion factory}.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Aspect<TFrom, TTo = TFrom> =\n      | InConverter.Aspect.Conversion<TTo>\n      | InConverter.Aspect.Factory<TFrom, TTo>;\n\n}\n\n/**\n * @category Converter\n */\nexport namespace InConverter.Value {\n\n  /**\n   * Input control value conversion factory signature.\n   *\n   * Called by {@link InControl.convert} to construct a {@link Conversion control conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo> =\n  /**\n   * @param from - Original input control.\n   * @param to - Converted input control.\n   *\n   * @returns Control conversion.\n   */\n      (\n          this: void,\n          from: InControl<TFrom>,\n          to: InControl<TTo>,\n      ) => Conversion<TFrom, TTo>;\n\n  /**\n   * Input control value conversion.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export interface Conversion<TFrom, TTo> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect?<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ): InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n    /**\n     * Converts original value.\n     *\n     * @param value - Original value to convert.\n     *\n     * @returns New value of converted control.\n     */\n    set(value: TFrom): TTo;\n\n    /**\n     * Restores original control value by converted one.\n     *\n     * @param value - A converted value to restore the original one by.\n     *\n     * @returns New value of original control.\n     */\n    get(value: TTo): TFrom;\n\n  }\n\n}\n\n/**\n * @category Converter\n */\nexport namespace InConverter.Aspect {\n\n  /**\n   * Input control aspect conversion factory signature.\n   *\n   * Called by {@link InControl.convert} to construct an {@link Conversion control aspect conversion}.\n   *\n   * Should not access converted control value as the one does not exist at calling time.\n   *\n   * @typeParam TFrom - Original input value type.\n   * @typeParam TTo - Converted input value type.\n   */\n  export type Factory<TFrom, TTo = TFrom> = (\n      this: void,\n      from: InControl<TFrom>,\n      to: InControl<TTo>,\n  ) => Conversion<TTo>;\n\n  /**\n   * Input control aspect conversion.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Conversion<TValue> {\n\n    /**\n     * Applies the given aspect to converted control in a custom way.\n     *\n     * @typeParam TInstance - Aspect instance type.\n     * @typeParam TKind - Aspect application kind.\n     * @param aspect - An aspect to apply.\n     *\n     * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. by converting\n     * it from corresponding aspect of original control).\n     */\n    applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined;\n\n  }\n\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @typeParam TValue - Input value type.\n * @param converters - Input control aspect converters.\n *\n * @returns Input control aspect conversion factory.\n */\nexport function intoConvertedBy<TValue>(\n    ...converters: InConverter.Aspect<TValue, TValue>[]\n): InConverter.Aspect.Factory<TValue, TValue>;\n\n/**\n * Creates converter that combines input value converter with aspect converters.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n * @param converter - Input control converter.\n * @param converters - Additional input control aspect converters.\n *\n * @returns Input control value conversion factory.\n */\nexport function intoConvertedBy<TFrom, TTo>(\n    converter: InConverter.Value<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Value.Factory<TFrom, TTo>;\n\n/**\n * Creates converter that combines any input control converter with aspect converters.\n *\n * @category Converter\n * @typeParam TFrom - Original input value type.\n * @typeParam TTo - Converted input value type.\n * @param converter - Input control converter.\n * @param converters - Additional input control aspect converters.\n *\n * @returns Input control conversion factory.\n */\nexport function intoConvertedBy<TFrom, TTo>(\n    converter?: InConverter<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Factory<TFrom, TTo>;\n\nexport function intoConvertedBy<TFrom, TTo>(\n    valueOrAspectConverter?: InConverter<TFrom, TTo> | InConverter.Aspect<TFrom, TTo>,\n    ...converters: InConverter.Aspect<TFrom, TTo>[]\n): InConverter.Factory<TFrom, TTo> {\n\n  type AspectApplicator = <TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n  if (!valueOrAspectConverter) {\n    return noopInConverter;\n  }\n\n  const converter = inConverter(valueOrAspectConverter);\n\n  if (!converters.length) {\n    return converter;\n  }\n\n  const aspectConverters = converters.map<InConverter.Aspect.Factory<TFrom, TTo>>(inConverter);\n\n  return (\n      from,\n      to,\n  ): InConverter.Conversion<TFrom, TTo> => {\n\n    const conversion = converter(from, to);\n    const conversions = overElementsOf<InConverter.Conversion<TFrom, TTo>>(\n        [conversion],\n        filterArray<InConverter.Aspect.Conversion<TTo> | undefined, InConverter.Aspect.Conversion<TTo>>(\n            aspectConverters.map(acf => acf(from, to)),\n            isPresent,\n        ),\n    );\n\n    const applyAspect: AspectApplicator = itsReduction(\n        conversions,\n        (prev: AspectApplicator, cv: InConverter.Conversion<TFrom, TTo>) => cv.applyAspect\n            ? (aspect => prev(aspect) || cv.applyAspect!(aspect))\n            : prev,\n        noop,\n    );\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      return {\n        applyAspect,\n      };\n    }\n\n    return {\n      set: conversion.set.bind(conversion),\n      get: conversion.get.bind(conversion),\n      applyAspect,\n    };\n  };\n}\n\n/**\n * Creates converter that combines input aspect converters.\n *\n * @category Converter\n * @typeParam TValue - Input value type.\n * @param aspects - Input aspect converter(s) to combine.\n *\n * @returns Input aspect conversion factory.\n */\nexport function intoConvertedAspects<TValue>(\n    aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[],\n): InConverter.Aspect.Factory<TValue> {\n  return aspects\n      ? intoConvertedBy(...arrayOfElements(aspects))\n      : intoConvertedBy<TValue>();\n}\n\n/**\n * Checks whether the given input control converter converts aspect only.\n *\n * @category Converter\n * @param conversion - Input control conversion to check.\n *\n * @returns `false` if the given conversion has a {@link InConverter.Value.Conversion.set set} method,\n * or `true` if there is no one.\n */\nexport function isInAspectConversion<TFrom, TTo>(\n    conversion: InConverter.Conversion<TFrom, TTo>,\n): conversion is InConverter.Aspect.Conversion<TTo> {\n  return !(conversion as Partial<InConverter.Value.Conversion<TFrom, TTo>>).set;\n}\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter.Value<TFrom, TTo>,\n): InConverter.Value.Factory<TFrom, TTo>;\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter.Aspect<TFrom, TTo>,\n): InConverter.Aspect.Factory<TFrom, TTo>;\n\n/**\n * @internal\n */\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter<TFrom, TTo>,\n): InConverter.Factory<TFrom, TTo>;\n\nfunction inConverter<TFrom, TTo>(\n    converter: InConverter<TFrom, TTo> | InConverter.Aspect<TFrom, TTo>,\n): InConverter.Factory<TFrom, TTo> | InConverter.Aspect.Factory<TFrom, TTo> {\n  return typeof converter === 'function' ? converter : valueProvider<any>(converter);\n}\n","import { InAspect } from './aspect';\nimport { InControl } from './control';\nimport { InConverter, intoConvertedBy } from './converter';\n\n/**\n * @internal\n */\nexport const InBuilder$Impl__symbol = (/*#__PURE__*/ Symbol('InBuilder.impl'));\n\n/**\n * @internal\n */\nexport class InBuilder$Impl<TControl extends InControl<TValue>, TValue> {\n\n  private readonly _aspectsByKey = new Map<InAspect<any, any>, InConverter.Aspect.Factory<TValue>>();\n  private _commonAspects: InConverter.Aspect.Factory<TValue> | undefined = undefined;\n  private _setup: ((control: TControl) => void) | undefined = undefined;\n\n  addAspect(aspect: InAspect<any, any>, converter: InConverter.Aspect<TValue>): void {\n\n    const prev = this._aspectsByKey.get(aspect);\n\n    this._aspectsByKey.set(aspect, prev ? intoConvertedBy(prev, converter) : intoConvertedBy(converter));\n  }\n\n  addAspects(aspects: readonly InConverter.Aspect<TValue>[]): void {\n    this._commonAspects = this._commonAspects\n        ? intoConvertedBy(this._commonAspects, ...aspects)\n        : intoConvertedBy(...aspects);\n  }\n\n  setup(setup: (control: TControl) => void): void {\n\n    const prev = this._setup;\n\n    if (prev) {\n      this._setup = control => {\n        prev(control);\n        setup(control);\n      };\n    } else {\n      this._setup = setup;\n    }\n  }\n\n  build(factory: InControl.Factory<TControl, TValue>): TControl {\n\n    const control = factory({ aspects: this._aspects() });\n\n    // Control setup\n    if (this._setup) {\n      control.setup(this._setup);\n    }\n\n    return control;\n  }\n\n  private _aspects(): InConverter.Aspect<TValue> | undefined {\n    if (this._aspectsByKey.size) {\n\n      const byKey = intoConvertedByKey(this._aspectsByKey);\n\n      return this._commonAspects ? intoConvertedBy(byKey, this._commonAspects) : byKey;\n    }\n\n    return this._commonAspects;\n  }\n\n}\n\nfunction intoConvertedByKey<TValue>(\n    byKey: Map<InAspect<any, any>, InConverter.Aspect.Factory<TValue>>,\n): InConverter.Aspect.Factory<TValue> {\n  return (from, to) => ({\n    applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<any, any>,\n    ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n\n      const converter = byKey.get(aspect);\n\n      return converter && converter(from, to).applyAspect(aspect);\n    },\n  });\n}\n","import { InAspect, InAspect__symbol } from './aspect';\nimport { isAspectKey } from './aspect.impl';\nimport { InBuilder$Impl, InBuilder$Impl__symbol } from './builder.impl';\nimport { InControl } from './control';\nimport { InConverter } from './converter';\n\n/**\n * User input control builder.\n *\n * @category Control\n * @typeParam TControl - Control type.\n * @typeParam TValue - Input value type.\n */\nexport class InBuilder<TControl extends InControl<TValue>, TValue = InControl.ValueType<TControl>> {\n\n  /**\n   * @internal\n   */\n  private readonly [InBuilder$Impl__symbol]: InBuilder$Impl<TControl, TValue> = new InBuilder$Impl();\n\n  /**\n   * Registers an aspect to add to the built control.\n   *\n   * @param aspectKey - A key of aspect to add.\n   * @param converter - An aspect converter to the built control from the {@link inValueOf same-valued one}.\n   *\n   * @returns `this` builder instance.\n   */\n  addAspect(aspectKey: InAspect.Key<any, any>, converter: InConverter.Aspect<TValue>): this {\n    this[InBuilder$Impl__symbol].addAspect(aspectKey[InAspect__symbol], converter);\n    return this;\n  }\n\n  /**\n   * Registers arbitrary aspects to add to the built control.\n   *\n   * These aspects always applied after {@link addAspect concrete} ones.\n   *\n   * @param aspects - Input aspects to add. These are aspect converters to the built control from the {@link inValueOf\n   * same-valued one}.\n   *\n   * @returns `this` builder instance.\n   */\n  addAspects(...aspects: InConverter.Aspect<TValue>[]): this {\n    if (aspects.length) {\n      this[InBuilder$Impl__symbol].addAspects(aspects);\n    }\n    return this;\n  }\n\n  /**\n   * Registers additional setup of the built control.\n   *\n   * The setup is performed when the control {@link build built}.\n   *\n   * @param setup - A function that accepts a built control as its only parameter.\n   *\n   * @returns `this` builder instance.\n   */\n  setup(setup: (this: void, control: TControl) => void): this;\n\n  /**\n   * Registers additional setup of the built control's aspect.\n   *\n   * The setup is performed when the control {@link build built}.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to set up.\n   * @param setup - A function that accepts an applied aspect instance and a built control as parameters.\n   *\n   * @returns `this` builder instance.\n   */\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n      setup: (this: void, aspect: InAspect.Application.Instance<TInstance, TValue, TKind>, control: TControl) => void,\n  ): this;\n\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<TInstance, TKind> | ((this: void, control: TControl) => void),\n      aspectSetup?: (\n          this: void,\n          aspect: InAspect.Application.Instance<TInstance, TValue, TKind>,\n          control: TControl,\n      ) => void,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      this[InBuilder$Impl__symbol].setup(control => control.setup(aspectKeyOrSetup, aspectSetup!));\n    } else {\n      this[InBuilder$Impl__symbol].setup(aspectKeyOrSetup);\n    }\n    return this;\n  }\n\n  /**\n   * Builds control.\n   *\n   * @param factory - Control factory.\n   *\n   * @returns New user input control constructed by the given `factory` and set up with configured aspects and setup\n   * procedures.\n   */\n  build(factory: InControl.Factory<TControl, TValue>): TControl {\n    return this[InBuilder$Impl__symbol].build(factory);\n  }\n\n}\n","import { InAspect } from './aspect';\nimport { InControl } from './control';\nimport { InConverter } from './converter';\n\n/**\n * @internal\n */\nexport const InControl$Aspects__symbol = (/*#__PURE__*/ Symbol('InControl.aspects'));\n\n/**\n * @internal\n */\nexport type InControl$Impl<TControl extends InControl<TValue>, TValue> = TControl & {\n\n  _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      _aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined;\n\n};\n\n/**\n * @internal\n */\nexport class InControl$Aspects<TControl extends InControl<TValue>, TValue> {\n\n  private readonly _byKey = new Map<InAspect<any, any>, InAspect.Applied<any, any>>();\n\n  constructor(\n      readonly control: InControl$Impl<TControl, TValue>,\n      readonly aspects: InConverter.Aspect.Conversion<TValue>,\n  ) {}\n\n  aspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> {\n\n    const applied = this._byKey.get(aspect);\n\n    if (applied) {\n      // Aspect applied already.\n      // Return it.\n      return applied;\n    }\n\n    const application = this.control._applyAspect(aspect)\n        || aspect.applyTo(this.control) as InAspect.Application.Result<TInstance, TValue, TKind>;\n\n    this._byKey.set(aspect, application);\n\n    return application;\n  }\n\n}\n","import { EventEmitter, OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { arrayOfElements, asis, noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { isAspectKey } from './aspect.impl';\nimport { InControl$Aspects, InControl$Aspects__symbol, InControl$Impl } from './control.impl';\nimport { InConverter, intoConvertedAspects, intoConvertedBy, isInAspectConversion } from './converter';\nimport { noopInConversion } from './noop-converter.impl';\n\n/**\n * User input control.\n *\n * Maintains input value and various aspects of the user input, such as input focus, validity, etc.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class InControl<TValue> extends ValueTracker<TValue> {\n\n  /**\n   * @internal\n   */\n  readonly [InControl$Aspects__symbol]: InControl$Aspects<this, TValue>;\n\n  /**\n   * Constructs user input control.\n   *\n   * @param aspects - Input aspects applied by default. These are aspect converters to constructed control from the\n   * {@link inValueOf same-valued one}.\n   */\n  constructor(\n      {\n        aspects,\n      }: {\n        readonly aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[];\n      } = {},\n  ) {\n    super();\n\n    const aspectList = arrayOfElements(aspects);\n\n    this[InControl$Aspects__symbol] = new InControl$Aspects(\n        this as unknown as InControl$Impl<this, TValue>,\n        aspectList.length\n            ? intoConvertedAspects(aspectList)(inValueOf(this), this)\n            : noopInConversion,\n    );\n  }\n\n  /**\n   * Input value.\n   */\n  abstract it: TValue;\n\n  /**\n   * This control's input supply.\n   *\n   * Releases all control resources when cut off.\n   *\n   * Each control has its own supply. An input supply of converted control depends on the input supply of control it\n   * is converted from.\n   *\n   * After this supply cut off the control should no longer be used.\n   */\n  abstract get supply(): Supply;\n\n  /**\n   * Retrieves an aspect instance applied to this control.\n   *\n   * If the given `aspect` is not applied yet, then applies it first.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to apply to this control.\n   *\n   * @returns An applied aspect instance.\n   */\n  aspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n  ): InAspect.Application.Instance<TInstance, TValue, TKind> {\n    return this[InControl$Aspects__symbol].aspect(aspectKey[InAspect__symbol]).instance;\n  }\n\n  /**\n   * Performs additional setup of this control.\n   *\n   * @param setup - A function that accepts this control as its only parameter.\n   *\n   * @returns `this` control instance.\n   */\n  setup(setup: (this: void, control: this) => void): this;\n\n  /**\n   * Performs additional setup of this control's aspect.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspectKey - A key of aspect to set up.\n   * @param setup - A function that accepts an applied aspect instance and this control as parameters.\n   *\n   * @returns `this` control instance.\n   */\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKey: InAspect.Key<TInstance, TKind>,\n      setup: (this: void, aspect: InAspect.Application.Instance<TInstance, TValue, TKind>, control: this) => void,\n  ): this;\n\n  setup<TInstance, TKind extends InAspect.Application.Kind>(\n      aspectKeyOrSetup: InAspect.Key<TInstance, TKind> | ((this: void, control: this) => void),\n      aspectSetup?: (\n          this: void,\n          aspect: InAspect.Application.Instance<TInstance, TValue, TKind>,\n          control: this,\n      ) => void,\n  ): this {\n    if (isAspectKey(aspectKeyOrSetup)) {\n      aspectSetup!(this.aspect(aspectKeyOrSetup), this);\n    } else {\n      aspectKeyOrSetup(this);\n    }\n    return this;\n  }\n\n  /**\n   * Converts this control to another one without changing its value type.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeParam TTo - Converted input value type.\n   * @param by - Input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert(\n      ...by: InConverter.Aspect<TValue, TValue>[]\n  ): InControl<TValue>;\n\n  /**\n   * Converts this control to another one.\n   *\n   * The converted aspect may have another value and input aspects.\n   *\n   * @typeParam TTo - Converted input value type.\n   * @param by - Input control converter.\n   * @param and - Additional input control aspect converters.\n   *\n   * @returns Converted control.\n   */\n  convert<TTo>(\n      by: InConverter<TValue, TTo>,\n      ...and: InConverter.Aspect<TValue, TTo>[]\n  ): InControl<TTo>;\n\n  convert<TTo>(\n      by?: InConverter<TValue, TTo>,\n      ...and: InConverter.Aspect<TValue, TTo>[]\n  ): InControl<TValue> | InControl<TTo> {\n    return new InControl$Converted(this, intoConvertedBy(by, ...and));\n  }\n\n  /**\n   * Applies the given aspect to this control in a custom way.\n   *\n   * @typeParam TInstance - Aspect instance type.\n   * @typeParam TKind - Aspect application kind.\n   * @param aspect - An aspect to apply.\n   *\n   * @returns Either applied aspect instance or `undefined` to apply the aspect in standard way (i.e. using\n   * `InAspect.applyTo()` method).\n   */\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return this[InControl$Aspects__symbol].aspects.applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InControl {\n\n  /**\n   * A value type of the given input control type.\n   *\n   * @typeParam TControl - Input control type.\n   */\n  export type ValueType<TControl extends InControl<any>> = TControl extends InControl<infer TValue> ? TValue : never;\n\n  /**\n   * User input control factory signature.\n   *\n   * @typeParam TControl - Control type.\n   * @typeParam TValue - Input value type.\n   */\n  export type Factory<TControl extends InControl<TValue>, TValue = ValueType<TControl>> =\n  /**\n   * @param aspects - Input aspects applied by default. This is an aspect converter to constructed control from the\n   * {@link inValueOf same-valued one}.\n   *\n   * @returns Created control instance.\n   */\n      (\n          this: void,\n          {\n            aspects,\n          }: {\n            readonly aspects?: InConverter.Aspect<TValue>;\n          },\n      ) => TControl;\n\n}\n\n/**\n * @internal\n */\nclass InControl$SameValued<TValue> extends InControl<TValue> {\n\n  private _supply?: Supply;\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n  }\n\n  get supply(): Supply {\n    return this._supply || (this._supply = new Supply(noop).needs(this._control));\n  }\n\n  get it(): TValue {\n    return this._control.it;\n  }\n\n  set it(value: TValue) {\n    this._control.it = value;\n  }\n\n  get on(): OnEvent<[TValue, TValue]> {\n    return this._control.on;\n  }\n\n}\n\n/**\n * Constructs input control with the same value as another one.\n *\n * The constructed control does not inherit any aspects from original one.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @param control - Original control containing the value.\n *\n * @returns New input control that accesses the value of original `control`.\n */\nexport function inValueOf<TValue>(control: InControl<TValue>): InControl<TValue> {\n  return new InControl$SameValued(control);\n}\n\nclass InControl$Converted<TFrom, TTo> extends InControl<TTo> {\n\n  readonly supply: Supply;\n  private readonly _on = new EventEmitter<[TTo, TTo]>();\n  private readonly _it: ValueTracker<[TTo, number]>;\n  protected readonly _applyAspect: <TInstance, TKind extends InAspect.Application.Kind>(\n      this: this,\n      aspect: InAspect<TInstance, TKind>,\n  ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n  constructor(src: InControl<TFrom>, by: InConverter.Factory<TFrom, TTo>) {\n    super();\n    this.supply = new Supply().needs(src);\n\n    let lastRev = 0;\n    let backward: TFrom | undefined;\n\n    const conversion = by(src, this);\n    let set: (value: TFrom) => TTo;\n    let get: (value: TTo) => TFrom;\n    let convertAspect: <TInstance, TKind extends InAspect.Application.Kind>(\n        aspect: InAspect<TInstance, TKind>,\n    ) => InAspect.Application.Result<TInstance, TTo, TKind> | undefined;\n\n    if (/*#__INLINE__*/ isInAspectConversion(conversion)) {\n      set = asis as (value: TFrom) => TTo;\n      get = asis as (value: TTo) => TFrom;\n      convertAspect = <TInstance, TKind extends InAspect.Application.Kind>(aspect: InAspect<TInstance, TKind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src[InControl$Aspects__symbol].aspect(aspect);\n\n        return fallback.attachTo ? fallback.attachTo(this) : fallback.convertTo(this);\n      };\n    } else {\n      set = conversion.set;\n      get = conversion.get;\n      convertAspect = <TInstance, TKind extends InAspect.Application.Kind>(aspect: InAspect<TInstance, TKind>) => {\n\n        const fallback: InAspect.Applied<any, any> = src[InControl$Aspects__symbol].aspect(aspect);\n\n        return fallback.convertTo(this);\n      };\n    }\n\n    this._applyAspect = aspect => conversion.applyAspect?.(aspect) || convertAspect(aspect);\n    this._it = trackValue([set(src.it), 0]);\n    this._it.supply.needs(this.supply);\n    this._it.on(([newValue], [oldValue]) => {\n      if (newValue !== oldValue) {\n        this._on.send(newValue, oldValue);\n      }\n    }).cuts(this._on);\n    src.on(value => {\n      if (value !== backward) {\n        this._it.it = [set(value), ++lastRev];\n      }\n    }).cuts(this);\n    this._it.on(([value, rev]) => {\n      if (rev !== lastRev) {\n        lastRev = rev;\n        backward = get(value);\n        try {\n          src.it = backward;\n        } finally {\n          backward = undefined;\n        }\n      }\n    });\n  }\n\n  get it(): TTo {\n    return this._it.it[0];\n  }\n\n  set it(value: TTo) {\n\n    const [prevValue, prevRev] = this._it.it;\n\n    if (value !== prevValue) {\n      this._it.it = [value, prevRev + 1];\n    }\n  }\n\n  get on(): OnEvent<[TTo, TTo]> {\n    return this._on.on;\n  }\n\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { inconvertibleInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\n\n/**\n * @internal\n */\nconst InContainer__aspect: InAspect<InContainer<any> | null, 'container'> = {\n  applyTo(control) {\n    return inconvertibleInAspect(control, InContainer);\n  },\n};\n\n/**\n * An input control containing other controls.\n *\n * Container is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n */\nexport abstract class InContainer<TValue> extends InControl<TValue> {\n\n  static get [InAspect__symbol](): InAspect<InContainer<any> | null, 'container'> {\n    return InContainer__aspect;\n  }\n\n  /**\n   * Controls of this input container.\n   */\n  abstract readonly controls: InContainerControls;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return aspect === InContainer__aspect as InAspect<any>\n        ? inconvertibleInAspect(this, InContainer, this) as InAspect.Application.Result<TInstance, TValue, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InContainer {\n\n  /**\n   * Input controls container entry.\n   *\n   * This is a tuple containing control key and control itself.\n   *\n   * Container implementations may apply limitations on the type of keys and input values they support.\n   */\n  export type Entry = readonly [PropertyKey, InControl<any>];\n\n  /**\n   * A snapshot of input controls within container.\n   *\n   * Extends an `Iterable` interface by iterating over all nested controls.\n   */\n  export interface Snapshot extends Iterable<InControl<any>> {\n\n    [Symbol.iterator](): IterableIterator<InControl<any>>;\n\n    /**\n     * Iterates over nested control entries.\n     *\n     * @returns An iterable iterator over entries.\n     */\n    entries(): IterableIterator<InContainer.Entry>;\n\n  }\n\n}\n\n/**\n * Controls of input container.\n *\n * Allows to track container contents. I.e. nested controls, their additions and removal.\n *\n * Implements `EventSender` interface by sending arrays of added and removed control entries.\n *\n * Implements `EventKeeper` interface by sending container contents instance each time it is changed.\n *\n * @category Control\n */\nexport abstract class InContainerControls\n     implements EventSender<[InContainer.Entry[], InContainer.Entry[]]>, EventKeeper<[InContainer.Snapshot]> {\n\n  /**\n   * An `OnEvent` sender of container updates.\n   *\n   * Sends two arrays on each container update: the first one contains added control entries, while the second one\n   * contains removed control entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InContainer.Entry[], InContainer.Entry[]]>;\n\n  /**\n   * An `AfterEvent` keeper of input container contents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InContainer.Snapshot]>;\n\n  [OnEvent__symbol](): OnEvent<[InContainer.Entry[], InContainer.Entry[]]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InContainer.Snapshot]> {\n    return this.read;\n  }\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input controls container application type.\n       */\n      container(): InContainer<TValue> | null;\n\n    }\n\n  }\n\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  OnEvent,\n  OnEvent__symbol,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { knownInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InContainer } from './container.control';\n\n/**\n * @internal\n */\nconst InParents__aspect: InAspect<InParents> = {\n  applyTo(control): InAspect.Applied<any, InParents> {\n    return knownInAspect(new InControlParents(control));\n  },\n};\n\n/**\n * Parents of input control.\n *\n * Reflects all containers the control belongs to. Note that component may belong to multiple containers. Or even\n * to the same container multiple times.\n *\n * Implements `EventSender` interface by sending arrays of parent entries the control is added to and removed from.\n *\n * Implements `EventKeeper` interface by sending a snapshot of all parents each time it is updated.\n *\n * @category Aspect\n */\nexport abstract class InParents\n    implements EventKeeper<[Iterable<InParents.Entry>]>, EventSender<[InParents.Entry[], InParents.Entry[]]> {\n\n  static get [InAspect__symbol](): InAspect<InParents> {\n    return InParents__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of parent updates.\n   *\n   * Sends two arrays on each parents update: the first one contains added parent entries, while the second one\n   * contains removed parent entries.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InParents.Entry[], InParents.Entry[]]>;\n\n  /**\n   * An `AfterEvent` keeper of control parents.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InParents.All]>;\n\n  [OnEvent__symbol](): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InParents.All]> {\n    return this.read;\n  }\n\n  /**\n   * Adds the input control to the given parent container under the given key.\n   *\n   * @param entry - Parent container entry.\n   *\n   * @returns A parent container supply. Removes the control from the parent container once cut off.\n   */\n  abstract add(entry: InParents.Entry): Supply;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InParents {\n\n  /**\n   * Parent container entry of input control.\n   */\n  export interface Entry {\n\n    /**\n     * Parent container.\n     */\n    readonly parent: InContainer<any>;\n\n  }\n\n  /**\n   * All control parents as iterable instance.\n   */\n  export interface All extends Iterable<Entry> {\n\n    [Symbol.iterator](): IterableIterator<Entry>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlParents extends InParents {\n\n  readonly read: AfterEvent<[InParents.All]>;\n  private readonly _map = new Map<InParents.Entry, Supply>();\n  private readonly _on = new EventEmitter<[InParents.Entry[], InParents.Entry[]]>();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n    this._on.supply.needs(this._control);\n\n    const allParents = (): InParents.All => ({\n      [Symbol.iterator]: () => this._map.keys(),\n    });\n\n    this.read = this.on.do(mapAfter(allParents, allParents));\n  }\n\n  add(entry: InParents.Entry): Supply {\n\n    const existingSupply = this._map.get(entry);\n\n    if (existingSupply) {\n      // Parent entry already added. Doing nothing\n      return existingSupply;\n    }\n\n    // Adding new entry\n    const supply = new Supply(() => {\n      this._map.delete(entry);\n      this._on.send([], [entry]);\n    });\n\n    this._map.set(entry, supply);\n    this._on.send([entry], []);\n\n    return supply\n        .needs(this._control)\n        .needs(entry.parent);\n  }\n\n  get on(): OnEvent<[InParents.Entry[], InParents.Entry[]]> {\n    return this._on.on;\n  }\n\n}\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { inconvertibleInAspect } from './applied-aspect';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InControl } from './control';\n\n/**\n * @internal\n */\nconst InElement__aspect: InAspect<InElement<any> | null, 'element'> = {\n  applyTo(control) {\n    return inconvertibleInAspect(control, InElement);\n  },\n};\n\n/**\n * HTML input element control.\n *\n * It is also available as aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nexport abstract class InElement<TValue, TElt = HTMLElement> extends InControl<TValue> {\n\n  static get [InAspect__symbol](): InAspect<InElement<any> | null, 'element'> {\n    return InElement__aspect;\n  }\n\n  /**\n   * HTML input element this control is based on.\n   */\n  abstract readonly element: TElt;\n\n  /**\n   * DOM event dispatcher of this element.\n   */\n  abstract readonly events: DomEventDispatcher;\n\n  /**\n   * An `AfterEvent` keeper of user input.\n   */\n  abstract readonly input: AfterEvent<[InElement.Input<TValue>]>;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<TInstance, TKind>,\n  ): InAspect.Application.Result<TInstance, TValue, TKind> | undefined {\n    return aspect as InAspect<any, any> === InElement__aspect\n        ? inconvertibleInAspect(\n            this,\n            InElement,\n            this as InElement<TValue, any>,\n        ) as InAspect.Application.Result<TInstance, TValue, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InElement {\n\n  /**\n   * User input.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Input<TValue> {\n\n    /**\n     * The value user entered.\n     */\n    value: TValue;\n\n    /**\n     * An event caused the value to be applied.\n     *\n     * The value has been applied programmatically if missing.\n     */\n    event?: Event;\n\n  }\n\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input element application type.\n       */\n      element(): InElement<TValue> | null;\n\n    }\n\n  }\n\n}\n","import {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSent,\n  afterSupplied,\n  afterThe,\n  digAfter,\n  digAfter_,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  mapAfter,\n  mapOn,\n  OnEvent,\n  OnEvent__symbol,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n  translateOn,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { valuesProvider } from '@proc7ts/primitives';\nimport { itsElements, overElementsOf } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { builtInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InParents } from '../containers';\nimport { InParentsAspect } from '../containers/parents.aspect.impl';\nimport { InControl } from '../control';\nimport { InElement } from '../element.control';\n\n/**\n * @internal\n */\nconst InMode__aspect: InAspect<InMode> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InMode> {\n    return builtInAspect(\n        control,\n        InMode,\n        ctrl => new InControlMode(ctrl),\n    );\n  },\n\n};\n\n/**\n * Input mode aspect of control.\n *\n * Control can be either enabled, disabled, or readonly.\n *\n * Each control maintains its own state, while nested controls respect container ones. I.e. when container is disabled\n * all nested ones are also disabled. When container is readonly, all nested ones are also readonly, unless explicitly\n * disabled.\n *\n * When applied to input element this aspect maintains its `disabled` and `readonly` attributes (not properties!).\n *\n * Implements `EventSender` interface by sending new and old mode values on each update.\n *\n * Implements `EventKeeper` interface by sending actual mode value.\n *\n * @category Aspect\n */\nexport abstract class InMode implements EventSender<[InMode.Value, InMode.Value]>, EventKeeper<[InMode.Value]> {\n\n  static get [InAspect__symbol](): InAspect<InMode> {\n    return InMode__aspect;\n  }\n\n  /**\n   * An `OnEvent` sender of input mode updates.\n   *\n   * Sends a new mode value along with old one as second parameter.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n\n  /**\n   * An `AfterEvent` keeper of input mode.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InMode.Value]>;\n\n  [OnEvent__symbol](): OnEvent<[InMode.Value, InMode.Value]> {\n    return this.on;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[InMode.Value]> {\n    return this.read;\n  }\n\n  /**\n   * Own input mode tracker.\n   */\n  abstract readonly own: ValueTracker<InMode.Value>;\n\n  /**\n   * Checks whether control in the given `mode` has data to submit.\n   *\n   * @param mode - Input control mode to check.\n   *\n   * @returns `true` if control in the given `mode` has data to submit, or `false` otherwise.\n   */\n  static hasData(mode: InMode.Value): boolean {\n    return mode !== 'off' && mode[0] !== '-';\n  }\n\n  /**\n   * Derives input mode from another `source`.\n   *\n   * If the `source` mode is disabled, this one would be disabled too. If the `source` mode is read-only, then this one\n   * would be read-only, unless disabled already.\n   *\n   * @param source - A source to derive input mode from.\n   *\n   * @returns Derived input mode supply. Disables `source` mode derivation once cut off.\n   */\n  abstract derive(source: InMode.Source): Supply;\n\n  /**\n   * Unregisters all receivers.\n   *\n   * @param reason - Optional reason.\n   *\n   * @returns `this` instance.\n   */\n  done(reason?: any): this {\n    this.own.supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InMode {\n\n  /**\n   * Possible input control mode value:\n   *\n   * - `on` when control is writable. This is the default.\n   * - `ro` when control is read-only. Such control can not be edited, but still can be submitted.\n   * - `off` when control is disabled. Such control is not submitted.\n   * - `-on` when control is writable, but not submitted.\n   * - `-ro` when control is read-only, but not submitted.\n   */\n  export type Value = 'on' | 'ro' | 'off' | '-on' | '-ro';\n\n  /**\n   * A source of input mode.\n   *\n   * This is either an event keeper of {@link Value mode value}, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<[InMode.Value]>\n      | ((this: void, control: InControl<any>) => EventKeeper<[InMode.Value]>);\n\n}\n\n/**\n * @internal\n */\nclass OwnModeTracker extends ValueTracker<InMode.Value> {\n\n  private readonly _tracker: ValueTracker<InMode.Value>;\n\n  constructor(element: InElement<any> | null) {\n    super();\n    this._tracker = trackValue(element ? initialInMode(element.element) : 'on');\n  }\n\n  get supply(): Supply {\n    return this._tracker.supply;\n  }\n\n  get it(): InMode.Value {\n    return this._tracker.it;\n  }\n\n  set it(value: InMode.Value) {\n    switch (value) {\n    case 'off':\n    case 'ro':\n    case '-on':\n    case '-ro':\n      break;\n    default:\n      value = 'on'; // Correct the value.\n    }\n\n    this._tracker.it = value;\n  }\n\n  get on(): OnEvent<[InMode.Value, InMode.Value]> {\n    return this._tracker.on;\n  }\n\n}\n\n/**\n * @internal\n */\nclass DerivedInModes {\n\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _all = new Set<AfterEvent<[InMode.Value]>>();\n  private readonly _on = new EventEmitter<[]>();\n\n  constructor() {\n\n    const sources: AfterEvent<[Set<AfterEvent<[InMode.Value]>>]> = afterSent(\n        this._on.on.do(mapOn(() => this._all)),\n        valuesProvider(this._all),\n    );\n\n    this.read = sources.do(\n        digAfter_((set: Set<AfterEvent<[InMode.Value]>>) => afterEach(...set)),\n        mapAfter(mergeInModes),\n    );\n  }\n\n  add(source: AfterEvent<[InMode.Value]>): Supply {\n\n    const supply = new Supply(() => {\n      this._all.delete(source);\n      this._on.send();\n    });\n\n    this._all.add(source);\n    this._on.send();\n\n    return supply;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlMode extends InMode {\n\n  readonly own: OwnModeTracker;\n  readonly on: OnEvent<[InMode.Value, InMode.Value]>;\n  readonly read: AfterEvent<[InMode.Value]>;\n  private readonly _derived = new DerivedInModes();\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    const element = _control.aspect(InElement);\n\n    this.own = new OwnModeTracker(element);\n    this.own.supply.needs(_control);\n    this.derive(_control.aspect(InParentsAspect).read.do(digAfter(parentsInMode)));\n\n    let last: InMode.Value = 'on';\n\n    this.read = afterAll({\n      derived: this._derived.read,\n      own: this.own,\n    }).do(translateAfter(\n        (\n            send,\n            {\n              derived: [derived],\n              own: [own],\n            },\n        ) => {\n\n          let next: InMode.Value;\n\n          if (own === 'off' || derived === 'off') {\n            next = 'off';\n          } else {\n\n            let off = false;\n\n            if (own[0] === '-') {\n              off = true;\n              own = own.substring(1) as InMode.Value;\n            }\n            if (derived[0] === '-') {\n              off = true;\n              derived = derived.substring(1) as InMode.Value;\n            }\n            next = derived === 'ro' ? 'ro' : own;\n            if (off) {\n              next = '-' + next as InMode.Value;\n            }\n          }\n\n          if (last !== next) {\n            send(last = next);\n          }\n        },\n        valuesProvider<[InMode.Value]>(last),\n    ));\n\n    let lastUpdate: InMode.Value = 'on';\n\n    this.on = this.read.do(translateOn((send, value) => {\n\n      const old = lastUpdate;\n\n      if (old !== value) {\n        send(lastUpdate = value, old);\n      }\n    }));\n\n    if (element) {\n      this.read(value => applyInMode(element.element, value));\n    }\n  }\n\n  derive(source: InMode.Source): Supply {\n    return this._derived.add(\n        afterSupplied(isEventKeeper(source) ? source : source(this._control)).do(supplyAfter(this._control)),\n    ).needs(this._control);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction initialInMode(element: HTMLElement): InMode.Value {\n  return element.getAttribute('disabled') != null\n      ? 'off'\n      : (element.getAttribute('readonly') != null ? 'ro' : 'on');\n}\n\n/**\n * @internal\n */\nfunction applyInMode(element: HTMLElement, value: InMode.Value): void {\n  switch (value) {\n  case 'off':\n    element.setAttribute('disabled', '');\n    break;\n  case 'ro':\n  case '-ro':\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    element.setAttribute('readonly', '');\n    break;\n  default:\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('disabled', '');\n    element.removeAttribute('disabled');\n    // Workaround of https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n    element.setAttribute('readonly', '');\n    element.removeAttribute('readonly');\n  }\n}\n\n/**\n * @internal\n */\nfunction parentsInMode(parents: InParents.All): AfterEvent<[InMode.Value]> {\n\n  const parentList = itsElements(parents);\n\n  if (!parentList.length) {\n    return afterThe('on');\n  }\n\n  const parentModes = parentList.map(({ parent }) => parent.aspect(InMode));\n\n  return afterEach(...parentModes).do(mapAfter(mergeInModes));\n}\n\n/**\n * @internal\n * @param modes\n */\nfunction mergeInModes(...modes: [InMode.Value][]): InMode.Value {\n  return inModeValue(...overElementsOf<InMode.Value>(...modes));\n}\n\n/**\n * Merges multiple input mode values.\n *\n * @category Aspect\n * @param modes - Input mode values to merge.\n *\n * @returns Merged input mode value.\n */\nexport function inModeValue(...modes: InMode.Value[]): InMode.Value {\n\n  let ro = false;\n  let off = false;\n\n  for (const mode of modes) {\n    switch (mode) {\n    case 'off':\n      return 'off';\n    case 'ro':\n      ro = true;\n      break;\n    case '-on':\n      off = true;\n      break;\n    case '-ro':\n      off = true;\n      ro = true;\n      break;\n    case 'on':\n    }\n  }\n\n  return off ? (ro ? '-ro' : '-on') : (ro ? 'ro' : 'on');\n}\n","import { afterAll, AfterEvent, mapAfter } from '@proc7ts/fun-events';\nimport { builtInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InMode } from './mode.aspect';\n\n/**\n * A data aspect of the input.\n *\n * Represents input control data that will be submitted.\n *\n * Input data is typically the same as control value with respect to {@link InMode input mode}. I.e. when input mode is\n * `off` the data is `undefined`.\n *\n * An aspect interface is an `AfterEvent` keeper of input data.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport type InData<TValue> = AfterEvent<[InData.DataType<TValue>?]>;\n\n/**\n * @internal\n */\nconst InData__aspect: Aspect = {\n\n  applyTo<TValue>(control: InControl<TValue>): Applied<TValue> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return builtInAspect(control, InData, <TValue>(ctrl: InControl<TValue>) => afterAll({\n      value: ctrl,\n      mode: ctrl.aspect(InMode),\n    }).do(mapAfter(\n        ({ value: [value], mode: [mode] }) => InMode.hasData(mode)\n            ? value as any\n            : undefined,\n    )));\n  },\n\n};\n\n/**\n * Input data aspect.\n */\ninterface Aspect extends InAspect<InData<any>, 'data'> {\n\n  applyTo<TValue>(control: InControl<TValue>): Applied<TValue>;\n\n}\n\n/**\n * An input data aspect applied to control.\n */\ninterface Applied<TValue> extends InAspect.Applied<TValue, InData<TValue>, InData<any>> {\n\n  convertTo<TTo>(target: InControl<TTo>): Applied<TTo> | undefined;\n\n}\n\n/**\n * @category Aspect\n */\nexport const InData = {\n\n  get [InAspect__symbol](): InAspect<InData<any>, 'data'> {\n    return InData__aspect;\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport namespace InData {\n\n  /**\n   * Input data type.\n   *\n   * This is either a partial value (for the object), or the value itself (for everything else).\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export type DataType<TValue> =\n      | (TValue extends object ? { [K in keyof TValue]?: DataType<TValue[K]> } : TValue)\n      | undefined;\n\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input data aspect application type.\n       */\n      data(): InData<TValue>;\n\n    }\n\n  }\n\n}\n","import {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  digAfter_,\n  EventEmitter,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  onceAfter,\n  OnEvent,\n  OnEvent__symbol,\n  supplyAfter,\n  trackValue,\n  translateOn,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport {\n  iteratorOf,\n  itsEach,\n  mapIt,\n  overEntries,\n  overIterator,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { neverSupply, Supply } from '@proc7ts/supply';\nimport { inconvertibleInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InControl } from '../control';\nimport { InConverter } from '../converter';\nimport { InData, InMode } from '../data';\nimport { InContainer, InContainerControls } from './container.control';\nimport { InParents } from './parents.aspect';\n\n/**\n * @internal\n */\nconst InGroup__aspect: InAspect<InGroup<any> | null, 'group'> = {\n  applyTo(control) {\n    return inconvertibleInAspect(control, InGroup);\n  },\n};\n\n/**\n * A group of input controls.\n *\n * Nested controls are identified by keys and can be added and removed via `controls` property.\n *\n * Group value (called model) is an object formed by nested control values. The model property value is the one of the\n * control with the same key, if present. When model is updated corresponding controls are also updated.\n *\n * Group is available as an aspect of itself and converted controls with the same value.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nexport abstract class InGroup<TModel extends object> extends InContainer<TModel> {\n\n  static get [InAspect__symbol](): InAspect<InGroup<any> | null, 'group'> {\n    return InGroup__aspect;\n  }\n\n  /**\n   * Input group controls.\n   */\n  abstract readonly controls: InGroupControls<TModel>;\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<TInstance, TModel, TKind> | undefined {\n    return aspect === InGroup__aspect\n        ? inconvertibleInAspect(this, InGroup, this) as InAspect.Application.Result<TInstance, TModel, TKind>\n        : super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @category Control\n */\nexport namespace InGroup {\n\n  /**\n   * Input group controls.\n   *\n   * This is a read-only object containing an input control per each model property under the same key.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   */\n  export type Controls<TModel> = {\n    readonly [K in keyof TModel]?: InControl<TModel[K]>;\n  };\n\n  /**\n   * Input controls group entry.\n   *\n   * This is a tuple containing model key and corresponding control.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   * @typeParam TKey - Model keys type.\n   */\n  export type Entry<TModel, TKey extends keyof TModel = any> = readonly [TKey, InControl<TModel[TKey]>];\n\n  /**\n   * A snapshot of input control group controls.\n   *\n   * @typeParam TModel - Group model type, i.e. its value type.\n   */\n  export interface Snapshot<TModel> extends InContainer.Snapshot {\n\n    entries(): IterableIterator<Entry<TModel>>;\n\n    /**\n     * Returns input control with the given key, if present.\n     *\n     * @param key - Control key, i.e. corresponding model property key.\n     *\n     * @returns Target control, or `undefined` if there is no control set for this key.\n     */\n    get<TKey extends keyof TModel>(key: TKey): InGroup.Controls<TModel>[TKey] | undefined;\n\n  }\n\n}\n\n/**\n * Input group controls.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n */\nexport abstract class InGroupControls<TModel>\n    extends InContainerControls\n    implements EventSender<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>,\n        EventKeeper<[InGroup.Snapshot<TModel>]> {\n\n  abstract readonly on: OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n\n  abstract readonly read: AfterEvent<[InGroup.Snapshot<TModel>]>;\n\n  /**\n   * Sets input control with the given key.\n   *\n   * Replaces existing control if already present.\n   *\n   * @typeParam TKey - Model key type.\n   * @param key - A key of input control to set. I.e. corresponding model property key.\n   * @param control - Input control to add, or `undefined` to remove control.\n   *\n   * @returns A supply of just added control that removes it once cut off. A cut off supply when set to `undefined`.\n   */\n  abstract set<TKey extends keyof TModel>(key: TKey, control: InControl<TModel[TKey]> | undefined): Supply;\n\n  /**\n   * Sets multiple input controls at a time.\n   *\n   * @param controls - A map of controls under their keys. A value can be `undefined` to remove corresponding control.\n   *\n   * @returns A supply of just added controls that removes them once cut off.\n   */\n  abstract set(controls: InGroup.Controls<TModel>): Supply;\n\n  /**\n   * Removes input control with the given key.\n   *\n   * Calling this method is the same as calling `set(key, undefined)`\n   *\n   * @param key - A key of input control to remove. I.e. corresponding model property key.\n   */\n  remove(key: keyof TModel): void {\n    this.set(key, undefined);\n  }\n\n  /**\n   * Removes all input controls.\n   */\n  abstract clear(): void;\n\n}\n\nexport interface InGroupControls<TModel> {\n\n  [OnEvent__symbol](): OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InGroup.Snapshot<TModel>]>;\n\n}\n\n/**\n * @internal\n */\ntype InGroupEntry = readonly [InControl<any>, Supply]; // When event supply is done the control is unused\n\n/**\n * @internal\n */\nconst inControlReplacedReason = {};\n\n/**\n * @internal\n */\nclass InGroupSnapshot<TModel> implements InGroup.Snapshot<TModel>, PushIterable<InControl<any>> {\n\n  private readonly _it: PushIterable<InControl<any>>;\n  private readonly _entriesIt: PushIterable<InGroup.Entry<TModel>>;\n\n  constructor(private readonly _map: Map<keyof TModel, InGroupEntry>) {\n    this._it = mapIt(\n        overIterator(() => this._map.values()),\n        ([control]: InGroupEntry) => control,\n    );\n    this._entriesIt = mapIt(this._map, ([key, [control]]) => [key, control]);\n  }\n\n  get<TKey extends keyof TModel>(key: TKey): InGroup.Controls<TModel>[TKey] | undefined {\n\n    const entry = this._map.get(key);\n\n    return entry && entry[0] as InGroup.Controls<TModel>[TKey];\n  }\n\n  [Symbol.iterator](): PushIterator<InControl<any>> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<InControl<any>>): PushIterator<InControl<any>> {\n    return this._it[PushIterator__symbol](accept);\n  }\n\n  entries(): PushIterator<InGroup.Entry<TModel>> {\n    return iteratorOf(this._entriesIt);\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupMap<TModel extends object> {\n\n  readonly _supply = new Supply();\n  private _map = new Map<keyof TModel, InGroupEntry>();\n  private _shot?: InGroupSnapshot<TModel>;\n\n  constructor(private readonly _controls: InGroupControlControls<TModel>) {\n  }\n\n  set<TKey extends keyof TModel>(\n      key: TKey,\n      control: InControl<TModel[TKey]> | undefined,\n      added: [keyof TModel, InGroupEntry][],\n      removed: [keyof TModel, InGroupEntry][],\n  ): Supply {\n\n    const replaced = this._map.get(key);\n    let supply: Supply;\n\n    if (control) {\n      supply = new Supply();\n\n      const entry = this.newEntry(key, control, supply);\n\n      let sendUpdate = true;\n\n      if (replaced) {\n        if (replaced[0] === control) {\n          // Do not send update when replacing control with itself\n          sendUpdate = false;\n        } else {\n          removed.push([key, replaced]);\n        }\n      }\n\n      if (sendUpdate) {\n        this.modify().set(key, entry);\n        added.push([key, entry]);\n      } else {\n        this._map.set(key, entry);\n      }\n    } else {\n      supply = neverSupply();\n      if (replaced) {\n        removed.push([key, replaced]);\n        this.modify().delete(key);\n      }\n    }\n    if (replaced) {\n      replaced[1].off(inControlReplacedReason);\n    }\n\n    return supply;\n  }\n\n  private newEntry<TKey extends keyof TModel>(\n      key: TKey,\n      control: InControl<TModel[TKey]>,\n      supply: Supply,\n  ): InGroupEntry {\n    return [\n      control,\n      new Supply(reason => {\n        if (reason !== inControlReplacedReason) {\n          this._controls.remove(key);\n        }\n      })\n          .needs(this._supply)\n          .needs(supply)\n          .whenOff(\n              reason => supply.off(reason === inControlReplacedReason ? undefined : reason),\n          ),\n    ];\n  }\n\n  private modify(): Map<keyof TModel, InGroupEntry> {\n    if (this._shot) {\n\n      const map = new Map<keyof TModel, InGroupEntry>();\n\n      itsEach(this._map.entries(), ([k, e]) => map.set(k, e));\n      this._shot = undefined;\n      this._map = map;\n    }\n\n    return this._map;\n  }\n\n  snapshot(): InGroup.Snapshot<TModel> {\n    return this._shot || (this._shot = new InGroupSnapshot<TModel>(this._map));\n  }\n\n  clear(): [keyof TModel, InGroupEntry][] {\n\n    const added: [keyof TModel, InGroupEntry][] = [];\n    const removed: [keyof TModel, InGroupEntry][] = [];\n\n    itsEach(this._map.keys(), key => this.set(key, undefined, added, removed));\n\n    return removed;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InGroupControlControls<TModel extends object> extends InGroupControls<TModel> {\n\n  readonly on: OnEvent<[InGroup.Entry<TModel>[], InGroup.Entry<TModel>[]]>;\n  readonly read: AfterEvent<[InGroup.Snapshot<TModel>]>;\n  private readonly _map: InGroupMap<TModel>;\n  private readonly _updates = new EventEmitter<[[keyof TModel, InGroupEntry][], [keyof TModel, InGroupEntry][]]>();\n\n  constructor(private readonly _group: InGroupControl<TModel>) {\n    super();\n\n    const applyModelToControls = (model: TModel): void => {\n      this.read.do(onceAfter)(snapshot => {\n\n        const withValues = new Set<keyof TModel>();\n\n        itsEach(overEntries(model), ([key, value]) => {\n          withValues.add(key);\n\n          const control = snapshot.get(key);\n\n          if (control) {\n            control.it = value;\n          }\n        });\n\n        itsEach(snapshot.entries(), ([key, control]) => {\n          if (!withValues.has(key)) {\n            control.it = undefined!;\n          }\n        });\n      });\n    };\n\n    this._map = new InGroupMap<TModel>(this);\n\n    this.on = this._updates.on.do(translateOn(\n        (send, added, removed) => send(\n            added.map(controlEntryToGroupEntry),\n            removed.map(controlEntryToGroupEntry),\n        ),\n    ));\n\n    const takeSnapshot = this._map.snapshot.bind(this._map);\n\n    this.read = this._updates.on.do(mapAfter(\n        takeSnapshot,\n        takeSnapshot,\n    ));\n\n    this._map._supply.needs(_group.read(applyModelToControls));\n  }\n\n  set<TKey extends keyof TModel>(\n      keyOrControls: TKey | InGroup.Controls<TModel>,\n      newControl?: InControl<TModel[TKey]> | undefined,\n  ): Supply {\n\n    const group = this._group;\n    const added: [keyof TModel, InGroupEntry][] = [];\n    const removed: [keyof TModel, InGroupEntry][] = [];\n    let supply: Supply;\n\n    if (typeof keyOrControls === 'object') {\n      supply = new Supply();\n      itsEach(overEntries(keyOrControls), ([key, value]) => {\n        this._map.set(key, value, added, removed).needs(supply);\n      });\n    } else {\n      supply = this._map.set(keyOrControls, newControl, added, removed);\n    }\n    if (added.length || removed.length) {\n      this._updates.send(added, removed);\n      if (added.length) {\n        applyControlsToModel();\n      }\n    }\n\n    return supply;\n\n    function applyControlsToModel(): void {\n\n      let newModel: TModel | undefined;\n\n      added.forEach(<TKey extends keyof TModel>(keyAndEntry: [keyof TModel, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [TKey, [InControl<TModel[TKey]>, Supply]];\n\n        control.aspect(InParents).add({ parent: group }).as(supply);\n\n        const value = control.it;\n\n        if (newModel) {\n          newModel[key] = value;\n        } else {\n\n          const model = group.it;\n\n          if (model[key] !== value) {\n            newModel = { ...model, [key]: value };\n          }\n        }\n      });\n\n      if (newModel) {\n        group.it = newModel;\n      }\n\n      added.forEach(<TKey extends keyof TModel>(keyAndEntry: [keyof TModel, InGroupEntry]) => {\n\n        const [key, [control, supply]] = keyAndEntry as [TKey, [InControl<TModel[TKey]>, Supply]];\n\n        control.read.do(supplyAfter(supply))(value => {\n          if (group.it[key] !== value) {\n            group.it = {\n              ...group.it,\n              [key]: value,\n            };\n          }\n        }).cuts(supply);\n      });\n    }\n  }\n\n  clear(): void {\n\n    const removed = this._map.clear();\n\n    if (removed.length) {\n      this._updates.send([], removed);\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction controlEntryToGroupEntry<TModel extends object>(\n    [key, [control]]: [keyof TModel, InGroupEntry],\n): InGroup.Entry<TModel> {\n  return [key, control];\n}\n\n/**\n * @internal\n */\nclass InGroupControl<TModel extends object> extends InGroup<TModel> {\n\n  private readonly _model: ValueTracker<TModel>;\n  readonly controls: InGroupControlControls<TModel>;\n\n  constructor(\n      model: TModel,\n      opts: {\n        readonly aspects?: InConverter.Aspect<TModel> | readonly InConverter.Aspect<TModel>[];\n      },\n  ) {\n    super(opts);\n    this._model = trackValue(model);\n    this.controls = new InGroupControlControls(this);\n    this.supply.whenOff(() => this.controls.clear());\n  }\n\n  get supply(): Supply {\n    return this._model.supply;\n  }\n\n  get it(): TModel {\n    return this._model.it;\n  }\n\n  set it(value: TModel) {\n    this._model.it = value;\n  }\n\n  get on(): OnEvent<[TModel, TModel]> {\n    return this._model.on;\n  }\n\n  protected _applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n      aspect: InAspect<any, any>,\n  ): InAspect.Application.Result<TInstance, TModel, TKind> | undefined {\n    if (aspect === InData[InAspect__symbol]) {\n      return {\n        instance: inGroupData(this),\n        convertTo: noop,\n      } as InAspect.Application.Result<any, any, any>;\n    }\n    return super._applyAspect(aspect);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction inGroupData<TModel extends object>(group: InGroup<TModel>): InData<TModel> {\n  return afterAll({\n    cs: group.controls,\n    model: group,\n    mode: group.aspect(InMode),\n  }).do(\n      digAfter_(readInGroupData),\n  );\n}\n\n/**\n * @internal\n */\nfunction readInGroupData<TModel extends object>(\n    {\n      cs: [controls],\n      model: [model],\n      mode: [mode],\n    }: {\n      cs: [InGroup.Snapshot<TModel>];\n      model: [TModel];\n      mode: [InMode.Value];\n    },\n): AfterEvent<[InData.DataType<TModel>?]> {\n  if (!InMode.hasData(mode)) {\n    return afterThe();\n  }\n\n  const csData = {} as { [key in keyof TModel]: InData<any> };\n\n  itsEach(controls.entries(), ([key, control]) => {\n    csData[key as keyof TModel] = control.aspect(InData);\n  });\n\n  return afterAll(csData).do(mapAfter(controlsData => {\n\n    const data: Partial<TModel> = { ...model };\n\n    itsEach(\n        overEntries(controlsData),\n        <TKey extends keyof TModel>(keyAndControlData: readonly [keyof TModel, [InData.DataType<any>?]]) => {\n\n          const [key, [controlData]] = keyAndControlData as readonly [TKey, [TModel[TKey]?]];\n\n          data[key] = controlData;\n        },\n    );\n\n    return data as InData.DataType<TModel>;\n  }));\n}\n\n/**\n * Constructs input controls group.\n *\n * @category Control\n * @typeParam TModel - Group model type, i.e. its value type.\n * @param model - Initial model of the group.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from {@link inValueOf same-valued one}.\n *\n * @returns New input controls group.\n */\nexport function inGroup<TModel extends object>(\n    model: TModel,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<TModel> | readonly InConverter.Aspect<TModel>[];\n    } = {},\n): InGroup<TModel> {\n  return new InGroupControl(model, { aspects });\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input control group application type.\n       */\n      group(): InGroup<TValue extends object ? TValue : never> | null;\n\n    }\n\n  }\n\n}\n","import { AfterEvent, afterThe } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\nconst RequireNothing$ = (/*#__PURE__*/ afterThe<[]>());\n\n/**\n * Input validator that requires nothing.\n *\n * @category Validation\n */\nexport function requireNothing(): AfterEvent<[]> {\n  return RequireNothing$;\n}\n","import {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  EventEmitter,\n  EventKeeper,\n  shareAfter,\n  supplyAfter,\n} from '@proc7ts/fun-events';\nimport { noop, valuesProvider } from '@proc7ts/primitives';\nimport { flatMapIt, itsEach } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { inValidator, InValidator } from './validator';\n\nconst dontRemove = {};\n\n/**\n * @internal\n */\nexport class InValidationMessages<TValue> implements EventKeeper<InValidation.Message[]> {\n\n  readonly _messages: AfterEvent<InValidation.Message[]>;\n  readonly from: (this: void, validator: InValidator<TValue>) => Supply;\n\n  constructor(control: InControl<TValue>) {\n\n    const emitter = new EventEmitter<InValidation.Message[]>();\n    const validators = new Map<AfterEvent<InValidation.Message[]>, Supply>();\n    const validatorMessages = new Map<InValidator<TValue>, InValidation.Message[]>();\n    // Sends validation messages\n    let send: () => void = noop;\n    // Validates using the given validator\n    let validate: (validator: AfterEvent<InValidation.Message[]>, validatorSupply: Supply) => void = noop;\n\n    this._messages = afterEventBy<InValidation.Message[]>(receiver => {\n\n      // Validation messages supply\n      const resultSupply = afterSupplied(emitter, valuesProvider())(receiver).whenOff(() => {\n        send = noop; // Disable message sending\n        validate = noop; // Disable validation\n      });\n\n      // Enable validation using the given validator\n      validate = (validator: AfterEvent<InValidation.Message[]>, validatorSupply: Supply) => {\n\n        const supply = validator(\n            (...messages) => {\n              if (messages.length) {\n                // Replace messages reported by validator.\n                validatorMessages.set(validator, messages);\n              } else if (!validatorMessages.delete(validator)) {\n                // Nothing removed. No need to send messages\n                return;\n              }\n              send(); // Send all messages.\n            },\n        )\n            .needs(validatorSupply)\n            .whenOff(reason => {\n              if (reason !== dontRemove) {\n                validatorSupply.off(reason);\n              }\n              if (validatorMessages.delete(validator)) {\n                // Send all messages only if the removed validator reported some messages earlier\n                send();\n              }\n            });\n\n        resultSupply.whenOff(() => supply.off(dontRemove));\n      };\n\n      // Enable each validator\n      itsEach(validators.entries(), ([validator, validatorSupply]) => validate(validator, validatorSupply));\n\n      // Enable message sending\n      send = () => {\n        emitter.send(...allMessages());\n      };\n\n      // Send messages if present already\n      if (validatorMessages.size) {\n        send();\n      }\n    }).do(\n        shareAfter,\n        supplyAfter(control),\n    );\n\n    this.from = validator => {\n\n      const source = inValidator(validator)(control);\n      const validatorSupply = new Supply(() => {\n        validators.delete(source);\n      });\n\n      validators.set(source, validatorSupply);\n      validate(source, validatorSupply); // Start validation using validator\n\n      return validatorSupply.needs(control);\n    };\n\n    function allMessages(): Iterable<InValidation.Message> {\n      return flatMapIt(validatorMessages.values());\n    }\n  }\n\n  [AfterEvent__symbol](): AfterEvent<InValidation.Message[]> {\n    return this._messages;\n  }\n\n}\n","import { AfterEvent, afterSupplied, EventKeeper, isEventKeeper, translateAfter } from '@proc7ts/fun-events';\nimport { arrayOfElements, valueProvider } from '@proc7ts/primitives';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\n\n/**\n * Input validator.\n *\n * Validator can be added to input validation aspect using `InValidation.by()` method. After that all validation\n * messages it sends are reported by validation aspect. Multiple messages could be sent at a time. These messages\n * replace the previously sent ones. To report the absence of error just send an empty event without messages.\n *\n * This can be one either a validation messages event keeper, a function returning one and accepting input control\n * as its only parameter, or simple validator instance.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n */\nexport type InValidator<TValue> =\n    | EventKeeper<InValidation.Message[]>\n    | ((this: void, control: InControl<TValue>) => EventKeeper<InValidation.Message[]>)\n    | InValidator.Simple<TValue>;\n\n/**\n * @category Validation\n */\nexport namespace InValidator {\n\n  /**\n   * Simple input validator.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Simple<TValue> {\n\n    /**\n     * Validates the user input.\n     *\n     * This method is called each time input value changes. The returned messages then reported by input validation\n     * aspect.\n     *\n     * @param control - Input control to validate.\n     *\n     * @returns Either validation message, array of validation messages, or `null`/`unknown` to indicate their absence.\n     */\n    validate(control: InControl<TValue>): InValidation.Message | InValidation.Message[] | null | undefined;\n\n  }\n\n}\n\n/**\n * Converts arbitrary input validator to normalized form.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validator - Validator to convert.\n *\n * @returns A function accepting input control as its only parameter and returning an `AfterEvent` keeper of validation\n * messages.\n */\nexport function inValidator<TValue>(\n    validator: InValidator<TValue>,\n): (this: void, control: InControl<TValue>) => AfterEvent<InValidation.Message[]> {\n  if (isEventKeeper(validator)) {\n    return valueProvider(afterSupplied(validator));\n  }\n  if (typeof validator === 'function') {\n    return control => afterSupplied(validator(control));\n  }\n\n  return control => control.read.do(\n      translateAfter(send => send(...arrayOfElements(validator.validate(control)))),\n  );\n}\n","import {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterSupplied,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport {\n  flatMapArray,\n  itsEach,\n  mapIt,\n  overArray,\n  overEntries,\n  overNone,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { builtInAspect } from '../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../aspect';\nimport { InContainer } from '../containers';\nimport { InControl } from '../control';\nimport { requireAll } from './require-all.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * @internal\n */\nconst InValidation__aspect: InAspect<InValidation<any>, 'validation'> = {\n  applyTo<TValue>(control: InControl<TValue>) {\n    return builtInAspect<TValue, InValidation<TValue>, 'validation'>(\n        control,\n        InValidation,\n        <TValue>(ctrl: InControl<TValue>, origin?: InControl<any>): InValidation<any> => {\n\n          const validation = new InControlValidation<TValue>(ctrl);\n\n          if (origin) {\n            validation.by(\n                origin.aspect(InValidation).read.do(\n                    translateAfter((send, result) => send(...result.messages())),\n                ),\n            );\n          }\n\n          return validation;\n        },\n    );\n  },\n};\n\n/**\n * Validation aspect of the input.\n *\n * Reports validation messages sent by registered validators. To register validator call a `InValidation.by()` method.\n *\n * Implements an `EventKeeper` interface by sending validation result whenever validation messages reported.\n *\n * A validation aspect of converted control reports all messages from original control in addition to its own.\n *\n * A validation aspect of input controls container reports all messages from nested controls in addition to its own.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport abstract class InValidation<TValue> implements EventKeeper<[InValidation.Result]> {\n\n  /**\n   * Input validation aspect.\n   */\n  static get [InAspect__symbol](): InAspect<InValidation<any>, 'validation'> {\n    return InValidation__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input validation result.\n   *\n   * An `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InValidation.Result]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InValidation.Result]> {\n    return this.read;\n  }\n\n  /**\n   * Validates the input using the given validators.\n   *\n   * Messages sent by each registered validator are handled independently. This means that every time the event received\n   * from validator, it replaces the list of validation messages reported previously by the same validator. But it never\n   * affects messages received from other validators.\n   *\n   * @param validators - Input validators to use.\n   *\n   * @returns Validators supply. Removes validators and their messages once cut off.\n   */\n  abstract by(...validators: InValidator<TValue>[]): Supply;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InValidation {\n\n  /**\n   * Input validation messages.\n   *\n   * This is a map of key/value pairs, where the key is a message code, while the value is arbitrary. Message codes\n   * are ignored when their values are falsy (i.e. `!message[code] === true`).\n   *\n   * Some message codes are treated specially by convenience.\n   */\n  export type Message = {\n    readonly [code in Extract<keyof GenericMessage, string>]?: any;\n  };\n\n  /**\n   * Generic input validation messages.\n   */\n  export interface GenericMessage {\n\n    readonly [code: string]: any;\n\n    /**\n     * Missing input.\n     */\n    readonly missing?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `missing` code.\n     */\n    readonly despiteMissing?: any;\n\n    /**\n     * Incomplete input, except missing one.\n     */\n    readonly incomplete?: any;\n\n    /**\n     * The message with this code would be reported by `requireNeeded()` validator despite there are messages with\n     * `incomplete` code.\n     */\n    readonly despiteIncomplete?: any;\n\n    /**\n     * Invalid input, except missing or incomplete one.\n     */\n    readonly invalid?: any;\n\n    /**\n     * Submit failure.\n     *\n     * This is set by input submit aspect.\n     */\n    readonly submit?: any;\n\n  }\n\n  /**\n   * Input validation result.\n   *\n   * Combines messages sent by all registered validators.\n   *\n   * Implements `Iterable` interface by iterating over all validation messages.\n   */\n  export interface Result extends Iterable<Message> {\n\n    /**\n     * Whether validation succeed.\n     *\n     * This is `true` when there is no validation messages, or `false` otherwise.\n     */\n    readonly ok: boolean;\n\n    /**\n     * Returns messages with the given code.\n     *\n     * @param code - Target code. All messages reported when absent.\n     *\n     * @returns An array of matching messages. Possibly empty.\n     */\n    messages(code?: string): readonly Message[];\n\n    /**\n     * Checks whether there are errors with the given code.\n     *\n     * @param code - Target code. Any message matches when absent.\n     *\n     * @returns `true` if there is at least one message with the given code, or `false` otherwise.\n     */\n    has(code?: string): boolean;\n\n    /**\n     * Checks whether there are errors without the given codes.\n     *\n     * @param codes - Excluded codes. Any message matches when empty.\n     *\n     * @returns `true` is there is at least one message without any of the given codes, or `false` otherwise.\n     */\n    hasBut(...codes: string[]): boolean;\n\n    [Symbol.iterator](): IterableIterator<Message>;\n\n  }\n\n  /**\n   * Successful input validation result.\n   */\n  export interface Ok extends Result {\n\n    readonly ok: true;\n\n  }\n\n  /**\n   * Unsuccessful input validation result.\n   */\n  export interface Errors extends Result {\n\n    readonly ok: false;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst noInValidationErrors: InValidation.Result & PushIterable<InValidation.Message> = {\n  get ok() {\n    return true;\n  },\n  messages() {\n    return [];\n  },\n  has() {\n    return false;\n  },\n  hasBut() {\n    return false;\n  },\n  [Symbol.iterator](): PushIterator<InValidation.Message> {\n    return overNone();\n  },\n  [PushIterator__symbol](_accept): PushIterator<InValidation.Message> {\n    return overNone();\n  },\n};\n\n/**\n * @internal\n */\nclass InValidationErrors implements InValidation.Result, PushIterable<InValidation.Message> {\n\n  private readonly _all: InValidation.Message[];\n  private readonly _it: PushIterable<InValidation.Message>;\n  private readonly _byCode = new Map<string, InValidation.Message[]>();\n\n  constructor(messages: InValidation.Message[]) {\n    this._all = [];\n    this._it = overArray(this._all);\n    messages.forEach(message => {\n\n      let nonEmpty = false;\n\n      itsEach(overEntries(message), ([code, codePresent]) => {\n        if (codePresent) {\n          nonEmpty = true;\n\n          const prev = this._byCode.get(code);\n\n          if (prev) {\n            prev.push(message);\n          } else {\n            this._byCode.set(code, [message]);\n          }\n        }\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (nonEmpty) {\n        this._all.push(message);\n      }\n    });\n  }\n\n  get ok(): boolean {\n    return !this._all.length;\n  }\n\n  messages(code?: string): InValidation.Message[] {\n    return code == null ? this._all : this._byCode.get(code) || [];\n  }\n\n  has(code?: string): boolean {\n    return code == null || this._byCode.has(code);\n  }\n\n  hasBut(...codes: string[]): boolean {\n    return this._all.some(\n        message => codes.every(code => !message[code]),\n    );\n  }\n\n  [Symbol.iterator](): PushIterator<InValidation.Message> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<InValidation.Message>): PushIterator<InValidation.Message> {\n    return this._it[PushIterator__symbol](accept);\n  }\n\n}\n\n/**\n * Returns successful input validation result.\n *\n * @category Validation\n * @returns Successful input validation result.\n */\nexport function inValidationResult(): InValidation.Ok;\n\n/**\n * Creates input validation result out of validation messages.\n *\n * @param messages - Input validation messages.\n *\n * @returns New input validation result containing the given `messages`.\n */\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result;\n\nexport function inValidationResult(...messages: InValidation.Message[]): InValidation.Result {\n  return messages.length ? new InValidationErrors(messages) : noInValidationErrors;\n}\n\n/**\n * @internal\n */\nclass InControlValidation<TValue> extends InValidation<TValue> {\n\n  readonly _messages: InValidationMessages<TValue>;\n  readonly read: AfterEvent<[InValidation.Result]>;\n\n  constructor(control: InControl<TValue>) {\n    super();\n    this._messages = new InValidationMessages(control);\n\n    this.read = afterSupplied(this._messages).do<AfterEvent<[InValidation.Result]>>(\n        mapAfter(inValidationResult),\n    );\n\n    const container = control.aspect(InContainer);\n\n    if (container) {\n      this._messages.from(nestedInValidationMessages(container));\n    }\n  }\n\n  by(...validators: InValidator<TValue>[]): Supply {\n    return this._messages.from(requireAll(...validators));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction nestedInValidationMessages(container: InContainer<any>): EventKeeper<InValidation.Message[]> {\n  return container.controls.read.do(\n      digAfter_(controls => afterEach(...mapIt(controls, control => control.aspect(InValidation)))),\n      translateAfter((send, ...results) => send(...flatMapArray(results, ([result]) => result))),\n  );\n}\n\ndeclare module '../aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input validation aspect application type.\n       */\n      validation(): InValidation<TValue>;\n\n    }\n\n  }\n\n}\n","import { InControl } from '../control';\nimport { requireNothing } from './require-nothing.validator';\nimport { InValidator } from './validator';\nimport { InValidationMessages } from './validator.impl';\n\n/**\n * Creates input validator that validates using all listed validators.\n *\n * @category Validation\n * @typeParam TValue - Input value type.\n * @param validators - Validators to validate the input with.\n *\n * @returns Validator that requires all the given `validators`. Or just the given validator if it is the only one given.\n */\nexport function requireAll<TValue>(...validators: InValidator<TValue>[]): InValidator<TValue> {\n\n  const numValidators = validators.length;\n\n  if (numValidators === 1) {\n    return validators[0];\n  }\n  if (!numValidators) {\n    return requireNothing;\n  }\n\n  return (control: InControl<TValue>) => {\n\n    const messages = new InValidationMessages(control);\n\n    validators.forEach(validator => messages.from(validator));\n\n    return messages;\n  };\n}\n","import { EventKeeper, translateAfter } from '@proc7ts/fun-events';\nimport { InControl } from '../control';\nimport { InValidation } from './validation.aspect';\nimport { InValidator } from './validator';\n\n/**\n * Creates input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n *\n * @category Validation\n */\nexport function requirePresent(): InValidator<any>;\n\n/**\n * Input validator that requires value to present.\n *\n * Reports empty (falsy) values with `missing` message code.\n */\nexport function requirePresent(control: InControl<any>): EventKeeper<InValidation.Message[]>;\n\nexport function requirePresent(\n    control?: InControl<any>,\n): InValidator<any> | EventKeeper<InValidation.Message[]> {\n  return control\n      ? control.read.do(\n          translateAfter((send, value) => value ? send() : send({ missing: 'missing' })),\n      )\n      : requirePresent;\n}\n","import {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  mapAfter,\n  supplyAfter,\n  trackValue,\n  translateAfter,\n} from '@proc7ts/fun-events';\nimport { itsEvery } from '@proc7ts/push-iterator';\nimport { builtInAspect } from './applied-aspect';\nimport { InAspect, InAspect__symbol } from './aspect';\nimport { InControl } from './control';\nimport { InData } from './data';\nimport { InValidation, inValidationResult } from './validation';\n\n/**\n * @internal\n */\nconst InSubmit__aspect: InAspect<InSubmit<any>, 'submit'> = {\n  applyTo<TValue>(control: InControl<TValue>) {\n    return builtInAspect(control, InSubmit, ctrl => new InControlSubmit(ctrl));\n  },\n};\n\n/**\n * Input submit error.\n *\n * Contains submit messages as validation result.\n *\n * @category Aspect\n */\nexport class InSubmitError extends Error {\n\n  /**\n   * Input submit errors.\n   */\n  readonly errors: InValidation.Errors;\n\n  /**\n   * Constructs input submit error.\n   *\n   * @param errors - Input submit error messages. A `submit` code will be added to each of them, unless already present.\n   */\n  constructor(...errors: [InValidation.Message, ...InValidation.Message[]]) {\n    super();\n    this.errors = inValidationResult(\n        ...errors.map(message => message.submit ? message : { ...message, submit: true }),\n    ) as InValidation.Errors;\n  }\n\n}\n\n/**\n * Input submit rejection error.\n *\n * Raised if submit is not ready or in process already.\n *\n * @category Aspect\n */\nexport class InSubmitRejectedError extends InSubmitError {\n\n  /**\n   * Constructs input submit rejection error.\n   *\n   * @param reason - A reason code.\n   */\n  constructor(reason: string) {\n    super({ submit: 'rejected', rejected: reason, [reason]: true });\n  }\n\n}\n\n/**\n * Input submit aspect.\n *\n * Allows to submit {@link InData input data} and reports submit status.\n *\n * Implements an `EventKeeper` interface by sending submit status flags to registered receivers.\n *\n * @category Aspect\n * @typeParam TValue - Input value type.\n */\nexport abstract class InSubmit<TValue> implements EventKeeper<[InSubmit.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InSubmit<any>, 'submit'> {\n    return InSubmit__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of submit status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InSubmit.Flags]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InSubmit.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Attempts to submit the input data.\n   *\n   * 1. Sets `submitted` status flag.\n   * 2.1. Rejects to submit if `busy` status flag is set, or if `ready` status flag is not set with\n   *      [InSubmitRejectedError].\n   *      Note that the latter mey be reset after the step 1. So this check is performed asynchronously.\n   * 2.2. Otherwise, sets the `busy` status flag.\n   * 3. Clears submit failure messages.\n   * 4. Calls `submitter` function.\n   * 5. Waits for the promise returned by `submitter` to resolve.\n   * 5.1. Resolves the result promise if submit were successful.\n   * 5.2. Otherwise, reports submit failure messages.\n   * 6. Rejects the result promise.\n   *\n   * @typeParam TResult - Submit result value type.\n   * @param submitter - A submitter function that performs actual submit.\n   *\n   * @returns Submit result promise.\n   */\n  abstract submit<TResult>(submitter: InSubmit.Submitter<TValue, TResult>): Promise<TResult>;\n\n  /**\n   * Resets the submit.\n   *\n   * Clears submit failure messages. Resets `submitted` flag.\n   */\n  abstract reset(): void;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InSubmit {\n\n  /**\n   * Input submit status flags.\n   *\n   * The flags of nested control are combined with parent ones.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input is ready to be submitted.\n     *\n     * The submit won't happen until this flag becomes `true`.\n     *\n     * This is `true` when there is a data to submit, and no validation messages (except submit failure messages with\n     * `submit` code).\n     */\n    ready: boolean;\n\n    /**\n     * Whether the input has been submitted.\n     *\n     * This becomes `true` on `InSubmit.submit()` method call. And becomes `false` on `InSubmit.reset()` method call.\n     */\n    submitted: boolean;\n\n    /**\n     * Whether the submit is in process.\n     *\n     * This becomes `true` when submit is initiated by `InSubmit.submit()` method call. And becomes `false` when submit\n     * is completed.\n     */\n    busy: boolean;\n\n  }\n\n  /**\n   * Input submitter function interface.\n   *\n   * A submitter is passed to `InSubmit.submit()` method to perform the actual submit.\n   *\n   * A submit failure (a returned promise rejection) is reported as validation messages. This can be either a\n   * [InSubmitError], or arbitrary error. Previously reported submit messages are replaced by the reported ones,\n   * and cleared on a new submit.\n   *\n   * @typeParam TValue - Input value type.\n   * @typeParam TResult - Submit result value type.\n   */\n  export type Submitter<TValue, TResult> =\n  /**\n   * @param data - Input data to submit.\n   * @param control - Input control the submit is performed for.\n   *\n   * @returns Submit result promise.\n   */\n      (\n          this: void,\n          data: TValue extends undefined ? never : TValue,\n          control: InControl<TValue>,\n      ) => Promise<TResult>;\n\n}\n\nclass InControlSubmit<TValue> extends InSubmit<TValue> {\n\n  readonly read: AfterEvent<[InSubmit.Flags]>;\n  private readonly _flags = trackValue({ submitted: false, busy: false });\n  private readonly _errors = trackValue<InValidation.Message[]>([]);\n\n  constructor(private readonly _control: InControl<TValue>) {\n    super();\n    this.read = afterAll({\n      flags: this._flags,\n      data: this._control.aspect(InData),\n      messages: this._control.aspect(InValidation),\n    }).do(\n        supplyAfter(this._control),\n        mapAfter(({\n          flags: [flags],\n          data: [data],\n          messages: [messages],\n        }): InSubmit.Flags => ({\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          ready: data !== undefined && (messages.ok || itsEvery(messages, message => message.submit)),\n          submitted: flags.submitted,\n          busy: flags.busy,\n        })),\n    );\n\n    const validation = _control.aspect(InValidation);\n\n    validation.by(this._errors.read.do(\n        translateAfter((send, messages) => send(...messages)),\n    ));\n  }\n\n  async submit<TResult>(submitter: InSubmit.Submitter<TValue, TResult>): Promise<TResult> {\n    if (this._control.supply.isOff) {\n      throw new InSubmitRejectedError('noInput');\n    }\n    if (this._flags.it.busy) {\n      throw new InSubmitRejectedError('busy');\n    }\n\n    const submit = this;\n    const control = this._control;\n    let errors: InValidation.Message[] | undefined;\n\n    this._flags.it = { ...this._flags.it, submitted: true, busy: true };\n    try {\n      if (this._errors.it.length) {\n        this._errors.it = [];\n      }\n      return await submitter(await submitData(), control);\n    } catch (error) {\n      errors = toInSubmitMessages(error);\n      throw error;\n    } finally {\n      this._flags.it = { ...this._flags.it, busy: false };\n      if (errors) {\n        this._errors.it = errors;\n      }\n    }\n\n    async function submitData(): Promise<TValue extends undefined ? never : TValue> {\n\n      const { data: [d], flags: [{ ready }] } = await afterAll({\n        data: control.aspect(InData),\n        flags: submit,\n      });\n\n      return ready\n          ? d as any\n          : Promise.reject(new InSubmitRejectedError('notReady'));\n    }\n  }\n\n  reset(): void {\n\n    const flags = this._flags.it;\n\n    if (flags.submitted) {\n      this._flags.it = { ...flags, submitted: false };\n    }\n    if (this._errors.it.length) {\n      this._errors.it = [];\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction toInSubmitMessages(error: any): InValidation.Message[] {\n  if (error instanceof InSubmitError) {\n    return [...error.errors];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  return [{ submit: error }];\n}\n\ndeclare module './aspect' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Input submit aspect application type.\n       */\n      submit(): InSubmit<TValue>;\n\n    }\n\n  }\n\n}\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { AfterEvent, EventEmitter, mapAfter, OnEvent, translateOn } from '@proc7ts/fun-events';\nimport { asis } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { InConverter } from '../converter';\nimport { InElement } from '../element.control';\n\n/**\n * Abstract implementation of {@link InElement input HTML element control}.\n *\n * @category Control\n * @typeParam TValue - Input value type.\n * @typeParam TElt - A type of input HTML element.\n */\nexport class AbstractInElement<TValue, TElt extends HTMLElement> extends InElement<TValue, TElt> {\n\n  readonly events: DomEventDispatcher;\n  readonly input: AfterEvent<[InElement.Input<TValue>]>;\n  readonly on: OnEvent<[TValue, TValue]>;\n  private readonly _get: (this: AbstractInElement<TValue, TElt>) => TValue;\n  private readonly _set: (this: AbstractInElement<TValue, TElt>, value: TValue) => void;\n  private readonly _input: EventEmitter<[InElement.Input<TValue>, TValue]> = new EventEmitter();\n  private _value: TValue;\n  private _update: (value: TValue, oldValue: TValue) => void;\n\n  /**\n   * Constructs HTML input element control.\n   *\n   * @param element - HTML input element the constructed control is based on.\n   * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n   * from the {@link inValueOf same-valued one}.\n   * @param get - Input value getter.\n   * @param set - Input value setter.\n   */\n  constructor(\n      readonly element: TElt,\n      {\n        aspects,\n        get,\n        set,\n      }: {\n        readonly aspects?: InConverter.Aspect<TValue> | readonly InConverter.Aspect<TValue>[];\n        readonly get: (this: AbstractInElement<TValue, TElt>) => TValue;\n        readonly set: (this: AbstractInElement<TValue, TElt>, value: TValue) => void;\n      },\n  ) {\n    super({ aspects });\n\n    const self = this;\n\n    this._get = get;\n    this._set = set;\n    this._value = this.it;\n\n    const doUpdate = this._update = (value: TValue, oldValue: TValue): void => update({ value }, oldValue);\n\n    this.events = new DomEventDispatcher(element);\n    this.events.supply.needs(this);\n    this.listenForInput(input => update(input, this._value));\n\n    this.on = this._input.on.do(\n        translateOn((\n            send,\n            { value: newValue },\n            oldValue,\n        ) => newValue !== oldValue && send(newValue, oldValue)),\n    );\n    this.input = this._input.on.do(mapAfter(asis, () => ({ value: this.it })));\n\n    function update(input: InElement.Input<TValue>, oldValue: TValue): void {\n      for (;;) {\n        self._value = input.value;\n\n        // Corrections are value updates performed by update event receivers\n        // The last correction is recorded and sent later, when all receivers receive current update\n        let correction: [InElement.Input<TValue>, TValue] | undefined;\n\n        // Record corrections\n        self._update = (newValue: TValue, old: TValue) => {\n          // Corrections retain the event instance\n          correction = [{ ...input, value: newValue }, old];\n        };\n        try {\n          self._input.send(input, oldValue);\n        } finally {\n          self._update = doUpdate;\n        }\n\n        if (!correction) {\n          break; // No more corrections\n        }\n\n        // Apply last correction\n        // noinspection JSUnusedAssignment\n        [input, oldValue] = correction;\n      }\n    }\n  }\n\n  get supply(): Supply {\n    return this._input.supply;\n  }\n\n  get it(): TValue {\n    return this._get();\n  }\n\n  set it(value: TValue) {\n\n    const oldValue = this.it;\n\n    if (value !== oldValue) {\n      this._set(value);\n      this._update(this._get(), oldValue);\n    }\n  }\n\n  /**\n   * Enables reaction to input input.\n   *\n   * By default listens for `input` and `change` events.\n   *\n   * @param update - Updates current value by user input and sends update event. This function is to be called by\n   * input event listeners.\n   */\n  protected listenForInput(update: (input: InElement.Input<TValue>) => void): void {\n\n    const onInput = (event: Event): void => update({ value: this.it, event });\n\n    this.events.on('input')(onInput);\n    this.events.on('change')(onInput);\n  }\n\n}\n","import { InConverter } from '../converter';\nimport { InElement } from '../element.control';\nimport { AbstractInElement } from './abstract-element.control';\n\n/**\n * Textual input control.\n *\n * @category Control\n */\nexport type InText = InElement<string, InText.Element>;\n\n/**\n * @category Control\n */\nexport namespace InText {\n\n  /**\n   * Text input element.\n   *\n   * Either `<input>`, `<textarea>`, or `<select>`.\n   */\n  export type Element = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n}\n\n/**\n * Creates control for the given textual input element.\n *\n * Note that this won't work for files, checkboxes, or radio buttons.\n *\n * For `<select multiple>` this would only reflect the first option. Consider to use `inSelect()` for multi-selects.\n *\n * @category Control\n * @param element - Target text input element.\n * @param aspects - Input aspects applied by default. These are aspect converters to constructed control\n * from the {@link inValueOf same-valued one}.\n *\n * @return New textual input control instance.\n */\nexport function inText(\n    element: InText.Element,\n    {\n      aspects,\n    }: {\n      readonly aspects?: InConverter.Aspect<string> | readonly InConverter.Aspect<string>[];\n    } = {},\n): InText {\n  return new AbstractInElement(\n      element,\n      {\n        get(): string {\n          return this.element.value;\n        },\n        set(value) {\n          this.element.value = value;\n        },\n        aspects,\n      },\n  );\n}\n","import { OnEvent, trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { builtInAspect } from '../../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\n\n/**\n * @internal\n */\nconst InFocus__aspect: InAspect<InFocus | null> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InFocus | null> {\n    return builtInAspect(control, InFocus, ctrl => {\n\n      const element = ctrl.aspect(InElement);\n\n      return element && new InControlFocus(element);\n    });\n  },\n\n};\n\n/**\n * Input focus aspect.\n *\n * This is a value tracker of element focus flag. Or `null` when {@link InElement} aspect is absent.\n *\n * @category Aspect\n */\nexport abstract class InFocus extends ValueTracker<boolean> {\n\n  static get [InAspect__symbol](): InAspect<InFocus | null> {\n    return InFocus__aspect;\n  }\n\n}\n\n/**\n * @internal\n */\nclass InControlFocus extends InFocus {\n\n  private readonly _it: ValueTracker<boolean>;\n\n  constructor(inElement: InElement<any>) {\n    super();\n\n    const { element, events } = inElement;\n    const owner: DocumentOrShadowRoot = element.getRootNode\n        ? element.getRootNode() as unknown as DocumentOrShadowRoot\n        : element.ownerDocument;\n\n    this._it = trackValue(owner.activeElement === element);\n    this.supply.needs(inElement);\n\n    events.on('focus')(() => this._it.it = true);\n    events.on('blur')(() => this._it.it = false);\n    this.on({\n      receive(ctx, newValue) {\n        ctx.onRecurrent(noop);\n        if (newValue) {\n          element.focus();\n        } else {\n          element.blur();\n        }\n      },\n    });\n  }\n\n  get supply(): Supply {\n    return this._it.supply;\n  }\n\n  get it(): boolean {\n    return this._it.it;\n  }\n\n  set it(value: boolean) {\n    this._it.it = value;\n  }\n\n  get on(): OnEvent<[boolean, boolean]> {\n    return this._it.on;\n  }\n\n}\n","import {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  digAfter_,\n  EventKeeper,\n  mapAfter,\n  onceAfter,\n  supplyAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { itsEach, mapIt } from '@proc7ts/push-iterator';\nimport { builtInAspect } from '../../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InContainer } from '../../containers';\nimport { InControl } from '../../control';\nimport { InElement } from '../../element.control';\nimport { InFocus } from './focus.aspect';\n\n/**\n * @internal\n */\nconst InStatus__aspect: InAspect<InStatus> = {\n\n  applyTo<TValue>(control: InControl<TValue>): InAspect.Applied<TValue, InStatus> {\n    return builtInAspect(control, InStatus, ctrl => {\n\n      const container = ctrl.aspect(InContainer);\n\n      return container != null ? new InContainerStatus(container) : new InControlStatus(ctrl);\n    });\n  },\n\n};\n\n/**\n * Aggregate status aspect of user input.\n *\n * Collects and reports input status flags. Like whether the input ever had focus or being altered.\n *\n * Supports input elements and containers. For the rest of input controls always sends default status flags.\n *\n * Implements `EventKeeper` interface by sending collected status flags to receivers.\n *\n * @category Aspect\n */\nexport abstract class InStatus implements EventKeeper<[InStatus.Flags]> {\n\n  static get [InAspect__symbol](): InAspect<InStatus> {\n    return InStatus__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of input status flags.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InStatus.Flags]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InStatus.Flags]> {\n    return this.read;\n  }\n\n  /**\n   * Marks the input as touched.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param touched - Whether to mark the input as touched or not. `true` by default. When `false` the input would be\n   * marked as non-edited too. Setting to `false` affects only edited flag when input has focus.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markTouched(touched?: boolean): this;\n\n  /**\n   * Marks the input as edited by user.\n   *\n   * For container invokes this method for each of the nested controls.\n   *\n   * @param edited - Whether to mark the input as edited by user. `true` by default, in which case the input will be\n   * marked as touched as well.\n   *\n   * @returns `this` aspect instance.\n   */\n  abstract markEdited(edited?: boolean): this;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InStatus {\n\n  /**\n   * A flags representing aggregated input status.\n   */\n  export interface Flags {\n\n    /**\n     * Whether the input has focus currently.\n     */\n    readonly hasFocus: boolean;\n\n    /**\n     * Whether the input had focus already.\n     *\n     * This flag can be set using `InStatus.markTouched()`.\n     */\n    readonly touched: boolean;\n\n    /**\n     * Whether the input has been edited by user.\n     *\n     * This flag can be set using `InStatus.markEdited()`.\n     */\n    readonly edited: boolean;\n\n  }\n\n}\n\n/**\n * @internal\n */\nconst defaultInStatusFlags: InStatus.Flags = {\n  hasFocus: false,\n  touched: false,\n  edited: false,\n};\n\n/**\n * @internal\n */\nclass InControlStatus extends InStatus {\n\n  private readonly _flags = trackValue<InStatus.Flags>(defaultInStatusFlags);\n\n  constructor(control: InControl<any>) {\n    super();\n    this._flags.supply.needs(control);\n    this._flags.by(elementInStatusFlags(this._flags, control));\n  }\n\n  get read(): AfterEvent<[InStatus.Flags]> {\n    return this._flags.read;\n  }\n\n  markTouched(touched = true): this {\n\n    const flags = this._flags.it;\n\n    if (!touched) {\n      if (flags.touched) {\n        // Try to reset touched.\n        // Still touched if in focus. Not edited anyway.\n        this._flags.it = { ...flags, touched: flags.hasFocus, edited: false };\n      }\n    } else if (!flags.touched) {\n      // Do not modify if already touched.\n      this._flags.it = { ...flags, touched };\n    }\n\n    return this;\n  }\n\n  markEdited(edited = true): this {\n\n    const flags = this._flags.it;\n\n    if (edited) {\n      if (!flags.edited) {\n        // Touched if edited\n        this._flags.it = { ...flags, touched: true, edited };\n      }\n    } else if (flags.edited) {\n      // Assume not edited\n      this._flags.it = { ...flags, edited };\n    }\n\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction elementInStatusFlags(\n    origin: ValueTracker<InStatus.Flags>,\n    control: InControl<any>,\n): AfterEvent<[InStatus.Flags]> {\n\n  const element = control.aspect(InElement);\n  const focus = control.aspect(InFocus);\n\n  return afterAll({\n    hasFocus: focus || afterThe(false),\n    edited: element ? element.input.do(mapAfter(({ event }) => !!event)) : afterThe(false),\n  }).do(mapAfter(\n      ({ hasFocus: [hasFocus], edited: [edited] }) => updateInStatusFlags(origin.it, hasFocus, edited),\n  ));\n}\n\n/**\n * @internal\n */\nfunction updateInStatusFlags(flags: InStatus.Flags, hasFocus: boolean, edited: boolean): InStatus.Flags {\n  if (hasFocus) {\n    flags = { ...flags, hasFocus, touched: true };\n  } else {\n    flags = { ...flags, hasFocus };\n  }\n  if (edited) {\n    flags = { ...flags, edited, touched: true };\n  }\n  return flags;\n}\n\n/**\n * @internal\n */\nclass InContainerStatus extends InStatus {\n\n  readonly read: AfterEvent<[InStatus.Flags]>;\n\n  constructor(private readonly _container: InContainer<any>) {\n    super();\n    this.read = containerInStatusFlags(this._container);\n  }\n\n  markEdited(edited?: boolean): this {\n    this._container.controls.read.do(onceAfter)(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markEdited(edited),\n    ));\n    return this;\n  }\n\n  markTouched(touched?: boolean): this {\n    this._container.controls.read.do(onceAfter)(snapshot => itsEach(\n        snapshot,\n        control => control.aspect(InStatus).markTouched(touched),\n    ));\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction containerInStatusFlags(container: InContainer<any>): AfterEvent<[InStatus.Flags]> {\n  return container.controls.read.do(\n      supplyAfter(container),\n      digAfter_((snapshot: InContainer.Snapshot) => afterEach(...inControlStatuses(snapshot))),\n      mapAfter(combineInStatusFlags),\n  );\n}\n\n/**\n * @internal\n */\nfunction inControlStatuses(snapshot: InContainer.Snapshot): Iterable<InStatus> {\n  return mapIt(snapshot, c => c.aspect(InStatus));\n}\n\n/**\n * @internal\n */\nfunction combineInStatusFlags(...flags: [InStatus.Flags][]): InStatus.Flags {\n\n  const result: { -readonly [K in keyof InStatus.Flags]: InStatus.Flags[K] } = {\n    hasFocus: false,\n    touched: false,\n    edited: false,\n  };\n\n  itsEach(\n      flags,\n      (([{ hasFocus, touched, edited }]) => {\n            if (touched) {\n              result.touched = true;\n            }\n            if (hasFocus) {\n              result.hasFocus = result.touched = true;\n            }\n            if (edited) {\n              result.edited = result.touched = true;\n            }\n          }\n      ),\n  );\n\n  return result;\n}\n","import { noop } from '@proc7ts/primitives';\nimport { InControl } from '../../control';\nimport { InConverter, intoConvertedAspects } from '../../converter';\nimport { InMode } from '../../data';\nimport { inModeByForm } from '../../data/modes';\nimport { InElement } from '../../element.control';\nimport { AbstractInElement } from '../abstract-element.control';\n\n/**\n * Form element control.\n *\n * It is connected to control to submit (form), but is not intended for submission itself, and has no value.\n *\n * It is used to update form element state. E.g. to make it read-only when {@link InSubmit.Flags.busy submitting}\n * the form.\n *\n * Form element control can be created by {@link inFormElement} function.\n *\n * @category Control\n * @typeParam TElt - A type of HTML form element.\n */\nexport type InFormElement<TElt extends HTMLElement = HTMLElement> = InElement<void, TElt>;\n\n/**\n * @category Control\n */\nexport namespace InFormElement {\n\n  /**\n   * Form element control options.\n   */\n  export interface Options {\n\n    /**\n     * Submitted control. Typically a {@link InContainer container}.\n     */\n    readonly form: InControl<any>;\n\n    /**\n     * Additional input aspects to apply. These are aspect converters to constructed control  from the\n     * {@link inValueOf same-valued one}.\n     */\n    readonly aspects?: InConverter.Aspect<void> | readonly InConverter.Aspect<void>[];\n\n    /**\n     * Input modes to derive from submitted control.\n     *\n     * Applied to form element control by {@link inModeByForm}.\n     */\n    readonly modes?: {\n\n      /**\n       * Input mode to set when submit is not ready. E.g. when input is invalid. `on` (enabled) by default.\n       */\n      readonly notReady?: InMode.Value;\n\n      /**\n       * Input mode to set when submit is not ready _and_ the form is submitted. `on` (enabled) by default.\n       */\n      readonly invalid?: InMode.Value;\n\n      /**\n       * Input mode to set while submitting. `ro` (read-only) by default.\n       */\n      readonly busy?: InMode.Value;\n\n    };\n\n  }\n\n}\n\n/**\n * Creates form element control.\n *\n * @category Control\n * @param element - HTML element to create control for.\n * @param options - Form element control options.\n *\n * @returns New form element control.\n */\nexport function inFormElement<TElt extends HTMLElement>(\n    element: TElt,\n    options: InFormElement.Options,\n): InFormElement<TElt> {\n\n  const { form, aspects, modes } = options;\n  const control = new AbstractInElement<void, TElt>(\n      element,\n      {\n        aspects: [intoConvertedAspects(aspects)],\n        get: noop,\n        set: noop,\n      },\n  );\n\n  control.supply.needs(form);\n\n  return control.setup(InMode, mode => mode.derive(inModeByForm(form, modes)));\n}\n","import { mapAfter } from '@proc7ts/fun-events';\nimport { InControl } from '../../control';\nimport { InSubmit } from '../../submit.aspect';\nimport { InMode, inModeValue } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on the given `form` control status.\n *\n * This can be applied e.g. to {@link InSubmitButton submit button}, to {@link InFormElement form element},\n * or to input controls. The defaults best suit the latter.\n *\n * @category Aspect\n * @param form - Form control the evaluated mode depends on. Should not be the same as the target control!\n * @param notReady - Input mode to set when submit is not ready. E.g. when input is invalid.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param invalid - Input mode to set when submit is not ready _and_ the form is submitted.\n * `on` (enabled) by default. An `off` (disable) value is a better choice for submit button.\n * @param busy - Input mode to set while submitting. `ro` (read-only) by default. An `off` (disabled) value is a better\n * choice for submit button.\n *\n * @returns A source of input mode.\n */\nexport function inModeByForm(\n    form: InControl<any>,\n    {\n      notReady = 'on',\n      invalid = 'on',\n      busy = 'ro',\n    }: {\n      notReady?: InMode.Value;\n      invalid?: InMode.Value;\n      busy?: InMode.Value;\n    } = {},\n): InMode.Source {\n\n  const submit = form.aspect(InSubmit);\n\n  return submit.read.do(mapAfter(\n      flags => inModeValue(\n          flags.busy ? busy : 'on',\n          flags.ready ? 'on' : (flags.submitted ? invalid : notReady),\n      ),\n  ));\n}\n","import { knownInAspect, nullInAspect } from '../../applied-aspect';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InControl } from '../../control';\nimport { InConverter } from '../../converter';\nimport { InElement } from '../../element.control';\n\n/**\n * An input aspect representing DOM element to apply styles to.\n *\n * This is a HTML element for input element control, and `null` for everything else by default.\n *\n * @category Aspect\n */\nexport type InStyledElement = Element;\n\n/**\n * @internal\n */\nconst InStyledElement__aspect: InAspect<InStyledElement | null> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InStyledElement | null> {\n\n    const element = control.aspect(InElement);\n\n    return element ? knownInAspect(element.element) : nullInAspect();\n  },\n\n};\n\n/**\n * @category Aspect\n */\nexport const InStyledElement = {\n\n  get [InAspect__symbol]() {\n    return InStyledElement__aspect;\n  },\n\n  /**\n   * Creates input control aspect converter that assigns the given styled element to converted control.\n   *\n   * This is useful for controls without elements (such as input groups), or can be used to apply CSS classes to input\n   * element wrappers (such as `form-group` in Bootstrap).\n   *\n   * @typeParam TValue - Converted control value type.\n   * @param element - A DOM element to apply styles to. Styles won't be applied when `null` or undefined.\n   *\n   * @returns Input control aspect converter.\n   */\n  to<TValue>(element: InStyledElement | null = null): InConverter.Aspect<any, TValue> {\n    return {\n      applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n          aspect: InAspect<any, any>,\n      ): InAspect.Applied<any, InAspect.Application.Instance<TInstance, TValue, TKind>> | undefined {\n        return aspect === InStyledElement__aspect\n            ? knownInAspect(element) as InAspect.Application.Result<TInstance, TValue, TKind>\n            : undefined;\n      },\n    };\n  },\n\n};\n","import { css__naming, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { RenderSchedule } from '@frontmeans/render-scheduler';\nimport { DeltaSet } from '@proc7ts/delta-set';\nimport {\n  afterEach,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterEventBy,\n  afterSupplied,\n  digAfter_,\n  EventKeeper,\n  EventNotifier,\n  isEventKeeper,\n  mapAfter,\n  mapAfter_,\n  shareAfter,\n  supplyAfter,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { InAspect, InAspect__symbol } from '../../aspect';\nimport { InNamespaceAliaser, InRenderScheduler } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InStyledElement } from './styled-element.aspect';\n\n/**\n * @internal\n */\nconst InCssClasses__aspect: InAspect<InCssClasses> = {\n\n  applyTo(control: InControl<any>): InAspect.Applied<any, InCssClasses> {\n    return {\n      instance: new InControlCssClasses(control),\n      convertTo: noop,\n    };\n  },\n\n};\n\n/**\n * An aspect of the user input representing CSS classes to apply to styled element.\n *\n * Implements an `EventKeeper` interface by reporting all CSS classes applied to styled element.\n *\n * @category Aspect\n */\nexport abstract class InCssClasses implements EventKeeper<[InCssClasses.Map]> {\n\n  static get [InAspect__symbol](): InAspect<InCssClasses> {\n    return InCssClasses__aspect;\n  }\n\n  /**\n   * An `AfterEvent` keeper of CSS classes to be applied to styled element.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * An `AfterEvent` keeper of added and removed CSS classes.\n   *\n   * Sends current CSS classes as added ones on receiver registration.\n   */\n  abstract readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[InCssClasses.Map]> {\n    return this.read;\n  }\n\n  /**\n   * Appends CSS classes from the given `source` to styled element.\n   *\n   * @param source - A source of CSS class names.\n   *\n   * @returns CSS class names supply. Removes `source` CSS classes from styled element once cut off.\n   */\n  abstract add(source: InCssClasses.Source): Supply;\n\n  /**\n   * Converts arbitrary CSS classes source to their {@link InCssClasses.Spec specifiers}.\n   *\n   * @param source - A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class name specifiers.\n   */\n  abstract specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]>;\n\n  /**\n   * Resolves arbitrary CSS classes source to {@link InCssClasses.Map map of class names}.\n   *\n   * @param source - A source of CSS classes names.\n   *\n   * @returns An `AfterEvent` keeper of CSS class names map.\n   */\n  abstract resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]>;\n\n  /**\n   * Applies CSS classes to the given styled element.\n   *\n   * @param element - Target element to apply CSS classes to.\n   * @param schedule - DOM render schedule to add CSS class updates to. A new schedule is constructed by\n   * {@link InRenderScheduler input render scheduler} by default.\n   *\n   * @returns CSS classes supply that stops their application and removes already applied ones once cut off.\n   */\n  abstract applyTo(element: InStyledElement, schedule?: RenderSchedule): Supply;\n\n  /**\n   * Removes all CSS class sources and stops applying CSS classes to styled elements.\n   *\n   * @param reason - An optional reason.\n   *\n   * @returns `this` instance.\n   */\n  abstract done(reason?: any): this;\n\n}\n\n/**\n * @category Aspect\n */\nexport namespace InCssClasses {\n\n  /**\n   * A source of CSS class names for styled element.\n   *\n   * This is either an event keeper of CSS class names, or a function returning one and accepting target input\n   * control as the only parameter.\n   */\n  export type Source =\n      | EventKeeper<Spec[]>\n      | ((this: void, control: InControl<any>) => EventKeeper<Spec[]>);\n\n  /**\n   * A specifier of CSS classes for styled element.\n   *\n   * This is either a single (potentially qualified) class name, or a {@link Map map of class names}.\n   *\n   * Qualified names are converted to simple ones by {@link InNamespaceAliaser} aspect.\n   */\n  export type Spec =\n      | QualifiedName\n      | Map;\n\n  /**\n   * A map of CSS class names for styled element.\n   *\n   * The keys of this map are class names to apply.\n   * - When the value is `true` corresponding class name will be added.\n   * - When the value is `false` corresponding class name will not be added.\n   * - The `undefined` value is ignored.\n   */\n  export type Map = {\n    readonly [name in string]?: boolean;\n  };\n\n}\n\n/**\n * @internal\n */\nconst UnsubscribeReason__symbol = (/*#__PURE__*/ Symbol('reason'));\n\n/**\n * @internal\n */\ninterface UnsubscribeReason {\n  readonly [UnsubscribeReason__symbol]?: any;\n}\n\n/**\n * @internal\n */\nfunction isUnsubscribeReason(reason: any): reason is UnsubscribeReason {\n  return reason && typeof reason === 'object' && UnsubscribeReason__symbol in reason;\n}\n\n/**\n * @internal\n */\nclass InControlCssClasses extends InCssClasses {\n\n  readonly read: AfterEvent<[InCssClasses.Map]>;\n  readonly track: AfterEvent<[readonly string[], readonly string[]]>;\n  private readonly _sources = trackValue<[Map<AfterEvent<[InCssClasses.Map]>, Supply>]>([new Map()]);\n  private _schedule?: RenderSchedule;\n\n  constructor(private readonly _control: InControl<any>) {\n    super();\n\n    _control.supply.whenOff(reason => this.done(reason));\n\n    this.read = this._sources.read.do(\n        supplyAfter(this._control),\n        digAfter_(([sources]) => afterEach(...sources.keys())),\n        mapAfter_((...classes: [InCssClasses.Map][]) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          classes.forEach(([map]) => mergeInCssClassesMap(map, result));\n\n          return result;\n        }),\n    );\n\n    this.track = afterEventBy<[readonly string[], readonly string[]]>(receiver => {\n      receiver.supply.needs(this._control);\n\n      const classes = new DeltaSet<string>();\n      const emitter = new EventNotifier<[readonly string[], readonly string[]]>();\n      let classesSent = false;\n      const sendClasses = (): void => {\n        classesSent = true;\n        classes.redelta(\n            (add, remove) => emitter.send(add, remove),\n        ).undelta();\n      };\n\n      emitter.on(receiver);\n\n      return this.read(map => {\n\n        const remove = new Set(classes);\n        const add: string[] = [];\n\n        itsEach(\n            filterIt<ObjectEntry<InCssClasses.Map>>(\n                overEntries<InCssClasses.Map>(map),\n                ([, flag]) => !!flag,\n            ),\n            ([name]) => {\n              if (!remove.delete(name)) {\n                add.push(name);\n              }\n            },\n        );\n\n        if (!classesSent || add.length || remove.size) {\n          classes.delta(add, remove);\n          sendClasses();\n        }\n      });\n    });\n\n    const element = _control.aspect(InStyledElement);\n\n    if (element) {\n      this.applyTo(element, this.schedule);\n    }\n  }\n\n  get schedule(): RenderSchedule {\n    return this._schedule || (this._schedule = controlSchedule(\n        this._control,\n        this._control.aspect(InStyledElement)!,\n    ));\n  }\n\n  specs(source: InCssClasses.Source): AfterEvent<InCssClasses.Spec[]> {\n    return afterSupplied(isEventKeeper(source) ? source : source(this._control));\n  }\n\n  resolve(source: InCssClasses.Source): AfterEvent<[InCssClasses.Map]> {\n\n    const nsAlias = this._control.aspect(InNamespaceAliaser);\n\n    return this.specs(source).do(\n        mapAfter((...names) => {\n\n          const result: { [name: string]: boolean } = {};\n\n          names.forEach(name => {\n            if (isQualifiedName(name)) {\n              result[css__naming.name(name, nsAlias)] = true;\n            } else {\n              mergeInCssClassesMap(name, result);\n            }\n          });\n\n          return result;\n        }),\n    );\n  }\n\n  add(source: InCssClasses.Source): Supply {\n\n    const inSupply = this._control.supply;\n\n    if (inSupply.isOff) {\n      return inSupply;\n    }\n\n    const classesSupply = new Supply();\n    const src = afterEventBy<[InCssClasses.Map]>(receiver => {\n\n      const supply = this.resolve(source)({\n        receive(context, ...event) {\n          receiver.receive(context, ...event);\n        },\n      });\n\n      receiver.supply.whenOff(reason => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        classesSupply.off({ [UnsubscribeReason__symbol]: reason });\n      });\n      classesSupply.needs(supply).whenOff(reason => {\n        if (isUnsubscribeReason(reason)) {\n          supply.off(reason[UnsubscribeReason__symbol]);\n        }\n      });\n    }).do(shareAfter);\n\n    const [sources] = this._sources.it;\n\n    sources.set(src, classesSupply);\n    classesSupply.whenOff(reason => {\n      if (!isUnsubscribeReason(reason)) {\n        sources.delete(src);\n        this._sources.it = [sources];\n      }\n    });\n\n    this._sources.it = [sources];\n\n    return classesSupply.needs(inSupply);\n  }\n\n  applyTo(\n      element: Element,\n      schedule: RenderSchedule = controlSchedule(this._control, element),\n  ): Supply {\n\n    const { classList } = element;\n    const classes = new DeltaSet<string>();\n    const updateClasses = (): void => {\n      classes.redelta((add, remove) => {\n        classList.remove(...remove);\n        classList.add(...add);\n      }).undelta();\n    };\n\n    return this.track((add, remove) => {\n      classes.delta(add, remove);\n      schedule(updateClasses);\n    }).whenOff(() => {\n      if (classes.size) {\n        classes.clear();\n        schedule(updateClasses);\n      }\n    });\n  }\n\n  done(reason?: any): this {\n    itsEach(\n        this._sources.it[0].values(),\n        supply => supply.off(reason),\n    );\n    this._sources.supply.off(reason);\n    return this;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction mergeInCssClassesMap(map: InCssClasses.Map, result: { [name: string]: boolean }): void {\n  itsEach(\n      overEntries(map),\n      ([name, flag]) => {\n        if (flag != null) {\n          result[name] = flag;\n        }\n      },\n  );\n}\n\n/**\n * @internal\n */\nfunction controlSchedule(control: InControl<any>, node: Node | undefined): RenderSchedule {\n  return control.aspect(InRenderScheduler)({ node });\n}\n","import { translateAfter } from '@proc7ts/fun-events';\nimport { arrayOfElements } from '@proc7ts/primitives';\nimport { InputAspects__NS } from '../../aspects';\nimport { InValidation } from '../../validation';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of error marker CSS classes.\n *\n * Applies error marker class(es) when the given error message codes present in\n * {@link InValidation.Result validation result}.\n *\n * @category Style\n * @param mark - Error mark. Specifies CSS class(es) to apply when requested error present.\n * A class with `has-error` name in {@link InputAspects__NS input aspects namespace} is used by default.\n * @param when - {@link InValidation.Message Validation message} code(s) to expect.\n * {@link InValidation.Result.ok Any} error matches by default.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssError(\n    {\n      mark,\n      when,\n    }: {\n      mark?: InCssClasses.Spec | readonly InCssClasses.Spec[];\n      when?: string | string[];\n    } = {},\n): InCssClasses.Source {\n\n  let hasError: (errors: InValidation.Result) => boolean;\n\n  if (!when) {\n    hasError = defaultInCssHasError;\n  } else if (Array.isArray(when)) {\n    hasError = when.length ? errors => when.every(code => errors.has(code)) : defaultInCssHasError;\n  } else {\n    hasError = errors => errors.has(when);\n  }\n\n  return control => control.aspect(InValidation).read.do(translateAfter(\n      (send, errors) => hasError(errors) ? send(...inCssErrorMarks(mark)) : send(),\n  ));\n}\n\n/**\n * @internal\n */\nfunction defaultInCssHasError(errors: InValidation.Result): boolean {\n  return !errors.ok;\n}\n\n/**\n * @internal\n */\nconst defaultInCssErrorMarks: readonly InCssClasses.Spec[] = [['has-error', InputAspects__NS]];\n\n/**\n * @internal\n */\nfunction inCssErrorMarks(mark?: InCssClasses.Spec | readonly InCssClasses.Spec[]): readonly InCssClasses.Spec[] {\n  if (!mark) {\n    return defaultInCssErrorMarks;\n  }\n\n  const marks = arrayOfElements(mark);\n\n  return marks.length ? marks : defaultInCssErrorMarks;\n}\n","import { NamespaceDef, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { afterAll, translateAfter } from '@proc7ts/fun-events';\nimport { InputAspects__NS } from '../../aspects';\nimport { InControl } from '../../control';\nimport { InMode } from '../../data';\nimport { InValidation } from '../../validation';\nimport { InStatus } from '../focus';\nimport { InCssClasses } from './css-classes.aspect';\n\n/**\n * Builds a source of informative CSS classes.\n *\n * Generates the following CSS classes:\n * - `disabled` when input control is disabled (i.e. has no data).\n * - `readonly` when input control is read-only,\n * - `invalid` when input control validation failed,\n * - `missing` when there are validation messages with `missing` code,\n * - `incomplete` when there are validation messages with `incomplete`,\n * - `has-focus` when input control has input focus,\n * - `touched` when input control is touched (i.e. had focus already),\n * - `edited` when input control is edited by user.\n *\n * These names are qualified with the given (or {@link InputAspects__NS default}) namespace.\n *\n * @category Style\n * @param ns - A definition of namespace to qualify CSS class names with. The {@link InputAspects__NS default namespace}\n * will be used when omitted.\n *\n * @returns A source of CSS class names to apply.\n */\nexport function inCssInfo(\n    {\n      ns = InputAspects__NS,\n    }: {\n      ns?: NamespaceDef;\n    } = {},\n): InCssClasses.Source {\n  return (control: InControl<any>) => {\n\n    const cls = (name: string) => [name, ns] as const;\n\n    return afterAll({\n      md: control.aspect(InMode),\n      vl: control.aspect(InValidation),\n      st: control.aspect(InStatus),\n    }).do(translateAfter(\n        (send, { md: [mode], vl: [valid], st: [{ hasFocus, touched, edited }] }) => {\n\n          const names: QualifiedName[] = [];\n\n          if (!InMode.hasData(mode)) {\n            names.push(cls('disabled'));\n          }\n          if (mode === 'ro' || mode === '-ro') {\n            names.push(cls('readonly'));\n          }\n          if (!valid.ok) {\n            names.push(cls('invalid'));\n          }\n          if (valid.has('missing')) {\n            names.push(cls('missing'));\n          }\n          if (valid.has('incomplete')) {\n            names.push(cls('incomplete'));\n          }\n          if (hasFocus) {\n            names.push(cls('has-focus'));\n          }\n          if (touched) {\n            names.push(cls('touched'));\n          }\n          if (edited) {\n            names.push(cls('edited'));\n          }\n\n          send(...names);\n        },\n    ));\n  };\n}\n","import type { HthvItem } from '../hthv-item';\nimport type { HthvPartial } from './hthv-partial';\n\n/**\n * @internal\n */\nexport function hthvItem<TItem extends HthvItem<any, any, any>>(\n    {\n      $ = 'raw',\n      n,\n      t,\n      v,\n      x = [],\n      p = {},\n      pl = [],\n    }: HthvPartial<TItem>,\n): TItem {\n  if (n) {\n    (p as Record<string, HthvPartial>)[n as unknown as string] = { $, n, v, x: [], p: {}, pl: [] };\n  }\n  return {\n    $,\n    n,\n    t,\n    v,\n    x,\n    p,\n    pl,\n  } as TItem;\n}\n","import type { HthvItem, HthvParamItem } from '../hthv-item';\n\n/**\n * @internal\n */\nexport function addParam(\n    {\n      p,\n      pl,\n    }: HthvItem,\n    param: HthvParamItem,\n): void {\n\n  const key = param.n || param.v;\n  const prev = p[key];\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!prev || !prev.n && param.n) {\n    p[key] = param;\n  }\n  pl.push(param);\n}\n","/**\n * @internal\n */\nexport const parseNone = (): false => false;\n","import { parseNone } from './parse-none';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\nconst datePattern = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d\\d (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d GMT/;\n\n/**\n * @internal\n */\nexport function dateTimeParser(\n    { dateTime }: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return dateTime ? parseDateTime : parseNone;\n}\n\nfunction parseDateTime(input: ParserInput, out: (value: string) => void): boolean {\n  input.s = input.s.substring(input.i);\n  input.i = 0;\n  if (datePattern.test(input.s)) {\n    out(input.s.substring(input.i, input.i += 29));\n    return true;\n  }\n  return false;\n}\n","import type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInItem({ delimiterOf }: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    const c = input.s[input.i];\n\n    input.d = delimiterOf(c);\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvExtraItem, HthvItem, HthvItemType } from '../hthv-item';\nimport { hthvItem } from '../impl';\nimport { angleBracketsParser } from './angle-brackets-parser';\nimport { dateTimeParser } from './date-time-parser';\nimport { nextInItem } from './next-in-item';\nimport { parseNone } from './parse-none';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { quotedStringParser } from './quoted-string-parser';\n\n/**\n * @internal\n */\nexport interface ItemParserConfig {\n  named?: boolean;\n  tagged?: boolean;\n  extra?: boolean;\n  next?: (input: ParserInput) => string;\n}\n\n/**\n * @internal\n */\nexport function itemParser(\n    config: ParserConfig,\n    {\n      named = true,\n      tagged = true,\n      extra = true,\n      next = nextInItem(config),\n    }: ItemParserConfig = {},\n): (input: ParserInput, out: (param: HthvItem<any, any, any>) => void) => boolean {\n\n  const parseAngleBrackets = angleBracketsParser(config);\n  const parseDateTime = dateTimeParser(config);\n  const parseQuotedString = quotedStringParser(config);\n  const parseExtra = extra ? itemParser(config, { next, tagged: false, named: false, extra: false }) : parseNone;\n\n  return (input, out) => {\n\n    let name = '';\n    let type: HthvItemType = 'raw';\n    let tag: string | undefined;\n    let value: string | undefined;\n\n    while (input.i < input.s.length) {\n\n      const c = next(input);\n\n      if (input.d) {\n        if (input.d & (HthvDelimiter.Item | HthvDelimiter.Parameter)) {\n          break;\n        }\n        if (value == null) {\n          if (input.d & HthvDelimiter.Assignment) {\n            value = name ? '' : c;\n            ++input.i;\n            continue;\n          }\n          if (input.d & HthvDelimiter.Quote) {\n            if (tagged || !name) {\n              parseQuotedString(input, v => {\n                if (name) {\n                  type = 'tagged-string';\n                  tag = name;\n                } else {\n                  type = 'quoted-string';\n                }\n                name = '';\n                value = v;\n              });\n            }\n            break;\n          }\n          if (!name && parseAngleBrackets(input, v => {\n            type = 'angle-bracketed-string';\n            value = v;\n          })) {\n            break;\n          }\n          value = name;\n          name = '';\n        } else if (input.d & HthvDelimiter.Quote) {\n          if (tagged || !value) {\n            parseQuotedString(input, v => {\n              if (value) {\n                type = 'tagged-string';\n                tag = value;\n              } else {\n                type = 'quoted-string';\n              }\n              value = v;\n            });\n          }\n          break;\n        } else if (!value && parseAngleBrackets(input, v => {\n          type = 'angle-bracketed-string';\n          value = v;\n        })) {\n          break;\n        }\n      }\n\n      if (value == null) {\n        if (!name && parseDateTime(input, v => value = v)) {\n          type = 'date-time';\n          break;\n        }\n        if (named) {\n          name += c;\n        } else {\n          value = c;\n        }\n      } else if (!value && parseDateTime(input, v => value = v)) {\n        type = 'date-time';\n        break;\n      } else {\n        value += c;\n      }\n\n      ++input.i;\n    }\n\n    let item: HthvItem<any, any>;\n\n    if (value == null) {\n      if (!name) {\n        return false;\n      }\n      item = hthvItem({ $: type, v: name });\n    } else {\n      item = hthvItem({ $: type, n: name || undefined, t: tag, v: value });\n    }\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseExtra(input, extraItem => item.x.push(extraItem as HthvExtraItem))); // eslint-disable-line curly\n\n    out(item);\n\n    return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function angleBracketsParser(\n    { delimiterOf }: ParserConfig,\n): (input: ParserInput, out: (v: string) => void) => boolean {\n  return (input, out) => {\n     if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.AngleBracketStart)) {\n       return false;\n     }\n\n     let result = '';\n\n     ++input.i;\n     while (input.i < input.s.length) {\n\n       const c = input.s[input.i++];\n\n       if (delimiterOf(c) & HthvDelimiter.AngleBracketEnd) {\n         break;\n       }\n       result += c;\n     }\n\n     out(result);\n\n     return true;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function quotedStringParser(\n    { delimiterOf }: ParserConfig,\n): (input: ParserInput, out: (value: string) => void) => void {\n  return (input, out) => {\n\n    let unquoted = '';\n\n    ++input.i;\n    for (; input.i < input.s.length; ++input.i) {\n\n      const c = input.s[input.i];\n\n      if (c === '\\\\') {\n\n        const next = input.s[++input.i];\n\n        if (next) {\n          unquoted += next;\n        } else {\n          unquoted += c;\n        }\n      } else if (delimiterOf(c) & HthvDelimiter.Quote) {\n        ++input.i;\n        out(unquoted);\n        return;\n      } else {\n        unquoted += c;\n      }\n    }\n\n    out(unquoted);\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function nextInComment({ delimiterOf }: ParserConfig): (input: ParserInput) => string {\n  return input => {\n\n    let c = input.s[input.i];\n\n    if (c !== '\\\\') {\n      input.d = delimiterOf(c);\n      return c;\n    }\n\n    ++input.i;\n    if (input.i < input.s.length) {\n      c = input.s[input.i];\n      input.d = delimiterOf(c) ? HthvDelimiter.NonToken : HthvDelimiter.None;\n    } else {\n      input.d = HthvDelimiter.NonToken;\n    }\n\n    return c;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\n\n/**\n * @internal\n */\nexport function spacesParser({ delimiterOf }: ParserConfig): (input: ParserInput) => boolean {\n  return input => {\n\n    const start = input.i;\n\n    do {\n\n      const c = input.s[input.i];\n\n      if (!(delimiterOf(c) & HthvDelimiter.Space)) {\n        break;\n      }\n      input.i++;\n    } while (input.i < input.s.length);\n\n    return input.i !== start;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvParamItem } from '../hthv-item';\nimport { itemParser, ItemParserConfig } from './item-parser';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function paramParser(\n    config: ParserConfig,\n    opts: ItemParserConfig = {},\n): (input: ParserInput, out: (param: HthvParamItem) => void) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n  const parseItem = itemParser(config, { ...opts, tagged: false });\n\n  return (input, out) => {\n    if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.Parameter)) {\n      return false;\n    }\n\n    ++input.i;\n    skipSpaces(input);\n\n    return parseItem(input, out);\n  };\n}\n","import { HthvDelimiter, HthvDelimiterChar } from '../hthv-delimiter';\nimport type { HthvParserConfig } from '../hthv-parser';\n\n/**\n * @internal\n */\nexport interface ParserConfig {\n  readonly dateTime?: boolean;\n  delimiterOf(this: void, char: string): number;\n}\n\n/**\n * @internal\n */\nexport type DelimitConfig = { [char in HthvDelimiterChar]: number };\n\n/**\n * @internal\n */\nexport const defaultDelimit: DelimitConfig = {\n  ' ': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space | HthvDelimiter.Item,\n  ',': HthvDelimiter.NonToken | HthvDelimiter.Item,\n  ';': HthvDelimiter.NonToken | HthvDelimiter.Parameter,\n  '\"': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Quote,\n  '\\\\': HthvDelimiter.NonToken | HthvDelimiter.Escaped,\n  '<': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketStart,\n  '>': HthvDelimiter.NonToken | HthvDelimiter.AngleBracketEnd,\n  '=': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n  '(': HthvDelimiter.NonToken,\n  ')': HthvDelimiter.NonToken,\n  '/': HthvDelimiter.NonToken,\n  ':': HthvDelimiter.NonToken,\n  '?': HthvDelimiter.NonToken,\n  '@': HthvDelimiter.NonToken,\n  '[': HthvDelimiter.NonToken,\n  ']': HthvDelimiter.NonToken,\n  '{': HthvDelimiter.NonToken,\n  '}': HthvDelimiter.NonToken,\n};\n\n/**\n * @internal\n */\nexport function buildParserConfig(\n    {\n      delimit,\n      dateTime,\n    }: HthvParserConfig = {},\n): ParserConfig {\n\n  const delimitConfig: DelimitConfig = delimit ? { ...defaultDelimit, ...delimit } : defaultDelimit;\n\n  return {\n    dateTime,\n    delimiterOf(c) {\n      return delimitConfig[c as HthvDelimiterChar]\n          || (c >= '\\u0000' && c <= ' ' || c === '\\u007f' ? HthvDelimiter.NonToken : HthvDelimiter.None);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport const defaultParserConfig = (/*#__PURE__*/ buildParserConfig());\n\n/**\n * @internal\n */\nexport const commentParserConfig = (/*#__PURE__*/ buildParserConfig({\n  delimit: {\n    ':': HthvDelimiter.NonToken | HthvDelimiter.Assignment,\n    '(': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Comment,\n    ')': HthvDelimiter.NonToken | HthvDelimiter.Escaped | HthvDelimiter.Item,\n    ' ': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '\\t': HthvDelimiter.NonToken | HthvDelimiter.Space,\n    '=': HthvDelimiter.NonToken,\n    ',': HthvDelimiter.NonToken,\n  },\n}));\n","import type { HthvDelimiterChar } from './hthv-delimiter';\nimport type { HthvItem } from './hthv-item';\nimport { hthvItem } from './impl';\nimport {\n  addParam,\n  buildParserConfig,\n  commentParser,\n  commentParserConfig,\n  defaultParserConfig,\n  itemDelimitParser,\n  itemParser,\n  paramParser,\n  parseNone,\n  ParserInput,\n} from './parser';\n\n/**\n * HTTP header value parser signature.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * @typeParam TNameMode - Whether parsed items have {@link HthvItem.n names}.\n * @typeParam TTagMode - Whether parsed items have {@link HthvItem.t tags}.\n * @typeParam TParamsMode - Whether parsed items have {@link HthvItem.p parameters}.\n */\nexport type HthvParser<\n    TNameMode extends 'has-name' | 'no-name' = 'has-name' | 'no-name',\n    TTagMode extends 'has-tag' | 'no-tag' = 'has-tag' | 'no-tag',\n    TParamsMode extends 'has-params' | 'no-params' = 'has-params' | 'no-params'> =\n/**\n * @param value - HTTP header value to parse.\n *\n * @returns An array of parsed value items.\n */\n    (this: void, value: string) => HthvItem<TNameMode, TTagMode, TParamsMode>[];\n\n/**\n * A configuration of HTTP header value parser.\n *\n * This is used to {@link newHthvParser configure new parser}.\n */\nexport interface HthvParserConfig {\n\n  /**\n   * Delimits configuration.\n   *\n   * An object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n   * and corresponding {@link HthvDelimiter delimiters} as values.\n   */\n  readonly delimit?: HthvDelimitConfig;\n\n  /**\n   * Whether to parse date/time values.\n   *\n   * @default `false`\n   */\n  readonly dateTime?: boolean;\n\n  /**\n   * Whether to parse comments.\n   *\n   * @default `false`.\n   */\n  readonly comments?: boolean;\n\n}\n\n/**\n * Delimits configuration for HTTP header value parser.\n *\n * This is an object literal with {@link HthvDelimiterChar supported delimiter characters} as keys\n * and corresponding {@link HthvDelimiter delimiters} as values.\n *\n * The default delimiter configuration is used for omitted characters.\n */\nexport type HthvDelimitConfig = { readonly [char in HthvDelimiterChar]?: number };\n\n/**\n * Creates and configures new HTTP header value parser.\n *\n * @param config - New parser configuration.\n *\n * @returns New HTTP header value parser function.\n */\nexport function newHthvParser(config?: HthvParserConfig): HthvParser {\n\n  const parserConfig = config ? buildParserConfig(config) : defaultParserConfig;\n  const parseItemDelimit = itemDelimitParser(parserConfig);\n  const parseParam = paramParser(parserConfig);\n  const parseItem = itemParser(parserConfig);\n  const parseComment = config?.comments ? commentParser(commentParserConfig) : parseNone;\n\n  return headerValue => {\n\n    const result: HthvItem[] = [];\n    const input: ParserInput = { i: 0, s: headerValue };\n\n    // noinspection StatementWithEmptyBodyJS\n    while (parseTopLevelItem()); // eslint-disable-line curly\n\n    return result;\n\n    function parseTopLevelItem(): boolean {\n      return input.i < input.s.length && (\n          parseItemDelimit(input)\n          || parseParam(\n              input,\n              param => {\n                if (!result.length) {\n                  result.push(hthvItem({ $: 'raw', v: '' }));\n                }\n                addParam(result[result.length - 1], param);\n              },\n          )\n          || parseComment(input, item => result.push(item))\n          || parseItem(input, item => result.push(item))\n      );\n    }\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function itemDelimitParser(config: ParserConfig): (input: ParserInput) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n\n  return input => {\n    if (delimiterOf(input.s[input.i]) & HthvDelimiter.Item) {\n      input.i++;\n      skipSpaces(input);\n      return true;\n    }\n    return false;\n  };\n}\n","import { HthvDelimiter } from '../hthv-delimiter';\nimport type { HthvItem } from '../hthv-item';\nimport { hthvItem } from '../impl';\nimport { addParam } from './add-param';\nimport { itemParser, ItemParserConfig } from './item-parser';\nimport { nextInComment } from './next-in-comment';\nimport { paramParser } from './param-parser';\nimport type { ParserConfig } from './parser-config';\nimport type { ParserInput } from './parser-input';\nimport { spacesParser } from './spaces-parser';\n\n/**\n * @internal\n */\nexport function commentParser(config: ParserConfig): (input: ParserInput, out: (item: HthvItem) => void) => boolean {\n\n  const { delimiterOf } = config;\n  const skipSpaces = spacesParser(config);\n  const commentParserConfig: ItemParserConfig = {\n    next: nextInComment(config),\n  };\n  const parseItem = itemParser(config, commentParserConfig);\n  const parseParam = paramParser(config, commentParserConfig);\n\n  return (input, out) => {\n    if (!(delimiterOf(input.s[input.i]) & HthvDelimiter.Comment)) {\n      return false;\n    }\n\n    ++input.i;\n\n    let result: HthvItem | undefined;\n\n    // noinspection StatementWithEmptyBodyJS\n    while ( // eslint-disable-line curly\n        skipSpaces(input)\n        || parseParam(\n            input,\n            param => {\n              if (!result) {\n                result = hthvItem({ $: 'raw', v: '' });\n              }\n              addParam(result, param);\n            },\n        )\n        || parseItem(input, item => result = item)\n        );\n\n    ++input.i; // closing parent\n    out(result || hthvItem({ $: 'raw', v: '' }));\n\n    return true;\n  };\n}\n","import { HthvParser, newHthvParser } from './hthv-parser';\n\n/**\n * Parses HTTP header value.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default {@link HthvParserConfig config}.\n *\n * Does not recognize comments or date/time values.\n *\n * Treats illegal characters as ASCII letters.\n *\n * @param value - HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParse: HthvParser = (/*#__PURE__*/ newHthvParser());\n\n/**\n * Parses HTTP header value that may contain date/time.\n *\n * Splits the value onto {@link HthvItem items}.\n *\n * Parser is configured with default config except {@link HthvParserConfig.dateTime date/time parsing enabled}.\n *\n * Does not recognize comments.\n *\n * Handles date/time values in [IMF-fixdate] format only.\n *\n * Treats illegal characters as ASCII letters.\n *\n * [IMF-fixdate]: https://tools.ietf.org/html/rfc7231#section-7.1.1.1\n *\n * @param value - HTTP header value to parse.\n *\n * @returns An array of comma- or space- separated value items.\n */\nexport const hthvParseDT: HthvParser = (/*#__PURE__*/ newHthvParser({ dateTime: true }));\n","import { HthvDelimiter } from './hthv-delimiter';\nimport { defaultParserConfig } from './parser';\n\n/**\n * Conditionally encloses HTTP header value or its part into double quotes.\n *\n * Quotes will be added if delimiter or special character is present in input `string`, or the input `string` is empty.\n * {@link hthvEscapeQ Escapes} `\"` and `\\` symbols.\n *\n * @param string - A string to quote.\n *\n * @returns Either a string enclosed in double quotes, or original `string` if there is no need to quote it.\n */\nexport function hthvQuote(string: string): string {\n  if (!string) {\n    return '\"\"';\n  }\n\n  const { delimiterOf } = defaultParserConfig;\n  let escaped: undefined | string;\n  let quote = false;\n\n  for (let i = 0; i < string.length; ++i) {\n\n    const c = string[i];\n    const delimiter = delimiterOf(c);\n\n    if (delimiter) {\n      if (delimiter & HthvDelimiter.Escaped) {\n        if (!escaped) {\n          escaped = string.substring(0, i);\n        }\n        escaped += '\\\\' + c;\n      }\n      quote = true;\n    } else if (escaped) {\n      escaped += c;\n    }\n  }\n\n  return quote ? `\"${escaped || string}\"` : string;\n}\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter, EventSender, OnEvent, onSupplied } from '@proc7ts/fun-events';\n\n/**\n * @internal\n */\ntype FetchAgent<TResponse extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<TResponse>,\n    request: Request,\n) => EventSender<TResponse>;\n\n/**\n * @internal\n */\ntype CombinedFetchAgent<TResponse extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<TResponse>,\n    request: Request,\n) => OnEvent<TResponse>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<TResponse extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>>\n    implements ContextUpRef<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>> {\n\n  readonly upKey: ContextUpKey.UpKey<CombinedFetchAgent<TResponse>, FetchAgent<TResponse>>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => slot.insert(slot.seed.do(digAfter(\n            (...agents) => {\n              if (agents.length) {\n                return afterThe(combineFetchAgents(agents));\n              }\n              if (slot.hasFallback && slot.or) {\n                return slot.or;\n              }\n\n              return afterThe(defaultFetchAgent);\n            },\n        ))),\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          CombinedFetchAgent<TResponse>,\n          ContextUpKey.Source<FetchAgent<TResponse>>,\n          AfterEvent<FetchAgent<TResponse>[]>>,\n  ): void {\n\n    let delegated: CombinedFetchAgent<TResponse>;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((next, request) => delegated(next, request));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultFetchAgent<TResponse extends any[]>(\n    next: (this: void, request: Request) => OnEvent<TResponse>,\n    request: Request,\n): OnEvent<TResponse> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<TResponse extends any[]>(\n    agents: FetchAgent<TResponse>[],\n): CombinedFetchAgent<TResponse> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<TResponse> = (\n        agentIdx,\n        agentRequest,\n    ) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","import { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter {@link HttpFetch} processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by {@link HttpFetch}.\n */\nexport type HttpFetchAgent =\n/**\n * @param next - Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request - HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * {@link HttpFetch} call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under {@link HttpFetchAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request - HTTP request.\n   *\n   * @returns An `OnEvent` sender of response object(s) receivers. It is returned as a result of {@link HttpFetch} call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an {@link HttpFetchAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent')\n);\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { EventEmitter, onceOn, OnEvent, onEventBy } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: Supply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new window.AbortController();\n        const { signal } = abortController;\n\n        supply = new Supply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal)\n              .on('abort')\n              .do(onceOn)(\n                  () => abortController.abort(),\n              );\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","import { FnContextKey, FnContextRef } from '@proc7ts/context-values/updatable';\nimport { OnEvent } from '@proc7ts/fun-events';\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of {@link HttpFetch} is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input - The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init - Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an {@link HttpFetch} instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n        'http-fetch',\n        {\n          byDefault: bootstrapDefault(newHttpFetch),\n        },\n    )\n);\n","import { drekAppender, drekCharger, DrekFragment, DrekTarget } from '@frontmeans/drek';\nimport { ContextKey, SingleContextKey } from '@proc7ts/context-values';\nimport { lazyValue, valueByRecipe } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext, ComponentRenderCtl, DefaultPreRenderScheduler } from '@wesib/wesib';\nimport { FragmentRenderer, FragmentRendererExecution } from './fragment-renderer';\nimport { RenderFragmentDef } from './render-fragment-def';\n\n/**\n * Fragment render control.\n *\n * Controls rendering by {@link FragmentRenderer fragment renderers}.\n *\n * Available in component context.\n */\nexport interface FragmentRenderCtl {\n\n  /**\n   * Enables fragment rendering by the given `renderer`.\n   *\n   * A `renderer` call will be scheduled by {@link DocumentRenderKit document render kit} once component state updated.\n   *\n   * @param renderer - Fragment renderer function.\n   * @param def - Optional fragment rendering definition.\n   *\n   * @returns Renderer supply. The rendering would stop once this supply is cut off.\n   */\n  renderFragmentBy(renderer: FragmentRenderer, def?: RenderFragmentDef): Supply;\n\n}\n\n/**\n * A key of component context value containing {@link FragmentRenderCtl fragment render control}.\n */\nexport const FragmentRenderCtl: ContextKey<FragmentRenderCtl> = (\n    /*#__PURE__*/ new SingleContextKey(\n        'fragment-render-ctl',\n        {\n          byDefault(context) {\n            return new FragmentRenderCtl$(context.get(ComponentContext));\n          },\n        },\n    )\n);\n\nconst RenderFragment$done = {};\n\nclass FragmentRenderCtl$ implements FragmentRenderCtl {\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  renderFragmentBy(renderer: FragmentRenderer, def: RenderFragmentDef = {}): Supply {\n\n    const spec = valueByRecipe(def, this._context);\n    const doRenderFragment = spec.settle === false\n        ? RenderFragment$justRender\n        : RenderFragment$settleThenRender;\n    const renderFragment = (fragment: DrekFragment, retainContent: boolean): void => {\n      if (!retainContent) {\n        doRenderFragment(fragment);\n      }\n    };\n    const { target = RenderFragment$defaultTarget } = spec;\n    const getTarget: () => DrekTarget = lazyValue(() => target(this._context));\n    const renderCtl = this._context.get(ComponentRenderCtl);\n    const scheduler = this._context.get(DefaultPreRenderScheduler);\n    const supply = new Supply();\n    const renderSupply = renderCtl.preRenderBy(\n        preExec => {\n\n          const fragment = new DrekFragment(getTarget(), { scheduler });\n          let retainContent = false;\n          const exec: FragmentRendererExecution = {\n            ...preExec,\n            supply,\n            fragment,\n            content: fragment.content,\n            postpone(postponed) {\n              preExec.postpone(() => postponed(exec));\n            },\n            renderBy(renderer) {\n              preExec.renderBy(renderExec => {\n                renderExec.renderBy(renderer);\n              });\n            },\n            retainContent(retain = true) {\n              retainContent = retain;\n            },\n            done() {\n              preExec.renderBy(({ supply }) => {\n                renderSupply.as(supply).off(RenderFragment$done);\n              });\n            },\n          };\n\n          renderer(exec);\n          renderFragment(fragment, retainContent);\n        },\n        spec,\n    ).needs(\n        supply,\n    ).whenOff(reason => {\n      if (reason !== RenderFragment$done) {\n        supply.off(reason);\n      }\n    });\n\n    return supply;\n  }\n\n}\n\nfunction RenderFragment$defaultTarget({ contentRoot }: ComponentContext): DrekTarget {\n  return drekCharger(drekAppender(contentRoot));\n}\n\nfunction RenderFragment$settleThenRender(fragment: DrekFragment): void {\n\n  const { innerContext } = fragment;\n  const { window } = innerContext;\n\n  innerContext.scheduler()(() => {\n    window.customElements.upgrade(fragment.content);\n  });\n  fragment.settle();\n  fragment.render();\n}\n\nfunction RenderFragment$justRender(fragment: DrekFragment): void {\n  fragment.render();\n}\n","import { drekAppender, drekCharger } from '@frontmeans/drek';\nimport { valueByRecipe } from '@proc7ts/primitives';\nimport {\n  AeComponentMember,\n  AeComponentMemberTarget,\n  ComponentClass,\n  ComponentContext,\n  ComponentMember,\n  ComponentMemberAmendment,\n} from '@wesib/wesib';\nimport { FragmentRenderCtl } from './fragment-render-ctl';\nimport { RenderFragmentDef } from './render-fragment-def';\n\n/**\n * Creates a {@link RenderFragmentDef.Method fragment renderer method} amendment (amd decorator).\n *\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Non-mandatory rendering definition.\n *\n * @returns New component method amendment.\n */\nexport function RenderFragment<\n    TClass extends ComponentClass,\n    TAmended extends AeComponentMember<RenderFragmentDef.Method, TClass>>(\n    def?: RenderFragmentDef,\n): ComponentMemberAmendment<RenderFragmentDef.Method, TClass, RenderFragmentDef.Method, TAmended> {\n  return ComponentMember<RenderFragmentDef.Method, TClass, RenderFragmentDef.Method, TAmended>((\n      { key, get, amend }: AeComponentMemberTarget<RenderFragmentDef.Method, TClass>,\n  ) => amend({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(() => {\n\n            const { component } = context;\n            const renderer = get(component).bind(component);\n\n            context.get(FragmentRenderCtl).renderFragmentBy(\n                renderer,\n                RenderFragment$def(context, key, def),\n            );\n          });\n        });\n      },\n    },\n  }));\n}\n\nfunction RenderFragment$def(\n    context: ComponentContext,\n    key: PropertyKey,\n    def: RenderFragmentDef = {},\n): RenderFragmentDef {\n\n  const spec = valueByRecipe(def, context);\n  const { target = ({ contentRoot }) => drekCharger(drekAppender(contentRoot), RenderFragment$defaultRem(key)) } = spec;\n\n  return { ...spec, target };\n}\n\nfunction RenderFragment$defaultRem(key: PropertyKey): string {\n\n  const rem = String(key);\n\n  return rem.startsWith('render') ? rem.substr(6) : rem;\n}\n","/**\n * Extracts URL contained in the hash of another URL.\n *\n * Extracted hash URL is based on origin of the original URL. Still, it may be absolute one.\n *\n * Input URL is never altered.\n *\n * @param url - An URL to extract hash from.\n *\n * @returns URL extracted from hash.\n */\nexport function getHashURL(url: URL): URL {\n  return new URL(url.hash.substring(1), url.origin);\n}\n\n/**\n * Creates an URL based on original one, but with hash substituted by the given hash URL.\n *\n * The hash URL is substituted as following:\n *\n * 1. If the hash URL's origin is not the same as the one of the base one, or if it contains a username,\n *    then absolute hash URL is substituted:\n * 2. Otherwise:\n *    - pathname is substituted, unless it is equal to `/` and no hash and search parameters present,\n *    - search parameters are substituted when at least one present,\n *    - hash is substituted only when present.\n *\n * Input URLs are never altered.\n *\n * @param url - Base URL.\n * @param hashURL - Hash URL to substitute.\n *\n * @returns URL with updated hash.\n */\nexport function setHashURL(url: URL, hashURL: URL): URL {\n  if (hashURL.origin !== url.origin || hashURL.username) {\n    return new URL(`#${hashURL}`, url);\n  }\n\n  const { pathname, search, hash } = hashURL;\n  const result = new URL('', url);\n\n  result.hash = (search || hash || pathname.length > 1) ? (pathname + search + hash) : (search + hash);\n\n  return result;\n}\n","import { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = (/*#__PURE__*/ Symbol('PageParam'));\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to {@link LeavePageEvent}). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeParam T - Parameter value type.\n * @typeParam TInput - Parameter input type.\n */\nexport abstract class PageParam<T, TInput> implements PageParam.Ref<T, TInput> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}. It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page - A page to assign navigation parameter to.\n   * @param input - Parameter input used to construct its initial value.\n   * @param context - Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: TInput, context: PageParamContext): PageParam.Handle<T, TInput>;\n\n  /**\n   * Creates default page parameter handle.\n   *\n   * This method is called when {@link Page.get requesting page parameter} which value is not present in the page.\n   * The value handle returned is assigned to the page.\n   *\n   * Returns nothing by default.\n   *\n   * @param _page - A page to assign navigation parameter to.\n   * @param _context - Page parameter context.\n   *\n   * @returns New page parameter value handle or nothing if there is no default value.\n   */\n  byDefault(_page: Page, _context: PageParamContext): PageParam.Handle<T, TInput> | undefined {\n    return;\n  }\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface Ref<T, TInput> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, TInput>;\n\n  }\n\n  /**\n   * Page navigation parameter that has default value.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface WithDefaults<T, TInput> extends PageParam<T, TInput> {\n\n    byDefault(page: Page, context: PageParamContext): PageParam.Handle<T, TInput>;\n\n  }\n\n  export namespace WithDefaults {\n\n    /**\n     * A reference to page navigation parameter that has default value.\n     *\n     * @typeParam T - Parameter value type.\n     * @typeParam TInput - Parameter input type.\n     */\n    export interface Ref<T, TInput> {\n\n      /**\n       * Referred page navigation parameter instance.\n       */\n      readonly [PageParam__symbol]: WithDefaults<T, TInput>;\n\n    }\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   */\n  export interface Handle<T, TInput> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input - Parameter input to use when updating its value.\n     */\n    put(input: TInput): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before {@link LeavePageEvent} is fired for each parameter handle of current page.\n     *\n     * @param to - A page to transfer parameter to.\n     * @param when - When the transfer happens. Either `pretend`, `pre-open`, `pre-replace`, `open`, or `return`.\n     * `return` is used when return to page generated by another app version. E.g. from the page that has been\n     * reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(\n        to: Page, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return',\n    ): Handle<T, TInput> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page - Entered page.\n     * @param when - When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at - The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { contextDestroyed, ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, afterThe, digAfter } from '@proc7ts/fun-events';\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next - Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional {@link Navigation.Target} parameter. The original target will be used instead when omitted.\n * @param when - When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n * @param from - The page to leave.\n * @param to - Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pretend' | 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\n/**\n * @internal\n */\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent> {\n\n  readonly upKey: ContextUpKey.UpKey<NavigationAgent.Combined, NavigationAgent>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        slot => {\n\n          const { document } = slot.context.get(BootstrapWindow);\n\n          slot.insert(slot.seed.do(\n              digAfter((...agents) => {\n                if (agents.length) {\n                  return afterThe(combinedAgent);\n                }\n                if (slot.hasFallback && slot.or) {\n                  return slot.or;\n                }\n\n                return afterThe(defaultNavigationAgent);\n\n                function combinedAgent(\n                    next: (this: void, target: Navigation.URLTarget) => void,\n                    when: 'pretend' | 'pre-open' | 'pre-replace',\n                    from: Page,\n                    to: Page,\n                ): void {\n\n                  return navigate(0, to);\n\n                  function navigate(agentIdx: number, agentTo: Page): void {\n\n                    const agent = agents[agentIdx];\n\n                    if (!agent) {\n                      return next(agentTo);\n                    }\n\n                    agent(\n                        (\n                            {\n                              url: nextURL = agentTo.url,\n                              title: nextTitle = agentTo.title,\n                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                              data: nextData = agentTo.data,\n                            }: Navigation.Target = agentTo,\n                        ) => navigate(\n                            agentIdx + 1,\n                            {\n                              url: new URL(String(nextURL), document.baseURI),\n                              title: nextTitle,\n                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                              data: nextData,\n                              get visited() {\n                                return agentTo.visited;\n                              },\n                              get current() {\n                                return agentTo.current;\n                              },\n                              get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n                                return agentTo.get(ref);\n                              },\n                              put(ref, input) {\n                                agentTo.put(ref, input);\n                              },\n                            },\n                        ),\n                        when,\n                        from,\n                        agentTo,\n                    );\n                  }\n                }\n              }),\n          ));\n        },\n    );\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          NavigationAgent.Combined,\n          ContextUpKey.Source<NavigationAgent>,\n          AfterEvent<NavigationAgent[]>>,\n  ): void {\n\n    let delegated: NavigationAgent.Combined;\n\n    slot.context.get(\n        this.upKey,\n        slot.hasFallback ? { or: slot.or != null ? afterThe(slot.or) : slot.or } : undefined,\n    )!(\n        agent => delegated = agent,\n    ).whenOff(\n        reason => delegated = contextDestroyed(reason),\n    );\n\n    slot.insert((next, when, from, to) => delegated(next, when, from, to));\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavigationAgent(\n    next: (this: void, target: Navigation.URLTarget) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n  next(to);\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under {@link NavigationAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or applies the final navigation target if this agent is the\n   * last one. Not calling this function effectively prevents navigation.\n   * Accepts an optional {@link Navigation.Target} parameter. The original target will be used instead when omitted.\n   * @param when - When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n   * @param from - The page to leave.\n   * @param to - Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pretend' | 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an {@link NavigationAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> = (\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent')\n);\n","import { ContextValues } from '@proc7ts/context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from '@proc7ts/context-values';\nimport { ValueTracker } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * @internal\n */\nconst NavHistory__key = (/*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'nav-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n));\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\n/**\n * @internal\n */\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      ? { data: state }\n      : (state as NavDataEnvelope)[NAV_DATA_KEY] as PartialNavData;\n}\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol](): ContextKey<NavHistory> {\n    return NavHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry): void {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        data,\n      },\n    };\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      get url() {\n        return target.url;\n      },\n      get title() {\n        return target.title;\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      get data(): any {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return target.data;\n      },\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(param);\n\n    if (handle) {\n      return handle.get();\n    }\n\n    const newHandle = param.byDefault(this.page, this._newContext());\n\n    return newHandle && this._init(param, newHandle);\n  }\n\n  put<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, TInput> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    return this._init(param, param.create(this.page, input, this._newContext()));\n  }\n\n  private _newContext(): PageParamContext {\n\n    const registry = new ContextRegistry<ParamContext>(this._bsContext);\n\n    class ParamContext extends PageParamContext {\n\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n\n    }\n\n    return new ParamContext();\n  }\n\n  private _init<T, TInput>(param: PageParam<T, TInput>, handle: PageParam.Handle<T, TInput>): T {\n    this._params.set(param, handle);\n\n    if (this.page.current && handle.enter) {\n      handle.enter(this.page, 'init');\n    }\n\n    return handle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): void {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page): void {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave(): void {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget(): void {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void): void {\n    this._update = update;\n  }\n\n  apply(): void {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n","import { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type - Event type.\n   * @param init - Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","import { DomEventDispatcher, OnDomEvent } from '@frontmeans/dom-events';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventSender,\n  mapAfter,\n  onAny,\n  OnEvent,\n  OnEvent__symbol,\n  onSupplied,\n  trackValue,\n} from '@proc7ts/fun-events';\nimport { mergeFunctions, noop } from '@proc7ts/primitives';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\n/**\n * @internal\n */\nconst Navigation__key = (/*#__PURE__*/ new SingleContextKey<Navigation>(\n    'navigation',\n    {\n      byDefault: bootstrapDefault(createNavigation),\n    },\n));\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * Current page.\n   */\n  abstract readonly page: Page;\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * An `OnDomEvent` sender of {@link EnterPageEvent enter page events}.\n   */\n  abstract readonly onEnter: OnDomEvent<EnterPageEvent>;\n\n  /**\n   * An `OnDomEvent` sender of {@link LeavePageEvent leave page events}.\n   *\n   * The registered listener may cancel navigation by calling `preventDefault()` method of received event.\n   */\n  abstract readonly onLeave: OnDomEvent<LeavePageEvent>;\n\n  /**\n   * An `OnDomEvent` {@link StayOnPageEvent stay on page events}.\n   *\n   * The registered listener is informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   *\n   * @returns `OnDomEvent` sender of {@link StayOnPageEvent stay on page events}.\n   */\n  abstract readonly onStay: OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * An `OnEvent` sender of {@link NavigationEvent navigation events}.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly on: OnEvent<[NavigationEvent]>;\n\n  [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on;\n  }\n\n  /**\n   * An `AfterEvent` keeper of {@link page current page}.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[Page]>;\n\n  [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read;\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta - Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target - Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target - Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url - An URL to replace the the current one with.\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeParam T - Parameter value type.\n   * @typeParam TInput - Parameter input type.\n   * @param ref - A reference to page navigation parameter to apply.\n   * @param input - Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeParam T - Parameter value type.\n     * @typeParam TInput - Parameter input type.\n     * @param ref - A reference to page navigation parameter to apply.\n     * @param input - Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target - Either navigation target or URL to navigate to. Navigates to current page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target - Either navigation target or URL to replace the latest history entry with. Navigates to current\n     * page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Pretends navigation.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target - Either navigation target or URL to pretend navigation to.\n     * @param callback - A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        target: Navigation.Target | string | URL,\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation to the same page.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param callback - A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation and builds navigation target.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target - Either navigation target or URL to pretend navigation to. Prepends navigation to current page\n     * when omitted.\n     *\n     * @returns Either Navigation target with URL value, or `undefined` when navigation failed.\n     */\n    pretend(\n        target?: Navigation.Target | string | URL,\n    ): URLTarget | undefined;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to {@link Navigation.open} and {@link Navigation.replace} methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n\nfunction createNavigation(context: BootstrapContext): Navigation {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate')(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange')(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  type NavTarget = { -readonly [K in keyof Navigation.URLTarget]: Navigation.URLTarget[K] };\n\n  class Navigation$ extends Navigation {\n\n    readonly onEnter: OnDomEvent<EnterPageEvent>;\n    readonly onLeave: OnDomEvent<LeavePageEvent>;\n    readonly onStay: OnDomEvent<StayOnPageEvent>;\n    readonly on: OnEvent<[NavigationEvent]>;\n    readonly read: AfterEvent<[Page]>;\n\n    constructor() {\n      super();\n      this.onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage);\n      this.onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage);\n      this.onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage);\n      this.on = onAny<[NavigationEvent]>(\n          onSupplied(this.onEnter),\n          onSupplied(this.onLeave),\n          onSupplied(this.onStay),\n      );\n      this.read = nav.read.do(\n          mapAfter(({ page }) => page),\n      );\n    }\n\n    get page(): Page {\n      return nav.it.page;\n    }\n\n    get length(): number {\n      return history.length;\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation$();\n\n  function withParam(applyParams: (page: Page) => void): Navigation.Parameterized {\n    return {\n      with<T, TInput>(ref: PageParam.Ref<T, TInput>, input: TInput): Navigation.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target?: Navigation.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target?: Navigation.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n      pretend<T>(\n          targetOrCallback?: Navigation.Target | string | URL | ((this: void, from: Page, to: Page) => T),\n          callback: (this: void, from: Page, to: Page) => T = (_from, to) => to as unknown as T,\n      ): T | undefined {\n\n        let target: Navigation.Target | string | URL | undefined;\n\n        if (typeof targetOrCallback === 'function') {\n          callback = targetOrCallback;\n          target = undefined;\n        } else {\n          target = targetOrCallback;\n        }\n\n        const navTarget = navTargetOf(target);\n        const fromEntry = nav.it;\n        const toEntry = newEntry('pretend', fromEntry, navTarget, applyParams);\n\n        try {\n          return applyAgent('pretend', fromEntry, navTarget, toEntry)\n              ? callback(fromEntry.page, toEntry.page)\n              : undefined;\n        } finally {\n          toEntry.stay(nav.it.page);\n        }\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function navTargetOf(target?: Navigation.Target | string | URL): NavTarget {\n    if (target == null || typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target?: Navigation.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const navTarget = navTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined = undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n        navHistory[when](toEntry, nav);\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = newEntry(whenLeave, fromEntry, navTarget, applyParams);\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      if (!dispatcher.dispatch(leavePage)\n          || next !== promise\n          || !applyAgent(whenLeave, fromEntry, navTarget, toEntry)) {\n        return stay(toEntry);\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: navTarget,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n\n  function newEntry(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      applyParams: (page: Page) => void,\n  ): PageEntry {\n\n    const toEntry = navHistory.newEntry(navTarget);\n\n    try {\n      fromEntry.transfer(toEntry, whenLeave);\n      applyParams(toEntry.page);\n    } catch (e) {\n      toEntry.stay(nav.it.page);\n      throw e;\n    }\n\n    return toEntry;\n  }\n\n  function applyAgent(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      toEntry: PageEntry,\n  ): boolean {\n\n    let navigated = false;\n\n    agent(\n        ({ url, data, title }) => {\n          navigated = true;\n          navTarget.url = url;\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          navTarget.data = data;\n          navTarget.title = title;\n        },\n        whenLeave,\n        fromEntry.page,\n        toEntry.page,\n    );\n\n    return navigated;\n  }\n\n}\n","import { DomEventDispatcher } from '@frontmeans/dom-events';\nimport { deriveDrekContext, drekContextOf, drekCssClassesOf } from '@frontmeans/drek';\nimport { css__naming, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { EventReceiver } from '@proc7ts/fun-events';\nimport { setOfElements, valueByRecipe } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentRenderScheduler, DefaultNamespaceAliaser, RenderDef, Wesib__NS } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { NavLink } from './nav-link';\n\nexport namespace NavElement {\n\n  /**\n   * Navigation element construction options.\n   *\n   * @typeParam TElement - Navigation element type.\n   */\n  export interface Options<TElement extends Element> {\n\n    /**\n     * Type or types of events to handle.\n     *\n     * `click` by default.\n     */\n    readonly event?: string | readonly string[];\n\n    /**\n     * Qualified name of CSS class to mark the active anchor element with.\n     *\n     * The `active` class in Wesib namespace is used by default.\n     */\n    readonly active?: QualifiedName;\n\n    /**\n     * Rendering definition options to pass to nav links render scheduler.\n     */\n    readonly render?: RenderDef.Options;\n\n    /**\n     * Extracts an {@link NavLink.href URI} the navigation link refers to.\n     *\n     * @param element - Navigation element instance.\n     *\n     * @returns Navigation URI.\n     */\n    href(element: TElement): string;\n\n  }\n\n}\n\nconst NavElement$activeClass: QualifiedName = ['active', Wesib__NS];\n\n/**\n * Creates navigation link for the given element.\n *\n * @typeParam TElement - Navigation element type.\n * @param element - Either target element, or a function returning one by the given navigation link owner.\n * @param options - Custom navigation element options.\n *\n * @returns Navigation link provider.\n */\nexport function navElement<TElement extends Element>(\n    element:\n        | TElement\n        | ((this: void, owner: NavLink.Owner) => TElement),\n    options: NavElement.Options<TElement>,\n): (this: void, owner: NavLink.Owner) => NavLink;\n\n/**\n * Optionally creates navigation link for the given element.\n *\n * @typeParam TElement - Navigation element type.\n * @param element - Either target element, or a function returning one by the given navigation link owner,\n * or nothing.\n * @param options - Custom navigation element options.\n *\n * @returns Navigation link provider.\n */\nexport function navElement<TElement extends Element>(\n    element:\n        | TElement\n        | ((this: void, owner: NavLink.Owner) => TElement | null | undefined)\n        | null\n        | undefined,\n    options: NavElement.Options<TElement>,\n): NavLink.Provider;\n\nexport function navElement<TElement extends Element>(\n    element:\n        | TElement\n        | ((this: void, owner: NavLink.Owner) => TElement | null | undefined)\n        | null\n        | undefined,\n    options: NavElement.Options<TElement>,\n): NavLink.Provider {\n\n  const getHref = options.href.bind(options);\n  const events = setOfElements(options.event || 'click');\n  const { active = NavElement$activeClass } = options;\n  let activeClass: string;\n\n  return owner => {\n\n    const anchor = valueByRecipe(element, owner);\n\n    if (!anchor) {\n      return;\n    }\n\n    const { context, supply: ownerSupply = context.supply } = owner;\n\n    activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n\n    const navigation = context.get(Navigation);\n    const scheduler = context.get(ComponentRenderScheduler);\n    const schedule = scheduler({ node: anchor });\n    const supply = new Supply().needs(ownerSupply);\n    const handleClick: EventReceiver<[Event]> = {\n      supply,\n      receive(_ctx, event) {\n\n        const href = getHref(anchor);\n        const pageURL = navigation.page.url;\n        const url = new URL(href, anchor.ownerDocument.baseURI);\n\n        if (url.origin !== pageURL.origin) {\n          return; // External link\n        }\n\n        event.preventDefault();\n        if (pageURL.href !== url.href) {\n          navigation.open(href).catch(console.error);\n        }\n      },\n    };\n    const eventDispatcher = new DomEventDispatcher(anchor);\n\n    supply.cuts(eventDispatcher);\n    for (const event of events) {\n      eventDispatcher.on(event)(handleClick);\n    }\n\n    const css = drekCssClassesOf(anchor)\n        .renderIn(\n            deriveDrekContext(\n                drekContextOf(anchor),\n                {\n                  scheduler: _opts => schedule,\n                },\n            ),\n        );\n\n    return ({\n\n      get href(): string {\n        return getHref(anchor!);\n      },\n\n      supply,\n\n      activate() {\n        return css.add(activeClass);\n      },\n\n    });\n  };\n}\n\n","import { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { DrekContentStatus } from '../content-status';\nimport { DrekContext } from '../context';\nimport { DrekContext$State } from '../context.impl';\nimport { DrekFragment } from '../fragment';\n\n/**\n * Creates a rendering context based on another one.\n *\n * @typeParam TStatus - A type of the tuple containing a context content status as its first element.\n * @param base - Base rendering context.\n * @param update - Context update.\n *\n * @returns Updated rendering context, or the `base` one if nothing to update.\n */\nexport function deriveDrekContext<TStatus extends [DrekContentStatus] = [DrekContentStatus]>(\n    base: DrekContext<TStatus>,\n    update: DrekContext.Update = {},\n): DrekContext<TStatus> {\n\n  const {\n    nsAlias: initialNsAlias = base.nsAlias,\n    scheduler: initialScheduler = base.scheduler,\n  } = update;\n\n  if (initialNsAlias === base.nsAlias && initialScheduler === base.scheduler) {\n    return base;\n  }\n\n  const state = new DrekContext$State({\n    nsAlias: initialNsAlias,\n    scheduler: initialScheduler,\n  });\n  let lift = (derived: DrekContext): DrekContext => {\n\n    const lifted = base.lift();\n\n    if (lifted === base) {\n      return derived;\n    }\n\n    state.set(lifted);\n    lift = _derived => lifted;\n\n    return lifted;\n  };\n\n  class DrekContext$Derived extends DrekContext<TStatus> {\n\n    get fragment(): DrekFragment | undefined {\n      return base.fragment;\n    }\n\n    get window(): Window {\n      return base.window;\n    }\n\n    get document(): Document {\n      return base.document;\n    }\n\n    get nsAlias(): NamespaceAliaser {\n      return state.nsAlias;\n    }\n\n    get scheduler(): RenderScheduler {\n      return state.scheduler;\n    }\n\n    get readStatus(): AfterEvent<TStatus> {\n      return base.readStatus;\n    }\n\n    lift(): DrekContext {\n      return lift(this);\n    }\n\n  }\n\n  return new DrekContext$Derived();\n}\n","import { Contextual, Contextual__symbol } from '@proc7ts/context-values';\nimport { afterAll, AfterEvent, afterThe, isAfterEvent, trackValue, translateAfter_ } from '@proc7ts/fun-events';\nimport { noop, valueByRecipe } from '@proc7ts/primitives';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { BootstrapWindow, ComponentContext } from '@wesib/wesib';\nimport { getHashURL } from '../hash-url';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { NavLink } from './nav-link';\n\nconst NavMenu$Links__symbol = (/*#__PURE__*/ Symbol('NavMenu.links'));\n\n/**\n * Navigation menu.\n *\n * Serves as an {@link NavLink.Owner owner} of navigation links. Activates the links matching {@link Navigation.page\n * current page}.\n */\nexport class NavMenu implements Contextual<NavMenu, ComponentContext>, SupplyPeer {\n\n  /**\n   * @internal\n   */\n  private readonly [NavMenu$Links__symbol]: NavMenu$Links;\n\n  /**\n   * Navigation menu supply.\n   */\n  get supply(): Supply {\n    return this[NavMenu$Links__symbol].supply;\n  }\n\n  /**\n   * Constructs navigation menu.\n   *\n   * @param links - Navigation links of this menu. Either an iterable of navigation links or their providers,\n   * an `AfterEvent` keeper of the same, or a function accepting component context and this menu as parameters,\n   * and returning one of the above.\n   * @param options - Additional options.\n   */\n  constructor(\n      links:\n          | Iterable<NavLink | NavLink.Provider>\n          | AfterEvent<(NavLink | NavLink.Provider)[]>\n          | ((this: void, context: ComponentContext, menu: NavMenu) =>\n          | Iterable<NavLink | NavLink.Provider>\n          | AfterEvent<(NavLink | NavLink.Provider)[]>),\n      options?: NavMenu.Options,\n  ) {\n    this[NavMenu$Links__symbol] = new NavMenu$Links(this, links, options);\n  }\n\n  /**\n   * Binds this menu to the given context.\n   *\n   * Subsequent calls have no effect.\n   *\n   * @param context - Owning component context.\n   *\n   * @returns `this` instance.\n   */\n  bindTo(context: ComponentContext): this {\n    this[NavMenu$Links__symbol].bindTo(context);\n    return this;\n  }\n\n  /**\n   * Binds this menu to the given context.\n   *\n   * Calls {@link bindTo} method.\n   *\n   * @param context - Owning component context.\n   *\n   * @returns `this` instance.\n   */\n  [Contextual__symbol](context: ComponentContext): this {\n    return this.bindTo(context);\n  }\n\n}\n\nexport namespace NavMenu {\n\n  /**\n   * Navigation menu options.\n   */\n  export interface Options {\n\n    /**\n     * Whether to activate navigation links.\n     *\n     * `true` by default.\n     */\n    readonly activate?: boolean;\n\n    /**\n     * Weighs matching navigation link.\n     *\n     * This method will be called for each navigation link on each current page update.\n     *\n     * By default:\n     * 1. If the link path has neither hash, nor search parameters, then:\n     * 1.1. Checks whether page URL path starts with the link's one.\n     * 1.2. If so, then uses link path length as weight.\n     * 2. If the link path has search parameters, but has no hash, then requires the page path to be the same as link's\n     *    one, and page search parameters include all of the link's ones. The number of link search parameters plus the\n     *    link path length is used as weight.\n     * 3. If the link path has a hash, then requires the page path and search parameters to be the same as link's ones,\n     *    and their hashes are treated as {@link getHashURL URLs}. The weight is calculated by applying steps 1, 2, and\n     *    3 to hash URLs increased by the link path length and the number of search parameters.\n     *\n     * Ignores search parameters with names starting and ending with double underscores. Like `__wesib_app_rev__`.\n     *\n     * @param link - Navigation link to weigh.\n     * @param menu - Owning navigation menu.\n     * @param context - Owning component context.\n     * @param page - Current navigation page.\n     *\n     * @returns Navigation link weight. Non-positive wight means the page URL doesn't match the link at all.\n     */\n    weigh?(\n        {\n          link,\n          menu,\n          context,\n          page,\n        }: {\n          link: NavLink;\n          menu: NavMenu;\n          context: ComponentContext;\n          page: Page;\n        },\n    ): number;\n\n  }\n\n}\n\nclass NavMenu$Links {\n\n  readonly supply: Supply;\n  private readonly _links = trackValue([new Set<NavLink>()]);\n  private readonly _active = new Map<NavLink, Supply>();\n  private readonly _activate: boolean;\n  private readonly _weigh: typeof defaultNavLinkWeight;\n\n  constructor(\n      private readonly _menu: NavMenu,\n      private readonly _navLinks:\n          | Iterable<NavLink | NavLink.Provider>\n          | AfterEvent<(NavLink | NavLink.Provider)[]>\n          | ((this: void, context: ComponentContext, menu: NavMenu) =>\n          | Iterable<NavLink | NavLink.Provider>\n          | AfterEvent<(NavLink | NavLink.Provider)[]>),\n      options: NavMenu.Options = {},\n  ) {\n    this.supply = new Supply().cuts(this._links);\n\n    const { activate = true, weigh } = options;\n\n    this._activate = activate;\n    this._weigh = weigh ? weigh.bind(options) : defaultNavLinkWeight;\n  }\n\n  bindTo(context: ComponentContext): void {\n    this.bindTo = noop;\n    context.whenConnected(context => {\n\n      let afterLinks: AfterEvent<(NavLink | NavLink.Provider)[]>;\n\n      if (isAfterEvent(this._navLinks)) {\n        afterLinks = this._navLinks;\n      } else {\n\n        const linkValues = valueByRecipe(this._navLinks, context, this._menu);\n\n        afterLinks = isAfterEvent(linkValues)\n            ? linkValues\n            : afterThe(linkValues).do(\n                translateAfter_((send, links) => send(...links)),\n            );\n      }\n\n      const owner: NavLink.Owner = {\n        context,\n        supply: this.supply,\n      };\n\n      afterLinks((...links) => {\n        this._replace(owner, links);\n      });\n\n      if (this._activate) {\n\n        const navigation = context.get(Navigation);\n\n        afterAll({\n          page: navigation,\n          links: this._links,\n        })(({\n          page: [page],\n          links: [[links]],\n        }) => {\n          this._updateActive(context, page, links);\n        });\n      }\n    });\n  }\n\n  private _replace(\n      owner: NavLink.Owner,\n      replacement: readonly (NavLink | NavLink.Provider)[],\n  ): void {\n\n    const toAdd = new Set<NavLink>();\n\n    for (const linkOrProvider of replacement) {\n\n      const link = valueByRecipe(linkOrProvider, owner);\n\n      if (link) {\n        toAdd.add(link);\n      }\n    }\n\n    const [links] = this._links.it;\n    const toRemove: NavLink[] = [];\n\n    for (const link of links.keys()) {\n      if (!toAdd.delete(link)) {\n        toRemove.push(link);\n      }\n    }\n\n    if (toAdd.size || toRemove.length) {\n      for (const removed of toRemove) {\n        links.delete(removed);\n        this._deactivate(removed);\n        removed.supply?.off();\n      }\n      for (const added of toAdd) {\n\n        const { supply } = added;\n\n        if (supply) {\n          if (supply.isOff) {\n            continue; // Exclude disabled nav link.\n          }\n\n          supply.needs(this).whenOff(() => {\n            // Handle nav link removal\n\n            const [links] = this._links.it;\n\n            if (links.delete(added)) {\n              this._links.it = [links];\n            }\n          });\n        }\n\n        links.add(added);\n      }\n\n      this._links.it = [links];\n    }\n  }\n\n  private _updateActive(context: ComponentContext, page: Page, links: Set<NavLink>): void {\n\n    const toDeactivate: NavLink[] = [];\n    const toActivate = this._selectActive(context, page, links);\n\n    for (const link of this._active.keys()) {\n      if (!toActivate.delete(link)) {\n        toDeactivate.push(link);\n      }\n    }\n\n    for (const deactivated of toDeactivate) {\n      this._deactivate(deactivated);\n    }\n    for (const activated of toActivate) {\n      if (activated.activate) {\n        this._active.set(\n            activated,\n            activated.activate(),\n        );\n      }\n    }\n  }\n\n  private _selectActive(context: ComponentContext, page: Page, links: Set<NavLink>): Set<NavLink> {\n\n    let maxWeight = 0;\n    let active = new Set<NavLink>();\n\n    for (const link of links) {\n\n      const weight = this._weigh({ link, menu: this._menu, context, page });\n\n      if (weight > maxWeight) {\n        maxWeight = weight;\n        active = new Set<NavLink>().add(link);\n      } else if (weight === maxWeight) {\n        active.add(link);\n      }\n    }\n\n    return active;\n  }\n\n  private _deactivate(link: NavLink): void {\n\n    const supply = this._active.get(link);\n\n    if (supply) {\n      this._active.delete(link);\n      supply.off();\n    }\n  }\n\n}\n\nfunction defaultNavLinkWeight(\n    {\n      link,\n      context,\n      page,\n    }: {\n      link: NavLink;\n      menu: NavMenu;\n      context: ComponentContext;\n      page: Page;\n    },\n): number {\n\n  const href = link.href;\n  const linkURL = new URL(href, context.get(BootstrapWindow).document.baseURI);\n\n  return calcNavLinkWeight(linkURL, page.url);\n}\n\nfunction calcNavLinkWeight(linkURL: URL, pageURL: URL): number {\n  if (linkURL.origin !== pageURL.origin) {\n    return -1;\n  }\n\n  const linkDir = navLinkPath2dir(linkURL);\n  const pageDir = navLinkPath2dir(pageURL);\n\n  if (linkURL.hash) {\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    // Require search parameters to be equal\n\n    const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n    if (searchParamWeight < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n      return -1;\n    }\n\n    return linkURL.pathname.length\n        + searchParamWeight\n        + calcNavLinkWeight(getHashURL(linkURL), getHashURL(pageURL));\n  }\n\n  const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n  if (searchParamWeight) {\n    if (searchParamWeight < 0) {\n      return -1;\n    }\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    return linkURL.pathname.length + searchParamWeight;\n  }\n\n  if (!pageDir.startsWith(linkDir)) {\n    return -1;\n  }\n\n  return linkURL.pathname.length;\n}\n\nfunction navLinkPath2dir(url: URL): string {\n\n  const path = url.pathname;\n\n  return path.endsWith('/') ? path : path + '/';\n}\n\nfunction navLinkSearchParamsWeight(\n    { searchParams: linkParams }: URL,\n    { searchParams: pageParams }: URL,\n): number {\n\n  let weight = 0;\n\n  linkParams.forEach((value, key) => {\n    if (!isIgnoredSearchParam(key)) {\n      if (weight >= 0) {\n        if (pageParams.getAll(key).includes(value)) {\n          weight += 1;\n        } else {\n          weight = -1;\n        }\n      }\n    }\n  });\n\n  return weight;\n}\n\nfunction isIgnoredSearchParam(key: string): boolean {\n  return key.startsWith('__') && key.endsWith('__');\n}\n","import { ContextUpRef } from '@proc7ts/context-values/updatable';\nimport { EventSender, OnEvent } from '@proc7ts/fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next - Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request - HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under {@link PageLoadAgent} key.\n   */\n  export type Combined =\n  /**\n   * @param next - Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request - HTTP request.\n   *\n   * @returns An `OnEvent` sender of page load response.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an {@link PageLoadAgent} instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent')\n);\n","import { OnEvent, onEventBy, supplyOn, trackValue, valueOn_ } from '@proc7ts/fun-events';\nimport { asis } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: Supply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = new Supply(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.cuts(trackSupply).cuts(tracker);\n\n        tracked = {\n          on: tracker.read.do(valueOn_(asis)),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on.do(supplyOn(supply))(receiver).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          }).catch(console.error);\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  mapOn_,\n  OnEvent,\n  onEventBy,\n  shareOn,\n  supplyOn,\n} from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { flatMapIt, itsEach, itsEvery, overIterator, PushIterable } from '@proc7ts/push-iterator';\nimport { neverSupply, Supply } from '@proc7ts/supply';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\nclass PageLoadRequestsParam$ extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam$();\n\n/**\n * @internal\n */\nexport class PageLoadRequests {\n\n  private readonly _map = new Map<Supply, PageLoadReq[]>();\n  private readonly _requests: PushIterable<PageLoadReq>;\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {\n    this._requests = flatMapIt(overIterator(() => this._map.values()));\n  }\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    if (!itsEvery(\n        this._requests,\n        request => {\n          if (!request.fragment) {\n            return false;\n          }\n          result.push(request.fragment);\n          return true;\n        },\n    )) {\n      return [];\n    }\n\n    return result;\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = new Supply(noop);\n    let loadSupply = neverSupply();\n\n    return {\n      get() {/* void */},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page, when) {\n        if (when === 'pretend') {\n          return;\n        }\n\n        const transferred = self._transfer();\n\n        to.put(PageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = new Supply(noop).needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page).do(supplyOn(loadSupply))(\n              response => emitter.send(response),\n          ).whenOff(error => {\n            if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n              // Report current page load error as failed load response\n              emitter.send({\n                ok: false as const,\n                page,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error,\n              });\n            }\n          });\n\n          return supply;\n        }).do(shareOn);\n\n        itsEach(\n            self._requests,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment)({\n              supply: new Supply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest): void {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, list.slice());\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.do(\n          mapOn_(\n              response => response.ok\n                  ? {\n                    ...response,\n                    fragment: (\n                        fragment.tag != null\n                            ? response.document.getElementsByTagName(fragment.tag)[0]\n                            : response.document.getElementById(fragment.id)\n                    ) || undefined,\n                  }\n                  : response,\n          ),\n      )\n      : onLoad;\n}\n","import { ContextUpRef, FnContextKey } from '@proc7ts/context-values/updatable';\nimport { noop, valueProvider } from '@proc7ts/primitives';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url - An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> = (\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) })\n);\n","import { hthvParse, hthvQuote } from '@hatsy/http-header-value';\nimport { SingleContextKey } from '@proc7ts/context-values';\nimport { afterThe, digOn_, EventNotifier, mapOn_, OnEvent, onEventBy, resolveOnOrdered } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = (/*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n));\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser = new window.DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ Accept: 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request)(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      requestPageFragments(page, fetchRequest);\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const dispatcher = new EventNotifier<[PageLoadResponse]>();\n\n        dispatcher.on(receiver);\n        dispatcher.send({ page });\n\n        httpFetch(fetchRequest).do(\n            mapOn_(response => Promise.all([response, response.text()])),\n            resolveOnOrdered,\n            digOn_((...batch: [Response, string][]) => afterThe<[Response, string][]>(...batch)),\n            mapOn_(([response, text]): PageLoadResponse => {\n              if (!response.ok) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error: response.status,\n                };\n              }\n              try {\n                return {\n                  ok: true as const,\n                  page,\n                  response,\n                  document: parsePageDocument(parser, url, response, text),\n                };\n              } catch (error) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                  error,\n                };\n              }\n            }),\n        )(receiver);\n      });\n    }\n  };\n}\n\nfunction requestPageFragments(page: Page, request: Request): void {\n\n  const fragments = page.get(PageLoadRequestsParam)?.fragments;\n\n  if (fragments && fragments.length) {\n    request.headers.set(\n        'Accept-Fragment',\n        fragments.reduce(\n            (header, fragment) => (header ? header + ', ' : '') + (\n                fragment.tag != null\n                    ? 'tag=' + hthvQuote(fragment.tag)\n                    : 'id=' + hthvQuote(fragment.id)\n            ),\n            '',\n        ),\n    );\n  }\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as DOMParserSupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","import { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nclass PageLoadParam$ extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext): PageParam.Handle<void, PageLoadRequest> {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(PageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const PageLoadParam: PageParam<void, PageLoadRequest> = (/*#__PURE__*/ new PageLoadParam$());\n","import { ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { AfterEvent, afterThe, mapOn_ } from '@proc7ts/fun-events';\nimport { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = (/*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<PageLoadURLModifier[]>;\n  readonly agent: AfterEvent<PageLoadAgent[]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe(\n          (next, request) => next(new Request(request.url, request)).do(\n              mapOn_(response => {\n                    if (response.ok) {\n\n                      const newRev = appRev(response.document);\n\n                      if (newRev && newRev !== rev) {\n\n                        const url = new URL(response.page.url.href);\n\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                      }\n                    }\n\n                    return response;\n                  }),\n          ),\n      );\n    }\n  }\n\n}\n\nfunction appRev(doc: Document): string | null | undefined {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","import { importNode } from '@frontmeans/dom-primitives';\nimport { mapOn_ } from '@proc7ts/fun-events';\nimport { filterArray, filterIt, itsEach, mapIt, PushIterable } from '@proc7ts/push-iterator';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(\n      mapOn_(response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, doc.scripts),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, response.document.querySelectorAll('script')),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      }),\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: ArrayLike<HTMLScriptElement>,\n): PushIterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterArray(scripts, ({ src }) => !!src),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","import { importNode } from '@frontmeans/dom-primitives';\nimport { mapOn_ } from '@proc7ts/fun-events';\nimport { itsEach, itsFirst, overArray } from '@proc7ts/push-iterator';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(\n      mapOn_(response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      }),\n  );\n}\n","import { mapOn_ } from '@proc7ts/fun-events';\nimport { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().do(mapOn_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  }));\n}\n","import { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    });\n    setup.provide({\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    });\n    setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n    setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n    setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n  },\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","import { importNodeContent } from '@frontmeans/dom-primitives';\nimport { ContextKey, SingleContextKey } from '@proc7ts/context-values';\nimport { onceAfter, trackValue } from '@proc7ts/fun-events';\nimport { valueByRecipe } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext } from '@wesib/wesib';\nimport { FragmentRenderCtl } from '../../fragment';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageFragmentRequest, PageLoadParam, PageLoadResponse } from '../page-load';\nimport { PageRenderer, PageRendererExecution } from './page-renderer';\nimport { RenderPageDef } from './render-page-def';\n\n/**\n * Page render control.\n *\n * Controls rendering by {@link PageRenderer page renderers} upon page load.\n *\n * Available in component context.\n */\nexport interface PageRenderCtl {\n\n  /**\n   * Enables loaded page rendering by the given `renderer`.\n   *\n   * A `renderer` call will be scheduled by {@link DocumentRenderKit document render kit} once {@link Navigation.page\n   * current page} changes.\n   *\n   * @param renderer - Page renderer function.\n   * @param def - Optional page rendering definition.\n   *\n   * @returns Renderer supply. The rendering would stop once this supply is cut off.\n   */\n  renderPageBy(renderer: PageRenderer, def?: RenderPageDef): Supply;\n\n}\n\n/**\n * A key of component context value containing {@link PageRenderCtl page render control}.\n */\nexport const PageRenderCtl: ContextKey<PageRenderCtl> = (/*#__PURE__*/ new SingleContextKey(\n    'page-render-ctl',\n    {\n      byDefault(context) {\n        return new PageRenderCtl$(context.get(ComponentContext));\n      },\n    },\n));\n\nclass PageRenderCtl$ implements PageRenderCtl {\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  renderPageBy(renderer: PageRenderer, def: RenderPageDef = {}): Supply {\n\n    const spec = valueByRecipe(def, this._context);\n    const { contentKey = RenderPage$contentKey$default } = spec;\n    const detectFragment = RenderPage$fragmentDetector(spec);\n\n    const navigation = this._context.get(Navigation);\n    const renderCtl = this._context.get(FragmentRenderCtl);\n\n    let lastPageKey: string;\n    const responseTracker = trackValue<[PageLoadResponse, string]>();\n    const handleResponse = (response: PageLoadResponse): void => {\n\n      const pageKey = contentKey(response.page);\n\n      if (pageKey === lastPageKey) {\n        return;// Only hash changed? Do not refresh the page.\n      }\n\n      responseTracker.it = [response, pageKey];\n    };\n    const supply = renderCtl.renderFragmentBy(\n        fragExec => {\n\n          const responseAndKey = responseTracker.it;\n\n          if (!responseAndKey) {\n            fragExec.retainContent();\n            return;\n          }\n\n          const [response, pageKey] = responseAndKey;\n          const exec: PageRendererExecution = {\n            ...fragExec,\n            postpone(postponed) {\n              fragExec.postpone(() => postponed(exec));\n            },\n            response,\n          };\n\n          if (response.ok) {\n            lastPageKey = pageKey;\n\n            const { fragment } = response;\n\n            if (fragment) {\n              importNodeContent(fragment, fragExec.content);\n            }\n          }\n\n          renderer(exec);\n        },\n        {\n          ...spec,\n          when: 'connected',\n          on: responseTracker.on,\n        },\n    );\n\n    this._context.whenConnected(context => {\n      lastPageKey = contentKey(navigation.page);\n      navigation.read.do(onceAfter)(page => {\n        page.put(\n            PageLoadParam,\n            {\n              fragment: detectFragment(context),\n              receiver: {\n                supply: new Supply().needs(supply),\n                receive: (_ctx, response) => handleResponse(response),\n              },\n            },\n        );\n      });\n    });\n\n    return supply;\n  }\n\n}\n\nfunction RenderPage$fragmentDetector(\n    { fragment }: RenderPageDef.Spec,\n): (context: ComponentContext) => PageFragmentRequest {\n  if (fragment) {\n    return _context => fragment;\n  }\n\n  return ({\n    element: { id, tagName },\n  }: {\n    element: Element;\n  }) => id\n      ? { id }\n      : { tag: tagName.toLowerCase() };\n}\n\nfunction RenderPage$contentKey$default({ url }: Page): string {\n  return new URL('', url).href;\n}\n","import { Share } from './share';\n\n/**\n * A key of {@link ShareRef component share reference} property containing a {@link Share component\n * share} instance.\n */\nexport const Share__symbol = (/*#__PURE__*/ Symbol('Share'));\n\n/**\n * A reference to {@link Share component share}.\n *\n * @typeParam T - Shared value type.\n */\nexport interface ShareRef<T> {\n\n  /**\n   * Component share instance.\n   */\n  readonly [Share__symbol]: Share<T>;\n\n}\n\n/**\n * Checks whether the given value is a {@link ShareRef component share reference}.\n *\n * @typeParam T - Shared value type.\n * @typeParam TOther - Another type the value may have.\n * @param value - A value to check.\n *\n * @returns `true` if the value has a {@link Share__symbol} property, or `false` otherwise.\n */\nexport function isShareRef<T, TOther>(value: ShareRef<T> | TOther): value is ShareRef<T> {\n  return !!value\n      && (typeof value === 'object' || typeof value === 'function')\n      && !!(value as Partial<ShareRef<T>>)[Share__symbol];\n}\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { trackValue, ValueTracker } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { bootstrapDefault, ComponentClass, DefaultNamespaceAliaser } from '@wesib/wesib';\nimport { Share } from './share';\n\nconst ShareRegistry__key = (/*#__PURE__*/ new SingleContextKey(\n    'share-registry',\n    {\n      byDefault: bootstrapDefault(bsContext => new ShareRegistry(bsContext.get(DefaultNamespaceAliaser))),\n    },\n));\n\n/**\n * @internal\n */\nexport class ShareRegistry {\n\n  static get [ContextKey__symbol](): ContextKey<ShareRegistry> {\n    return ShareRegistry__key;\n  }\n\n  private readonly _sharers = new Map<Share<unknown>, ValueTracker<Sharers>>();\n\n  constructor(readonly nsAlias: DefaultNamespaceAliaser) {\n  }\n\n  addSharer(\n      share: Share<unknown>,\n      componentType: ComponentClass,\n      elementName: string | undefined,\n      supply: Supply,\n  ): void {\n\n    let sharers = this._sharers.get(share);\n\n    if (!sharers) {\n      sharers = Sharers$new();\n      this._sharers.set(share, sharers);\n      Sharers$addSharer(sharers, componentType, supply);\n      Sharers$addName(sharers, elementName, supply);\n    } else {\n      Sharers$addSharer(sharers, componentType, supply);\n      Sharers$addName(sharers, elementName, supply);\n      sharers.it = { ...sharers.it };\n    }\n  }\n\n  sharers(share: Share<unknown>): ValueTracker<Sharers> {\n\n    let sharers = this._sharers.get(share);\n\n    if (!sharers) {\n      sharers = Sharers$new();\n      this._sharers.set(share, sharers);\n    }\n\n    return sharers;\n  }\n\n}\n\n/**\n * @internal\n */\nexport interface Sharers {\n\n  readonly names: Map<string, number>;\n  readonly sharers: Map<ComponentClass, number>;\n\n}\n\nfunction Sharers$new(): ValueTracker<Sharers> {\n  return trackValue({ names: new Map(), sharers: new Map() });\n}\n\nfunction Sharers$addName(\n    tracker: ValueTracker<Sharers>,\n    name: string | undefined,\n    supply: Supply,\n): void {\n  if (!name) {\n    return;\n  }\n\n  const sharers = tracker.it;\n  const counter = sharers.names.get(name) || 0;\n\n  sharers.names.set(name, counter + 1);\n  supply.whenOff(() => {\n\n    const counter = sharers.names.get(name)! - 1;\n\n    if (counter > 0) {\n      sharers.names.set(name, counter);\n    } else {\n      sharers.names.delete(name);\n    }\n\n    tracker.it = { ...sharers };\n  });\n}\n\nfunction Sharers$addSharer(\n    tracker: ValueTracker<Sharers>,\n    componentType: ComponentClass,\n    supply: Supply,\n): void {\n\n  const sharers = tracker.it;\n  const counter = sharers.sharers.get(componentType) || 0;\n\n  sharers.sharers.set(componentType, counter + 1);\n  supply.whenOff(() => {\n\n    const counter = sharers.sharers.get(componentType)! - 1;\n\n    if (counter > 0) {\n      sharers.sharers.set(componentType, counter);\n    } else {\n      sharers.sharers.delete(componentType);\n    }\n\n    tracker.it = { ...sharers };\n  });\n}\n","import { ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, digAfter } from '@proc7ts/fun-events';\nimport { Share } from './share';\nimport { SharedValue } from './shared-value';\n\n/**\n * @internal\n */\nexport class ShareKey<T> extends ContextUpKey<AfterEvent<[T?]>, SharedValue<T>> {\n\n  constructor(name: string, private readonly _share: Share<T>) {\n    super(`${name}:share`);\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          AfterEvent<[T?]>,\n          Share.Source<T>,\n          AfterEvent<SharedValue<T>[]>>,\n  ): void {\n    slot.insert(\n        slot.seed.do(\n            digAfter((...values) => this._share.selectValue(...values)),\n        ),\n    );\n  }\n\n}\n","import { html__naming } from '@frontmeans/namespace-aliaser';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { arrayOfElements } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { BootstrapContext, DefinitionContext } from '@wesib/wesib';\nimport { Share } from './share';\nimport { ShareKey } from './share-key.impl';\nimport { Share__symbol } from './share-ref';\nimport { ShareRegistry } from './share-registry.impl';\nimport { SharedValue } from './shared-value';\n\n/**\n * @internal\n */\nexport const Share$impl__symbol = (/*#__PURE__*/ Symbol('Share.impl'));\n\n/**\n * @internal\n */\nexport class Share$<T> {\n\n  readonly key: ContextUpKey<AfterEvent<[T?]>, SharedValue<T>>;\n  private readonly _aliases: readonly Share<T>[];\n\n  constructor(\n      private readonly _share: Share<T>,\n      readonly name: string,\n      options: Share.Options<T>,\n  ) {\n    this.key = new ShareKey(name, _share);\n    this._aliases = arrayOfElements(options.as).map(alias => alias[Share__symbol]);\n  }\n\n  addSharer(defContext: DefinitionContext, options: SharedValue.Options = {}): Supply {\n\n    const { local, name = defContext.elementDef.name } = options;\n    const registry = defContext.get(BootstrapContext).get(ShareRegistry);\n    const supply = new Supply();\n    const { componentType } = defContext;\n    const elementName = local\n        ? undefined\n        : name && html__naming.name(name, registry.nsAlias).toLowerCase();\n\n    registry.addSharer(this._share, componentType, elementName, supply);\n    for (const alias of this._aliases) {\n      registry.addSharer(alias, componentType, elementName, supply);\n    }\n\n    return supply;\n  }\n\n  shareValue(\n      registrar: SharedValue.Registrar<T>,\n  ): void {\n    registrar.shareAs(this._share);\n\n    const priorityOffset = registrar.priority + 1;\n\n    this._aliases.forEach((alias, index) => {\n      alias.shareValue(registrar.withPriority(priorityOffset + index));\n    });\n  }\n\n}\n","import { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { ComponentContext } from '@wesib/wesib';\nimport { ShareRef } from './share-ref';\n\n/**\n * A key of the {@link SharedValue.Detailed detailed shared value descriptor} containing the\n * {@link SharedValue.Details shared value details}.\n */\nexport const SharedValue__symbol = (/*#__PURE__*/ Symbol('SharedValue'));\n\n/**\n * A value shared by component.\n *\n * Either a pure value, or its {@link SharedValue.Detailed detailed descriptor}.\n *\n * @typeParam T - Shared value type.\n */\nexport type SharedValue<T> = T | SharedValue.Detailed<T>;\n\nexport namespace SharedValue {\n\n  /**\n   * Value sharing options.\n   *\n   * Declare availability of the shared value.\n   */\n  export interface Options {\n\n    /**\n     * The name of the element the sharer component is bound to. Defaults to component's element name.\n     *\n     * Ignored for {@link local} shares\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Whether the share is local.\n     *\n     * - `true` to make the value available only locally, i.e. only when requested by sharer context.\n     * - `false` (by default) to make the value available to nested components too.\n     */\n    readonly local?: boolean;\n\n  }\n\n  /**\n   * A detailed descriptor of the value shared by component.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export interface Detailed<T> {\n\n    /**\n     * Shared value details.\n     */\n    readonly [SharedValue__symbol]: Details<T>;\n\n  }\n\n  /**\n   * Details of the shared value.\n   */\n  export interface Details<T> {\n\n    /**\n     * A priority of the shared value.\n     *\n     * Never negative. The lesser value means higher priority. The shared value with higher priority\n     * {@link Share.selectValue takes precedence}.\n     */\n    readonly priority: number;\n\n    /**\n     * Builds the shared value.\n     *\n     * @returns Either the shared value, or its `AfterEvent` keeper.\n     */\n    get(): T | AfterEvent<[T?]>;\n\n  }\n\n  /**\n   * Shared value registrar.\n   *\n   * Passed to {@link Share.shareValue} method in order to share the value.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export interface Registrar<T> extends SupplyPeer {\n\n    /**\n     * The default priority of the shared value.\n     *\n     * Never negative.\n     */\n    readonly priority: number;\n\n    /**\n     * Shared value supply.\n     *\n     * Stops value sharing once cut off.\n     */\n    readonly supply: Supply;\n\n    /**\n     * Shares the value under the given alias.\n     *\n     * @param alias - A reference to share alias.\n     * @param priority - Shared value priority. Equals to {@link priority default one} when omitted.\n     */\n    shareAs(this: void, alias: ShareRef<T>, priority?: number): void;\n\n    /**\n     * Builds a shared value registrar instance with another default priority.\n     *\n     * @param priority - New default shared value priority.\n     *\n     * @returns New registrar instance with {@link priority} set to the given value.\n     */\n    withPriority(this: void, priority: number): Registrar<T>;\n\n  }\n\n  /**\n   * Shared value provider.\n   *\n   * Can be used to {@link Share.createRegistrar create} a {@link SharedValue.Registrar} instance.\n   *\n   * @typeParam TSharer - Supported sharer component type.\n   * @typeParam T - Shared value type.\n   */\n  export interface Provider<T, TSharer extends object = any> {\n\n    /**\n     * The default priority of the shared value.\n     *\n     * Equals to `0` when absent or negative.\n     */\n    readonly priority?: number;\n\n    /**\n     * Shared value supply.\n     *\n     * Stops value sharing once cut off.\n     *\n     * New supply instance will be created when absent.\n     */\n    readonly supply?: Supply;\n\n    /**\n     * Provides shared value for the given component context.\n     *\n     * @typeParam TComponent - Actual sharer component type.\n     * @param context - Sharer component context to provide value for.\n     *\n     * @returns Either a shared value, or its `AfterEvent` keeper.\n     */\n    provide<TComponent extends TSharer>(context: ComponentContext<TComponent>): T | AfterEvent<[T?]>;\n\n  }\n\n}\n\nexport const SharedValue = {\n\n  /**\n   * Checks whether the given value shared by component is has details.\n   *\n   * @typeParam T - Shared value type.\n   * @param value - Shared value to check.\n   *\n   * @returns `true` if the given value is an object implementing a {@link SharedValue.Detailed} interface.\n   */\n  hasDetails<T>(\n      this: void,\n      value: SharedValue<T>,\n  ): value is SharedValue.Detailed<T> {\n    return !!value\n        && typeof value === 'object'\n        && typeof (value as SharedValue.Detailed<T>)[SharedValue__symbol] === 'object';\n  },\n\n};\n","import { applyContextTo, ContextBuilder, ContextBuilder__symbol, ContextRegistry } from '@proc7ts/context-values';\nimport { applyContextAfter } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, isAfterEvent, translateAfter } from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext } from '@wesib/wesib';\nimport { Share } from './share';\nimport { Share__symbol } from './share-ref';\nimport { SharedValue, SharedValue__symbol } from './shared-value';\n\n/**\n * @internal\n */\nexport function SharedValue$ContextBuilder<T, TSharer extends object>(\n    share: Share<T>,\n    provider: SharedValue.Provider<T, TSharer>,\n): ContextBuilder<ComponentContext<TSharer>> {\n  return {\n    [ContextBuilder__symbol]: registry => {\n\n      const registrar = share.createRegistrar(registry, provider);\n\n      share.shareValue(registrar);\n\n      return registrar.supply;\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function SharedValue$Registrar<T, TSharer extends object>(\n    registry: ContextRegistry<ComponentContext<TSharer>>,\n    provider: SharedValue.Provider<T, TSharer>,\n): SharedValue.Registrar<T> {\n  return SharedValue$BoundRegistrar(registry, SharedValue$bindProvider(provider));\n}\n\nfunction SharedValue$BoundRegistrar<T, TSharer extends object>(\n    registry: ContextRegistry<ComponentContext<TSharer>>,\n    provider: SharedValue$BoundProvider<T, TSharer>,\n): SharedValue.Registrar<T> {\n\n  const { priority, supply, provide } = provider;\n\n  return {\n    priority,\n    supply,\n    shareAs: (alias, newPriority = priority) => {\n      newPriority = Math.max(0, newPriority);\n      registry.provide({\n        a: alias[Share__symbol],\n        by: newPriority\n            ? SharedValue$detailedProvider(provide, newPriority)\n            : SharedValue$bareProvider(provide),\n      }).as(supply);\n    },\n    withPriority: newPriority => SharedValue$BoundRegistrar(\n        registry,\n        { ...provider, priority: Math.max(0, newPriority) },\n    ),\n  };\n}\n\ninterface SharedValue$BoundProvider<T, TSharer extends object> {\n  readonly priority: number;\n  readonly supply: Supply;\n  provide(this: void, context: ComponentContext<TSharer>): T | AfterEvent<[T?]>;\n}\n\nfunction SharedValue$bindProvider<T, TSharer extends object>(\n    provider: SharedValue.Provider<T>,\n): SharedValue$BoundProvider<T, TSharer> {\n\n  const priority = provider.priority ? Math.max(0, provider.priority) : 0;\n  const { supply = new Supply() } = provider;\n\n  return {\n    priority,\n    supply,\n    provide: (context: ComponentContext): T | AfterEvent<[T?]> => {\n\n      const value = provider.provide(context);\n\n      if (isAfterEvent(value)) {\n        return value.do(\n            applyContextAfter(context),\n        );\n      }\n\n      return applyContextTo(value)(context);\n    },\n  };\n}\n\nfunction SharedValue$bareProvider<T, TComponent extends object>(\n    provider: (context: ComponentContext<TComponent>) => T | AfterEvent<[T?]>,\n): (\n    context: ComponentContext<TComponent>,\n) => T | AfterEvent<T[]> | null | undefined {\n  return context => {\n\n    const value = provider(context);\n\n    if (isAfterEvent(value)) {\n      return value.do(\n          translateAfter((send, value?) => value !== undefined ? send(value) : send()),\n      );\n    }\n\n    return value;\n  };\n}\n\nfunction SharedValue$detailedProvider<T, TComponent extends object>(\n    provider: (context: ComponentContext<TComponent>) => T | AfterEvent<[T?]>,\n    priority: number,\n): (\n    context: ComponentContext<TComponent>,\n) => SharedValue.Detailed<T> {\n  return context => ({\n    [SharedValue__symbol]: {\n      priority,\n      get: () => provider(context),\n    },\n  });\n}\n","import { valueProvider } from '@proc7ts/primitives';\nimport type { ContextValues } from '../context-values';\nimport type { ContextValueProvider } from '../registry';\nimport type { Contextual } from './contextual';\nimport { Contextual__symbol, isContextual } from './contextual';\n\n/**\n * Converts a value or its {@link Contextual.Mandatory mondatory contextual reference} to mandatory context value\n * {@link ContextValueProvider provider}.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param value - A value to convert. May be either a bare value, its contextual reference, or `null`/`undefined` to\n * provide nothing.\n *\n * @returns Mandatory context value provider.\n */\nexport function applyContextTo<T, TCtx extends ContextValues = ContextValues>(\n    value: Contextual.Mandatory<T, TCtx> | T | null | undefined,\n): (this: void, context: TCtx) => T;\n\n/**\n * Converts a value or its {@link Contextual contextual reference} to context value {@link ContextValueProvider\n * provider}.\n *\n * @typeParam T - Value type.\n * @typeParam TCtx - Supported context type.\n * @param value - A value to convert. May be either a bare value, its contextual reference, or `null`/`undefined` to\n * provide nothing.\n *\n * @returns Context value provider.\n */\nexport function applyContextTo<T, TCtx extends ContextValues = ContextValues>(\n    value: Contextual<T, TCtx> | T | null | undefined,\n): ContextValueProvider<T, TCtx>;\n\nexport function applyContextTo<T, TCtx extends ContextValues = ContextValues>(\n    value: Contextual<T, TCtx> | T | null | undefined,\n): ContextValueProvider<T, TCtx> {\n  return isContextual(value)\n      ? context => value[Contextual__symbol](context)\n      : valueProvider(value);\n}\n","import { nodeHost } from '@frontmeans/dom-primitives';\nimport { ContextKey__symbol, ContextRegistry } from '@proc7ts/context-values';\nimport { ContextUpKey, ContextUpRef } from '@proc7ts/context-values/updatable';\nimport {\n  afterAll,\n  AfterEvent,\n  afterEventBy,\n  afterThe,\n  deduplicateAfter,\n  deduplicateAfter_,\n  digAfter_,\n  isAfterEvent,\n  sendEventsTo,\n  shareAfter,\n  translateAfter_,\n} from '@proc7ts/fun-events';\nimport { Supply } from '@proc7ts/supply';\nimport { BootstrapContext, ComponentContext, ComponentElement, ComponentSlot, DefinitionContext } from '@wesib/wesib';\nimport { ShareLocator } from './share-locator';\nimport { Share__symbol, ShareRef } from './share-ref';\nimport { ShareRegistry } from './share-registry.impl';\nimport { Share$, Share$impl__symbol } from './share.impl';\nimport { SharedValue, SharedValue__symbol } from './shared-value';\nimport { SharedValue$Registrar } from './shared-value.impl';\n\n/**\n * A kind of the value a component shares with the nested ones.\n *\n * The sharing implies the following:\n *\n * - The sharer component {@link addSharer registers} its element name as the one bound to sharer.\n * - The sharer component {@link shareValue provides} an (updatable) shared value within its context.\n * - The consumer component {@link valueFor obtains} the shared value by searching the parent element with a sharer\n *   bound to it.\n *\n * A share instance is used as an identifier in all these steps.\n *\n * A {@link Shared @Shared} component property decorator may be used to automate this.\n *\n * @typeParam T - Shared value type.\n */\nexport class Share<T> implements ShareRef<T>, ContextUpRef<AfterEvent<[T?]>, SharedValue<T>> {\n\n  /**\n   * @internal\n   */\n  readonly [Share$impl__symbol]: Share$<T>;\n\n  /**\n   * Constructs new component share.\n   *\n   * @param name - A human-readable name of the share.\n   * @param options - Constructed share options.\n   */\n  constructor(name: string, options: Share.Options<T> = {}) {\n    this[Share$impl__symbol] = new Share$(this, name, options);\n  }\n\n  /**\n   * Refers to itself.\n   */\n  get [Share__symbol](): this {\n    return this;\n  }\n\n  /**\n   * A human-readable name of the name.\n   */\n  get name(): string {\n    return this[Share$impl__symbol].name;\n  }\n\n  /**\n   * A key of the sharer component context value containing an `AfterEvent` keeper of the shared value.\n   */\n  get [ContextKey__symbol](): ContextUpKey<AfterEvent<[T?]>, SharedValue<T>> {\n    return this[Share$impl__symbol].key;\n  }\n\n  /**\n   * Registers a sharer component.\n   *\n   * The registration is necessary for consumers to be able to find the element bound to sharer by that element's name.\n   *\n   * @param defContext - The definition context of the sharer component.\n   * @param options - Value sharing options.\n   *\n   * @returns Sharer registration supply. Revokes the sharer registration once cut off.\n   */\n  addSharer(defContext: DefinitionContext, options?: SharedValue.Options): Supply {\n    return this[Share$impl__symbol].addSharer(defContext, options);\n  }\n\n  /**\n   * Shares a value by providing it for the sharer component context.\n   *\n   * @param registrar - Shared value registrar.\n   *\n   * @return A builder of shared value for component context.\n   */\n  shareValue(\n      registrar: SharedValue.Registrar<T>,\n  ): void {\n    this[Share$impl__symbol].shareValue(registrar);\n  }\n\n  /**\n   * Creates a shared value registrar that shares a value created by the given provider.\n   *\n   * @typeParam TSharer - Sharer component type.\n   * @param registry - Target component context registry.\n   * @param provider - Shared value provider.\n   *\n   * @returns New shared value registrar.\n   */\n  createRegistrar<TSharer extends object>(\n      registry: ContextRegistry<ComponentContext<TSharer>>,\n      provider: SharedValue.Provider<T, TSharer>,\n  ): SharedValue.Registrar<T> {\n    return SharedValue$Registrar(registry, provider);\n  }\n\n  /**\n   * Locates a shared value for the consuming component.\n   *\n   * Searches among parent elements for the one bound to the sharer component, then obtains the shared value from\n   * the sharer's context.\n   *\n   * @param consumer - Consumer component context.\n   * @param options - Location options.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n  valueFor(\n      consumer: ComponentContext,\n      options: ShareLocator.Options = {},\n  ): AfterEvent<[T, ComponentContext] | []> {\n\n    const { host = nodeHost, local } = options;\n    const sharers = consumer.get(BootstrapContext).get(ShareRegistry).sharers(this);\n    const status = consumer.readStatus.do(\n        deduplicateAfter_(\n            (a, b) => a === b,\n            Share$consumerStatus,\n        ),\n    );\n\n    return afterAll({\n      sharers,\n      status,\n    }).do(\n        digAfter_(({ sharers: [sharers] }): AfterEvent<[T, ComponentContext] | []> => {\n          if (local) {\n            if (sharers.sharers.has(consumer.componentType)) {\n              return Share$sharedValue(this, consumer);\n            }\n            if (local === true) {\n              return afterThe();\n            }\n          }\n\n          let element: ComponentElement | undefined = host(consumer.element);\n\n          while (element) {\n            if (sharers.names.has(element.tagName.toLowerCase())) {\n              return ComponentSlot.of(element).read.do(\n                  digAfter_(sharer => sharer ? Share$sharedValue(this, sharer) : afterThe()),\n              );\n            }\n\n            element = host(element);\n          }\n\n          return afterThe();\n        }),\n        deduplicateAfter(),\n    );\n  }\n\n  /**\n   * Selects a shared value among candidates.\n   *\n   * It is especially useful when the value shared by multiple sharers.\n   *\n   * By default:\n   *\n   * - Prefers bare value.\n   * - Prefers the value from {@link SharedValue.Detailed detailed specifier} with higher priority\n   *   (i.e. lesser {@link SharedValue.Details.priority priority value}).\n   * - Prefers the value declared last.\n   *\n   * @param values - The values shared by sharers. May contain a {@link SharedValue.Detailed detailed value\n   * specifiers} in addition to pure values.\n   *\n   * @returns An `AfterEvent` keeper of selected value, if present.\n   */\n  selectValue(...values: SharedValue<T>[]): AfterEvent<[T?]> {\n\n    let selected: SharedValue.Details<T> | undefined;\n\n    for (let i = values.length - 1; i >= 0; --i) {\n\n      const value = values[i];\n\n      if (!SharedValue.hasDetails(value)) {\n        return afterThe(value);\n      }\n\n      const details = value[SharedValue__symbol];\n\n      if (!selected || selected.priority > details.priority) {\n        selected = details;\n      }\n    }\n\n    if (!selected) {\n      return afterThe();\n    }\n\n    return afterEventBy<[T?]>(receiver => {\n\n      const value = selected!.get();\n\n      if (isAfterEvent(value)) {\n        value(receiver);\n      } else {\n        sendEventsTo(receiver)(value);\n      }\n    }).do(\n        shareAfter,\n    );\n  }\n\n}\n\nexport namespace Share {\n\n  /**\n   * {@link Share Component share} options.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export interface Options<T> {\n\n    /**\n     * Component share reference(s) the share provides a value for in addition to the one it provides for itself.\n     *\n     * The order of aliases is important. It defines the {@link SharedValue.Details.priority priority} of the\n     * value shared for the corresponding share.\n     */\n    readonly as?: ShareRef<T> | readonly ShareRef<T>[];\n\n  }\n\n  /**\n   * A key of context value containing an `AfterEvent` keeper of shared value.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Key<T> = ContextUpKey<AfterEvent<[T?]>, SharedValue<T>>;\n\n  /**\n   * A source value accepted by {@link Share component share} context value.\n   *\n   * Either a single shared value, its {@link SharedValue.Detailed detailed descriptor}, or an `AfterEvent`\n   * keeper of the above.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Source<T> = ContextUpKey.Source<SharedValue<T>>;\n\n}\n\nfunction Share$consumerStatus([{ settled, connected }]: [ComponentContext]): 0 | 1 | 2 {\n  return connected ? 2 : settled ? 1 : 0;\n}\n\nfunction Share$sharedValue<T>(\n    share: Share<T>,\n    sharer: ComponentContext,\n): AfterEvent<[T, ComponentContext] | []> {\n  return sharer.get(share).do(\n      translateAfter_((send, value?) => value ? send(value, sharer) : send()),\n  );\n}\n","import { nodeHost } from '@frontmeans/dom-primitives';\nimport { AfterEvent } from '@proc7ts/fun-events';\nimport { ComponentContext } from '@wesib/wesib';\nimport { isShareRef, Share__symbol, ShareRef } from './share-ref';\n\n/**\n * Shared value locator.\n *\n * Can be one of:\n *\n * - component share {@link ShareRef reference},\n * - shared value locator specified {@link ShareLocator.Spec},\n * - {@link ShareLocator.CustomWithFallback custom} shared value locator, or\n * - `null`/`undefined` to locate a fallback share.\n *\n * A {@link shareLocator} function can be used to convert arbitrary locator to a function.\n *\n * @typeParam T - Shared value type.\n */\nexport type ShareLocator<T> =\n    | ShareRef<T>\n    | ShareLocator.Spec<T>\n    | ShareLocator.CustomWithFallback<T>\n    | null\n    | undefined;\n\n/**\n * Converts mandatory shared value locator to locator function.\n *\n * @typeParam T - Shared value type.\n * @param locator - Shared value locator to convert.\n * @param defaultOptions - Default shared value locator options.\n *\n * @returns Shared value locator function.\n */\nexport function shareLocator<T>(\n    locator: ShareLocator.Mandatory<T>,\n    defaultOptions?: ShareLocator.Options,\n): ShareLocator.Fn<T>;\n\n/**\n * Converts arbitrary shared value locator to locator function.\n *\n * @typeParam T - Shared value type.\n * @param locator - Shared value locator to convert.\n * @param defaultSpec - Default shared value locator specifier including fallback share reference.\n *\n * @returns Shared value locator function.\n */\nexport function shareLocator<T>(\n    locator: ShareLocator<T>,\n    defaultSpec: ShareLocator.MandatorySpec<T>,\n): ShareLocator.Fn<T>;\n\nexport function shareLocator<T>(\n    locator:\n        | ShareRef<T>\n        | Partial<ShareLocator.MandatorySpec<T>>\n        | ShareLocator.CustomWithFallback<T>\n        | null\n        | undefined,\n    defaultSpec: ShareLocator.Spec<T> = {},\n): ShareLocator.Fn<T> {\n  if (isShareRef(locator)) {\n\n    const share = locator[Share__symbol];\n\n    return (consumer, options = {}) => {\n\n      const { host = defaultSpec.host, local = defaultSpec.local } = options;\n\n      return share.valueFor(consumer, { host, local });\n    };\n  }\n\n  if (typeof locator === 'function') {\n\n    const {\n      host: hostByDefault = nodeHost,\n      local: localByDefault = false,\n      share: shareByDefault,\n    } = defaultSpec;\n\n    return (consumer, options = {}) => {\n\n      const {\n        share = shareByDefault!,\n        host = hostByDefault,\n        local = localByDefault,\n      } = options;\n\n      return locator(consumer, { share, host, local });\n    };\n  }\n\n  const {\n    share: shareRef = defaultSpec.share!,\n    host: hostByDefault = defaultSpec.host,\n    local: localByDefault = defaultSpec.local,\n  } = locator || {};\n  const share = shareRef[Share__symbol];\n\n  return (consumer, options = {}) => {\n\n    const { host = hostByDefault, local = localByDefault } = options;\n\n    return share.valueFor(consumer, { host, local });\n  };\n}\n\nexport namespace ShareLocator {\n\n  /**\n   * Mandatory shared value locator.\n   *\n   * Can be one of:\n   *\n   * - component share {@link ShareRef reference},\n   * - shared value locator specified {@link ShareLocator.Spec}, or\n   * - {@link ShareLocator.Custom custom} shared value locator.\n   *\n   * A {@link shareLocator} function can be used to convert arbitrary locator to a function.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Mandatory<T> =\n      | ShareRef<T>\n      | MandatorySpec<T>\n      | Custom<T>;\n\n  /**\n   * Shared value location options.\n   */\n  export interface Options {\n\n    /**\n     * Detects a host element of the given one.\n     *\n     * By default utilizes a `nodeHost()` function that founds parent element crossing shadow DOM bounds.\n     *\n     * A `drekHost()` can be uses to also cross a rendered fragment bounds.\n     *\n     * @param element - An element to detect a host of.\n     *\n     * @returns Either a host element, or `undefined` if no host found.\n     */\n    readonly host?: (this: void, element: Element) => Element | undefined;\n\n    /**\n     * Whether to search locally, in consumer component itself.\n     *\n     * - `false` (by default), to start the search from consumer's parent,\n     * - `true` to search locally, i.e. only in consumer component, or\n     * - `'too'` to start the search from consumer component.\n     */\n    readonly local?: boolean | 'too';\n\n  }\n\n  /**\n   * Shared value location options with all properties present.\n   */\n  export type FullOptions = Required<Options>;\n\n  /**\n   * Shared value locator specifier.\n   *\n   * @typeParam T - Share value type.\n   */\n  export interface Spec<T> extends Options {\n\n    /**\n     * Target share.\n     */\n    readonly share?: ShareRef<T>;\n\n  }\n\n  /**\n   * Mandatory shared value locator specifier.\n   *\n   * @typeParam T - Share value type.\n   */\n  export interface MandatorySpec<T> extends Spec<T> {\n\n    /**\n     * Target share.\n     */\n    readonly share: ShareRef<T>;\n\n  }\n\n  /**\n   * Shared value locator specifier with all properties set.\n   *\n   * @typeParam T - Share value type.\n   */\n  export type FullSpec<T> = Required<MandatorySpec<T>>;\n\n  /**\n   * Signature of custom shared value locator.\n   *\n   * @typeParam T - Shared value type.\n   * @typeParam consumer - Consumer component context.\n   * @typeParam options - Shared value location options.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n  export type Custom<T> =\n  /**\n   * @param consumer - Consumer component context.\n   * @param options - Full shared value location options.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n      (\n          this: void,\n          consumer: ComponentContext,\n          options: FullOptions,\n      ) => AfterEvent<[] | [T, ComponentContext]>;\n\n  /**\n   * Signature of custom shared value locator that expects a fallback share reference to be specified.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type CustomWithFallback<T> =\n  /**\n   * @param consumer - Consumer component context.\n   * @param options - Full shared value location specifier, including fallback share reference.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n      (\n          this: void,\n          consumer: ComponentContext,\n          spec: FullSpec<T>,\n      ) => AfterEvent<[] | [T, ComponentContext]>;\n\n  /**\n   * Signature of shared value locator function.\n   *\n   * Can be constructed by {@link shareLocator} function.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Fn<T> =\n  /**\n   * @param consumer - Consumer component context.\n   * @param options - Shared value location options.\n   *\n   * @returns An `AfterEvent` keeper of the shared value and its sharer context, if found.\n   */\n      (\n          this: void,\n          consumer: ComponentContext,\n          defaultSpec?: Spec<T>,\n      ) => AfterEvent<[] | [T, ComponentContext]>;\n\n}\n","import { Contextual, Contextual__symbol } from '@proc7ts/context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  afterValue,\n  EventKeeper,\n  trackValueBy,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { noop, valueProvider, valueRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\n\nconst Shareable$Internals__symbol = (/*#__PURE__*/ Symbol('Shareable.internals'));\n\n/**\n * Abstract implementation of value shareable by component.\n *\n * Shareable instance contains a {@link body} that become usable only when bound to sharer component.\n *\n * @typeParam TBody - Shareable body type.\n * @typeParam TSharer - Sharer component type.\n */\nexport class Shareable<TBody = unknown, TSharer extends object = any>\n    implements EventKeeper<[TBody]>, Contextual<Shareable<TBody, TSharer>> {\n\n  /**\n   * Converts shareable body or its provider to provider that always returns an `AfterEvent` keeper of shareable body.\n   *\n   * @typeParam TBody - Shareable body type.\n   * @typeParam TSharer - Sharer component type.\n   * @param body - Either shareable body, or its provider.\n   *\n   * @returns Shareable body provider.\n   */\n  static provider<TBody = unknown, TSharer extends object = any>(\n      body: TBody | Shareable.Provider<TBody, TSharer>,\n  ): (\n      this: void,\n      sharer: ComponentContext<TSharer>,\n  ) => AfterEvent<[TBody]> {\n\n    const provider = valueRecipe(body);\n\n    return context => afterValue(provider(context));\n  }\n\n  /**\n   * @internal\n   */\n  private [Shareable$Internals__symbol]: Shareable$Internals<TBody, TSharer>;\n\n  /**\n   * Constructs shareable instance.\n   *\n   * @param body - Either shareable body, or its provider.\n   */\n  constructor(body: TBody | Shareable.Provider<TBody, TSharer>) {\n    this[Shareable$Internals__symbol] = new Shareable$Internals(this, body);\n  }\n\n  /**\n   * Sharer component context.\n   *\n   * Accessing it throws an exception until bound to sharer.\n   */\n  get sharer(): ComponentContext<TSharer> {\n    return this[Shareable$Internals__symbol].sharer();\n  }\n\n  /**\n   * An `AfterEvent` keeper of shareable body.\n   *\n   * An `[AfterEvent__symbol]` method always returns this value.\n   */\n  get read(): AfterEvent<[TBody]> {\n    return this[Shareable$Internals__symbol].get().read;\n  }\n\n  /**\n   * Binds this shareable instance to sharer component.\n   *\n   * @param sharer - Sharer component context.\n   *\n   * @returns `this` instance.\n   */\n  [Contextual__symbol](sharer: ComponentContext): this {\n    this[Shareable$Internals__symbol].bind(sharer);\n    return this;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[TBody]> {\n    return this.read;\n  }\n\n  /**\n   * Shareable body.\n   *\n   * Accessing is throws an exception until bound to sharer.\n   */\n  get body(): TBody {\n    return this[Shareable$Internals__symbol].get().it;\n  }\n\n}\n\nexport namespace Shareable {\n\n  /**\n   * Shareable provider signature.\n   *\n   * Provides shareable body rather the shareable instance itself.\n   *\n   * @typeParam TBody - Shareable body type.\n   * @typeParam TSharer - Sharer component type.\n   */\n  export type Provider<TBody = unknown, TSharer extends object = any> =\n  /**\n   * @param sharer - Sharer component context.\n   *\n   * @returns Either shareable body instance, or an `AfterEvent` keeper reporting one.\n   */\n      (\n          this: void,\n          sharer: ComponentContext<TSharer>,\n      ) => TBody | AfterEvent<[TBody]>;\n\n}\n\nclass Shareable$Internals<TBody, TSharer extends object> {\n\n  private readonly _get: (\n      this: void,\n      sharer: ComponentContext<TSharer>,\n  ) => AfterEvent<[TBody]>;\n\n  constructor(\n      private readonly _source: Shareable<TBody, TSharer>,\n      body: TBody | Shareable.Provider<TBody, TSharer>,\n  ) {\n    this._get = Shareable.provider(body);\n  }\n\n  sharer(): ComponentContext<TSharer> {\n    this._notBound();\n  }\n\n  get(): ValueTracker<TBody> {\n    this._notBound();\n  }\n\n  bind(sharer: ComponentContext<TSharer>): void {\n    this.bind = noop;\n    this.sharer = valueProvider(sharer);\n    this.get = () => {\n\n      const tracker = trackValueBy(this._get(sharer));\n\n      this.get = valueProvider(tracker);\n\n      return tracker;\n    };\n  }\n\n  private _notBound(): never {\n    throw new TypeError(`${String(this._source)} is not properly shared yet`);\n  }\n\n}\n","import { Contextual__symbol, isContextual } from '@proc7ts/context-values';\nimport { isAfterEvent, trackValue, trackValueBy, ValueTracker } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { AeComponentMember, ComponentClass, ComponentContext, ComponentInstance } from '@wesib/wesib';\nimport { SharedDef } from './shared.amendment';\n\n/**\n * @internal\n */\nexport class ShareAccessor<T, TValue extends SharedDef.Value<T>, TClass extends ComponentClass> {\n\n  private readonly _get: () => TValue;\n  private readonly _set: (value: TValue) => void;\n  private readonly _ctx: ComponentContext<InstanceType<TClass>>;\n  private _valSupply?: Supply;\n  readonly val: ValueTracker<T | undefined>;\n\n  constructor(\n      target: AeComponentMember<TValue, TClass>,\n      component: ComponentInstance<InstanceType<TClass>>,\n  ) {\n    this._get = target.get.bind(undefined, component);\n    this._set = target.writable ? target.set.bind(undefined, component) : noop;\n    this._ctx = ComponentContext.of(component);\n\n    const value = this._get();\n    let dynSync = false;\n\n    if (isAfterEvent(value)) {\n      dynSync = true;\n      this.val = trackValueBy(value);\n    } else {\n      this.val = trackValue(value as T);\n    }\n\n    this.val.supply.needs(this._ctx);\n\n    // Bind to context as the very first operation\n    this.val.read(value => isContextual(value) && value[Contextual__symbol](this._ctx));\n\n    if (dynSync) {\n      this._syncDyn();\n    } else {\n      this._syncVal();\n    }\n  }\n\n  get(): TValue {\n    return (this._valSupply ? this.val.it! : this.val.read) as TValue;\n  }\n\n  set(value: TValue): void {\n    if (isAfterEvent(value)) {\n      this.val.by(value);\n      this._syncDyn();\n    } else {\n      this.val.it = value as T;\n      this._syncVal();\n    }\n  }\n\n  private _syncVal(): void {\n    if (!this._valSupply) {\n      this._valSupply = this.val.read(value => this._set(value as TValue));\n    }\n  }\n\n  private _syncDyn(): void {\n    if (this._valSupply) {\n      this._valSupply.off();\n      this._valSupply = undefined;\n      this._set(this.val.read as TValue);\n    }\n  }\n\n}\n","import {\n  AeClass,\n  allAmender,\n  Amendment,\n  AmendRequest,\n  AmendTarget,\n  MemberAmendment,\n  newAmendTarget,\n} from '@proc7ts/amend';\nimport { AfterEvent, digAfter_ } from '@proc7ts/fun-events';\nimport { Class, valuesProvider } from '@proc7ts/primitives';\nimport {\n  AeComponentMember,\n  ComponentClass,\n  ComponentInstance,\n  ComponentMember,\n  DefinitionContext,\n  DefinitionSetup,\n} from '@wesib/wesib';\nimport { Share } from './share';\nimport { ShareAccessor } from './share-accessor.impl';\nimport { Share__symbol } from './share-ref';\nimport { SharedValue$ContextBuilder } from './shared-value.impl';\nimport { targetShare, TargetShare } from './target-share';\n\n/**\n * An amended entity representing a shared component member to amend.\n *\n * @typeParam T - Shared value type.\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - Amended component class type.\n */\nexport interface AeShared<\n    T,\n    TValue extends SharedDef.Value<T> = SharedDef.Value<T>,\n    TClass extends ComponentClass = Class>\n    extends AeComponentMember<TValue, TClass> {\n\n  /**\n   * Target share instance.\n   */\n  readonly share: Share<T>;\n\n  /**\n   * Whether the share is local.\n   *\n   * - `true` to make the value available only locally, i.e. only when requested by sharer context.\n   * - `false` to make the value available to nested components too.\n   */\n  readonly localShare: boolean;\n\n  /**\n   * Reads value shared by target `component`.\n   *\n   * This method is not amendable.\n   *\n   * @param component - Sharer component instance.\n   *\n   * @returns An `AfterEvent` keeper of shared value.\n   */\n  getShared(this: void, component: InstanceType<TClass>): AfterEvent<[T?]>;\n\n}\n\n/**\n * An amendment of shared component member.\n *\n * Constructed by {@link Shared} function.\n *\n * @typeParam T - Shared value type.\n * @typeParam TValue - Amended member value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended shared member entity type.\n */\nexport type SharedAmendment<\n    T,\n    TValue extends SharedDef.Value<T>,\n    TClass extends ComponentClass = Class,\n    TAmended extends AeShared<T, TValue, TClass> = AeShared<T, TValue, TClass>> =\n    MemberAmendment.ForBase<AeClass<TClass>, AeShared<T, TValue, TClass>, TValue, TClass, TValue, TAmended>;\n\n/**\n * Creates an amendment (and decorator) of component member that {@link Share shares} its value.\n *\n * The amended member should contain either a static value, or its `AfterEvent` keeper.\n *\n * Applies current component context to {@link Contextual} shared values.\n *\n * @typeParam T - Shared value type.\n * @typeParam TClass - A type of decorated component class.\n * @param share - Target component share.\n * @param amendments - Amendments to apply.\n *\n * @returns New shared member amendment.\n */\nexport function Shared<\n    T,\n    TValue extends SharedDef.Value<T> = SharedDef.Value<T>,\n    TClass extends ComponentClass = Class,\n    TAmended extends AeShared<T, TValue, TClass> = AeShared<T, TValue, TClass>>(\n    share: TargetShare<T>,\n    ...amendments: Amendment<TAmended>[]\n): SharedAmendment<T, TValue, TClass, TAmended> {\n\n  const { share: { [Share__symbol]: share$default }, local: localShare$default = false } = targetShare(share);\n\n  return ComponentMember<TValue, TClass, TValue, TAmended>(baseTarget => {\n\n    const accessorKey = Symbol(`${String(baseTarget.key)}:shared`);\n\n    type Component = ComponentInstance<InstanceType<TClass>> & {\n      [accessorKey]?: ShareAccessor<T, TValue, TClass>;\n    };\n\n    let lastTarget: AeComponentMember<TValue, TClass> = baseTarget;\n    const accessorOf = (component: Component): ShareAccessor<T, TValue, TClass> => component[accessorKey]\n        || (component[accessorKey] = new ShareAccessor(lastTarget, component));\n    const getShared = (component: InstanceType<TClass>): AfterEvent<[T?]> => accessorOf(component).val.read;\n\n    const lastAmender = (target: AmendTarget<AeShared<T, TValue, TClass>>): void => {\n      lastTarget = target;\n      target.amend({\n        get: component => accessorOf(component).get(),\n        set: target.writable\n            ? (component, value) => accessorOf(component).set(value)\n            : undefined,\n        componentDef: {\n          setup(setup: DefinitionSetup<InstanceType<TClass>>): void {\n            setup.perComponent(SharedValue$ContextBuilder(\n                target.share,\n                {\n                  provide: context => context.onceReady.do(\n                      digAfter_(\n                          ({ component }) => accessorOf(component).val,\n                          valuesProvider<[T?]>(),\n                      ),\n                  ),\n                },\n            ));\n          },\n          define(defContext: DefinitionContext<InstanceType<TClass>>) {\n            target.share.addSharer(defContext, { local: target.localShare });\n          },\n        },\n      });\n    };\n\n    allAmender([...amendments, lastAmender])(newAmendTarget({\n      base: {\n        ...baseTarget as TAmended,\n        share: share$default,\n        localShare: localShare$default,\n        getShared,\n      },\n      amend<TBase extends TAmended, TExt>(\n          base: TBase,\n          request = {} as AmendRequest<TBase, TExt>,\n      ): () => AmendTarget.Draft<TBase & TExt> {\n\n        const {\n          share = base.share,\n          localShare = base.localShare,\n          getShared: $getShared,\n          ...baseRequest\n        } = request;\n\n        const createBaseTarget = baseTarget.amend(baseRequest as AmendRequest<any>);\n\n        return () => ({\n          ...createBaseTarget(),\n          share,\n          localShare,\n          getShared,\n        } as AmendTarget.Draft<TBase & TExt>);\n      },\n    }));\n  }) as SharedAmendment<T, TValue, TClass, TAmended>;\n}\n\nexport namespace SharedDef {\n\n  /**\n   * Shared member value type.\n   *\n   * Either shared value, or its `AfterEvent` keeper.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export type Value<T> = T | AfterEvent<[T?]>;\n\n}\n","import { isShareRef, ShareRef } from './share-ref';\n\n/**\n * A specifier of component share to share the value of.\n *\n * Can be one of:\n *\n * - component share {@link ShareRef reference}, or\n * - detailed target component share {@link TargetShare.Spec specifier}.\n *\n * @typeParam T - Shared value type.\n */\nexport type TargetShare<T> =\n    | ShareRef<T>\n    | TargetShare.Spec<T>;\n\nexport namespace TargetShare {\n\n  /**\n   * A detailed specifier of the component share to share the value of.\n   *\n   * @typeParam T - Shared value type.\n   */\n  export interface Spec<T> {\n\n    /**\n     * Target component share reference.\n     */\n    readonly share: ShareRef<T>;\n\n    /**\n     * Whether to share is local.\n     *\n     * - `true` to make the value available only locally, i.e. only when requested by sharer context.\n     * - `false` (by default) to make the value available to nested components too.\n     */\n    readonly local?: boolean;\n\n  }\n\n}\n\n/**\n * Converts arbitrary {@link TargetShare target component share} to its detailed {@link TargetShare.Spec specifier}.\n *\n * @typeParam T - Share value type.\n * @param target\n */\nexport function targetShare<T>(target: TargetShare<T>): TargetShare.Spec<T> {\n  return isShareRef(target) ? { share: target } : target;\n}\n","import {\n  InAspect,\n  InBuilder,\n  InControl,\n  InNamespaceAliaser,\n  InRenderScheduler,\n  knownInAspect,\n} from '@frontmeans/input-aspects';\nimport { ComponentContext, ComponentRenderScheduler, DefaultNamespaceAliaser } from '@wesib/wesib';\nimport { Field } from './field';\nimport { Form } from './form';\nimport { FormPreset } from './form-preset';\n\n/**\n * @internal\n */\nexport const DefaultFormPreset: FormPreset.Spec = {\n\n  setupField<TValue, TSharer extends object>(\n      { sharer, control }: Field.Builder<TValue, TSharer>,\n  ): void {\n    DefaultFormPreset$setup(sharer, control);\n  },\n\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      { sharer, control, element }: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    DefaultFormPreset$setup(sharer, control);\n    DefaultFormPreset$setup(sharer, element);\n  },\n\n};\n\nfunction DefaultFormPreset$setup<TValue, TSharer extends object>(\n    sharer: ComponentContext<TSharer>,\n    builder: InBuilder<InControl<TValue>>,\n): void {\n\n  const nsAliaser = sharer.get(DefaultNamespaceAliaser);\n  const renderScheduler = sharer.get(ComponentRenderScheduler);\n\n  builder\n      .addAspect(\n          InNamespaceAliaser,\n          {\n            applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n                _aspect: InAspect<TInstance, TKind>,\n            ): InAspect.Application.Result<TInstance, TValue, TKind> {\n              return knownInAspect(nsAliaser) as InAspect.Application.Result<TInstance, TValue, TKind>;\n            },\n          },\n      ).addAspect(\n      InRenderScheduler,\n      {\n        applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n            _aspect: InAspect<TInstance, TKind>,\n        ): InAspect.Application.Result<TInstance, TValue, TKind> {\n          return knownInAspect(renderScheduler) as InAspect.Application.Result<TInstance, TValue, TKind>;\n        },\n      },\n  );\n}\n","import { ContextKey__symbol, ContextSupply, ContextValueSlot } from '@proc7ts/context-values';\nimport { ContextUpKey } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, mapAfter, supplyAfter } from '@proc7ts/fun-events';\nimport { DefaultFormPreset } from './default.preset.impl';\nimport { Field } from './field';\nimport { Form } from './form';\n\nclass FormPresetKey extends ContextUpKey<FormPreset, FormPreset.Spec> {\n\n  constructor() {\n    super('form-preset');\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  grow(\n      slot: ContextValueSlot<\n          FormPreset,\n          ContextUpKey.Source<FormPreset.Spec>,\n          AfterEvent<FormPreset.Spec[]>>,\n  ): void {\n    slot.insert(new FormPreset(slot.seed.do(\n        mapAfter((...specs) => FormPreset.combine(...specs, DefaultFormPreset)),\n        supplyAfter(slot.context.get(ContextSupply)),\n    )));\n  }\n\n}\n\nconst FormPreset__key = (/*#__PURE__*/ new FormPresetKey());\nconst FormPreset$rules__symbol = (/*#__PURE__*/ Symbol('FormPreset.rules'));\n\n/**\n * Form controls preset.\n *\n * Any number of presets can be {@link FormPreset.Spec specified} in component context to be applies to forms\n * and fields. They would be combined into single preset available in component context.\n */\nexport class FormPreset implements FormPreset.Rules, EventKeeper<[FormPreset.Rules]> {\n\n  /**\n   * A key of component context value containing default form preset combined from all provided {@link FormPreset.Spec\n   * specifiers}.\n   *\n   * As a bare minimum it attaches the following aspects to controls:\n   *\n   * - `InRenderScheduler` set to `ElementRenderScheduler`,\n   * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n   */\n  static get [ContextKey__symbol](): ContextUpKey<FormPreset, FormPreset.Spec> {\n    return FormPreset__key;\n  }\n\n  /**\n   * Combines form preset specifiers.\n   *\n   * @param specs - Form preset specifiers to combine.\n   *\n   * @returns Form preset rules instance combining the given specifiers.\n   */\n  static combine(...specs: FormPreset.Spec[]): FormPreset.Rules {\n    return {\n      setupField: FormPreset$setupField(specs),\n      setupForm: FormPreset$setupForm(specs),\n    };\n  }\n\n  /**\n   * @internal\n   */\n  private [FormPreset$rules__symbol]: FormPreset.Rules;\n\n  /**\n   * Constructs form preset.\n   *\n   * @param rules - An `AfterEvent` keeper of form preset {@link FormPreset.Rules rules}.\n   */\n  constructor(readonly rules: AfterEvent<[FormPreset.Rules]>) {\n    rules(rules => {\n      this[FormPreset$rules__symbol] = rules;\n    });\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of this form preset {@link FormPreset.Rules rules}.\n   */\n  [AfterEvent__symbol](): AfterEvent<[FormPreset.Rules]> {\n    return this.rules;\n  }\n\n  /**\n   * Sets up form field controls.\n   *\n   * @param builder - Target field builder.\n   */\n  setupField<TValue, TSharer extends object>(\n      builder: Field.Builder<TValue, TSharer>,\n  ): void {\n    this[FormPreset$rules__symbol].setupField(builder);\n  }\n\n  /**\n   * Sets up form controls.\n   *\n   * @param builder - Target form builder.\n   */\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      builder: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    this[FormPreset$rules__symbol].setupForm(builder);\n  }\n\n}\n\nexport namespace FormPreset {\n\n  /**\n   * A {@link FormPreset form preset} specifier.\n   *\n   * Contains a partial form preset implementation.\n   */\n  export interface Spec {\n\n    /**\n     * Sets up form field controls.\n     *\n     * @param builder - Target field builder.\n     */\n    setupField?<TValue, TSharer extends object>(\n        builder: Field.Builder<TValue, TSharer>,\n    ): void;\n\n    /**\n     * Sets up form controls.\n     *\n     * @param builder - Target form builder.\n     */\n    setupForm?<TModel, TElt extends HTMLElement, TSharer extends object>(\n        builder: Form.Builder<TModel, TElt, TSharer>,\n    ): void;\n\n  }\n\n  /**\n   * {@link FormPreset Form preset} rules.\n   *\n   * Multiple {@link Spec specifiers} could be combined into single rule instance by {@link FormPreset.combine} static\n   * method.\n   */\n  export interface Rules extends FormPreset.Spec {\n\n    setupField<TValue, TSharer extends object>(\n        this: void,\n        builder: Field.Builder<TValue, TSharer>,\n    ): void;\n\n    setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n        this: void,\n        builder: Form.Builder<TModel, TElt, TSharer>,\n    ): void;\n\n  }\n\n}\n\nfunction FormPreset$setupField(\n    specs: readonly FormPreset.Spec[],\n): <TValue, TSharer extends object>(\n    builder: Field.Builder<TValue, TSharer>,\n) => void {\n  return specs.reduce(\n      (prev, spec) => spec.setupField\n          ? <TValue, TSharer extends object>(\n              builder: Field.Builder<TValue, TSharer>,\n          ): void => {\n            prev(builder);\n            spec.setupField!(builder);\n          }\n          : prev,\n      FormPreset$noFieldSetup,\n  );\n}\n\nfunction FormPreset$noFieldSetup<TValue, TSharer extends object>(\n    _builder: Field.Builder<TValue, TSharer>,\n): void {\n  // No field setup\n}\n\nfunction FormPreset$setupForm(\n    specs: readonly FormPreset.Spec[],\n): <TModel, TElt extends HTMLElement, TSharer extends object>(\n    builder: Form.Builder<TModel, TElt, TSharer>,\n) => void {\n  return specs.reduce(\n      (prev, spec) => spec.setupForm\n          ? <TModel, TElt extends HTMLElement, TSharer extends object>(\n              builder: Form.Builder<TModel, TElt, TSharer>,\n          ): void => {\n            prev(builder);\n            spec.setupForm!(builder);\n          }\n          : prev,\n      FormPreset$noFormSetup,\n  );\n}\n\nfunction FormPreset$noFormSetup<TModel, TElt extends HTMLElement, TSharer extends object>(\n    _builder: Form.Builder<TModel, TElt, TSharer>,\n): void {\n  // No form setup\n}\n","import { InControl } from '@frontmeans/input-aspects';\nimport { Contextual__symbol } from '@proc7ts/context-values';\nimport { noop } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { Shareable } from '../shares';\n\n/**\n * Abstract unit of input {@link Form form}.\n *\n * Represents a form or its field control and contains its value.\n *\n * @typeParam TValue - Input value type.\n * @typeParam TControls - A type of input controls this unit represents.\n * @typeParam TSharer - Unit sharer component type.\n */\nexport abstract class FormUnit<\n    TValue,\n    TControls extends FormUnit.Controls<TValue> = FormUnit.Controls<TValue>,\n    TSharer extends object = any>\n    extends Shareable<TControls | undefined, TSharer> {\n\n  /**\n   * Constructs form unit.\n   *\n   * @param controls - Either input controls, or their provider.\n   */\n  constructor(// eslint-disable-line @typescript-eslint/no-useless-constructor\n      controls: TControls | Shareable.Provider<TControls | undefined, TSharer>,\n  ) {\n    super(controls);\n  }\n\n  /**\n   * Input control of the field, if present.\n   */\n  get control(): InControl<TValue> | undefined {\n    return this.body?.control;\n  }\n\n  [Contextual__symbol](sharer: ComponentContext): this {\n    super[Contextual__symbol](sharer);\n    this.read(noop).needs(sharer); // Create controls eagerly.\n    return this;\n  }\n\n}\n\nexport namespace FormUnit {\n\n  /**\n   * A value type for the given form unit type.\n   *\n   * @typeParam TUnit - Target unit type.\n   */\n  export type ValueType<TUnit extends FormUnit<any, any, any>> =\n      TUnit extends FormUnit<infer TValue, any, any> ? TValue : never;\n\n  /**\n   * A type of controls type for the given form unit type.\n   *\n   * @typeParam TUnit - Target unit type.\n   */\n  export type ControlsType<TUnit extends FormUnit<any, any, any>> =\n      TUnit extends FormUnit<any, infer TControls, any> ? TControls : never;\n\n  /**\n   * A type of the sharer for the given form unit type.\n   *\n   * @typeParam TUnit - Target unit type.\n   */\n  export type SharerType<TUnit extends FormUnit<any, any, any>> =\n      TUnit extends FormUnit<any, any, infer TSharer> ? TSharer : never;\n\n  /**\n   * Form unit controls.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Controls<TValue> {\n\n    /**\n     * An input control of the unit.\n     */\n    readonly control: InControl<TValue>;\n\n  }\n\n}\n","import { InBuilder, InControl } from '@frontmeans/input-aspects';\nimport { AfterEvent, afterValue, deduplicateAfter_, digAfter_, mapAfter } from '@proc7ts/fun-events';\nimport { valueRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { Shareable } from '../shares';\nimport { FormPreset } from './form-preset';\nimport { FormUnit } from './form-unit';\n\n/**\n * A field of the user input {@link Form form}.\n *\n * A component {@link FieldShare shares} field (e.g. using {@link SharedField @SharedField} decorator) to make it\n * accessible by component itself and nested ones. E.g. to add it to {@link Form form} or to manipulate its value.\n *\n * The field instance is not usable until it is bound to its sharer component. The latter is done automatically when\n * the field is shared by {@link FieldShare}.\n *\n * @typeParam TValue - Field value type.\n * @typeParam TSharer - Field sharer component type.\n */\nexport class Field<TValue, TSharer extends object = any> extends FormUnit<TValue, Field.Body<TValue>, TSharer> {\n\n  /**\n   * Creates a form field by the given field control factory.\n   *\n   * @param factory - Field control factory.\n   *\n   * @returns New field instance.\n   */\n  static by<TValue, TSharer extends object = any>(\n      factory: InControl.Factory<InControl<TValue>>,\n  ): Field<TValue, TSharer> {\n    return new this(this.providerBy(factory));\n  }\n\n  /**\n   * Creates a form field controls provider by the given control factory.\n   *\n   * @param factory - Field control factory.\n   *\n   * @returns New form field controls provider.\n   */\n  static providerBy<TValue, TSharer extends object = any>(\n      factory: InControl.Factory<InControl<TValue>>,\n  ): Field.Provider<TValue, TSharer> {\n    return builder => ({\n      control: builder.control.build(factory),\n    });\n  }\n\n  /**\n   * Constructs form field.\n   *\n   * @param controls - Either a field controls instance, or its provider.\n   */\n  constructor(controls: Field.Controls<TValue> | Field.Provider<TValue, TSharer>) {\n    super(Field$provider(() => this, valueRecipe(controls)));\n  }\n\n  toString(): string {\n    return 'Field';\n  }\n\n}\n\nexport namespace Field {\n\n  /**\n   * A value type of the given form field.\n   *\n   * @typeParam TField - Field type.\n   */\n  export type ValueType<TField extends Field<any>> = FormUnit.ValueType<TField>;\n\n  /**\n   * Form field controls.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Controls<TValue> extends FormUnit.Controls<TValue> {\n\n    /**\n     * Field input control.\n     */\n    readonly control: InControl<TValue>;\n\n  }\n\n  /**\n   * Form field body containing its input control.\n   *\n   * @typeParam TValue - Input value type.\n   */\n  export interface Body<TValue, TSharer extends object = any> extends FormUnit.Controls<TValue> {\n\n    /**\n     * A field the input control belongs to.\n     */\n    readonly field: Field<TValue, TSharer>;\n\n    /**\n     * Field input control.\n     */\n    readonly control: InControl<TValue>;\n\n  }\n\n  /**\n   * Form field builder.\n   *\n   * @typeParam TValue - Field value type.\n   * @typeParam TSharer - Field sharer component type.\n   */\n  export interface Builder<TValue, TSharer extends object> {\n\n    /**\n     * Sharer component context.\n     */\n    readonly sharer: ComponentContext<TSharer>;\n\n    /**\n     * Target field.\n     */\n    readonly field: Field<TValue, TSharer>;\n\n    /**\n     * Field input control builder.\n     */\n    readonly control: InBuilder<InControl<TValue>, TValue>;\n\n  }\n\n  /**\n   * Form field controls provider signature.\n   *\n   * @typeParam TValue - Field value type.\n   * @typeParam TSharer - Field sharer component type.\n   */\n  export type Provider<TValue, TSharer extends object = any> =\n  /**\n   * @param builder - Field builder.\n   *\n   * @returns Either field controls instance, or an `AfterEvent` keeper reporting one.\n   */\n      (\n          this: void,\n          builder: Builder<TValue, TSharer>,\n      ) => Controls<TValue> | AfterEvent<[Controls<TValue>?]>;\n\n}\n\nfunction Field$provider<TValue, TSharer extends object>(\n    field: () => Field<TValue, TSharer>,\n    provider: Field.Provider<TValue>,\n): Shareable.Provider<Field.Body<TValue> | undefined, TSharer> {\n  return sharer => sharer.get(FormPreset).rules.do(\n      digAfter_(preset => {\n\n        const builder: Field.Builder<TValue, TSharer> = {\n          sharer,\n          field: field(),\n          control: new InBuilder<InControl<TValue>, TValue>(),\n        };\n\n        preset.setupField(builder);\n\n        return afterValue(provider(builder));\n      }),\n      deduplicateAfter_(Field$isDuplicateControls, ([controls]) => controls),\n      mapAfter(controls => controls && { field: field(), control: controls.control }),\n  );\n}\n\nfunction Field$isDuplicateControls<TValue>(\n    prior?: Field.Controls<TValue>,\n    next?: Field.Controls<TValue>,\n): boolean {\n  if (prior?.control !== next?.control) {\n    prior?.control.supply.off();\n    return false;\n  }\n  return true;\n}\n","import { ContextKey__symbol } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { Share, Share__symbol } from '../shares';\nimport { Field } from './field';\n\nconst FieldShare$map = (/*#__PURE__*/ new WeakMap<Class, FieldShare<any>>());\n\n/**\n * A kind of component share containing a {@link Field form field}.\n *\n * This class may be inherited to represent a specific type of forms. E.g. to distinguish multiple fields defined\n * within the same component.\n *\n * @typeParam TValue - Field value type.\n */\nexport class FieldShare<TValue = any> extends Share<Field<TValue>> {\n\n  /**\n   * Default field share instance.\n   */\n  static get [Share__symbol](): FieldShare {\n\n    let instance = FieldShare$map.get(this);\n\n    if (!instance) {\n      instance = new this('field');\n      FieldShare$map.set(this, instance);\n    }\n\n    return instance;\n  }\n\n  /**\n   * A key of component context value containing default field instance.\n   */\n  static get [ContextKey__symbol](): Share.Key<Field<any>> {\n    return this[Share__symbol][ContextKey__symbol];\n  }\n\n}\n","import { ContextKey__symbol } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { Share, Share__symbol } from '../shares';\nimport { Form } from './form';\n\nconst FormShare$map = (/*#__PURE__*/ new WeakMap<Class, FormShare<any, any>>());\n\n/**\n * A kind of component share containing a user input form.\n *\n * This class may be inherited to represent a specific type of forms. E.g. to support multiple forms within the same\n * component tree.\n *\n * @typeParam TModel - A model type of the form.\n * @typeParam TElt - A type of HTML form element.\n */\nexport class FormShare<TModel = any, TElt extends HTMLElement = HTMLElement> extends Share<Form<TModel, TElt>> {\n\n  /**\n   * Default form share instance.\n   */\n  static get [Share__symbol](): FormShare<any, any> {\n\n    let instance = FormShare$map.get(this);\n\n    if (!instance) {\n      instance = new this('form');\n      FormShare$map.set(this, instance);\n    }\n\n    return instance;\n  }\n\n  /**\n   * A key of component context value containing default form instance.\n   */\n  static get [ContextKey__symbol](): Share.Key<Form> {\n    return this[Share__symbol][ContextKey__symbol];\n  }\n\n}\n","import { InBuilder, InControl } from '@frontmeans/input-aspects';\nimport { AfterEvent, afterThe, afterValue, digAfter } from '@proc7ts/fun-events';\nimport { valueRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { shareLocator, ShareLocator } from '../shares';\nimport { Field } from './field';\nimport { FieldShare } from './field.share';\nimport { Form } from './form';\nimport { FormUnit } from './form-unit';\nimport { FormShare } from './form.share';\n\n/**\n * Creates a field adjacent to some form unit.\n *\n * Suitable e.g. for buttons or error indicators.\n *\n * The controls of adjacent field are based on the ones of the unit it is adjacent to.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TAdjacentTo - A type of form unit the field is adjacent to.\n * @typeParam TAdjusted - A type of controls to adjust. I.e. the ones of the form unit the field is adjacent to.\n * @typeParam TSharer - Adjacent field sharer component type.\n */\nexport function adjacentField<\n    TValue,\n    TAdjacentTo extends FormUnit<unknown, TAdjusted>,\n    TAdjusted extends FormUnit.Controls<unknown> = FormUnit.ControlsType<TAdjacentTo>,\n    TSharer extends object = FormUnit.SharerType<TAdjacentTo>,\n    >(\n    controls: Field.Controls<TValue> | AdjacentField.Provider<TValue, TAdjacentTo, TAdjusted, TSharer>,\n    adjacentTo: ShareLocator.Mandatory<TAdjacentTo>,\n): Field<TValue, TSharer> {\n  return new Field(AdjacentField$provider(\n      valueRecipe(controls),\n      shareLocator(adjacentTo, { local: 'too' }),\n  ));\n}\n\n/**\n * Creates a field adjacent to another one.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TSharer - Adjacent field sharer component type.\n * @param controls - Either a field controls instance, or its provider.\n * @param adjacentTo - A locator of the field share the created field is adjacent to. Includes local shares by\n * default. Defaults to {@link FieldShare}.\n */\nexport function adjacentToField<TValue, TSharer extends object = any>(\n    controls:\n        | Field.Controls<TValue>\n        | AdjacentField.Provider<TValue, Field<unknown>, Field.Controls<unknown>, TSharer>,\n    adjacentTo: ShareLocator.Mandatory<Field<unknown>> = FieldShare,\n): Field<TValue, TSharer> {\n  return adjacentField(controls, adjacentTo);\n}\n\n/**\n * Creates a field adjacent to form.\n *\n * @typeParam TValue - Adjacent field value type.\n * @typeParam TSharer - Adjacent field sharer component type.\n * @param controls - Either a field controls instance, or its provider.\n * @param adjacentTo - A locator of the form share the created field is adjacent to. Includes local shares by default.\n * Defaults to {@link FormShare}.\n */\nexport function adjacentToForm<TValue, TSharer extends object = any>(\n    controls:\n        | Field.Controls<TValue>\n        | AdjacentField.Provider<TValue, Form<unknown>, Form.Body<unknown>, TSharer>,\n    adjacentTo: ShareLocator.Mandatory<Form<unknown>> = FormShare,\n): Field<TValue, TSharer> {\n  return adjacentField(controls, adjacentTo);\n}\n\nexport namespace AdjacentField {\n\n  /**\n   * Adjacent field builder.\n   *\n   * @typeParam TValue - Adjacent field value type.\n   * @typeParam TAdjacentTo - A type of form unit the field is adjacent to.\n   * @typeParam TAdjusted - A type of controls to adjust. I.e. the ones of the form unit the field is adjacent to.\n   * @typeParam TSharer - Adjacent field sharer component type.\n   */\n  export interface Builder<\n      TValue,\n      TAdjacentTo extends FormUnit<unknown, TAdjusted>,\n      TAdjusted extends FormUnit.Controls<unknown> = FormUnit.ControlsType<TAdjacentTo>,\n      TSharer extends object = any,\n      > extends Field.Builder<TValue, TSharer> {\n\n    /**\n     * Sharer component context.\n     */\n    readonly sharer: ComponentContext<TSharer>;\n\n    /**\n     * Target field.\n     */\n    readonly field: Field<TValue, TSharer>;\n\n    /**\n     * Field input control builder.\n     */\n    readonly control: InBuilder<InControl<TValue>, TValue>;\n\n    /**\n     * Form unit the field is adjacent to.\n     */\n    readonly adjacentTo: TAdjacentTo;\n\n    /**\n     * Adjusted form unit control.\n     */\n    readonly adjusted: TAdjusted;\n\n  }\n\n  /**\n   * Adjacent field controls provider signature.\n   *\n   * @typeParam TValue - Adjacent field value type.\n   * @typeParam TAdjacentTo - A type of form unit the field is adjacent to.\n   * @typeParam TAdjusted - A type of controls to adjust. I.e. the ones of the form unit the field is adjacent to.\n   * @typeParam TSharer - Adjacent field sharer component type.\n   */\n  export type Provider<\n      TValue,\n      TAdjacentTo extends FormUnit<unknown, TAdjusted>,\n      TAdjusted extends FormUnit.Controls<unknown> = FormUnit.ControlsType<TAdjacentTo>,\n      TSharer extends object = any,\n      > =\n  /**\n   * @param builder - Adjacent field builder.\n   *\n   * @returns Either field controls instance, or an `AfterEvent` keeper reporting one.\n   */\n      (\n          this: void,\n          builder: Builder<TValue, TAdjacentTo, TAdjusted, TSharer>,\n      ) => Field.Controls<TValue> | AfterEvent<[Field.Controls<TValue>?]>;\n\n}\n\nfunction AdjacentField$provider<\n    TValue,\n    TAdjacentTo extends FormUnit<unknown, TAdjusted>,\n    TAdjusted extends FormUnit.Controls<unknown> = FormUnit.ControlsType<TAdjacentTo>,\n    TSharer extends object = any>(\n    provider: AdjacentField.Provider<TValue, TAdjacentTo, TAdjusted, TSharer>,\n    adjacentLocator: ShareLocator.Fn<TAdjacentTo>,\n): Field.Provider<TValue, TSharer> {\n  return builder => adjacentLocator(builder.sharer).do(\n      digAfter((adjacentTo?: TAdjacentTo, _sharer?): AfterEvent<[Field.Controls<TValue>?]> => adjacentTo\n          ? adjacentTo.read.do(\n              digAfter((adjusted?: TAdjusted): AfterEvent<[Field.Controls<TValue>?]> => adjusted\n                  ? afterValue(provider({\n                    ...builder,\n                    adjacentTo,\n                    adjusted,\n                  }))\n                  : afterThe()),\n          )\n          : afterThe()),\n  );\n}\n","/**\n * @internal\n */\nexport function Field$name(key: string | symbol, name: string | undefined): string | null {\n  if (name === '') {\n    return null;\n  }\n  if (name) {\n    return name;\n  }\n  return Field$nameByKey(key);\n}\n\n/**\n * @internal\n */\nexport function Field$nameByKey(key: string | symbol): string | null {\n  return typeof key === 'string' ? key : null;\n}\n","import { InGroup } from '@frontmeans/input-aspects';\nimport { Amendment } from '@proc7ts/amend';\nimport { afterAll, consumeEvents, digAfter_ } from '@proc7ts/fun-events';\nimport { asis, Class, valuesProvider } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentClass } from '@wesib/wesib';\nimport { SharedDef, shareLocator, ShareLocator } from '../shares';\nimport { Field } from './field';\nimport { Field$nameByKey } from './field.impl';\nimport { Form } from './form';\nimport { FormUnit } from './form-unit';\nimport { FormShare } from './form.share';\nimport { AeSharedField } from './shared-field.amendment';\nimport { AeSharedFormUnit } from './shared-form-unit.amendment';\nimport { AeSharedForm } from './shared-form.amendment';\n\n/**\n * Creates a {@link SharedForm shared form} member amendment that adds nested form to enclosing one.\n *\n * @typeParam TForm - Nested form type.\n * @typeParam TModel - Nested form model type.\n * @typeParam TElt - A type of nested HTML form element.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Nested form naming definition.\n *\n * @returns Shared form definition builder.\n */\nexport function FormName<\n    TForm extends Form<TModel, TElt>,\n    TModel = Form.ModelType<TForm>,\n    TElt extends HTMLElement = Form.ElementType<TForm>,\n    TClass extends ComponentClass = Class>(\n    def?: FieldNameDef,\n): Amendment<AeSharedForm<TForm, SharedDef.Value<TForm>, TModel, TElt, TClass>> {\n  return FormUnitName<TForm, TModel, Form.Controls<TModel, TElt>, TClass>(def);\n}\n\n/**\n * Creates a {@link SharedField shared field} member amendment that adds the field to enclosing form.\n *\n * @typeParam TField - Field type.\n * @typeParam TValue - Field value type.\n * @typeParam TClass - A type of decorated component class.\n * @param def - Field naming definition.\n *\n * @returns Shared field definition builder.\n */\nexport function FieldName<\n    TField extends Field<TFieldValue>,\n    TFieldValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class>(\n    def: FieldNameDef = {},\n): Amendment<AeSharedField<TField, SharedDef.Value<TField>, TFieldValue, TClass>> {\n  return FormUnitName<TField, TFieldValue, Field.Controls<TFieldValue>, TClass>(def);\n}\n\nfunction FormUnitName<\n    TUnit extends FormUnit<TUnitValue, TControls, any>,\n    TUnitValue,\n    TControls extends FormUnit.Controls<TUnitValue>,\n    TClass extends ComponentClass = Class>(\n    def: FieldNameDef = {},\n): Amendment<AeSharedFormUnit<TUnit, SharedDef.Value<TUnit>, TUnitValue, TControls, TClass>> {\n  return ({\n    key,\n    share,\n    locateForm: defaultForm,\n    name: defaultName,\n    amend,\n  }) => {\n\n    const { name = defaultName } = def;\n    let fieldName: string;\n\n    if (name) {\n      fieldName = name;\n    } else if (name != null) {\n      return; // Empty field name. Do not ad it to form.\n    } else {\n\n      const autoName = Field$nameByKey(key);\n\n      if (!autoName) {\n        return;\n      }\n\n      fieldName = autoName;\n    }\n\n    const locateForm = shareLocator(def.form || defaultForm, { share: FormShare });\n\n    amend({\n      componentDef: {\n        setup(setup) {\n          setup.whenComponent(context => {\n            afterAll({\n              unit: context.get(share).do(\n                  digAfter_(asis, valuesProvider<[TControls?]>()),\n              ),\n              form: locateForm(context).do(\n                  digAfter_((form?, _sharer?) => form, valuesProvider<[FormUnit.Controls<any>?]>()),\n              ),\n            }).do(\n                consumeEvents(({ unit: [field], form: [form] }): Supply | undefined => {\n                  if (!form || !field) {\n                    return;\n                  }\n\n                  const group = form.control.aspect(InGroup);\n\n                  if (!group) {\n                    return;\n                  }\n\n                  return group.controls.set(fieldName, field.control);\n                }),\n            );\n          });\n        },\n      },\n    });\n  };\n}\n\n/**\n * Form field naming definition.\n */\nexport interface FieldNameDef {\n\n  /**\n   * A locator of form unit to add the field to.\n   *\n   * Either {@link SharedFieldDef.form predefined}, or {@link FormShare default} form share is used when omitted.\n   */\n  readonly form?: ShareLocator<FormUnit<any>>;\n\n  /**\n   * Field name.\n   *\n   * The shared field will be added to the input control group (`InGroup`) within the {@link form target form},\n   * unless the name is empty string.\n   *\n   * Either {@link SharedFieldDef.name predefined}, or property name is used when omitted.\n   */\n  readonly name?: string;\n\n}\n","import {\n  InAspect,\n  InAspect__symbol,\n  InBuilder,\n  InControl,\n  InConverter,\n  inconvertibleInAspect,\n  inFormElement,\n  InFormElement,\n  nullInAspect,\n} from '@frontmeans/input-aspects';\nimport { AfterEvent, afterValue, deduplicateAfter_, digAfter_, mapAfter } from '@proc7ts/fun-events';\nimport { lazyValue, valueRecipe } from '@proc7ts/primitives';\nimport { ComponentContext } from '@wesib/wesib';\nimport { Shareable } from '../shares';\nimport { FormPreset } from './form-preset';\nimport { FormUnit } from './form-unit';\n\nconst Form__aspect: Form$Aspect = {\n\n  applyTo<TValue>(_control: InControl<TValue>): Form$Applied<TValue> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return nullInAspect();\n  },\n\n};\n\n/**\n * User input form.\n *\n * A component {@link FormShare shares} form (e.g. using {@link SharedForm @SharedForm} decorator) to make its\n * accessible by component itself and nested ones. E.g. to add {@link Field fields} to it or submit it.\n *\n * A form may be nested within another one, as it implements a {@link Field} interface.\n *\n * The form instance is not usable until it is bound to its sharer component. The latter is done automatically when the\n * form is shared by {@link FormShare}.\n *\n * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n * @typeParam TElt - A type of HTML form element.\n * @typeParam TSharer - Form sharer component type.\n */\nexport class Form<TModel = any, TElt extends HTMLElement = HTMLElement, TSharer extends object = any>\n    extends FormUnit<TModel, Form.Body<TModel, TElt>, TSharer> {\n\n  /**\n   * Builds a user input form for the given form control and HTML element.\n   *\n   * @param control - Submitted control. Typically a container one.\n   * @param element - HTML element to create control for.\n   * @param options - Form element control options.\n   *\n   * @returns New form instance.\n   */\n  static forElement<TModel, TElt extends HTMLElement>(\n      control: InControl<TModel>,\n      element: TElt,\n      options?: Omit<InFormElement.Options, 'form'>,\n  ): Form.Controls<TModel, TElt> {\n    return {\n      control,\n      element: inFormElement(element, { ...options, form: control }),\n    };\n  }\n\n  /**\n   * Creates a form instance by the given control factories.\n   *\n   * @param factory - Submittable form control factory.\n   * @param elementFactory - Form element control factory or options.\n   *\n   * @returns New form instance.\n   */\n  static by<\n      TModel,\n      TElt extends HTMLElement = HTMLElement,\n      TSharer extends object = any>(\n      factory: InControl.Factory<InControl<TModel>, TModel>,\n      elementFactory: (\n          this: void,\n          options: Parameters<InControl.Factory<InFormElement<TElt>, void>>[0] & { form: InControl<TModel>},\n      ) => InFormElement<TElt>,\n  ): Form<TModel, TElt, TSharer> {\n    return new this(this.providerBy(factory, elementFactory));\n  }\n\n  /**\n   * Creates a form controls provider by the given control factories.\n   *\n   * @param factory - Submittable form control factory.\n   * @param elementFactory - Form element control factory or options.\n   *\n   * @returns New form controls provider.\n   */\n  static providerBy<\n      TModel,\n      TElt extends HTMLElement = HTMLElement,\n      TSharer extends object = any>(\n      factory: InControl.Factory<InControl<TModel>, TModel>,\n      elementFactory: (\n          this: void,\n          options: Parameters<InControl.Factory<InFormElement<TElt>, void>>[0] & { form: InControl<TModel>},\n      ) => InFormElement<TElt>,\n  ): Form.Provider<TModel, TElt, TSharer> {\n    return builder => {\n\n      let control = (): InControl<TModel> => builder.control.build(\n          // Allow recurrent access to `Form` aspect during control setup.\n          opts => (control = lazyValue(() => factory(opts)))(),\n      );\n      let element = (): InFormElement<TElt> => builder.element.build(\n          // Allow recurrent access to `Form` aspect during control setup.\n          opts => (element = lazyValue(() => elementFactory({\n            form: control(),\n            ...opts,\n          })))(),\n      );\n\n      return {\n        get control() {\n          return control();\n        },\n        get element() {\n          return element();\n        },\n      };\n    };\n  }\n\n  /**\n   * An input control aspect representing a form this control belongs to.\n   *\n   * This aspect is available in {@link Form.Body.control submittable form control} and {@link Form.Body.element form\n   * element control}.\n   */\n  static get [InAspect__symbol](): InAspect<Form.Whole | null> {\n    return Form__aspect;\n  }\n\n  /**\n   * Constructs form.\n   *\n   * @param controls - Either form controls instance, or its provider.\n   */\n  constructor(\n      controls: Form.Controls<TModel, TElt> | Form.Provider<TModel, TElt, TSharer>,\n  ) {\n    super(Form$provider(() => this, valueRecipe(controls)));\n  }\n\n  /**\n   * Form element control, if present.\n   *\n   * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n   * element issuing a `submit` event.\n   */\n  get element(): InFormElement<TElt> | undefined {\n    return this.body?.element;\n  }\n\n  toString(): string {\n    return 'Form';\n  }\n\n}\n\nfunction Form$provider<TModel, TElt extends HTMLElement, TSharer extends object>(\n    form: () => Form<TModel, TElt, TSharer>,\n    provider: Form.Provider<TModel, TElt, TSharer>,\n): Shareable.Provider<Form.Body<TModel, TElt> | undefined, TSharer> {\n\n  const formAspect: InConverter.Aspect.Factory<any> = control => ({\n    applyAspect<TInstance, TKind extends InAspect.Application.Kind>(\n        _aspect: InAspect<any, any>,\n    ): InAspect.Application.Result<TInstance, any, TKind> | undefined {\n      return inconvertibleInAspect(\n          control,\n          Form,\n          form() as Form.Whole,\n      ) as InAspect.Application.Result<TInstance, any, TKind>;\n    },\n  });\n\n  return sharer => sharer.get(FormPreset).rules.do(\n      digAfter_(preset => {\n\n        const builder: Form.Builder<TModel, TElt, TSharer> = {\n          sharer,\n          form: form(),\n          control: new InBuilder<InControl<TModel>, TModel>().addAspect(Form, formAspect),\n          element: new InBuilder<InFormElement<TElt>, void>().addAspect(Form, formAspect),\n        };\n\n        preset.setupForm(builder);\n\n        return afterValue(provider(builder));\n      }),\n      deduplicateAfter_(Form$isDuplicateControls, ([controls]) => controls),\n      mapAfter(controls => controls && {\n        get form() {\n          return form();\n        },\n        get control() {\n          return controls!.control;\n        },\n        get element() {\n          return controls!.element;\n        },\n      }),\n  );\n}\n\nfunction Form$isDuplicateControls<TModel, TElt extends HTMLElement>(\n    prior: Form.Controls<TModel, TElt> | undefined,\n    next: Form.Controls<TModel, TElt> | undefined,\n): boolean {\n\n  let duplicate = true;\n\n  if (prior?.control !== next?.control) {\n    prior?.control.supply.off();\n    duplicate = false;\n  }\n  if (prior?.element !== next?.element) {\n    prior?.element.supply.off();\n    duplicate = false;\n  }\n\n  return duplicate;\n}\n\nexport namespace Form {\n\n  /**\n   * A whole form instance containing controls.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TSharer - Form sharer component type.\n   */\n  export interface Whole<\n      TModel = any,\n      TElt extends HTMLElement = HTMLElement,\n      TSharer extends object = any>\n      extends Form<TModel, TElt, TSharer> {\n\n    /**\n     * Form body.\n     */\n    readonly body: Body<TModel, TElt, TSharer>;\n\n    /**\n     * Submittable form input control.\n     */\n    readonly control: InControl<TModel>;\n\n    /**\n     * Form element control.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    readonly element: InFormElement<any>;\n\n  }\n\n  /**\n   * A model type of the given form.\n   *\n   * @typeParam TForm - Form type.\n   */\n  export type ModelType<TForm extends Form<any, any>> = FormUnit.ValueType<TForm>;\n\n  /**\n   * HTML form element type of the form.\n   *\n   * @typeParam TForm - Form type.\n   */\n  export type ElementType<TForm extends Form<any, any>> = TForm extends Form<any, infer TElt> ? TElt : never;\n\n  /**\n   * Form controls.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   */\n  export interface Controls<TModel, TElt extends HTMLElement = HTMLElement> extends FormUnit.Controls<TModel> {\n\n    /**\n     * Submittable form input control.\n     */\n    readonly control: InControl<TModel>;\n\n    /**\n     * Form element control.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    readonly element: InFormElement<TElt>;\n\n  }\n\n  /**\n   * Form body containing input controls.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TSharer - Form sharer component type.\n   */\n  export interface Body<\n      TModel,\n      TElt extends HTMLElement = HTMLElement,\n      TSharer extends object = any,\n      > extends FormUnit.Controls<TModel> {\n\n    /**\n     * A form the controls belong to.\n     */\n    readonly form: Form<TModel, TElt, TSharer>;\n\n    /**\n     * Submittable form input control.\n     */\n    readonly control: InControl<TModel>;\n\n    /**\n     * Form element control.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    readonly element: InFormElement<TElt>;\n\n  }\n\n  /**\n   * Form builder.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   */\n  export interface Builder<TModel, TElt extends HTMLElement, TSharer extends object> {\n\n    /**\n     * Sharer component context.\n     */\n    readonly sharer: ComponentContext<TSharer>;\n\n    /**\n     * Target form.\n     */\n    readonly form: Form<TModel, TElt, TSharer>;\n\n    /**\n     * Submittable form control builder.\n     */\n    readonly control: InBuilder<InControl<TModel>, TModel>;\n\n    /**\n     * Form element control builder.\n     *\n     * Unlike {@link control input control} this one is not supposed to be submitted, but rather contains a `<form>`\n     * element issuing a `submit` event.\n     */\n    readonly element: InBuilder<InFormElement<TElt>, void>;\n\n  }\n\n  /**\n   * Form controls provider signature.\n   *\n   * @typeParam TModel - A model type of the form, i.e. a type of its control value.\n   * @typeParam TElt - A type of HTML form element.\n   * @typeParam TSharer - Form sharer component type.\n   */\n  export type Provider<TModel = any, TElt extends HTMLElement = HTMLElement, TSharer extends object = object> =\n  /**\n   * @param builder - Form builder.\n   *\n   * @returns Either form controls instance, or an `AfterEvent` keeper reporting one.\n   */\n      (\n          this: void,\n          builder: Builder<TModel, TElt, TSharer>,\n      ) => Controls<TModel, TElt> | AfterEvent<[Controls<TModel, TElt>?]>;\n\n}\n\n/**\n * Form aspect.\n */\ninterface Form$Aspect extends InAspect<Form | null, 'form'> {\n\n  applyTo<TValue>(control: InControl<TValue>): Form$Applied<TValue>;\n\n}\n\n/**\n * A form aspect applied to control.\n */\ntype Form$Applied<TValue> = InAspect.Applied<TValue, Form.Whole<TValue> | null, Form.Whole<any> | null>;\n\ndeclare module '@frontmeans/input-aspects' {\n\n  export namespace InAspect.Application {\n\n    export interface Map<TInstance, TValue> {\n\n      /**\n       * Form aspect application type.\n       */\n      form(): Form.Whole<TValue> | null;\n\n    }\n\n  }\n\n}\n","import { InControl, InRole } from '@frontmeans/input-aspects';\nimport { arrayOfElements } from '@proc7ts/primitives';\nimport { neverSupply, Supply, SupplyPeer } from '@proc7ts/supply';\n\n/**\n * A scope of form setup applicability.\n *\n * Selects controls to set up:\n *\n * - `false` - to set up nothing,\n * - `true` - to set up every control,\n * - role name or array of role names - to set up only to controls with that roles,\n * - `null`, `undefined`, or empty array - to set up only controls with default role.\n */\nexport type FormScope =\n    | boolean\n    | string\n    | readonly string[]\n    | null\n    | undefined;\n\nexport const FormScope = {\n\n  /**\n   * Creates an input control setup procedure applied to the given scope.\n   *\n   * @typeParam TControl - Input control type.\n   * @typeParam TValue - Input value type.\n   * @param scope - Setup applicability scope.\n   * @param setup - A setup procedure to apply. Accepts target control instance as parameter and returns a setup supply\n   * peer. The setup should be reverted once this peer's supply cut off.\n   * @param defaultRole - A role name to apply by default. `'default'` when omitted.\n   *\n   * @returns A setup procedure accepting target control as parameter and returning a setup supply. The setup is\n   * reverted once this supply cut off.\n   */\n  createSetup<TControl extends InControl<TValue>, TValue = InControl.ValueType<TControl>>(\n      this: void,\n      scope: FormScope,\n      setup: (this: void, control: TControl) => SupplyPeer,\n      defaultRole = 'default',\n  ): (this: void, control: TControl) => Supply {\n    if (scope === false) {\n      return _control => neverSupply();\n    }\n    if (scope === true) {\n      return control => setup(control).supply;\n    }\n\n    let roles = arrayOfElements(scope);\n\n    if (!roles.length) {\n      roles = [defaultRole];\n    }\n\n    if (roles.length === 1) {\n      return control => control.aspect(InRole).when(roles[0], () => setup(control));\n    }\n\n    return control => roles.reduce(\n        (supply, role) => control.aspect(InRole).when(role, () => setup(control)).as(supply),\n        new Supply(),\n    );\n  },\n\n};\n","import { ContextBuilder, ContextBuilder__symbol, ContextRegistry } from '@proc7ts/context-values';\nimport { Class } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Field } from '../field';\nimport { Form } from '../form';\nimport { FormPreset } from '../form-preset';\n\nconst AbstractFormPreset$map = (/*#__PURE__*/ new WeakMap<typeof AbstractFormPreset, FeatureDef>());\n\n/**\n * Abstract form preset implementation.\n *\n * A class extending it may be used as a feature. E.g. passed to `bootstrapComponents()` function or used as a\n * dependency of another feature.\n *\n * An instance of implementation class may be created to customize its behavior. Such instance implements a\n * `ContextBuilder` interface. Thus is can be passed to context value registration method.\n */\nexport abstract class AbstractFormPreset implements FormPreset.Spec, ContextBuilder {\n\n  /**\n   * Feature definition of the preset.\n   */\n  static get [FeatureDef__symbol](): FeatureDef {\n\n    const found = AbstractFormPreset$map.get(this);\n\n    if (found) {\n      return found;\n    }\n\n    const preset = new (this as unknown as Class<AbstractFormPreset>)();\n    const featureDef: FeatureDef = {\n      setup: setup => {\n        setup.provide(preset);\n      },\n    };\n\n    AbstractFormPreset$map.set(this, featureDef);\n\n    return featureDef;\n  }\n\n  /**\n   * Provides this form preset to the given context.\n   *\n   * @param registry - A context registry to provide a value to.\n   *\n   * @returns A supply instance that removes the added preset once cut off.\n   */\n  [ContextBuilder__symbol](registry: ContextRegistry): Supply {\n    return registry.provide({ a: FormPreset, is: this });\n  }\n\n  /**\n   * Sets up form field controls.\n   *\n   * Does nothing by default.\n   *\n   * @param _builder - Target field builder.\n   */\n  setupField<TValue, TSharer extends object>(\n      _builder: Field.Builder<TValue, TSharer>,\n  ): void {\n    // No field setup\n  }\n\n  /**\n   * Sets up form controls.\n   *\n   * Does nothing by default.\n   *\n   * @param _builder - Target form builder.\n   */\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      _builder: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    // No form setup\n  }\n\n}\n","import { InControl } from '@frontmeans/input-aspects';\nimport { Supply, SupplyPeer } from '@proc7ts/supply';\nimport { FormScope } from './form-scope';\n\n/**\n * Scoped form setup configuration.\n *\n * Contains setup options along with the scope they applicable to.\n *\n * May be one of:\n *\n * - `false` - to not apply configuration,\n * - `true` - to apply default configuration to every control,\n * - role name or array of role names - to apply default configuration only to controls with that roles,\n * - `null`, `undefined`, or empty array - to apply default configuration only to controls with default role,\n * - an array containing options as the first element, and role names as the rest of them - to apply these options\n *   only to controls with that roles,\n * - a tuple consisting of options and {@link FormScope scope} specifier - to apply these options to specified scope.\n *\n * @typeParam TOptions - A type of setup options.\n */\nexport type ScopedFormConfig<TOptions> =\n    | TOptions\n    | FormScope\n    | readonly [TOptions, FormScope?]\n    | readonly [TOptions, ...string[]];\n\nexport const ScopedFormConfig = {\n\n  /**\n   * Creates an input control setup procedure that applies the given configuration to appropriate scope.\n   *\n   * @typeParam TOptions - A type of setup options.\n   * @typeParam TControl - Input control type.\n   * @typeParam TValue - Input value type.\n   * @param config - Scoped form setup configuration.\n   * @param createSetup - A function accepting setup options and returning a procedure that sets up the given control\n   * with these options. The setup procedure returns a setup supply peer. The setup should be reverted once this peer's\n   * supply cut off.\n   * @param defaultRole - A role name to apply by default. `'default'` when omitted.\n   *\n   * @returns A setup procedure accepting target control as parameter and returning a setup supply. The setup is\n   * reverted once this supply cut off.\n   */\n  createSetup<\n      TOptions,\n      TControl extends InControl<TValue>,\n      TValue = InControl.ValueType<TControl>,\n      >(\n      config: ScopedFormConfig<TOptions>,\n      createSetup: (this: void, options?: TOptions) => (this: void, control: TControl) => SupplyPeer,\n      defaultRole?: string,\n  ): (this: void, control: TControl) => Supply {\n\n    let scope: FormScope;\n    let options: TOptions | undefined;\n\n    if (Array.isArray(config)) {\n\n      const [first, ...rest] = config;\n\n      if (ScopedFormConfig$isOptions(first)) {\n        scope = rest.length > 1 ? rest : rest[0];\n        options = first;\n      } else {\n        scope = config;\n      }\n    } else if (ScopedFormConfig$isOptions(config)) {\n      options = config as TOptions;\n    } else {\n      scope = config;\n    }\n\n    return FormScope.createSetup<TControl, TValue>(\n        scope,\n        createSetup(options),\n        defaultRole,\n    );\n  },\n\n};\n\nfunction ScopedFormConfig$isOptions<TOptions>(\n    config: TOptions | string | boolean | undefined,\n): config is TOptions {\n  return config != null && typeof config !== 'string' && typeof config !== 'boolean';\n}\n","import {\n  AeClass,\n  allAmender,\n  Amender,\n  Amendment,\n  AmendRequest,\n  AmendTarget,\n  isAmendatory,\n  MemberAmendment,\n  newAmendTarget,\n} from '@proc7ts/amend';\nimport { Class } from '@proc7ts/primitives';\nimport { ComponentClass } from '@wesib/wesib';\nimport {\n  Share,\n  Shared,\n  SharedAmendment,\n  SharedDef,\n  ShareLocator,\n  shareLocator,\n  ShareRef,\n  TargetShare,\n} from '../shares';\nimport { Field } from './field';\nimport { FieldName } from './field-name.amendment';\nimport { Field$name } from './field.impl';\nimport { FieldShare } from './field.share';\nimport { FormUnit } from './form-unit';\nimport { FormShare } from './form.share';\nimport { AeSharedFormUnit } from './shared-form-unit.amendment';\n\n/**\n * An amended entity representing a component member containing a shared field to amend.\n *\n * @typeParam TField - Field type.\n * @typeParam TMemberValue - Amended member value type.\n * @typeParam TFieldValue - Field value type.\n * @typeParam TClass - Amended component class type.\n */\nexport interface AeSharedField<\n    TField extends Field<TFieldValue>,\n    TMemberValue extends SharedDef.Value<TField> = SharedDef.Value<TField>,\n    TFieldValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class>\n    extends AeSharedFormUnit<TField, TMemberValue, TFieldValue, Field.Controls<TFieldValue>, TClass> {\n\n  /**\n   * Target field share instance.\n   */\n  readonly share: Share<TField>;\n\n  /**\n   * Predefined locator function of the form unit to add the shared field to.\n   */\n  readonly locateForm: ShareLocator.Fn<FormUnit<any>>;\n\n  /**\n   * Predefined field name, or `null`/`undefined` when the field is not to be added to the {@link locateForm form}.\n   */\n  readonly name: string | null;\n\n}\n\n/**\n * An amendment of component member containing a shared field.\n *\n * Created by {@link SharedField} function.\n *\n * @typeParam TField - Field type.\n * @typeParam TMemberValue - Amended member value type.\n * @typeParam TFieldValue - Field value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended field entity type.\n */\nexport type SharedFieldAmendment<\n    TField extends Field<TFieldValue>,\n    TMemberValue extends SharedDef.Value<TField> = SharedDef.Value<TField>,\n    TFieldValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class,\n    TAmended extends AeSharedField<TField, TMemberValue, TFieldValue, TClass> =\n        AeSharedField<TField, TMemberValue, TFieldValue, TClass>> =\n    MemberAmendment.ForBase<\n        AeClass<TClass>,\n        AeSharedField<TField, TMemberValue, TFieldValue, TClass>,\n        TMemberValue,\n        TClass,\n        TMemberValue,\n        TAmended>;\n/**\n * Creates an amendment (and decorator) of component member that {@link FieldShare shares} a form field.\n *\n * @typeParam TField - Field type.\n * @typeParam TMemberValue - Amended member value type.\n * @typeParam TFieldValue - Field value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended field entity type.\n * @param def - Field definition.\n * @param amendments - Amendments to apply.\n *\n * @return New field member amendment.\n */\nexport function SharedField<\n    TField extends Field<TFieldValue>,\n    TMemberValue extends SharedDef.Value<TField> = SharedDef.Value<TField>,\n    TFieldValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class,\n    TAmended extends AeSharedField<TField, TMemberValue, TFieldValue, TClass> =\n        AeSharedField<TField, TMemberValue, TFieldValue, TClass>>(\n    def?: SharedFieldDef<TField, TFieldValue>,\n    ...amendments: Amendment<TAmended>[]\n): SharedFieldAmendment<TField, TMemberValue, TFieldValue, TClass, TAmended>;\n\n/**\n * Creates an amendment (and decorator) of component member that {@link FieldShare shares} a form field and adds it\n * to the {@link FormShare default form} under amended member name.\n *\n * @typeParam TField - Field type.\n * @typeParam TMemberValue - Amended member value type.\n * @typeParam TFieldValue - Field value type.\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended field entity type.\n * @param amendments - Amendments to apply.\n *\n * @return Component property decorator.\n */\nexport function SharedField<\n    TField extends Field<TFieldValue>,\n    TMemberValue extends SharedDef.Value<TField> = SharedDef.Value<TField>,\n    TFieldValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class,\n    TAmended extends AeSharedField<TField, TMemberValue, TFieldValue, TClass> =\n        AeSharedField<TField, TMemberValue, TFieldValue, TClass>>(\n    ...amendments: Amendment<TAmended>[]\n): SharedFieldAmendment<TField, TMemberValue, TFieldValue, TClass, TAmended>;\n\nexport function SharedField<\n    TField extends Field<TFieldValue>,\n    TMemberValue extends SharedDef.Value<TField> = SharedDef.Value<TField>,\n    TFieldValue = Field.ValueType<TField>,\n    TClass extends ComponentClass = Class,\n    TAmended extends AeSharedField<TField, TMemberValue, TFieldValue, TClass> =\n        AeSharedField<TField, TMemberValue, TFieldValue, TClass>>(\n    defOrAmendment:\n        | SharedFieldDef<TField, TFieldValue>\n        | Amendment<TAmended> = {},\n    ...amendments: Amendment<TAmended>[]\n): SharedAmendment<TField, TMemberValue, TClass, TAmended> {\n\n  let def: SharedFieldDef<TField, TFieldValue>;\n  let fieldName: string | undefined;\n  let amender: Amender<TAmended>;\n\n  if (typeof defOrAmendment === 'function' || isAmendatory(defOrAmendment)) {\n    def = {};\n    amender = allAmender([defOrAmendment, ...amendments, FieldName()]);\n  } else {\n    def = defOrAmendment;\n    fieldName = defOrAmendment.name;\n    amender = allAmender([...amendments, FieldName({ name: fieldName })]);\n  }\n\n  const {\n    share = FieldShare as ShareRef<any> as ShareRef<TField>,\n    form,\n  } = def;\n  const locateForm$default = shareLocator(form, { share: FormShare });\n\n  return Shared<TField, TMemberValue, TClass, TAmended>(\n      share,\n      baseTarget => {\n        amender(newAmendTarget({\n          base: {\n            ...baseTarget as TAmended,\n            locateForm: locateForm$default,\n            name: Field$name(baseTarget.key, fieldName),\n          },\n          amend<TBase extends TAmended, TExt>(\n              base: TBase,\n              request: AmendRequest<TBase, TExt> = {} as AmendRequest<TBase, TExt>,\n          ): () => AmendTarget.Draft<TBase & TExt> {\n\n            const {\n              locateForm = base.locateForm,\n              name = base.name,\n              ...baseRequest\n            } = request;\n\n            const createBaseTarget = baseTarget.amend(baseRequest as AmendRequest<any>);\n\n            return () => ({\n              ...createBaseTarget(),\n              locateForm,\n              name,\n            } as AmendTarget.Draft<TBase & TExt>);\n          },\n        }));\n      },\n  );\n}\n\n/**\n * Shared form field definition.\n *\n * @typeParam TField - Field type.\n * @typeParam TValue - Field value type.\n */\nexport interface SharedFieldDef<TField extends Field<TValue>, TValue = Field.ValueType<TField>> {\n\n  /**\n   * Target field share.\n   */\n  readonly share?: TargetShare<TField>;\n\n  /**\n   * A locator of form unit to add the shared field to.\n   *\n   * The {@link FormShare default form share} is used when omitted.\n   */\n  readonly form?: ShareLocator<FormUnit<unknown>>;\n\n  /**\n   * Field name.\n   *\n   * The shared field will be added to the input control group (`InGroup`) within the {@link form target form},\n   * unless the name is empty string.\n   *\n   * Equals to decorated property name when omitted.\n   */\n  readonly name?: string;\n\n}\n","/**\n * @internal\n */\nexport function isReadonlyArray<T>(value: any): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): array is readonly [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: T[]): array is [T, ...T[]];\n\n/**\n * @internal\n */\nexport function isNotEmptyArray<T>(array: readonly T[]): boolean {\n  return !!array.length;\n}\n","import { StypColor } from './color';\nimport { StypNumeric } from './numeric';\nimport { StypPriority } from './priority';\nimport { StypURL } from './url';\n\n/**\n * CSS property value.\n *\n * This is either a scalar value, or {@link StypValueStruct structured} one.\n *\n * @category CSS Value\n */\nexport type StypValue =\n    | string\n    | number\n    | boolean\n    | undefined\n    | StypNumeric<any>\n    | StypURL\n    | StypColor;\n\n/**\n * Structured property CSS value. E.g. [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length),\n * [percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/percentage),\n * [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value), etc.\n *\n * @category CSS Value\n * @typeParam TSelf - A type of itself.\n */\nexport abstract class StypValueStruct<TSelf extends StypValueStruct<TSelf>> {\n\n  /**\n   * CSS property value priority.\n   *\n   * The value {@link StypPriority.Important} and above means the property is `!important`. Everything else means normal\n   * priority.\n   *\n   * The property value with higher priority number takes precedence over the one with lower one.\n   */\n  readonly priority: number;\n\n  /**\n   * Constructs structured CSS property value.\n   *\n   * @param opts - Construction options.\n   */\n  protected constructor(opts?: StypValue.Opts) {\n    this.priority = opts && opts.priority || StypPriority.Default;\n  }\n\n  /**\n   * Checks whether this value equals to CSS property value.\n   *\n   * @param other - CSS property value to compare with.\n   */\n  abstract is(other: StypValue): boolean;\n\n  /**\n   * Creates structured CSS value with the given `priority`.\n   *\n   * @param priority - New priority.\n   *\n   * @returns Either a new value equal to this one but having the given `priority`, or this one if `priority` did\n   * not change.\n   */\n  abstract prioritize(priority: number): TSelf;\n\n  /**\n   * Creates `!important` variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to {@link StypPriority.Important},\n   * or this one if already the case.\n   */\n  important(): TSelf {\n    return this.prioritize(StypPriority.Important);\n  }\n\n  /**\n   * Creates usual (not `!important`) variant of this value.\n   *\n   * @returns Either a new value equal to this one but having `priority` equal to {@link StypPriority.Usual},\n   * or this one if already the case.\n   */\n  usual(): TSelf {\n    return this.prioritize(StypPriority.Usual);\n  }\n\n  /**\n   * Maps the given CSS property value to the value of this one's type. Defaults to this value if mapping is not\n   * possible.\n   *\n   * This method allows to use an structured value instance as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source - A raw property value that should be converted.\n   *\n   * @returns Mapped property value.\n   */\n  abstract by(source: StypValue): StypValue;\n\n  /**\n   * Returns textual representation of this value.\n   *\n   * Textual representation never contains an `!important` suffix.\n   *\n   * @returns A textual representation of this value to use as CSS property value.\n   */\n  abstract toString(): string;\n\n}\n\n/**\n * @category CSS Value\n */\nexport namespace StypValue {\n\n  /**\n   * Construction options of structured property CSS value.\n   */\n  export interface Opts {\n\n    /**\n     * Constructed value priority.\n     *\n     * The value {@link StypPriority.Important} and above means the property is `!important`. Everything else means\n     * normal priority.\n     */\n    readonly priority?: number;\n\n  }\n\n}\n\n/**\n * Checks whether two CSS property values are equal.\n *\n * Compares scalar values verbatim. Compares structured values using their {@link StypValueStruct.is} method. The latter\n * method is applied when at least one of the values is structured.\n *\n * @category CSS Value\n * @param first - The first CSS property value to compare.\n * @param second - The second CSS property value to compare.\n *\n * @returns `true` if `first` equals to `second`, or `false otherwise.\n */\nexport function stypValuesEqual(first: StypValue, second: StypValue): boolean {\n  if (first === second) {\n    return true;\n  }\n  if (typeof first === 'object') {\n    return first.is(second);\n  }\n  if (typeof second === 'object') {\n    return second.is(first);\n  }\n  return false;\n}\n","import { StypValue, StypValueStruct } from '../value';\n\n/**\n * Structured [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) CSS property value.\n *\n * Colors are represented by either `rgb()`, or `hsl()` functional notations.\n *\n * @category CSS Value\n */\nexport type StypColor = StypRGB | StypHSL;\n\n/**\n * Structured color CSS property value base.\n *\n * @category CSS Value\n */\nexport abstract class StypColorStruct<TSelf extends StypColorStruct<TSelf, TCoords>, TCoords>\n    extends StypValueStruct<TSelf> {\n\n  /**\n   * Color value type corresponding to color coordinates. Either `rgb` or `hsl`\n   */\n  abstract readonly type: 'rgb' | 'hsl';\n\n  /**\n   * This color in RGB coordinates.\n   */\n  abstract readonly rgb: StypRGB;\n\n  /**\n   * This color in HSL coordinates.\n   */\n  abstract readonly hsl: StypHSL;\n\n  /**\n   * Constructs another color value with updated coordinates.\n   *\n   * @param coords - Either partial color coordinates to apply or a function returning them and accepting this color\n   * instance as its only argument. Missing values are taken from this color.\n   *\n   * @returns Updated color value.\n   */\n  abstract set(coords: Partial<TCoords> | ((this: void, color: this) => Partial<TCoords>)): TSelf;\n\n}\n\n/**\n * CSS property value representing [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors)\n * in `rgb()` or `rgba()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypRGB extends StypColorStruct<StypRGB, StypRGB.Coords> implements StypRGB.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  /**\n   * `rgb` value type.\n   */\n  get type(): 'rgb' {\n    return 'rgb';\n  }\n\n  /**\n   * Red color value between `0` and `255`.\n   */\n  readonly r: number;\n\n  /**\n   * Green color value between `0` and `255`.\n   */\n  readonly g: number;\n\n  /**\n   * Blue color value between `0` and `255`.\n   */\n  readonly b: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs RGB color value.\n   *\n   * @param coords - Color coordinates.\n   * @param opts - Construction options.\n   */\n  constructor(coords: StypRGB.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.r = intCoord(coords.r, 255);\n    this.g = intCoord(coords.g, 255);\n    this.b = intCoord(coords.b, 255);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get rgb(): this {\n    return this;\n  }\n\n  /**\n   * This color in HSL coordinates.\n   */\n  get hsl(): StypHSL {\n\n    const { a } = this;\n    const r = this.r * 100 / 255;\n    const g = this.g * 100 / 255;\n    const b = this.b * 100 / 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = Math.round((max + min) / 2);\n\n    if (max === min) {\n      return new StypHSL({ h: 0, s: 0, l, a }, this);\n    }\n\n    const d = max - min;\n    const s = Math.round(l > 50 ? d * 100 / (200 - max - min) : d * 100 / (max + min));\n    let h: number;\n\n    switch (max) {\n    case r:\n      h = ((g - b) / d) + (g < b ? 6 : 0);\n      break;\n    case g:\n      h = ((b - r) / d) + 2;\n      break;\n    default:\n      h = ((r - g) / d) + 4;\n      break;\n    }\n    h *= 60;\n    h = Math.round(h);\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  by(source: StypValue): StypColor {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.r === this.r\n        && other.g === this.g\n        && other.b === this.b\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypRGB {\n    return this.priority === priority ? this : new StypRGB(this, { priority });\n  }\n\n  set(coords: Partial<StypRGB.Coords> | ((this: void, color: this) => Partial<StypRGB.Coords>)): StypRGB {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { r = this.r, g = this.g, b = this.b, a = this.a } = coords;\n\n    return new StypRGB({ r, g, b, a }, this);\n  }\n\n  toString(): string {\n\n    const rgb = `${this.r}, ${this.g}, ${this.b}`;\n\n    return this.a === 1 ? `rgb(${rgb})` : `rgba(${rgb}, ${this.a})`;\n\n  }\n\n}\n\n/**\n * @category CSS Value\n */\nexport namespace StypRGB {\n\n  /**\n   * [RGB color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#RGB_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Red color value between `0` and `255`.\n     */\n    r: number;\n\n    /**\n     * Green color value between `0` and `255`.\n     */\n    g: number;\n\n    /**\n     * Blue color value between `0` and `255`.\n     */\n    b: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * CSS property value representing [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors)\n * in `hsl()` or `hsla()` functional notation.\n *\n * @category CSS Value\n */\nexport class StypHSL extends StypColorStruct<StypHSL, StypHSL.Coords> implements StypHSL.Coords {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'hsl' {\n    return 'hsl';\n  }\n\n  /**\n   * Hue angle value in degrees between `0` and `360`.\n   */\n  readonly h: number;\n\n  /**\n   * Saturation percentage.\n   */\n  readonly s: number;\n\n  /**\n   * Lightness percentage.\n   */\n  readonly l: number;\n\n  /**\n   * Alpha value between `0` and `1`.\n   */\n  readonly a: number;\n\n  /**\n   * Constructs HSL color value.\n   *\n   * @param coords - Color coordinates.\n   * @param opts - Construction options.\n   */\n  constructor(coords: StypHSL.Coords, opts?: StypValue.Opts) {\n    super(opts);\n    this.h = angleCoord(coords.h);\n    this.s = coord(coords.s, 100);\n    this.l = coord(coords.l, 100);\n    this.a = coords.a != null ? coord(coords.a, 1) : 1;\n  }\n\n  /**\n   * This color in RGB coordinates.\n   */\n  get rgb(): StypRGB {\n\n    const { a } = this;\n    const s = this.s / 100;\n    const l = this.l / 100;\n\n    if (!s) {\n\n      const c = l * 255;\n\n      return new StypRGB({ r: c, g: c, b: c, a }, this);\n    }\n\n    const q = l < 0.5 ? l * (1 + s) : (l + s) - (l * s);\n    const p = (2 * l) - q;\n    const hueAsFraction = this.h / 360;\n\n    return new StypRGB(\n        {\n          r: hueToRgb(p, q, hueAsFraction + (1.0 / 3.0)),\n          g: hueToRgb(p, q, hueAsFraction),\n          b: hueToRgb(p, q, hueAsFraction - (1.0 / 3.0)),\n          a,\n        },\n        this,\n    );\n  }\n\n  /**\n   * This color in HSL coordinates.\n   *\n   * Always the same as `this`.\n   */\n  get hsl(): this {\n    return this;\n  }\n\n  by(source: StypValue): StypColor {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return StypColor.by(source) || this;\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === this.type\n        && other.h === this.h\n        && other.s === this.s\n        && other.l === this.l\n        && other.a === this.a\n        && other.priority === this.priority;\n  }\n\n  prioritize(priority: number): StypHSL {\n    return this.priority === priority ? this : new StypHSL(this, { priority });\n  }\n\n  set(coords: Partial<StypHSL.Coords> | ((this: void, color: this) => Partial<StypHSL.Coords>)): StypHSL {\n    if (typeof coords === 'function') {\n      coords = coords(this);\n    }\n\n    const { h = this.h, s = this.s, l = this.l, a = this.a } = coords;\n\n    return new StypHSL({ h, s, l, a }, this);\n  }\n\n  toString(): string {\n\n    const hsl = `${this.h}, ${this.s}%, ${this.l}%`;\n\n    return this.a === 1 ? `hsl(${hsl})` : `hsla(${hsl}, ${this.a})`;\n  }\n\n}\n\n/**\n * @category CSS Value\n */\nexport namespace StypHSL {\n\n  /**\n   * [HSL color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#HSL_colors) coordinates.\n   */\n  export interface Coords {\n\n    /**\n     * Hue angle value in degrees.\n     */\n    h: number;\n\n    /**\n     * Saturation percentage.\n     */\n    s: number;\n\n    /**\n     * Lightness percentage.\n     */\n    l: number;\n\n    /**\n     * Alpha value between `0` and `1`. `1` (full opacity) by default.\n     */\n    a?: number;\n  }\n\n}\n\n/**\n * @category CSS Value\n */\nexport const StypColor = {\n\n  /**\n   * Maps the given CSS property value to color. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a {@link StypColor} object as {@link StypMapper.Mapping CSS property mapping}.\n   *\n   * @param source - A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  by(source: StypValue): StypColor | undefined {\n    if (typeof source === 'object' && (source.type === 'rgb' || source.type === 'hsl')) {\n      return source;\n    }\n    return;\n  },\n\n};\n\n/**\n * @internal\n */\nfunction angleCoord(value: number): number {\n  value = value % 360;\n  return value < 0 ? 360 + value : value;\n}\n\n/**\n * @internal\n */\nfunction intCoord(value: number, max: number): number {\n  return coord(Math.round(value), max);\n}\n\n/**\n * @internal\n */\nfunction coord(value: number, max: number): number {\n  return Math.max(Math.min(value, max), 0);\n}\n\n/**\n * @internal\n */\nfunction hueToRgb(p: number, q: number, t: number): number {\n\n  let newT = t;\n\n  if (newT < 0) {\n    newT += 1;\n  } else if (newT > 1) {\n    newT -= 1;\n  }\n\n  let result;\n\n  if (newT < 1.0 / 6.0) {\n    result = p + ((q - p) * (6 * newT));\n  } else if (newT < 1.0 / 2.0) {\n    result = q;\n  } else if (newT < 2.0 / 3.0) {\n    result = p + (((q - p) * ((2.0 / 3.0) - newT)) * 6);\n  } else {\n    result = p;\n  }\n\n  return result * 255;\n}\n","import { StypColor, StypRGB } from './color';\n\n/**\n * Mixes two colors.\n *\n * Both the `weight` and the relative opacity of each color determines how much of each color is in the result.\n *\n * @category CSS Value\n * @param color1 - First color to mix\n * @param color2 - Second color to mix.\n * @param weight - A number between `0` and `1`. A larger weight indicates that more of `color1` should be used, and a\n * smaller weight indicates that more of `color2` should be used.\n *\n * @returns Mixed color.\n */\nexport function mixStypColors(color1: StypColor, color2: StypColor, weight: number): StypColor {\n\n  const w = weight * 2 - 1;\n  const rgba1 = color1.rgb;\n  const rgba2 = color2.rgb;\n  const aDiff = rgba1.a - rgba2.a;\n  const w1 = (((w * aDiff === -1) ? w : (w + aDiff) / (1 + w * aDiff)) + 1) / 2.0;\n  const w2 = 1 - w1;\n  return new StypRGB(\n      {\n        r: rgba1.r * w1 + rgba2.r * w2,\n        g: rgba1.g * w1 + rgba2.g * w2,\n        b: rgba1.b * w1 + rgba2.b * w2,\n        a: rgba1.a * weight + rgba2.a * (1 - weight),\n      },\n      color1,\n  );\n}\n","import { StypValue, StypValueStruct } from '../value';\nimport { StypZero } from './zero';\n\n/**\n * Structured numeric CSS property value.\n *\n * This represents either dimension, zero value, or a `calc()` CSS function call.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed unit type.\n * @typeParam TZero - A type of zero value. {@link StypZero} by default.\n */\nexport type StypNumeric<TUnit extends string, TZero extends StypZero<TUnit> | StypDimension<TUnit> = StypZero<TUnit>> =\n    | StypDimension<TUnit>\n    | StypCalc<TUnit>\n    | TZero;\n\n/**\n * Base implementation of structured numeric CSS property value.\n *\n * @category CSS Value\n * @typeParam TSelf - A type of itself.\n * @typeParam TUnit - Allowed unit type.\n */\nexport abstract class StypNumericStruct<TSelf extends StypNumericStruct<TSelf, TUnit>, TUnit extends string>\n    extends StypValueStruct<TSelf> {\n\n  /**\n   * A type of structured numeric CSS property value.\n   */\n  abstract type: 'dimension' | 'calc' | 0;\n\n  readonly dim: StypDimension.Kind<TUnit>;\n\n  constructor(opts: StypDimension.Opts<TUnit>) {\n    super(opts);\n    this.dim = opts.dim;\n  }\n\n  /**\n   * Tries to converts this numeric value to another dimension.\n   *\n   * Does not actually construct a value in another dimension, as long as dimension unit supported by both dimensions.\n   *\n   * @typeParam TDimUnit - A unit type allowed in target dimension.\n   * @param dim - Target dimension.\n   *\n   * @returns Either a value in dimension compatible with `dim`, or `undefined` if this value's unit is not supported\n   * by `dim`.\n   */\n  abstract toDim<TDimUnit extends string>(dim: StypDimension.Kind<TDimUnit>): StypNumeric<TDimUnit> | undefined;\n\n  abstract add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  abstract add(addendum: number, unit: TUnit): StypNumeric<TUnit>;\n\n  abstract sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  abstract sub(subtrahend: number, unit: TUnit): StypNumeric<TUnit>;\n\n  abstract mul(multiplier: number): StypNumeric<TUnit>;\n\n  abstract div(divisor: number): StypNumeric<TUnit>;\n\n  abstract negate(): StypNumeric<TUnit>;\n\n  by(source: StypValue): StypNumeric<TUnit> {\n    return this.dim.by(source) || this as StypNumeric<TUnit>;\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns CSS value text without `!important` or `calc()`.\n   */\n  abstract toFormula(): string;\n\n  toString(): string {\n    return this.toFormula();\n  }\n\n}\n\n/**\n * Structured [dimension](https://developer.mozilla.org/en-US/docs/Web/CSS/dimension) value with unit.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed units type.\n */\nexport interface StypDimension<TUnit extends string>\n    extends StypValueStruct<StypDimension<TUnit>>, StypNumericStruct<StypDimension<TUnit>, TUnit> {\n\n  readonly type: 'dimension';\n\n  readonly dim: StypDimension.Kind<TUnit>;\n\n  /**\n   * Dimension value.\n   */\n  readonly val: number;\n\n  /**\n   * Dimension unit.\n   */\n  readonly unit: TUnit;\n\n  add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  add(addendum: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  sub(subtrahend: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  by(source: StypValue): StypNumeric<TUnit>;\n\n}\n\n/**\n * @category CSS Value\n */\nexport namespace StypDimension {\n\n  /**\n   * A kind of dimensions. E.g. angle, length, percentage, etc.\n   *\n   * It is perfectly fine to use dimensions interchangeably as long as dimension units are compatible.\n   *\n   * @typeParam TUnit - Allowed units type.\n   */\n  export interface Kind<TUnit extends string> {\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports and, in addition, supporting percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if supports percents.\n     */\n    readonly pt?: Kind<TUnit | '%'>;\n\n    /**\n     * A similar kind of dimensions supporting all units this one supports, except percents (`%`).\n     *\n     * `undefined` if there is no such dimension kind. Refers itself if does not support percents.\n     */\n    readonly noPt: Kind<Exclude<TUnit, '%'>>;\n\n    /**\n     * Zero value of this kind.\n     *\n     * Typically, this is unit-less {@link StypZero}. But some dimensions require units.\n     */\n    readonly zero: StypDimension<TUnit> | StypZero<TUnit>;\n\n    /**\n     * Constructs dimension value.\n     *\n     * @param val - Numeric dimension value.\n     * @param unit - Dimension unit.\n     *\n     * @returns Constructed dimension value. Either {@link StypDimension} instance, or {@link StypZero} if `val` is `0`\n     * and this dimension kind supports unitless zero.\n     */\n    of(val: number, unit: TUnit): StypDimension<TUnit> | StypZero<TUnit>;\n\n    /**\n     * Maps the given CSS property value to the one compatible with this dimension kind. Defaults to `undefined`\n     * if mapping is not possible.\n     *\n     * This method allows to use a dimension kind as {@link StypMapper.Mapping CSS property mapping}.\n     *\n     * Any scalar or non-numeric value is mapped to `undefined`. A numeric value is converted to this dimension by\n     * {@link StypNumericStruct.toDim} method.\n     *\n     * @param source - A raw property value that should be converted.\n     *\n     * @returns Mapped property value or `undefined`.\n     */\n    by(source: StypValue): StypNumeric<TUnit, StypDimension<TUnit> | StypZero<TUnit>> | undefined;\n\n  }\n\n  export namespace Kind {\n\n    /**\n     * A kind of dimension with unit-less zero. E.g. angle or length.\n     *\n     * @typeParam TUnit - Allowed units type.\n     */\n    export interface UnitlessZero<TUnit extends string> extends Kind<TUnit> {\n\n      readonly pt?: UnitlessZero<TUnit | '%'>;\n\n      readonly noPt: UnitlessZero<Exclude<TUnit, '%'>>;\n\n      /**\n       * Zero value of this kind without unit.\n       */\n      readonly zero: StypZero<TUnit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val - Numeric dimension value.\n       * @param unit - Dimension unit.\n       *\n       * @returns Constructed dimension value. Either {@link StypDimension} instance, or {@link StypZero} if `val` is\n       * `0`.\n       */\n      of(val: number, unit: TUnit): StypDimension<TUnit> | StypZero<TUnit>;\n\n      by(source: StypValue): StypNumeric<TUnit> | undefined;\n\n    }\n\n    /**\n     * A kind of dimension which zero value has unit. E.g. frequency or resolution.\n     *\n     * @typeParam TUnit - Allowed units type.\n     */\n    export interface UnitZero<TUnit extends string> extends Kind<TUnit> {\n\n      readonly pt?: UnitZero<TUnit | '%'>;\n\n      readonly noPt: UnitZero<Exclude<TUnit, '%'>>;\n\n      /**\n       * Zero value of this kind that has unit.\n       */\n      readonly zero: StypDimension<TUnit>;\n\n      /**\n       * Constructs dimension value.\n       *\n       * @param val - Numeric dimension value.\n       * @param unit - Dimension unit.\n       *\n       * @returns Constructed dimension value as a {@link StypDimension} instance.\n       */\n      of(val: number, unit: TUnit): StypDimension<TUnit>;\n\n      by(source: StypValue): StypNumeric<TUnit, StypDimension<TUnit>> | undefined;\n\n    }\n\n  }\n\n  /**\n   * Construction options of dimensions.\n   *\n   * @typeParam TUnit - Allowed units type.\n   */\n  export interface Opts<TUnit extends string> extends StypValue.Opts {\n\n    /**\n     * A kind of dimension.\n     */\n    dim: Kind<TUnit>;\n\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation.\n *\n * This is either a {@link StypAddSub addition/subtraction}, or {@link StypMulDiv multiplication/division}.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed unit type.\n */\nexport type StypCalc<TUnit extends string> = StypAddSub<TUnit> | StypMulDiv<TUnit>;\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed unit type.\n */\nexport interface StypAddSub<TUnit extends string> extends StypNumericStruct<StypAddSub<TUnit>, TUnit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<TUnit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '+' | '-';\n\n  /**\n   * Right operand.\n   */\n  readonly right: StypNumeric<TUnit>;\n\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @category CSS Value\n * @typeParam TUnit - Allowed unit type.\n */\nexport interface StypMulDiv<TUnit extends string> extends StypNumericStruct<StypMulDiv<TUnit>, TUnit> {\n\n  readonly type: 'calc';\n\n  /**\n   * Left operand.\n   */\n  readonly left: StypNumeric<TUnit>;\n\n  /**\n   * Operator.\n   */\n  readonly op: '*' | '/';\n\n  /**\n   * Right operand.\n   */\n  readonly right: number;\n\n}\n","import { itsEach, overKeys } from '@proc7ts/push-iterator';\nimport { StypProperties } from '../rule';\nimport { StypValue } from './value';\n\n/**\n * A type of function that maps CSS properties to something else.\n *\n * @category CSS Value\n * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n */\nexport type StypMapper<TResult> =\n/**\n * @param from - CSS properties to map.\n *\n * @returns Mapping result.\n */\n    (this: void, from: StypProperties) => TResult;\n\n/**\n * @category CSS Value\n */\nexport namespace StypMapper {\n\n  /**\n   * CSS property mapping.\n   *\n   * It is used to recognize raw property value and convert it to the one of the given type.\n   *\n   * It is one of:\n   * - Default property value. Replaces the source property value, unless the the have the same type.\n   * - A mapping function. Replaces the source property value with the result of this function call.\n   * - An object containing mapping method called `by()`. Replaces the source property value with the result of this\n   *   method call.\n   *\n   * @typeParam TResult - A type of mapped properties. This is an object containing mapped properties.\n   * @typeParam TResultKey - Type of mapped properties keys.\n   */\n  export type Mapping<TResult, TResultKey extends keyof TResult> =\n      | MappingFunction<TResult, TResultKey>\n      | MappingObject<TResult, TResultKey>\n      | TResult[TResultKey];\n\n  /**\n   * CSS property mapping function.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   * @typeParam TResultKey - Type of mapped properties keys.\n   */\n  export type MappingFunction<TResult, TResultKey extends keyof TResult> =\n  /**\n   * @param source - A raw property value that should be converted.\n   * @param mapped - An object granting access to other mapped properties.\n   * @param key - A key of converted property.\n   *\n   * @returns Mapped property value.\n   */\n      (this: void, source: StypValue, mapped: Mapped<TResult>, key: TResultKey) => TResult[TResultKey];\n\n  /**\n   * CSS property mapping object.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   * @typeParam TResultKey - Type of mapped properties keys.\n   */\n  export interface MappingObject<TResult, TResutKey extends keyof TResult> {\n\n    /**\n     * Maps CSS property value.\n     *\n     * @param source - A raw property value that should be converted.\n     * @param mapped - An object granting access to other mapped properties.\n     * @param key - A key of converted property.\n     *\n     * @returns Mapped property value.\n     */\n    by(source: StypValue, mapped: Mapped<TResult>, key: TResutKey): TResult[TResutKey];\n\n  }\n\n  /**\n   * Grants access to mapped values.\n   *\n   * Passed as a second argument to mapping function.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   */\n  export interface Mapped<TResultKey> {\n\n    /**\n     * Original properties to convert.\n     */\n    from: StypProperties;\n\n    /**\n     * Maps the property with the given type accordingly to mapping instruction.\n     *\n     * The mapping is performed at most once per property.\n     *\n     * @param key - Mapped property key.\n     *\n     * @returns Mapped property value.\n     */\n    get<TKey extends keyof TResultKey>(key: TKey): TResultKey[TKey];\n\n  }\n\n  /**\n   * Mappings of CSS properties.\n   *\n   * Contains mappings for each mapped CSS property with that property name as a key.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   */\n  export type Mappings<TResult> = { readonly [key in keyof TResult]: Mapping<TResult, key>; };\n\n}\n\n/**\n * @category CSS Value\n */\nexport const StypMapper = {\n\n  /**\n   * Maps CSS properties accordingly to the given `mappings`.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   * @param mappings - Mappings of CSS properties.\n   * @param from - Raw CSS properties to map.\n   *\n   * @returns Mapped properties.\n   */\n  map<TResult>(mappings: StypMapper.Mappings<TResult>, from: StypProperties): TResult {\n\n    const result = {} as { [key in keyof TResult]: TResult[key] };\n    const mapped = {\n      from,\n      get<TKey extends keyof TResult>(key: TKey): TResult[TKey] {\n        if (key in result) {\n          return result[key];\n        }\n\n        const mapper = mappingBy<TResult, TKey>(mappings[key]);\n        const mappedValue = mapper(from[key as string], this, key);\n\n        result[key] = mappedValue;\n\n        return mappedValue;\n      },\n    };\n\n    itsEach(overKeys(mappings), key => mapped.get(key));\n\n    return result;\n  },\n\n  /**\n   * Creates CSS properties mapper function.\n   *\n   * @typeParam TResult - A type of mapped properties. This is a mapping result type.\n   * @param mappings - Mappings of CSS properties.\n   *\n   * @returns A function that maps CSS properties accordingly to the given `mappings`.\n   */\n  by<TResult>(mappings: StypMapper.Mappings<TResult>): StypMapper<TResult> {\n    return StypMapper.map.bind<void, StypMapper.Mappings<TResult>, [StypProperties], TResult>(undefined, mappings);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction mappingBy<TResult, TResultKey extends keyof TResult>(\n    mapping: StypMapper.Mapping<TResult, TResultKey> | undefined,\n): StypMapper.MappingFunction<TResult, TResultKey> {\n  switch (typeof mapping) {\n  case 'function':\n    return mapping as StypMapper.MappingFunction<TResult, TResultKey>;\n  case 'object':\n    return (mapping as StypMapper.MappingObject<TResult, TResultKey>).by.bind(mapping);\n  default:\n  }\n\n  const type = typeof mapping;\n\n  return (from: StypValue): TResult[TResultKey] => typeof from === type\n      ? from as unknown as TResult[TResultKey]\n      : mapping as TResult[TResultKey];\n}\n","import { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue } from './value';\n\n/**\n * Predefined CSS property value priorities.\n *\n * @category CSS Value\n */\nexport const enum StypPriority {\n\n  /**\n   * Usual, non-important priority.\n   *\n   * This priority is assigned to values by {@link StypValueStruct.usual} method.\n   */\n  Usual = 0,\n\n  /**\n   * Default priority.\n   *\n   * The same as `Usual`. This priority is assigned to values by default.\n   */\n  Default = Usual,\n\n  /**\n   * Important priority.\n   *\n   * This priority corresponds to values with `!important` suffix. It is applied to string values with `!important`\n   * suffix, and can be assigned to structured values using {@link StypValueStruct.important} method.\n   *\n   * All numeric priorities with higher values are rendered as `!important` ones.\n   */\n  Important = 1,\n\n}\n\n/**\n * Splits undefined CSS property value onto non-prioritized value and priority.\n *\n * @category CSS Value\n * @param value - Undefined CSS property value to split.\n *\n * @returns An `[undefined, 0]` tuple.\n */\nexport function stypSplitPriority<T extends StypValue>(value: undefined): [undefined, 0];\n\n/**\n * Splits string CSS property value onto non-prioritized value and priority.\n *\n * @param value - CSS property value to split.\n *\n * @returns A tuple containing the value without `!priority` suffix, and numeric priority (0 or 1).\n */\nexport function stypSplitPriority(value: string): [string, 0 | 1];\n\n/**\n * Splits scalar CSS property value onto non-prioritized value and priority.\n *\n * @param value - CSS property value to split.\n *\n * @returns A tuple containing the value and `0` priority.\n */\nexport function stypSplitPriority<T extends number | boolean>(value: T): [T, 0];\n\n/**\n * Splits arbitrary CSS property value onto value non-prioritized value and priority.\n *\n * @param value - CSS property value to split.\n *\n * @returns A tuple containing the value and numeric priority.\n */\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number];\n\nexport function stypSplitPriority<T extends StypValue>(value: T): [T, number] {\n  if (value == null) {\n    return [undefined as T, StypPriority.Default];\n  }\n\n  switch (typeof value) {\n  case 'object':\n    return [value, value.priority];\n  case 'string':\n    if (value.endsWith(IMPORTANT_CSS_SUFFIX)) {\n      return [\n        value.substring(0, value.length - IMPORTANT_CSS_SUFFIX.length).trim() as T,\n        StypPriority.Important,\n      ];\n    }\n    break;\n  default:\n  }\n\n  return [value, StypPriority.Default];\n}\n","/**\n * @internal\n */\nexport const IMPORTANT_CSS_SUFFIX = '!important';\n","import { StypPriority } from '../priority';\nimport { StypValue, stypValuesEqual } from '../value';\nimport {\n  StypAddSub as StypAddSub_,\n  StypDimension as StypDimension_,\n  StypMulDiv as StypMulDiv_,\n  StypNumeric,\n  StypNumericStruct,\n} from './numeric';\nimport { StypZero } from './zero';\n\n/**\n * @internal\n */\nexport class StypDimension<TUnit extends string>\n    extends StypNumericStruct<StypDimension<TUnit>, TUnit>\n    implements StypDimension_<TUnit> {\n\n  get type(): 'dimension' {\n    return 'dimension';\n  }\n\n  /**\n   * The number value.\n   */\n  readonly val: number;\n\n  /**\n   * The unit.\n   */\n  readonly unit: TUnit;\n\n  /**\n   * Constructs new structured dimension value.\n   *\n   * @param val - The numeric value.\n   * @param unit - The unit.\n   * @param opts - CSS value options.\n   */\n  constructor(val: number, unit: TUnit, opts: StypDimension_.Opts<TUnit>) {\n    super(opts);\n    this.val = val;\n    this.unit = unit;\n  }\n\n  toDim<TDimUnit extends string>(dim: StypDimension_.Kind<TDimUnit>): StypDimension_<TDimUnit> | undefined {\n\n    const thisDim: StypDimension_.Kind<any> = this.dim;\n\n    if (dim === thisDim /* same dimension */\n        || dim === thisDim.pt /* !% to compatible +% */\n        || dim === (this.unit === '%' ? dim.pt /* % to any +% */ : thisDim.noPt /* !% to compatible -% */)) {\n      return this as StypDimension_<any>;\n    }\n\n    return;\n  }\n\n  is(other: StypValue): boolean {\n    if (other === this) {\n      return true;\n    }\n    return typeof other === 'object'\n        && other.type === this.type\n        && this.unit === other.unit\n        && this.val === other.val\n        && this.priority === other.priority;\n  }\n\n  prioritize(priority: number): StypDimension<TUnit> {\n    return this.priority === priority\n        ? this\n        : new StypDimension(this.val, this.unit, { dim: this.dim, priority });\n  }\n\n  add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  add(addendum: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  add(addendum: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit || this.unit, this);\n    }\n    if (addendum.type === 'dimension' && this.unit === addendum.unit) {\n      return stypDimension(this.val + addendum.val, this.unit, this);\n    }\n    return stypAddSub(this, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  sub(subtrahend: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  sub(subtrahend: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit || this.unit, this);\n    }\n    if (subtrahend.type === 'dimension' && this.unit === subtrahend.unit) {\n      return stypDimension(this.val - subtrahend.val, this.unit, this);\n    }\n    return stypAddSub(this, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<TUnit> {\n    return multiplier === 1 ? this : stypDimension(this.val * multiplier, this.unit, this);\n  }\n\n  div(divisor: number): StypNumeric<TUnit> {\n    return divisor === 1 ? this : stypDimension(this.val / divisor, this.unit, this);\n  }\n\n  negate(): StypNumeric<TUnit> {\n    return stypDimension(-this.val, this.unit, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `<value><unit>` or just `0`.\n   */\n  toFormula(): string {\n    return `${this.val}${this.unit}`;\n  }\n\n}\n\n/**\n * Constructs structured [dimension] CSS property value.\n *\n * @param val - Numeric value.\n * @param unit - Value unit.\n * @param opts - Construction options.\n *\n * @returns Either {@link StypDimension}, or {@link StypZero} if `val === 0`.\n *\n * [dimension]: https://developer.mozilla.org/en-US/docs/Web/CSS/dimension\n *\n * @internal\n */\nexport function stypDimension<TUnit extends string>(\n    val: number,\n    unit: TUnit,\n    opts: StypDimension_.Opts<TUnit>,\n): StypDimension_<TUnit> | StypZero<TUnit> {\n  return val\n      ? new StypDimension<TUnit>(val, unit, opts)\n      : opts.dim.zero.prioritize(opts.priority || StypPriority.Default);\n}\n\n/**\n * @internal\n */\nexport abstract class StypCalcBase<\n    TSelf extends StypCalcBase<TSelf, TOp, TRight, TUnit>,\n    TOp extends '+' | '-' | '*' | '/',\n    TRight extends number | StypNumeric<TUnit>,\n    TUnit extends string\n    > extends StypNumericStruct<TSelf, TUnit> {\n\n  // noinspection JSMethodCanBeStatic\n  get type(): 'calc' {\n    return 'calc';\n  }\n\n  readonly left: StypNumeric<TUnit>;\n  readonly op: TOp;\n  readonly right: TRight;\n\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(\n      left: StypNumeric<TUnit>,\n      op: TOp,\n      right: TRight,\n      opts: StypDimension_.Opts<TUnit>,\n  ) {\n    super(opts);\n    this.left = left.usual();\n    this.op = op;\n    this.right = right;\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object' && other.type === this.type) {\n      return this.op === other.op\n          && this.left.is(other.left)\n          && stypValuesEqual(this.right, other.right)\n          && this.priority === other.priority;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  add(addendum: number, unit: TUnit): StypNumeric<TUnit>;\n\n  add(addendum: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as TUnit, this);\n    }\n    return stypAddSub(this as StypNumeric<TUnit>, '+', addendum);\n  }\n\n  sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  sub(subtrahend: number, unit: TUnit): StypNumeric<TUnit>;\n\n  sub(subtrahend: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as TUnit, this);\n    }\n    return stypAddSub(this as StypNumeric<TUnit>, '-', subtrahend);\n  }\n\n  mul(multiplier: number): StypNumeric<TUnit> {\n    return stypMul(this as StypNumeric<TUnit>, multiplier);\n  }\n\n  div(divisor: number): StypNumeric<TUnit> {\n    return stypDiv(this as StypNumeric<TUnit>, divisor);\n  }\n\n  abstract negate(): StypNumeric<TUnit>;\n\n  abstract prioritize(priority: number): TSelf;\n\n  abstract toFormula(): string;\n\n  toString(): string {\n    return 'calc' + super.toString();\n  }\n\n}\n\n/**\n * CSS `calc()` function call representation containing either addition or subtraction.\n *\n * @typeParam TUnit - Allowed unit type.\n *\n * @internal\n */\nexport class StypAddSub<TUnit extends string>\n    extends StypCalcBase<StypAddSub<TUnit>, '+' | '-', StypNumeric<TUnit>, TUnit>\n    implements StypAddSub_<TUnit> {\n\n  constructor(left: StypNumeric<TUnit>, op: '+' | '-', right: StypNumeric<TUnit>, opts: StypDimension_.Opts<TUnit>) {\n    super(left, op, right.usual(), opts);\n  }\n\n  prioritize(priority: number): StypAddSub<TUnit> {\n    return this.priority === priority\n        ? this\n        : new StypAddSub(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<TDimUnit extends string>(dim: StypDimension_.Kind<TDimUnit>): StypAddSub<TDimUnit> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    const right = this.right.toDim(dim);\n\n    if (!right) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any> && right === this.right as StypNumeric<any>) {\n      return this as StypAddSub<any>;\n    }\n\n    return new StypAddSub<TDimUnit>(left, this.op, right, { dim, priority: this.priority });\n  }\n\n  negate(): StypNumeric<TUnit> {\n    return this.op === '-'\n        ? new StypAddSub(this.right, this.op, this.left, this)\n        : new StypAddSub(this.left.negate(), '-', this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right.toFormula()})`;\n  }\n\n}\n\nfunction stypAddSub<TUnit extends string>(\n    left: StypNumeric<TUnit>,\n    op: '+' | '-',\n    right: StypNumeric<TUnit>,\n): StypNumeric<TUnit> {\n  return !right.type ? left : new StypAddSub(left, op, right, left);\n}\n\n/**\n * CSS `calc()` function call representation containing either multiplication or division.\n *\n * @typeParam TUnit - Allowed unit type.\n *\n * @internal\n */\nexport class StypMulDiv<TUnit extends string>\n    extends StypCalcBase<StypMulDiv<TUnit>, '*' | '/', number, TUnit>\n    implements StypMulDiv_<TUnit> {\n\n  prioritize(priority: number): StypMulDiv<TUnit> {\n    return this.priority === priority\n        ? this\n        : new StypMulDiv(this.left, this.op, this.right, { dim: this.dim, priority });\n  }\n\n  toDim<TDimUnit extends string>(dim: StypDimension_.Kind<TDimUnit>): StypMulDiv<TDimUnit> | undefined {\n\n    const left = this.left.toDim(dim);\n\n    if (!left) {\n      return;\n    }\n\n    if (left === this.left as StypNumeric<any>) {\n      return this as StypMulDiv<any>;\n    }\n\n    return new StypMulDiv<TDimUnit>(left, this.op, this.right, { dim, priority: this.priority });\n  }\n\n  mul(multiplier: number): StypNumeric<TUnit> {\n    return (this.op === '*'\n        ? stypMul(this.left, this.right * multiplier)\n        : stypDiv(this.left, this.right / multiplier))\n        .prioritize(this.priority);\n  }\n\n  div(divisor: number): StypNumeric<TUnit> {\n    return (this.op === '/'\n        ? stypDiv(this.left, this.right * divisor)\n        : stypMul(this.left, this.right / divisor))\n        .prioritize(this.priority);\n  }\n\n  negate(): StypNumeric<TUnit> {\n    return new StypMulDiv(this.left, this.op, -this.right, this);\n  }\n\n  /**\n   * Returns a textual representation of this value to be used within CSS `calc()` function.\n   *\n   * @returns `(<left> <op> <right>)`.\n   */\n  toFormula(): string {\n    return `(${this.left.toFormula()} ${this.op} ${this.right})`;\n  }\n\n}\n\nfunction stypMul<TUnit extends string>(left: StypNumeric<TUnit>, right: number): StypNumeric<TUnit> {\n  return !right\n      ? left.dim.zero.prioritize(left.priority)\n      : right === 1\n          ? left.prioritize(left.priority)\n          : new StypMulDiv(left, '*', right, left);\n}\n\nfunction stypDiv<TUnit extends string>(left: StypNumeric<TUnit>, right: number): StypNumeric<TUnit> {\n  return right === 1\n      ? left.prioritize(left.priority)\n      : new StypMulDiv(left, '/', right, left);\n}\n\n/**\n * @internal\n */\nexport function isStypNumeric(source: StypValue): source is StypNumeric<any, any> {\n  return typeof source === 'object' && (source.type === 'dimension' || source.type === 'calc' || source.type === 0);\n}\n","import { StypPriority } from '../priority';\nimport { StypValue } from '../value';\nimport { StypDimension, StypNumeric, StypNumericStruct } from './index';\nimport { stypDimension } from './numeric.impl';\nimport { StypZero } from './zero';\n\nclass Zero<TUnit extends string> extends StypNumericStruct<Zero<TUnit>, TUnit> implements StypZero<TUnit> {\n\n  constructor(private readonly _byPriority: ZeroByPriority<TUnit>, opts: StypDimension.Opts<TUnit>) {\n    super(opts);\n  }\n\n  get type(): 0 {\n    return 0;\n  }\n\n  toDim<TDimUnit extends string>(dim: StypDimension.Kind<TDimUnit>): StypDimension<TDimUnit> | StypZero<TDimUnit> {\n    return dim.zero.prioritize(this.priority);\n  }\n\n  is(other: StypValue): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (typeof other === 'object') {\n      return other.type === this.type && other.priority === this.priority;\n    }\n    if (other === 0 || other === '0') {\n      return this.priority === StypPriority.Usual;\n    }\n    if (other === '0 !important') {\n      return this.priority === StypPriority.Important;\n    }\n    return false;\n  }\n\n  add(addendum: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  add(addendum: number, unit?: TUnit): StypNumeric<TUnit>;\n\n  add(addendum: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof addendum === 'number') {\n      addendum = stypDimension(addendum, unit as TUnit, this);\n    }\n    return addendum.prioritize(this.priority);\n  }\n\n  sub(subtrahend: StypNumeric<TUnit>): StypNumeric<TUnit>;\n\n  sub(subtrahend: number, unit: TUnit): StypNumeric<TUnit>;\n\n  sub(subtrahend: StypNumeric<TUnit> | number, unit?: TUnit): StypNumeric<TUnit> {\n    if (typeof subtrahend === 'number') {\n      subtrahend = stypDimension(subtrahend, unit as TUnit, this);\n    }\n    return subtrahend.negate().prioritize(this.priority);\n  }\n\n  mul(): this {\n    return this;\n  }\n\n  div(): this {\n    return this;\n  }\n\n  negate(): this {\n    return this;\n  }\n\n  prioritize(priority: number): Zero<TUnit> {\n    return this._byPriority.get(priority);\n  }\n\n  important(): Zero<TUnit> {\n    return this._byPriority.important;\n  }\n\n  usual(): Zero<TUnit> {\n    return this._byPriority.usual;\n  }\n\n  toFormula(): string {\n    return '0';\n  }\n\n}\n\nclass ZeroByPriority<TUnit extends string> {\n\n  readonly usual: Zero<TUnit>;\n  readonly important: Zero<TUnit>;\n\n  constructor(readonly dim: StypDimension.Kind<TUnit>) {\n    this.usual = new Zero(this, { dim });\n    this.important = new Zero(this, { dim, priority: StypPriority.Important });\n  }\n\n  get(priority: number): Zero<TUnit> {\n    switch (priority) {\n    case StypPriority.Usual: return this.usual;\n    case StypPriority.Important: return this.important;\n    }\n    return new Zero(this, { dim: this.dim, priority });\n  }\n\n}\n\n/**\n * @internal\n */\nexport function newStypZero<TUnit extends string>(dim: StypDimension.Kind.UnitlessZero<TUnit>): StypZero<TUnit> {\n  return new ZeroByPriority<TUnit>(dim).usual;\n}\n","import { StypValue } from '../value';\nimport { StypDimension, StypNumeric } from './numeric';\nimport { isStypNumeric, StypDimension as StypDimension_ } from './numeric.impl';\nimport { StypZero } from './zero';\nimport { newStypZero } from './zero.impl';\n\n/**\n * @internal\n */\nexport function unitlessZeroDimensionKind<TUnit extends string>(\n    {\n      pt,\n      noPt,\n    }: {\n      pt: () => StypDimension.Kind.UnitlessZero<TUnit | '%'>;\n      noPt: () => StypDimension.Kind.UnitlessZero<Exclude<TUnit, '%'>>;\n    },\n): StypDimension.Kind.UnitlessZero<TUnit> {\n\n  const dimension: StypDimension.Kind.UnitlessZero<TUnit> = {\n\n    get zero(): StypZero<TUnit> {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return zero;\n    },\n\n    get pt() {\n      return pt();\n    },\n\n    get noPt() {\n      return noPt();\n    },\n\n    of(val: number, unit: TUnit): StypDimension<TUnit> | StypZero<TUnit> {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return val ? new StypDimension_(val, unit, { dim: this }) : zero;\n    },\n\n    by(source: StypValue): StypNumeric<TUnit> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n      return (source as StypNumeric<TUnit>).toDim(this);\n    },\n\n  };\n\n  const zero = newStypZero<TUnit>(dimension);\n\n  return dimension;\n}\n\n/**\n * @internal\n */\nexport function unitZeroDimensionKind<TUnit extends string>(\n    {\n      zeroUnit,\n      withPercent,\n      noPercent,\n    }: {\n      zeroUnit: TUnit;\n      withPercent?: () => StypDimension.Kind.UnitZero<TUnit | '%'>;\n      noPercent?: () => StypDimension.Kind.UnitZero<Exclude<TUnit, '%'>>;\n    },\n): StypDimension.Kind.UnitZero<TUnit> {\n\n  const dim: StypDimension.Kind.UnitZero<TUnit> = {\n\n    get pt() {\n      return withPercent && withPercent();\n    },\n\n    get noPt() {\n      return noPercent ? noPercent() : this as StypDimension.Kind.UnitZero<Exclude<TUnit, '%'>>;\n    },\n\n    get zero(): StypDimension<TUnit> {\n      return zero;// eslint-disable-line @typescript-eslint/no-use-before-define\n    },\n\n    of(val: number, unit: TUnit): StypDimension<TUnit> {\n      return new StypDimension_(val, unit, { dim: this });\n    },\n\n    by(source: StypValue): StypNumeric<TUnit, StypDimension<TUnit>> | undefined {\n      if (!isStypNumeric(source)) {\n        return;\n      }\n      return (source as StypNumeric<TUnit>).toDim(this) as StypNumeric<TUnit, StypDimension<TUnit>>;\n    },\n\n  };\n\n  const zero = new StypDimension_(0, zeroUnit, { dim });\n\n  return dim;\n}\n","import { StypDimension, StypNumeric } from '../numeric';\nimport { unitlessZeroDimensionKind } from '../numeric/dimension-kind.impl';\n\n/**\n * Structured [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) property value.\n *\n * Can be constructed using `StypLength.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLength = StypNumeric<StypLength.Unit>;\n\n/**\n * @category CSS Value\n */\nexport namespace StypLength {\n\n  /**\n   * Supported length units, excluding percent.\n   */\n  export type Unit = 'cap' | 'ch' | 'em' | 'ex' | 'ic' | 'lh' | 'rem' | 'rlh'\n      | 'vh' | 'vw' | 'vi' | 'vb' | 'vmin' | 'vmax'\n      | 'px' | 'cm' | 'mm' | 'Q' | 'in' | 'pc' | 'pt';\n\n}\n\n/**\n * @category CSS Value\n */\nexport const StypLength: StypDimension.Kind.UnitlessZero<StypLength.Unit> = (/*#__PURE__*/ unitlessZeroDimensionKind({\n  pt() {\n    return StypLengthPt;// eslint-disable-line @typescript-eslint/no-use-before-define\n  },\n  noPt() {\n    return StypLength;\n  },\n}));\n\n/**\n * Structured [length-percentage](https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage) CSS property\n * value.\n *\n * Can be constructed using `StypLengthPt.of()` function.\n *\n * @category CSS Value\n */\nexport type StypLengthPt = StypNumeric<StypLengthPt.Unit>;\n\n/**\n * @category CSS Value\n */\nexport namespace StypLengthPt {\n\n  /**\n   * Supported length units, including percent.\n   */\n  export type Unit = StypLength.Unit | '%';\n\n}\n\n/**\n * @category CSS Value\n */\nexport const StypLengthPt: StypDimension.Kind.UnitlessZero<StypLengthPt.Unit> = (\n    /*#__PURE__*/ unitlessZeroDimensionKind({\n      pt() {\n        return StypLengthPt;\n      },\n      noPt() {\n        return StypLength;\n      },\n    })\n);\n","import { escapeCSSVal } from '@frontmeans/httongue';\nimport { stypSplitPriority } from './priority';\nimport { StypValue, StypValueStruct } from './value';\n\n/**\n * Structured [URL](https://developer.mozilla.org/en-US/docs/Web/CSS/url) CSS property value.\n *\n * @category CSS Value\n */\nexport class StypURL extends StypValueStruct<StypURL> {\n\n  /**\n   * Target URL.\n   */\n  readonly url: string;\n\n  /**\n   * `url` value type.\n   */\n  get type(): 'url' {\n    return 'url';\n  }\n\n  /**\n   * Maps the given CSS property value to URL. Defaults to `undefined` if mapping is not possible.\n   *\n   * This method allows to use a {@link StypURL} class as [CSS property mapping]{@link StypMapper.Mapping}.\n   *\n   * Strings are treated as URLs (without `url()` functional syntax). `!important` suffix is respected.\n   *\n   * @param source - A raw property value that should be converted.\n   *\n   * @returns Mapped property value or `undefined`.\n   */\n  static by(source: StypValue): StypURL | undefined {\n    switch (typeof source) {\n    case 'string': {\n\n      const [url, priority] = stypSplitPriority(source);\n\n      return new StypURL(url, { priority });\n    }\n    case 'object':\n      if (source.type === 'url') {\n        return source;\n      }\n      break;\n    default:\n    }\n    return;\n  }\n\n  /**\n   * Constructs URL value.\n   *\n   * @param url - Target URL.\n   * @param opts - Construction options.\n   */\n  constructor(url: string, opts?: StypValue.Opts) {\n    super(opts);\n    this.url = url;\n  }\n\n  by(source: StypValue): StypURL {\n    return StypURL.by(source) || this;\n  }\n\n  prioritize(priority: number): StypURL {\n    return priority === this.priority ? this : new StypURL(this.url, { priority });\n  }\n\n  is(other: StypValue): boolean {\n    return typeof other === 'object'\n        && other.type === 'url'\n        && other.url === this.url\n        && other.priority === this.priority;\n  }\n\n  toString(): string {\n    return `url(\"${escapeCSSVal(this.url)}\")`;\n  }\n\n}\n","import {\n  afterAll,\n  AfterEvent,\n  afterSupplied,\n  afterThe,\n  deduplicateAfter,\n  EventKeeper,\n  EventSender,\n  isEventKeeper,\n  isEventSender,\n  mapAfter,\n  mapAfter_,\n} from '@proc7ts/fun-events';\nimport { isPresent, valuesProvider } from '@proc7ts/primitives';\nimport { filterIt, itsIterator, itsReduction, overEntries } from '@proc7ts/push-iterator';\nimport { IMPORTANT_CSS_SUFFIX } from '../internal';\nimport { StypValue, stypValuesEqual } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * @internal\n */\nexport const noStypProperties: AfterEvent<[StypProperties]> = (/*#__PURE__*/ afterThe({}));\n\n/**\n * @internal\n */\nexport function noStypPropertiesSpec(): AfterEvent<[StypProperties]> {\n  return noStypProperties;\n}\n\n/**\n * @internal\n */\nexport function stypPropertiesBySpec(rule: StypRule, spec?: StypProperties.Spec): AfterEvent<[StypProperties]> {\n  if (!spec) {\n    return noStypProperties;\n  }\n  if (typeof spec !== 'string') {\n    if (isEventKeeper(spec)) {\n      return preventDuplicates(spec);\n    }\n    if (isEventSender(spec)) {\n      return preventDuplicates(propertiesKeeper(spec));\n    }\n    if (typeof spec === 'function') {\n\n      const senderOrProperties = spec(rule);\n\n      if (typeof senderOrProperties !== 'string') {\n        if (isEventKeeper(senderOrProperties)) {\n          return preventDuplicates(senderOrProperties);\n        }\n        if (isEventSender(senderOrProperties)) {\n          return preventDuplicates(propertiesKeeper(senderOrProperties));\n        }\n      }\n\n      return afterThe(propertiesMap(senderOrProperties));\n    }\n  }\n\n  return afterThe(propertiesMap(spec));\n}\n\nfunction propertiesKeeper(sender: EventSender<[string | StypProperties]>): AfterEvent<[string | StypProperties]> {\n  return afterSupplied(sender, valuesProvider({}));\n}\n\nfunction preventDuplicates(properties: EventKeeper<[string | StypProperties]>): AfterEvent<[StypProperties]> {\n  return afterSupplied(properties).do(\n      mapAfter_(propertiesMap),\n      deduplicateAfter(isDuplicateProperties, cloneProperties),\n  );\n}\n\nfunction propertiesMap(properties: string | StypProperties): StypProperties {\n  return typeof properties === 'string' ? { $$css: properties } : properties;\n}\n\nfunction isDuplicateProperties(first: StypProperties, second: StypProperties): boolean {\n\n  const s = itsIterator(propertyEntries(second));\n\n  for (const [key, value] of propertyEntries(first)) {\n\n    const { value: sentry } = s.next() as IteratorResult<[keyof StypProperties, StypValue], undefined>;\n\n    if (!sentry || key !== sentry[0] || !stypValuesEqual(value, sentry[1])) {\n      return false;\n    }\n  }\n\n  return !s.next().value;\n}\n\nfunction cloneProperties([properties]: [StypProperties]): StypProperties {\n  return { ...properties };\n}\n\nfunction propertyEntries(properties: StypProperties): Iterable<readonly [keyof StypProperties, StypValue]> {\n  return filterIt(\n      overEntries(properties),\n      ([, value]) => isPresent(value),\n  );\n}\n\n/**\n * @internal\n */\nexport function mergeStypProperties(\n    base: AfterEvent<[StypProperties]>,\n    addendum: AfterEvent<[StypProperties]>,\n): AfterEvent<[StypProperties]> {\n  return preventDuplicates(\n      afterAll({ base, addendum }).do(\n          mapAfter(\n              ({\n                base: [baseProperties],\n                addendum: [addendumProperties],\n              }) => addValues(baseProperties, addendumProperties),\n          ),\n      ),\n  );\n}\n\nfunction addValues(base: StypProperties, addendum: StypProperties): StypProperties {\n  return itsReduction(\n      overEntries(addendum),\n      (result, [k, v]) => addValue(result, k, v),\n      { ...base },\n  );\n}\n\nfunction addValue(\n    properties: StypProperties.Mutable,\n    key: keyof StypProperties,\n    value: StypValue,\n): StypProperties.Mutable {\n  if (priorityOf(properties[key]) <= priorityOf(value)) {\n    delete properties[key];\n    properties[key] = value;\n  }\n  return properties;\n}\n\nfunction priorityOf(value: StypValue): number {\n  switch (typeof value) {\n  case 'string':\n    return value.endsWith(IMPORTANT_CSS_SUFFIX) ? 1 : 0;\n  case 'object':\n    return value.priority;\n  default:\n    return 0;\n  }\n}\n","import { compareNames, isQualifiedName, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { flatMapIt } from '@proc7ts/push-iterator';\nimport { isNotEmptyArray, isReadonlyArray } from '../internal';\nimport { StypPureSelector } from './pure-selector';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSubSelector } from './sub-selector';\n\n/**\n * @internal\n */\nexport function isCombinator(\n    item: string | StypSelector.Part | StypSelector.Combinator,\n): item is StypSelector.Combinator {\n  return item === '>' || item === '+' || item === '~';\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * @internal\n */\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function normalizeStypSelector(selector: StypSelector): StypSelector.Normalized {\n  if (!isReadonlyArray(selector)) {\n    return [normalizeKey(selector)];\n  }\n\n  const normalized: StypSelector.Mutable = [];\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (const item of selector) {\n\n    const prevCombinator = combinator;\n\n    if (combinator) {\n      normalized.push(combinator);\n      combinator = undefined;\n    }\n\n    let part: StypSelector.NormalizedPart;\n\n    if (isCombinator(item)) {\n      combinator = item;\n      if (!prevCombinator) {\n        continue;\n      }\n      part = {};\n    } else {\n      part = normalizeKey(item);\n    }\n\n    normalized.push(part);\n  }\n  if (combinator) {\n    normalized.push(combinator, {});\n  }\n\n  return normalized;\n}\n\nfunction normalizeKey(key: StypSelector.Part | string): StypSelector.NormalizedPart {\n  if (typeof key === 'string') {\n    if (!key) {\n      return {};\n    }\n    return { s: key };\n  }\n  return normalizeStypSelectorPart(key);\n}\n\n/**\n * @internal\n */\nexport function normalizeStypSelectorPart(part: StypSelector.Part): StypSelector.NormalizedPart {\n\n  const ns = part.ns || undefined;\n  const i = part.i || undefined;\n  const c = normalizeClasses(part.c);\n  const u = normalizeSubSelectors(part.u);\n\n  return {\n    ns,\n    e: (part.e !== '*' || !ns && !i && !c && u && isPseudoSubSelector(u[0])) && part.e || undefined,\n    i,\n    c,\n    u,\n    s: part.s || undefined,\n    $: normalizeQualifiers(part.$),\n  };\n}\n\nfunction normalizeClasses(\n    classes: QualifiedName | readonly QualifiedName[] | undefined,\n): readonly [QualifiedName, ...QualifiedName[]] | undefined {\n  if (!classes) {\n    return;\n  }\n  if (isQualifiedName(classes)) {\n    return [classes];\n  }\n\n  const result = classes.filter(c => !!c);\n\n  return isNotEmptyArray(result) ? result.sort(compareNames) : undefined;\n}\n\nfunction normalizeSubSelectors(\n    subs: StypSubSelector | readonly StypSubSelector[] | undefined,\n): readonly [StypSubSelector.Normalized, ...StypSubSelector.Normalized[]] | undefined {\n  if (!subs) {\n    return;\n  }\n  if (/*#__INLINE__*/ isSubSelectorsArray(subs)) {\n\n    const result = subs.map(normalizeSubSelector);\n\n    return isNotEmptyArray(result) ? result : undefined;\n  }\n\n  return [normalizeSubSelector(subs)];\n}\n\nfunction isSubSelectorsArray(\n    subs: StypSubSelector | readonly StypSubSelector[],\n): subs is readonly StypSubSelector[] {\n  return typeof subs[0] !== 'string';\n}\n\nfunction normalizeSubSelector(sub: StypSubSelector): StypSubSelector.Normalized {\n  if (!isPseudoSubSelector(sub)) {\n    return sub;\n  }\n  if (sub.length < 3) {\n    return sub as StypSubSelector.Normalized;\n  }\n\n  const [prefix, name, ...params] = sub;\n\n  if (/*#__INLINE__*/ isSubSelectorParametersArray(params)) {\n    return [prefix, name, ...params.map(normalizeStypSelector)];\n  }\n\n  return [prefix, name, normalizeStypSelector(params)];\n}\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector.Normalized): sub is StypSubSelector.NormalizedPseudo;\n\n/**\n * @internal\n */\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo;\n\nexport function isPseudoSubSelector(sub: StypSubSelector): sub is StypSubSelector.Pseudo {\n  return sub.length > 1 && (sub[0] === ':' || sub[0] === '::');\n}\n\nfunction isSubSelectorParametersArray(\n    param: StypSubSelector.Parameter | readonly StypSubSelector.Parameter[],\n): param is readonly StypSubSelector.Parameter[] {\n  return isReadonlyArray(param[0]);\n}\n\nfunction normalizeQualifiers(\n    qualifiers: string | readonly string[] | undefined,\n): readonly [string, ...string[]] | undefined {\n  if (!qualifiers) {\n    return;\n  }\n\n  if (!isReadonlyArray(qualifiers)) {\n    qualifiers = [...exposeQualifier(qualifiers)];\n  } else {\n    qualifiers = [...new Set(flatMapIt(qualifiers, exposeQualifier))].sort();\n  }\n\n  return isNotEmptyArray(qualifiers) ? qualifiers : undefined;\n}\n\nconst noQualifiers: ReadonlySet<string> = new Set();\n\nfunction exposeQualifier(qualifier: string): ReadonlySet<string> {\n  if (!qualifier) {\n    return noQualifiers;\n  }\n\n  const eqIdx = qualifier.indexOf('=');\n  const name = eqIdx < 0 ? qualifier : qualifier.substring(0, eqIdx);\n  const exposed = new Set<string>();\n  let lastExposed: string | undefined;\n\n  for (const part of name.split(':')) {\n    if (lastExposed) {\n      lastExposed += ':' + part;\n    } else {\n      lastExposed = part;\n    }\n    exposed.add(lastExposed);\n  }\n  if (eqIdx >= 0) {\n    exposed.add(qualifier);\n  }\n\n  return exposed;\n}\n\nconst noKeyAndTail: [[]] = [[]];\n\n/**\n * @internal\n */\nexport function stypRuleKeyAndTail(\n    selector: StypSelector.Normalized,\n): readonly [[]] | readonly [StypRuleKey.Nested, StypSelector.Normalized?] {\n  if (!selector.length) {\n    return noKeyAndTail;\n  }\n\n  let i = 0;\n  let combinator: StypSelector.Combinator | undefined;\n\n  for (;;) {\n\n    const part = selector[i++];\n\n    if (isCombinator(part)) {\n      combinator = part;\n      continue;\n    }\n\n    const key: StypRuleKey = combinator ? [combinator, part] : [part];\n\n    return [key, selector.slice(i)];\n  }\n}\n\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * @internal\n */\nexport function stypOuterSelector(\n    selector: StypSelector.Normalized,\n): StypSelector.Normalized | undefined {\n\n  let i = selector.length - 1;\n\n  if (i <= 0) {\n    return i ? undefined : rootSelector;\n  }\n\n  do {\n    --i;\n    switch (selector[i]) {\n    case '>':\n      return selector.slice(0, i);\n    case '+':\n    case '~':\n      --i;\n      continue;\n    default:\n      return selector.slice(0, i + 1);\n    }\n  } while (i > 0);\n\n  return;\n}\n","import { namesEqual, NamespaceDef, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { normalizeStypSelectorPart } from './selector.impl';\n\n/**\n * CSS rule query.\n *\n * It may represent a selector like `element-name#id.class1.classN` with any of sub-parts omitted.\n *\n * Queries are used to grab a subset of matching rules from `StypRule`.\n *\n * All of its properties are optional.\n *\n * @category CSS Rule\n */\nexport interface StypQuery {\n\n  /**\n   * Element namespace.\n   */\n  readonly ns?: string | NamespaceDef;\n\n  /**\n   * Element name.\n   *\n   * This is the same as `*` when absent.\n   */\n  readonly e?: QualifiedName;\n\n  /**\n   * Element identifier.\n   */\n  readonly i?: QualifiedName;\n\n  /**\n   * Element class name or names.\n   */\n  readonly c?: QualifiedName | readonly QualifiedName[];\n\n  /**\n   * Qualifier or qualifiers.\n   */\n  readonly $?: string | readonly string[];\n\n}\n\n/**\n * @category CSS Rule\n */\nexport namespace StypQuery {\n\n  /**\n   * Normalized CSS rule query.\n   */\n  export type Normalized = StypQuery & StypSelector.NormalizedPart;\n\n}\n\n/**\n * Normalizes arbitrary CSS rule query.\n *\n * @category CSS Rule\n * @param query - CSS rule query to normalize.\n *\n * @returns Normalized CSS rule query.\n */\nexport function stypQuery(query: StypQuery): StypQuery.Normalized {\n  return normalizeStypSelectorPart(query);\n}\n\n/**\n * Checks whether the given structured CSS `selector` matches target `query`.\n *\n * @category CSS Rule\n * @param selector - Normalized structured CSS selector.\n * @param query - Normalized CSS rule query.\n *\n * @returns `true` if `selector` matches the `query`, or `false` otherwise.\n */\nexport function stypSelectorMatches(\n    selector: StypSelector.Normalized | StypPureSelector.Normalized,\n    query: StypQuery.Normalized,\n): boolean {\n  if (!selector.length) {\n    return false;\n  }\n\n  const part = selector[selector.length - 1] as StypSelector.NormalizedPart;\n\n  if (query.ns && part.ns !== query.ns) {\n    return false;\n  }\n  if (query.e && part.e !== query.e) {\n    return false;\n  }\n  if (query.i && part.i !== query.i) {\n    return false;\n  }\n  if (query.c && !classesMatch(part.c, query.c)) {\n    return false;\n  }\n  // noinspection RedundantIfStatementJS\n  if (query.$ && !classesMatch(part.$, query.$)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * @internal\n */\nfunction classesMatch(\n    classes: readonly QualifiedName[] | undefined,\n    query: readonly QualifiedName[],\n): boolean | undefined {\n  return classes && query.every(qClass => classes.find(mClass => namesEqual(qClass, mClass)));\n}\n","import { StypSelector } from './index';\nimport { StypPureSelector } from './pure-selector';\nimport { normalizeStypSelector } from './selector.impl';\n\n/**\n * Converts normalized pure CSS selector part to normalized pure CSS selector.\n *\n * @category CSS Rule\n * @param selector - Normalized pure CSS selector part.\n *\n * @returns Normalized pure CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypPureSelector.NormalizedPart): [StypPureSelector.NormalizedPart];\n\n/**\n * Converts normalized structured CSS selector part to normalized structured CSS selector.\n *\n * @category CSS Rule\n * @param selector - Normalized CSS selector part.\n *\n * @returns Normalized structured CSS selector. An array containing `selector` as its only item.\n */\nexport function stypSelector(selector: StypSelector.NormalizedPart): [StypSelector.NormalizedPart];\n\n/**\n * Normalizes arbitrary pure CSS selector.\n *\n * @param selector - CSS selector to normalize.\n *\n * @returns Normalized pure CSS selector.\n */\nexport function stypSelector(selector: StypPureSelector): StypPureSelector.Normalized;\n\n/**\n * Normalizes arbitrary structured CSS selector.\n *\n * @param selector - CSS selector to normalize.\n *\n * @returns Normalized structured CSS selector.\n */\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized;\n\nexport function stypSelector(selector: StypSelector): StypSelector.Normalized {\n  return normalizeStypSelector(selector);\n}\n","import { escapeCSS, escapeCSSVal } from '@frontmeans/httongue';\nimport {\n  css__naming,\n  html__naming,\n  id__naming,\n  NamespaceAliaser,\n  NamespaceDef,\n  newNamespaceAliaser,\n} from '@frontmeans/namespace-aliaser';\nimport { StypRuleKey } from './rule-key';\nimport { StypSelector } from './selector';\nimport { StypSelectorFormat } from './selector-text';\nimport { isCombinator, isPseudoSubSelector } from './selector.impl';\nimport { StypSubSelector } from './sub-selector';\n\nconst ruleKeyTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${escapeCSS(qualifier)}`;\n  },\n};\n\n/**\n * @internal\n */\nexport function stypRuleKeyText(key: StypRuleKey): string {\n  return formatStypSelector(key, ruleKeyTextOpts);\n}\n\nconst displayTextOpts: StypSelectorFormat = {\n  qualify(qualifier: string) {\n    return `@${qualifier}`;\n  },\n};\n\n/**\n * @internal\n */\nexport function stypSelectorDisplayText(selector: StypSelector.Normalized): string {\n  return formatStypSelector(selector, displayTextOpts);\n}\n\nconst defaultFormat: StypSelectorFormat = {};\n\n/**\n * @internal\n */\nexport function formatStypSelector(\n    selector: StypSelector.Normalized,\n    {\n      qualify,\n      nsAlias = newNamespaceAliaser(),\n    }: StypSelectorFormat = defaultFormat,\n): string {\n\n  const format: ItemFormat = { qualify, nsAlias };\n\n  return selector.reduce(\n      (result, item) => {\n        if (isCombinator(item)) {\n          return result + item;\n        }\n        if (result && !isCombinator(result[result.length - 1])) {\n          result += ' ';\n        }\n        return result + formatItem(item, format);\n      },\n      '',\n  );\n}\n\ninterface ItemFormat extends StypSelectorFormat {\n  nsAlias: NamespaceAliaser;\n}\n\nfunction formatItem(\n    item: StypSelector.NormalizedPart,\n    {\n      qualify,\n      nsAlias,\n    }: ItemFormat,\n): string {\n\n  const { ns, e, i, c, s, u, $ } = item;\n  let hasProperties = false;\n  let out = '';\n\n  if (i) {\n    hasProperties = true;\n    out += `#${escapeCSS(id__naming.name(i, nsAlias))}`;\n  }\n  if (c) {\n    hasProperties = true;\n    out = c.reduce<string>(\n        (result, className) => `${result}.${escapeCSS(css__naming.name(className, nsAlias))}`,\n        out,\n    );\n  }\n  if (u) {\n    hasProperties = true;\n\n    const subFormat: ItemFormat = { nsAlias };\n\n    out = u.reduce(\n        (result, sub) => formatSubSelector(result, sub, subFormat),\n        out,\n    );\n  }\n  if (s) {\n    hasProperties = true;\n    out += s;\n  }\n  if (qualify && $) {\n    out = $.reduce((result, qualifier) => result + qualify(qualifier), out);\n  }\n  if (ns) {\n\n    const alias = xmlNs(ns, nsAlias);\n\n    if (alias) {\n      out = `${alias}|${e || '*'}${out}`;\n    } else {\n      out = qualifyElement();\n    }\n  } else {\n    out = qualifyElement();\n  }\n\n  return out;\n\n  function qualifyElement(): string {\n    if (hasProperties) {\n      return `${e ? html__naming.name(e, nsAlias) : ''}${out}`;\n    }\n    return `${e ? html__naming.name(e, nsAlias) : '*'}${out}`;\n  }\n}\n\nfunction formatSubSelector(\n    out: string,\n    sub: StypSubSelector.Normalized,\n    format: ItemFormat,\n): string {\n  if (isPseudoSubSelector(sub)) {\n    out += sub[0] + sub[1];\n\n    const len = sub.length;\n\n    if (len > 2) {\n      out += '(' + formatStypSelector(sub[2], format);\n      for (let i = 3; i < sub.length; ++i) {\n        out += ',' + formatStypSelector(sub[i] as StypSubSelector.NormalizedParameter, format);\n      }\n      out += ')';\n    }\n\n    return out;\n  }\n\n  const [attrName, attrOp, attrVal, attrFlag] = sub;\n\n  out += '[' + escapeCSS(attrName);\n  if (attrOp) {\n    out += `${attrOp}\"${escapeCSSVal(attrVal!)}\"`;\n  }\n  if (attrFlag) {\n    out += ' ' + attrFlag;\n  }\n\n  return out + ']';\n}\n\nfunction xmlNs(ns: string | NamespaceDef, nsAlias: NamespaceAliaser): string | undefined {\n  return typeof ns === 'string' ? ns : ns.url ? nsAlias(ns) : undefined;\n}\n","import { AfterEvent, mapAfter } from '@proc7ts/fun-events';\nimport { filterIt, itsReduction, ObjectEntry, overEntries } from '@proc7ts/push-iterator';\nimport { isNotEmptyArray } from '../../internal';\nimport { StypProperties, StypRule } from '../../rule';\nimport { mergeStypProperties } from '../../rule/properties.impl';\nimport { StypSelector, stypSelector } from '../../selector';\nimport { isCombinator } from '../../selector/selector.impl';\nimport { stypSplitPriority, StypValue } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * @internal\n */\nclass AtRulesRenderer implements StypRenderer.Spec {\n\n  constructor(private readonly _rule: StypRule) {\n  }\n\n  read(properties: AfterEvent<[StypProperties]>): AfterEvent<[StypProperties]> {\n\n    let outer = this._rule.outer;\n\n    while (outer) {\n      properties = mergeStypProperties(outer.read.do(mapAfter(onlyAtProperties)), properties);\n      outer = outer.outer;\n    }\n\n    return properties;\n  }\n\n  render(producer: StyleProducer, properties: StypProperties): void {\n\n    const { selector } = producer;\n    let { writer } = producer;\n\n    if (!writer.isGroup) {\n      producer.render(properties);\n      return;\n    }\n\n    let sheet = writer;\n    const extracted = extractAtSelectors(selector);\n\n    if (!extracted) {\n      producer.render(properties);\n      return;\n    }\n\n    const [atSelectors, restSelector] = extracted;\n\n    for (const atSelector of atSelectors) {\n\n      const [name, params] = buildAtSelector(properties, atSelector);\n\n      if (params) {\n        writer = sheet = sheet.addGroup(name, params);\n      } else {\n        writer = sheet.addStyle(name);\n        break;\n      }\n    }\n\n    producer.render(properties, { writer, selector: restSelector });\n  }\n\n}\n\n/**\n * @internal\n */\nfunction buildAtSelector(\n    properties: StypProperties,\n    [key, [names, customQuery]]: [string, [Set<string>, string?]],\n): [string, string?] {\n\n  let query = '';\n  const addQuery = (q?: StypValue): void => {\n    if (q) {\n      if (query) {\n        query += ' and ';\n      }\n      query += q;\n    }\n  };\n\n  for (const name of names) {\n\n    const [namedQuery] = stypSplitPriority(properties[name]);\n\n    addQuery(namedQuery);\n  }\n\n  addQuery(customQuery);\n\n  return query ? [key, query] : [key];\n}\n\n/**\n * CSS stylesheet renderer of at-rules like `@media` queries.\n *\n * At-rules are represented by qualifiers which names start with `@` symbol. Qualifier names are used as at-rules keys,\n * and their values - as queries. If the rest of the selector is not empty, then properties are rendered in CSS\n * rule nested inside at-rule. Otherwise the properties are rendered in at-rule.\n *\n * So, for example CSS rule with `{ c: 'screen-only', $: '@media=screen' }` selector would be rendered as\n * ```css\n * @media screen {\n *   .screen-only {\n *      \\/* CSS properties *\\/\n *   }\n * }\n * ```\n *\n * Another option is to use named at-rules qualifiers. When named qualifier is used, the corresponding property is\n * searched in CSS rule and all of its outer rules. The values of all matching properties are used as queries.\n *\n * So the above example could be written as: `{ c: 'screen-only', $: '@media:screen' }` if CSS rule (or its outer\n * one) contains property `@media:screen` with value `screen`.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nexport const stypRenderAtRules: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER,\n\n  create(rule) {\n    return new AtRulesRenderer(rule);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction onlyAtProperties(properties: StypProperties): StypProperties {\n  return itsReduction(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          isAtEntry,\n      ),\n      (result: StypProperties.Mutable, [key, value]: ObjectEntry<StypProperties, string>) => {\n        result[key] = value;\n        return result;\n      },\n      {},\n  );\n}\n\n/**\n * @internal\n */\nfunction isAtEntry(entry: ObjectEntry<StypProperties>): entry is ObjectEntry<StypProperties, string> {\n  return String(entry[0])[0] === '@';\n}\n\n/**\n * @internal\n */\nfunction extractAtSelectors(\n    selector: StypSelector.Normalized,\n): [Map<string, [Set<string>, string?]>, StypSelector.Normalized] | undefined {\n\n  const atSelectors = new Map<string, [Set<string>, string?]>();\n  const rest: StypSelector.Mutable = [];\n\n  for (const part of selector) {\n    if (isCombinator(part)) {\n      rest.push(part);\n    } else {\n      rest.push(extractPartAtSelectors(part, atSelectors));\n    }\n  }\n\n  if (!atSelectors.size) {\n    return; // No at-rule qualifiers found.\n  }\n\n  return [atSelectors, stypSelector(rest)];\n}\n\n/**\n * @internal\n */\nfunction extractPartAtSelectors(\n    part: StypSelector.NormalizedPart,\n    atSelectors: Map<string, [Set<string>, string?]>,\n): StypSelector.NormalizedPart {\n\n  const qualifiers = part.$;\n\n  if (!qualifiers) {\n    return part;\n  }\n\n  const restQualifies: string[] = [];\n\n  for (const qualifier of qualifiers) {\n    if (qualifier[0] === '@') {\n      addAtSelector(atSelectors, qualifier);\n    } else {\n      restQualifies.push(qualifier);\n    }\n  }\n\n  if (restQualifies.length === qualifiers.length) {\n    return part; // No at-rule qualifiers found\n  }\n  if (isNotEmptyArray(restQualifies)) {\n    return { ...part, $: restQualifies };\n  }\n\n  return { ...part, $: undefined };\n}\n\n/**\n * @internal\n */\nfunction addAtSelector(atSelectors: Map<string, [Set<string>, string?]>, qualifier: string): void {\n\n  const eqIdx = qualifier.indexOf('=');\n  let name: string;\n  let query: string | undefined;\n\n  if (eqIdx < 0) {\n    name = qualifier;\n  } else {\n    name = qualifier.substring(0, eqIdx);\n    query = qualifier.substring(eqIdx + 1);\n  }\n\n  const colonIdx = name.indexOf(':');\n  const key = colonIdx < 0 ? name : name.substring(0, colonIdx);\n  const atSelector = atSelectors.get(key);\n\n  if (!atSelector) {\n    atSelectors.set(key, [new Set<string>().add(name), query]);\n  } else {\n\n    const [names, prevQuery] = atSelector;\n\n    names.add(name);\n    if (query) {\n      atSelector[1] = prevQuery ? `${prevQuery} and ${query}` : query;\n    }\n  }\n}\n","/**\n * @internal\n */\nexport const FIRST_RENDER_ORDER = -0xffff;\n","import { overEntries } from '@proc7ts/push-iterator';\nimport { StypProperties } from '../../rule';\nimport { stypSplitPriority, StypURL, StypValue } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { StypWriter } from '../writer';\nimport { stypRenderAtRules } from './at-rules.renderer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * CSS stylesheet renderer of global at-rules.\n *\n * It renders at-rules that should stay at the top level:\n * - `@namespace`\n * - `@import`\n *\n * At-rule parameters are taken from root CSS rule properties and treated as following.\n *\n * **`@import:url`** property value is treated as media query and appended after stylesheet URL. I.e.\n * ```json\n * {\n *     \"@import:path/to/included.css\": \"screen\"\n * }\n * ```\n * becomes\n * ```css\n * @import url(path/to/included.css) screen;\n * ```\n *\n * **`@namespace`** property value is treated as default namespace URL. I.e.\n * ```json\n * {\n *     \"@namespace\": \"http://www.w3.org/1999/xhtml\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace url(http://www.w3.org/1999/xhtml);\n * ```\n *\n * **`@namespace:prefix`** property value is treated as namespace URL with the given prefix. I.e\n * ```json\n * {\n *     \"@namespace:svg\": \"http://www.w3.org/2000/svg\"\n * }\n * ```\n * becomes\n * ```css\n * @namespace svg url(http://www.w3.org/2000/svg);\n * ```\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nexport const stypRenderGlobals: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER + 1,\n\n  needs: stypRenderAtRules,\n\n  render(producer: StyleProducer, properties: StypProperties) {\n\n    const rootRule = !producer.rule.selector.length;\n\n    const { sheet } = producer;\n    let importIndex = 0;\n    let nsIndex = 0;\n\n    for (const [k, v] of overEntries(properties)) {\n\n      const key = String(k);\n\n      if (key[0] === '@') {\n\n        const [value] = stypSplitPriority(v);\n        const importDelta = rootRule ? renderImport(sheet, importIndex, key, value) : 0;\n\n        importIndex += importDelta;\n        nsIndex += importDelta;\n\n        const url = StypURL.by(value);\n\n        if (url) {\n          nsIndex += renderDefaultNamespace(sheet, nsIndex, key, url);\n          nsIndex += renderNamespacePrefix(sheet, nsIndex, key, url);\n        }\n      }\n    }\n\n    producer.render(properties);\n  },\n\n};\n\n/**\n * @internal\n */\nconst IMPORT_PREFIX = '@import:';\n\n/**\n * @internal\n */\nfunction renderImport(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    value: StypValue,\n): number {\n  if (!key.startsWith(IMPORT_PREFIX)) {\n    return 0;\n  }\n\n  const url = new StypURL(key.substring(IMPORT_PREFIX.length));\n  let css = String(url);\n\n  if (value) {\n    css += ` ${value}`;\n  }\n\n  sheet.addGlobal('@import', css, index);\n\n  return 1;\n}\n\n/**\n * @internal\n */\nfunction renderDefaultNamespace(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    url: StypURL,\n): number {\n  if (key !== '@namespace') {\n    return 0;\n  }\n\n  sheet.addGlobal('@namespace', String(url), index);\n\n  return 1;\n}\n\n/**\n * @internal\n */\nconst NS_PREFIX = '@namespace:';\n\n/**\n * @internal\n */\nfunction renderNamespacePrefix(\n    sheet: StypWriter.Sheet,\n    index: number,\n    key: string,\n    url: StypURL,\n): number {\n  if (!key.startsWith(NS_PREFIX)) {\n    return 0;\n  }\n\n  const prefix = key.substring(NS_PREFIX.length);\n\n  sheet.addGlobal('@namespace', `${prefix} ${url}`, index);\n\n  return 1;\n}\n","import { hyphenateCSSName } from '@frontmeans/httongue';\nimport { filterIt, itsEach, ObjectEntry, overEntries } from '@proc7ts/push-iterator';\nimport { StypProperties } from '../../rule';\nimport { stypSplitPriority } from '../../value';\nimport { StyleProducer } from '../style-producer';\n\n/**\n * Renders CSS properties.\n *\n * This renderer is always present, so there is typically no need to use it explicitly.\n *\n * @category Rendering\n */\nexport function stypRenderProperties(producer: StyleProducer, properties: StypProperties): void {\n\n  const style = producer.addStyle();\n\n  itsEach(\n      filterIt<ObjectEntry<StypProperties>, ObjectEntry<StypProperties, string>>(\n          overEntries(properties),\n          notCustomProperty,\n      ),\n      ([k, v]) => {\n\n        const [value, priority] = stypSplitPriority(v);\n\n        style.set(hyphenateCSSName(k), `${value}`, priority);\n      },\n  );\n\n  producer.render(properties, { writer: style });\n}\n\n/**\n * @internal\n */\nfunction notCustomProperty(\n    entry: ObjectEntry<StypProperties>,\n): entry is ObjectEntry<Required<StypProperties>, string> {\n\n  const [key, value] = entry;\n\n  if (value == null) {\n    return false;\n  }\n\n  const first = String(key)[0];\n\n  return first >= 'a' && first <= 'z' || first >= 'A' && first <= 'Z';\n}\n","import { StypProperties } from '../../rule';\nimport { StyleProducer } from '../style-producer';\n\n/**\n * Renders raw CSS text. I.e. the contents of {@link StypProperties.Generic.$$css} property.\n *\n * It should be rendered before CSS properties normally to add the rendered rule as a first one.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nexport function stypRenderText(producer: StyleProducer, properties: StypProperties): void {\n\n  const css = properties.$$css;\n\n  if (!css) {\n    producer.render(properties);\n  } else {\n\n    const style = producer.addStyle();\n\n    style.replace(css);\n    producer.render(properties, { writer: style });\n  }\n}\n","import { NamespaceDef } from '@frontmeans/namespace-aliaser';\nimport { isPresent } from '@proc7ts/primitives';\nimport { StypProperties } from '../../rule';\nimport { StypSelector } from '../../selector';\nimport { isCombinator } from '../../selector/selector.impl';\nimport { StypURL } from '../../value';\nimport { StypRenderer } from '../renderer';\nimport { StyleProducer } from '../style-producer';\nimport { stypRenderGlobals } from './globals.renderer';\nimport { FIRST_RENDER_ORDER } from './renderer.impl';\n\n/**\n * CSS stylesheet renderer of global XML namespace definitions.\n *\n * Renders `@namespace` declarations for CSS selectors containing namespace definitions.\n *\n * Enabled by default in {@link produceStyle} function.\n *\n * @category Rendering\n */\nexport const stypRenderXmlNs: StypRenderer = {\n\n  order: FIRST_RENDER_ORDER,\n\n  needs: stypRenderGlobals,\n\n  render(producer: StyleProducer, properties: StypProperties) {\n\n    const xmlNsDefs = extractXmlNsDefs(producer.selector);\n\n    if (xmlNsDefs.length) {\n\n      const declareNs = (result: StypProperties.Mutable, ns: NamespaceDef): StypProperties.Mutable => {\n\n        const alias = producer.nsAlias(ns);\n\n        result[`@namespace:${alias}`] = new StypURL(ns.url);\n\n        return result;\n      };\n\n      producer.render(xmlNsDefs.reduce(declareNs, { ...properties }));\n    } else {\n      producer.render(properties);\n    }\n  },\n\n};\n\n/**\n * @internal\n */\nfunction extractXmlNsDefs(selector: StypSelector.Normalized): readonly NamespaceDef[] {\n  return selector\n      .map(part => !isCombinator(part) && part.ns && typeof part.ns !== 'string' ? part.ns : null)\n      .filter(isPresent);\n}\n","import { newRenderSchedule, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { isReadonlyArray } from '../../internal';\nimport { StypRule } from '../../rule';\nimport { StypFormat } from '../format';\nimport { StypRenderer } from '../renderer';\nimport { stypRenderProperties } from '../renderers';\n\n/**\n * @internal\n */\nexport interface StypRendererSpecFactory extends StypRenderer.Factory {\n  create(rule: StypRule): StypRenderer.Spec;\n}\n\n/**\n * @internal\n */\nexport function stypRenderFactories(format: StypFormat): readonly StypRendererSpecFactory[] {\n\n  const factories = new Map<StypRenderer, StypRendererSpecFactory>();\n\n  addRenderers(format.renderer);\n  factories.delete(stypRenderProperties);\n\n  return [...factories.values(), rendererFactory(stypRenderProperties)].sort(compareRenderers);\n\n  function addRenderers(renderers: StypRenderer | readonly StypRenderer[] | undefined): void {\n    if (renderers) {\n      if (isReadonlyArray(renderers)) {\n        renderers.forEach(addRenderer);\n      } else {\n        addRenderer(renderers);\n      }\n    }\n  }\n\n  function addRenderer(renderer: StypRenderer): void {\n    if (factories.has(renderer)) {\n      return;\n    }\n\n    const factory = rendererFactory(renderer);\n\n    factories.set(renderer, factory);\n    addRenderers(factory.needs);\n  }\n}\n\nfunction rendererFactory(renderer: StypRenderer): StypRendererSpecFactory {\n  if (typeof renderer === 'function') {\n    return {\n      create() {\n        return { render: renderer };\n      },\n    };\n  }\n  if (isRendererFactory(renderer)) {\n    return {\n      order: renderer.order,\n      needs: renderer.needs,\n      create(rule) {\n        return rendererSpec(renderer.create(rule));\n      },\n    };\n  }\n\n  const render = renderer.render.bind(renderer);\n\n  return {\n    order: renderer.order,\n    needs: renderer.needs,\n    create() {\n      return { render };\n    },\n  };\n}\n\nfunction isRendererFactory(renderer: StypRenderer): renderer is StypRenderer.Factory {\n  return 'create' in renderer;\n}\n\nfunction compareRenderers(first: StypRenderer.Factory, second: StypRenderer.Factory): number {\n\n  const firstOrder = first.order || 0;\n  const secondOrder = second.order || 0;\n\n  return firstOrder > secondOrder ? 1 : firstOrder < secondOrder ? -1 : 0;\n}\n\nfunction rendererSpec(renderer: ReturnType<StypRenderer.Factory['create']>): StypRenderer.Spec {\n  return typeof renderer === 'function' ? { render: renderer } : renderer;\n}\n\n/**\n * @internal\n */\nexport function stypRenderScheduler(\n    parent: Node,\n    scheduler: RenderScheduler = newRenderSchedule,\n): RenderScheduler {\n  return (options = {}) => {\n\n    const { node = parent } = options;\n\n    return scheduler({\n      ...options,\n      node,\n    });\n  };\n}\n\n/**\n * @internal\n */\nexport function removeStyleElement(element: HTMLStyleElement): void {\n  element.parentNode?.removeChild(element);\n}\n","import { immediateRenderScheduler, RenderScheduler } from '@frontmeans/render-scheduler';\nimport { EventEmitter, OnEvent } from '@proc7ts/fun-events';\nimport { StypPriority } from '../../value';\nimport { StypFormat, StypFormatConfig } from '../format';\nimport { StypWriter } from '../writer';\n\n/**\n * Textual CSS production format.\n *\n * Represents each style sheet in textual form and reports it to registered receivers. Such receivers should be\n * registered before {@link produceStyle style production} started in order to receive all style sheets.\n *\n * @category Rendering\n */\nexport interface StypTextFormat extends StypFormat, StypTextFormatConfig {\n\n  /**\n   * Detailed configuration of CSS text pretty print, or `false` for compact output.\n   */\n  readonly pretty: StypTextFormatConfig.PrettyPrint | false;\n\n  /**\n   * An `OnEvent` sender of style sheet textual representation.\n   *\n   * Sends textual representation of each rendered style sheet on each update.\n   */\n  readonly onSheet: OnEvent<[StypSheetText]>;\n\n}\n\n/**\n * Configuration of {@link stypTextFormat textual CSS production format}.\n *\n * @category Rendering\n */\nexport interface StypTextFormatConfig extends StypFormatConfig {\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `immediateRenderScheduler` by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n  /**\n   * How to pretty-print generated CSS text.\n   *\n   * - `false` to disable pretty print and generate compact output,\n   * - `true` (default value) for default pretty print,\n   * - {@link StypTextFormatConfig.PrettyPrint detailed configuration object}.\n   */\n  readonly pretty?: boolean | StypTextFormatConfig.PrettyPrint;\n\n}\n\n/**\n * @category Rendering\n */\nexport namespace StypTextFormatConfig {\n\n  /**\n   * Detailed configuration of CSS text pretty print.\n   */\n  export interface PrettyPrint {\n\n    /**\n     * Indentation string to use when formatting CSS text.\n     *\n     * Two spaces by default.\n     */\n    indent?: string;\n\n  }\n\n}\n\n/**\n * Style sheet textual representation.\n *\n * This is sent when producing styles in {@link StypTextFormat.onSheet textual format}.\n *\n * @category Rendering\n */\nexport interface StypSheetText {\n\n  /**\n   * Unique style sheet identifier.\n   *\n   * Style sheet is reported with the same identifier on each update.\n   */\n  readonly id: string;\n\n  /**\n   * The textual representation of style sheet formatted accordingly to {@link StypTextFormatConfig options},\n   * or `undefined` to inform that corresponding style sheet have been removed.\n   */\n  readonly css?: string;\n\n}\n\n/**\n * @internal\n */\ninterface StypTextFormatter {\n  readonly pre: string;\n  readonly nv: string;\n  readonly eol: string;\n  indent(): StypTextFormatter;\n}\n\n/**\n * @internal\n */\nconst defaultPrettyPrint: StypTextFormatConfig.PrettyPrint = {\n  indent: '  ',\n};\n\n/**\n * @internal\n */\nconst compactStypTextFormatter: StypTextFormatter = {\n  nv: '',\n  eol: '',\n  pre: '',\n  indent() {\n    return this;\n  },\n};\n\n/**\n * @internal\n */\nclass StypTextFormatter$ implements StypTextFormatter {\n\n  constructor(\n      private readonly _config: StypTextFormatConfig.PrettyPrint,\n      readonly pre = '',\n  ) {\n  }\n\n  get nv(): string {\n    return ' ';\n  }\n\n  get eol(): string {\n    return '\\n';\n  }\n\n  indent(): StypTextFormatter$ {\n    return new StypTextFormatter$(this._config, this.pre + this._config.indent!);\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypStyleTextWriter implements StypWriter.Style {\n\n  private readonly nf: StypTextFormatter;\n  private body = '';\n\n  constructor(\n      private readonly f: StypTextFormatter,\n      readonly selector: string,\n  ) {\n    this.nf = f.indent();\n  }\n\n  get isGroup(): false {\n    return false;\n  }\n\n  set(name: string, value: string, priority: number): void {\n\n    const p = priority >= StypPriority.Important ? ' !important' : '';\n    const { pre, nv, eol } = this.nf;\n\n    if (this.body) {\n      this.body += `;${eol}`;\n    }\n\n    this.body += `${pre}${name}:${nv}${value}${p}`;\n  }\n\n  replace(css: string): void {\n    this.body = css.trim();\n    if (this.body.endsWith(';')) {\n      this.body = this.body.substr(0, this.body.length - 1);\n    }\n  }\n\n  toString(): string {\n\n    const { pre, nv, eol } = this.f;\n\n    if (this.body) {\n\n      const afterBody = eol ? `;${eol}` : '';\n\n      return `${pre}${this.selector}${nv}{${eol}${this.body}${afterBody}${pre}}`;\n    }\n\n    return '';\n  }\n\n}\n\n/**\n * @internal\n */\nabstract class AbstractStypGroupTextWriter implements StypWriter.Group {\n\n  readonly _nested: any[] = [];\n\n  protected constructor(readonly nf: StypTextFormatter) {\n  }\n\n  get isGroup(): true {\n    return true;\n  }\n\n  addGroup(name: string, params: string, index?: number): StypWriter.Group {\n    return this._add(new StypGroupTextWriter(this.nf, name, params), index);\n  }\n\n  addStyle(selector: string, index?: number): StypWriter.Style {\n    return this._add(new StypStyleTextWriter(this.nf, selector), index);\n  }\n\n  toString(): string {\n\n    let out = '';\n\n    for (const nested of this._nested) {\n\n      const text = String(nested);\n\n      if (text) {\n        if (out) {\n          out += this.nf.eol;\n        }\n        out += text;\n      }\n    }\n\n    return out;\n  }\n\n  protected _add<TNested>(nested: TNested, index = this._nested.length): TNested {\n    this._nested.splice(index, 0, nested);\n    return nested;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypGroupTextWriter extends AbstractStypGroupTextWriter implements StypWriter.Group {\n\n  constructor(readonly f: StypTextFormatter, readonly name: string, readonly params: string) {\n    super(f.indent());\n  }\n\n  toString(): string {\n\n    const body = super.toString();\n\n    if (!body) {\n      return '';\n    }\n\n    const { pre, nv, eol } = this.f;\n\n    return `${pre}${this.name} ${this.params}${nv}{${eol}${body}${eol}${pre}}`;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypSheetTextWriter extends AbstractStypGroupTextWriter implements StypWriter.Sheet {\n\n  constructor(\n      readonly id: string,\n      readonly f: StypTextFormatter,\n      readonly sender: EventEmitter<[StypSheetText]>,\n  ) {\n    super(f);\n  }\n\n  addGlobal(name: string, value: string, index?: number): void {\n    this._add(`${this.f.pre}${name} ${value};`, index);\n  }\n\n  clear(): void {\n    this._nested.length = 0;\n  }\n\n  remove(): void {\n    this.clear();\n    this.sender.send({ id: this.id });\n  }\n\n  done(): void {\n    this.sender.send({\n      id: this.id,\n      css: this.toString(),\n    });\n  }\n\n}\n\n/**\n * Builds textual CSS production format.\n *\n * It is necessary to register {@link StypTextFormat.onSheet CSS text receiver(s)} prior to start {@link produceStyle\n * style production} in order to receive CSS text for style sheets.\n *\n * @category Rendering\n * @param config - Textual format config.\n *\n * @returns Textual CSS production format.\n */\nexport function stypTextFormat(config: StypTextFormatConfig = {}): StypTextFormat {\n\n  const pretty: StypTextFormatConfig.PrettyPrint | false = config.pretty === true || config.pretty == null\n      ? defaultPrettyPrint\n      : (config.pretty || false);\n  const { scheduler = immediateRenderScheduler } = config;\n  const sender = new EventEmitter<[StypSheetText]>();\n  const formatter: StypTextFormatter = pretty ? new StypTextFormatter$(pretty) : compactStypTextFormatter;\n  let idSeq = 0;\n\n  return {\n    ...config,\n    pretty,\n    scheduler,\n    onSheet: sender.on,\n    addSheet() {\n      return new StypSheetTextWriter(String(++idSeq), formatter, sender);\n    },\n  };\n}\n","import { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { StypFormat } from '../format';\nimport { removeStyleElement, stypRenderScheduler } from './format.impl';\nimport { stypTextFormat, StypTextFormatConfig } from './text.format';\n\n/**\n * Configuration of {@link stypDomFormat DOM style production format}.\n *\n * @category Rendering\n */\nexport interface StypDomFormatConfig extends StypTextFormatConfig {\n\n  /**\n   * Document to add style elements to.\n   *\n   * `parent.ownerDocument` or `window.document` by default.\n   */\n  readonly document?: Document;\n\n  /**\n   * Parent DOM node to add stylesheets to.\n   *\n   * `document.head` by default.\n   *\n   * This node don't have to be attached to document.\n   */\n  readonly parent?: Node;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `newRenderSchedule` for {@link parent} node by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n}\n\n/**\n * Builds DOM style production format.\n *\n * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and fills it with CSS text\n * generated by {@link stypTextFormat textual CSS production format}.\n *\n * This format is generally slower than {@link stypObjectFormat CSS object model production format}, but allows to add\n * `<style>` elements to DOM node outside document. E.g. to `DocumentFragment`.\n *\n * @category Rendering\n * @param config - DOM style format configuration.\n *\n * @returns CSS production format.\n */\nexport function stypDomFormat(\n    config: StypDomFormatConfig = {},\n): StypFormat {\n\n  const {\n    document = config.parent?.ownerDocument || window.document,\n    parent = document.head,\n  } = config;\n  const textFormat = stypTextFormat(config);\n  const scheduler = stypRenderScheduler(parent, config.scheduler);\n  const schedule = scheduler();\n  const elements = new Map<string, HTMLStyleElement>();\n  const supply = textFormat.onSheet(({ id, css }) => {\n    // CSS text is reported within schedule. No need to re-schedule DOM manipulations here.\n\n    let element = elements.get(id);\n\n    if (css == null) { // element exists here\n      elements.delete(id);\n      removeStyleElement(element!);\n    } else if (element) {\n      element.textContent = css;\n    } else {\n      element = document.createElement('style');\n      element.setAttribute('type', 'text/css');\n      element.textContent = css;\n      parent.appendChild(element);\n      elements.set(id, element);\n      supply.whenOff(\n          // Schedule element removal on style sheet removal instead of removing it right away.\n          () => schedule(() => removeStyleElement(element!)),\n      );\n    }\n  });\n\n  return {\n    ...config,\n    scheduler,\n    addSheet(producer) {\n      supply.needs(producer);\n      this.addSheet = textFormat.addSheet.bind(textFormat);\n      return this.addSheet(producer);\n    },\n  };\n}\n","import { RenderScheduler } from '@frontmeans/render-scheduler';\nimport { StypPriority } from '../../value';\nimport { StypFormat, StypFormatConfig } from '../format';\nimport { StypWriter } from '../writer';\nimport { removeStyleElement, stypRenderScheduler } from './format.impl';\n\n/**\n * @internal\n */\nclass StypStyleObjectWriter implements StypWriter.Style {\n\n  constructor(private readonly _target: CSSStyleRule) {\n  }\n\n  get isGroup(): false {\n    return false;\n  }\n\n  set(name: string, value: string, priority: number): void {\n    this._target.style.setProperty(name, value, priority >= StypPriority.Important ? 'important' : undefined);\n  }\n\n  replace(css: string): void {\n    this._target.style.cssText = css;\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypGroupObjectWriter implements StypWriter.Group {\n\n  constructor(readonly _target: CSSStyleSheet | CSSGroupingRule) {\n  }\n\n  get isGroup(): true {\n    return true;\n  }\n\n  addGroup(name: string, params: string, index?: number): StypWriter.Group {\n    return new StypGroupObjectWriter(\n        this._add(\n            `${name} ${params}{}`,\n            index,\n        ) as CSSGroupingRule,\n    );\n  }\n\n  addStyle(selector: string, index?: number): StypWriter.Style {\n    return new StypStyleObjectWriter(this._add(`${selector}{}`, index) as CSSStyleRule);\n  }\n\n  protected _add(\n      ruleText: string,\n      index = this._target.cssRules.length,\n  ): CSSRule {\n\n    const idx = this._target.insertRule(ruleText, index);\n\n    return this._target.cssRules[idx];\n  }\n\n}\n\n/**\n * @internal\n */\nclass StypSheetObjectWriter extends StypGroupObjectWriter implements StypWriter.Sheet {\n\n  constructor(private readonly _element: HTMLStyleElement) {\n    super(_element.sheet as CSSStyleSheet);\n  }\n\n  addGlobal(name: string, value: string, index?: number): void {\n    this._add(`${name} ${value};`, index);\n  }\n\n  clear(): void {\n\n    const { cssRules } = this._target;\n\n    while (cssRules.length) {\n      this._target.deleteRule(cssRules.length - 1);\n    }\n  }\n\n  remove(): void {\n    removeStyleElement(this._element);\n  }\n\n  done(): void {\n    /* do nothing */\n  }\n\n}\n\n/**\n * Configuration of {@link stypObjectFormat CSS object model production format}.\n *\n * @category Rendering\n */\nexport interface StypObjectFormatConfig extends StypFormatConfig {\n\n  /**\n   * Parent DOM node to add stylesheets to.\n   *\n   * `document.head` by default.\n   *\n   * This node has to be attached to document.\n   */\n  readonly parent?: Node;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * Uses `newRenderSchedule` for {@link parent} node by default.\n   */\n  readonly scheduler?: RenderScheduler;\n\n}\n\n/**\n * Builds CSS object model production format.\n *\n * The sheet writer creates a `<style>` element inside the `parent` node per CSS rule and builds its style sheet\n * with CSS object model methods.\n *\n * @category Rendering\n * @param config - Object format configuration.\n *\n * @returns CSS production format.\n */\nexport function stypObjectFormat(\n    config: StypObjectFormatConfig = {},\n): StypFormat {\n\n  const { parent = document.head }: { parent?: Node } = config;\n  const doc = parent.ownerDocument!;\n\n  return {\n    ...config,\n    scheduler: stypRenderScheduler(parent, config.scheduler),\n    addSheet() {\n\n      const element = doc.createElement('style');\n\n      element.setAttribute('type', 'text/css');\n      element.append(doc.createTextNode(''));\n\n      parent.appendChild(element);\n\n      return new StypSheetObjectWriter(element);\n    },\n  };\n}\n","import { NamespaceDef, newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { newRenderSchedule } from '@frontmeans/render-scheduler';\nimport { AfterEvent, afterSupplied, onSupplied } from '@proc7ts/fun-events';\nimport { noop } from '@proc7ts/primitives';\nimport { itsReduction, mapIt } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { StypProperties, StypRule, StypRules } from '../rule';\nimport { StypSelector, stypSelector, StypSelectorFormat, stypSelectorText } from '../selector';\nimport { isCombinator } from '../selector/selector.impl';\nimport { StypFormat } from './format';\nimport { stypRenderFactories } from './formats/format.impl';\nimport { StypRenderer } from './renderer';\nimport { StyleProducer } from './style-producer';\nimport { StypWriter } from './writer';\n\n/**\n * Produces and dynamically updates basic CSS stylesheets based on the given CSS rules.\n *\n * Unlike {@link produceStyle}, this function does not enable renderers but the basic one which just renders CSS\n * properties. This can be used to save the bundle size by enabling only select renderers.\n *\n * @category Rendering\n * @param rules - CSS rules to produce stylesheets for. This can be e.g. a {@link StypRule.rules} to render all rules,\n * or a result of {@link StypRuleList.grab} method call to render only matching ones.\n * @param format - Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceBasicStyle(rules: StypRules, format: StypFormat): Supply {\n\n  const {\n    rootSelector = { e: 'body' },\n    scheduler = newRenderSchedule,\n    nsAlias = newNamespaceAliaser(),\n  } = format;\n  const supply = new Supply();\n  const selectorFormat: StypSelectorFormat = { nsAlias };\n  const factories = stypRenderFactories(format);\n  const renderSupply = renderRules(rules);\n  const trackSupply = trackRules();\n\n  return supply.as(renderSupply).as(trackSupply);\n\n  function styleProducer(\n      rule: StypRule,\n      renderer: StypRenderer.Function,\n      production: {\n        sheet: StypWriter.Sheet;\n        writer: StypWriter;\n        selector: StypSelector.Normalized;\n      },\n  ): StyleProducer {\n\n    class StyleProducer$ implements StyleProducer {\n\n      get supply(): Supply {\n        return supply;\n      }\n\n      get rule(): StypRule {\n        return rule;\n      }\n\n      get sheet(): StypWriter.Sheet {\n        return production.sheet;\n      }\n\n      get writer(): StypWriter {\n        return production.writer;\n      }\n\n      get selector(): StypSelector.Normalized {\n        return production.selector;\n      }\n\n      nsAlias(ns: NamespaceDef): string {\n        return nsAlias(ns);\n      }\n\n      render(properties: StypProperties, options?: StypRenderer.Options): void {\n        if (!options) {\n          renderer(this, properties);\n        } else {\n          renderer(\n              styleProducer(\n                  rule,\n                  renderer,\n                  {\n                    sheet: production.sheet,\n                    writer: options.writer || production.writer,\n                    selector: options.selector || production.selector,\n                  },\n              ),\n              properties,\n          );\n        }\n      }\n\n      addStyle(_selector: StypSelector.Normalized = production.selector): StypWriter.Style {\n\n        const { writer } = production;\n\n        if (!writer.isGroup) {\n          return writer;\n        }\n\n        return writer.addStyle(selectorText(_selector));\n      }\n\n    }\n\n    return new StyleProducer$();\n  }\n\n  function selectorText(selector: StypSelector.Normalized): string {\n    return stypSelectorText(selector, selectorFormat);\n  }\n\n  function renderRules(rulesToRender: Iterable<StypRule>): Supply {\n    return itsReduction<Supply, Supply>(\n        mapIt(rulesToRender, renderRule),\n        (prev, supply) => new Supply().cuts(supply).cuts(prev),\n        new Supply(),\n    );\n  }\n\n  function trackRules(): Supply {\n\n    const supply = new Supply();\n\n    return onSupplied(rules)({\n      supply,\n      receive: (_ctx, added) => {\n        added.forEach(r => renderRule(r).needs(supply));\n      },\n    });\n  }\n\n  function renderRule(rule: StypRule): Supply {\n\n    const [reader, renderer] = rendererForRule(rule);\n    let sheet: StypWriter.Sheet | undefined;\n    const selector = ruleSelector(rule);\n    const schedule = scheduler();\n\n    return reader(renderProperties).whenOff(removeStyle);\n\n    function renderProperties(properties: StypProperties): void {\n      schedule(() => {\n        sheet?.clear();\n\n        const producer = styleProducer(\n            rule,\n            renderer,\n            {\n              get sheet(): StypWriter.Sheet {\n                if (!sheet) {\n                  sheet = format.addSheet(producer);\n                }\n                return sheet;\n              },\n              get writer(): StypWriter.Sheet {\n                return this.sheet;\n              },\n              selector,\n            },\n        );\n\n        producer.render(properties);\n        sheet?.done();\n      });\n    }\n\n    function removeStyle(): void {\n      schedule(() => {\n\n        const lastSheet = sheet;\n\n        if (lastSheet) {\n          sheet = undefined;\n          return lastSheet.remove();\n        }\n        // Otherwise element is removed before anything rendered.\n        // Should never happen for properly constructed rule.\n      });\n    }\n  }\n\n  function ruleSelector(rule: StypRule): StypSelector.Normalized {\n\n    const selector = rule.selector;\n\n    if (!selector.length) {\n      // Use configured root selector\n      return stypSelector(rootSelector);\n    }\n    if (isCombinator(selector[0])) {\n      // First combinator is relative to root selector\n      return [...stypSelector(rootSelector), ...selector];\n    }\n\n    return selector;\n  }\n\n  function rendererForRule(rule: StypRule): [AfterEvent<[StypProperties]>, StypRenderer.Function] {\n\n    const specs = factories.map(factory => factory.create(rule));\n    const reader = specs.reduce(\n        (read, spec) => spec.read ? afterSupplied(spec.read(read)) : read,\n        rule.read,\n    );\n\n    return [reader, renderAt(0)];\n\n    function renderAt(index: number): StypRenderer.Function {\n      return (producer, properties) => {\n\n        const nextIndex = index + 1;\n        let nextRenderer: StypRenderer.Function;\n\n        if (nextIndex === factories.length) {\n          nextRenderer = noop;\n        } else {\n          nextRenderer = renderAt(nextIndex);\n        }\n\n        const nextProducer = styleProducer(producer.rule, nextRenderer, producer);\n\n        specs[index].render(nextProducer, properties);\n      };\n    }\n  }\n}\n","import { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { StypPureSelector } from './pure-selector';\nimport { StypSelector } from './selector';\nimport { stypSelector } from './selector-constructor';\nimport { formatStypSelector } from './selector-text.impl';\n\n/**\n * Structured CSS selector textual format.\n *\n * @category CSS Rule\n */\nexport interface StypSelectorFormat {\n\n  /**\n   * Qualifier formatting function. When present, it is called for each qualifier to build its\n   * textual representation. When unspecified, the qualifiers won't be attached to resulting CSS selector text.\n   *\n   * @param qualifier - Qualifier to format.\n   *\n   * @returns Textual representation of `qualifier`.\n   */\n  qualify?: (qualifier: string) => string;\n\n  /**\n   * Namespace aliaser to use.\n   *\n   * New instance will be created if not specified.\n   */\n  nsAlias?: NamespaceAliaser;\n\n}\n\n/**\n * Converts structured CSS selector to its textual representation.\n *\n * @category CSS Rule\n * @param selector - Target CSS selector.\n * @param format - CSS selector format.\n *\n * @returns CSS selector string.\n */\nexport function stypSelectorText(selector: StypSelector | StypPureSelector, format?: StypSelectorFormat): string {\n  return formatStypSelector(stypSelector(selector), format);\n}\n","import { isReadonlyArray } from '../../internal';\nimport { StypRenderer } from '../renderer';\nimport { stypRenderAtRules } from './at-rules.renderer';\nimport { stypRenderGlobals } from './globals.renderer';\nimport { stypRenderText } from './text.renderer';\nimport { stypRenderXmlNs } from './xml-ns.renderer';\n\n/**\n * @internal\n */\nexport function defaultStypRenderers(\n    renderer: StypRenderer | readonly StypRenderer[] | undefined,\n): readonly StypRenderer[] {\n\n  const result: StypRenderer[] = [\n    stypRenderAtRules,\n    stypRenderXmlNs,\n    stypRenderGlobals,\n    stypRenderText,\n  ];\n\n  if (renderer) {\n    if (isReadonlyArray(renderer)) {\n      result.push(...renderer);\n    } else {\n      result.push(renderer);\n    }\n  }\n\n  return result;\n}\n","import { Supply } from '@proc7ts/supply';\nimport { StypRules } from '../rule';\nimport { StypFormat } from './format';\nimport { produceBasicStyle } from './produce-basic-style';\nimport { defaultStypRenderers } from './renderers/default-renderers.impl';\n\n/**\n * Produces and dynamically updates CSS stylesheets based on the given CSS rules.\n *\n * Appends `<style>` element(s) to the given parent DOM node (`document.head` by default) and updates them when CSS\n * rules change.\n *\n * This function enables all default renderers. E.g. the one supporting raw CSS text rules. If some of them are not\n * needed a {@link produceBasicStyle} variant of this function may be used instead.\n *\n * @category Rendering\n * @param rules - CSS rules to produce stylesheets for. This can be e.g. a {@link StypRule.rules} to render all rules,\n * or a result of {@link StypRuleList.grab} method call to render only matching ones.\n * @param format - Production format.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\nexport function produceStyle(rules: StypRules, format: StypFormat): Supply {\n  return produceBasicStyle(rules, { ...format, renderer: defaultStypRenderers(format.renderer) });\n}\n\n\n","import { AfterEvent, AfterEvent__symbol, EventKeeper, OnEvent, OnEvent__symbol } from '@proc7ts/fun-events';\nimport { StypQuery, StypRuleKey, StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { StypRules } from './rules';\n\n/**\n * CSS rule.\n *\n * Represents CSS selector and corresponding CSS properties.\n *\n * @category CSS Rule\n */\nexport abstract class StypRule implements EventKeeper<[StypProperties]> {\n\n  /**\n   * A reference to the root CSS rule.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * A reference to outer CSS rule.\n   *\n   * The outer rule is the one for enclosing element.\n   * I.e. for the rule with selector is `a b+c` the parent one is `a b`, while the outer one is `a`.\n   *\n   * This is `null` for the root rule and may be `null` for the rule removed from hierarchy.\n   */\n  abstract readonly outer: StypRule | null;\n\n  /**\n   * CSS selector of this rule.\n   */\n  abstract readonly selector: StypSelector.Normalized;\n\n  /**\n   * A key of this rule in the enclosing one.\n   */\n  abstract readonly key: StypRuleKey;\n\n  /**\n   * Whether this rule's properties are empty.\n   *\n   * This is `true` when the rule properties are constant and empty.\n   *\n   * Empty CSS rules returned from `rule()` method when there is no matching rule found.\n   */\n  abstract readonly empty: boolean;\n\n  /**\n   * Dynamic list of all CSS rules in hierarchy starting from this one.\n   */\n  abstract readonly rules: StypRuleHierarchy;\n\n  /**\n   * An `AfterEvent` keeper of CSS properties of this rule.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[StypProperties]>;\n\n  [AfterEvent__symbol](): AfterEvent<[StypProperties]> {\n    return this.read;\n  }\n\n  /**\n   * Sets CSS properties of this rule.\n   *\n   * @param properties - CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: StypProperties.Spec): this;\n\n  /**\n   * Appends CSS properties to this rule.\n   *\n   * @param properties - CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  add(properties: StypProperties.Spec): this {\n    return this.rules.add([], properties) as this;\n  }\n\n  /**\n   * Clears CSS properties of this rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n  /**\n   * Removes this rule from hierarchy along with all nested rules.\n   *\n   * @param reason - Optional removal reason.\n   *\n   * @returns `this` (just removed) rule instance.\n   */\n  abstract remove(reason?: any): this;\n\n}\n\n/**\n * Dynamically updated list of CSS rules.\n *\n * This is an iterable of rules, an EventSender` of their updates, and an `EventKeeper` of itself.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleList implements StypRules, EventKeeper<[StypRuleList]> {\n\n  /**\n   * An `AfterEvent` keeper of rule list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[StypRuleList]>;\n\n  /**\n   * An `OnEvent` sender of this rule list updates.\n   *\n   * The list updates receiver accepts two arguments:\n   * - An array of added rules\n   * - An array of removed rules.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of rule list updates.\n   */\n  abstract readonly onUpdate: OnEvent<[StypRule[], StypRule[]]>;\n\n  [AfterEvent__symbol](): AfterEvent<[StypRuleList]> {\n    return this.read;\n  }\n\n  [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n    return this.onUpdate;\n  }\n\n  abstract [Symbol.iterator](): IterableIterator<StypRule>;\n\n  /**\n   * Grabs rules from this list matching the given `query`.\n   *\n   * @param query - CSS rule query to match.\n   *\n   * @returns Dynamic list of rules in this list matching the given query.\n   */\n  abstract grab(query: StypQuery): StypRuleList;\n\n}\n\n/**\n * Dynamic list of all CSS rules in hierarchy starting from its root.\n *\n * @category CSS Rule\n */\nexport abstract class StypRuleHierarchy extends StypRuleList {\n\n  /**\n   * Dynamic list containing only root CSS rule.\n   *\n   * This list never changes actually.\n   */\n  abstract readonly self: StypRuleList;\n\n  /**\n   * Dynamic list of all CSS rules directly nested within the root one.\n   */\n  abstract readonly nested: StypRuleList;\n\n  /**\n   * Appends CSS properties to nested rule.\n   *\n   * Creates target rule if necessary.\n   *\n   * @param selector - Target rule selector.\n   * @param properties - Optional CSS properties specifier.\n   *\n   * @returns Modified CSS rule.\n   */\n  abstract add(selector: StypSelector, properties?: StypProperties.Spec): StypRule;\n\n  /**\n   * Returns nested CSS rule matching the given `selector`.\n   *\n   * @param selector - Target rule selector.\n   *\n   * @returns Either matching CSS rule, or `undefined` if not found.\n   */\n  abstract get(selector: StypSelector): StypRule | undefined;\n\n  /**\n   * Watches for CSS rule properties.\n   *\n   * The properties are empty when the watched rule does not exist.\n   *\n   * @param selector - CSS selector of watched rule.\n   *\n   * @returns An `AfterEvent` registrar of CSS properties receiver.\n   */\n  abstract watch(selector: StypSelector): AfterEvent<[StypProperties]>;\n\n}\n","import { AfterEvent, mapAfter, OnEvent, onEventBy, onSupplied, shareOn } from '@proc7ts/fun-events';\nimport { asis, valueProvider } from '@proc7ts/primitives';\nimport { filterIt, itsIterator } from '@proc7ts/push-iterator';\nimport { stypQuery, StypQuery, stypSelectorMatches } from '../selector';\nimport { StypRule, StypRuleList } from './rule';\nimport { StypRules } from './rules';\n\n/**\n * @internal\n */\nexport class Rules extends StypRuleList {\n\n  readonly read: AfterEvent<[StypRuleList]>;\n  readonly onUpdate: OnEvent<[StypRule[], StypRule[]]>;\n  private readonly _buildList: () => Iterable<StypRule>;\n  // noinspection JSMismatchedCollectionQueryUpdate\n  private _ruleSet?: Set<StypRule>; // `undefined` updates are not tracked\n\n  constructor(private readonly _list: StypRules, ruleMatches?: (rule: StypRule) => boolean) {\n    super();\n\n    let filterArray: (rules: StypRule[]) => StypRule[];\n\n    if (ruleMatches) {\n      this._buildList = () => filterIt(_list, ruleMatches);\n      filterArray = rules => rules.filter(ruleMatches);\n    } else {\n      this._buildList = valueProvider(_list);\n      filterArray = asis;\n    }\n\n    this.onUpdate = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n      const rules = this._ruleSet || (this._ruleSet = new Set(this._buildList()));\n\n      onSupplied(this._list)({\n        supply: receiver.supply.whenOff(() => this._ruleSet = undefined),\n        receive: (context, added, removed) => {\n          added = filterArray(added);\n          removed = filterArray(removed);\n          if (removed.length || added.length) {\n            removed.forEach(rule => rules.delete(rule));\n            added.forEach(rule => rules.add(rule));\n            receiver.receive(context, added, removed);\n          }\n        },\n      });\n    }).do(shareOn);\n\n    const returnSelf = valueProvider(this);\n\n    this.read = this.onUpdate.do(mapAfter(returnSelf, returnSelf));\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    if (this._ruleSet) {\n      // List changes are tracked.\n      return this._ruleSet.values();\n    }\n    // List changes are not currently tracked.\n    // Request the rules explicitly.\n    return itsIterator(this._buildList());\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function grabRules(list: StypRuleList, query: StypQuery): StypRuleList {\n\n  const q = stypQuery(query);\n\n  return new Rules(list, rule => stypSelectorMatches(rule.selector, q));\n}\n","import {\n  AfterEvent,\n  afterEventBy,\n  consumeEvents,\n  digAfter,\n  EventEmitter,\n  mapAfter,\n  OnEvent,\n  OnEvent__symbol,\n  shareAfter,\n  trackValue,\n  ValueTracker,\n} from '@proc7ts/fun-events';\nimport { lazyValue, valueProvider } from '@proc7ts/primitives';\nimport {\n  flatMapIt,\n  itsElements,\n  itsIterator,\n  overElementsOf,\n  overOne,\n  PushIterable,\n  PushIterator,\n  PushIterator__symbol,\n} from '@proc7ts/push-iterator';\nimport { StypQuery, StypRuleKey, stypSelector, StypSelector } from '../selector';\nimport { stypRuleKeyText } from '../selector/selector-text.impl';\nimport { stypOuterSelector, stypRuleKeyAndTail } from '../selector/selector.impl';\nimport { StypProperties } from './properties';\nimport { mergeStypProperties, noStypPropertiesSpec, stypPropertiesBySpec } from './properties.impl';\nimport { StypRule, StypRuleHierarchy, StypRuleList } from './rule';\nimport { StypRules } from './rules';\nimport { grabRules, Rules } from './rules.impl';\n\nclass AllRules extends StypRuleHierarchy implements PushIterable<StypRule$> {\n\n  readonly self: StypRuleList;\n  readonly read: AfterEvent<[AllRules]>;\n  private readonly _updates = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  private readonly _it: () => PushIterable<StypRule$>;\n\n  constructor(private readonly _root: StypRule$, readonly nested: NestedRules) {\n    super();\n    this.self = selfRuleList(_root, this);\n    this._it = lazyValue(() => iterateAllRules(_root));\n\n    const returnSelf = valueProvider(this);\n\n    this.read = this._updates.on.do(mapAfter(returnSelf, returnSelf));\n  }\n\n  get onUpdate(): OnEvent<[StypRule$[], StypRule$[]]> {\n    return this._updates.on;\n  }\n\n  [Symbol.iterator](): PushIterator<StypRule$> {\n    return this[PushIterator__symbol]();\n  }\n\n  [PushIterator__symbol](accept?: PushIterator.Acceptor<StypRule$>): PushIterator<StypRule$> {\n    return this._it()[PushIterator__symbol](accept);\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  add(selector: StypSelector, properties?: StypProperties.Spec): StypRule$ {\n    return extendRule(this._root, stypSelector(selector), properties, true);\n  }\n\n  get(selector: StypSelector): StypRule$ | undefined {\n    return this._get(stypSelector(selector));\n  }\n\n  private _get(selector: StypSelector.Normalized): StypRule$ | undefined {\n\n    const [key, tail] = stypRuleKeyAndTail(selector);\n\n    if (!tail) {\n      return this._root;\n    }\n\n    const found = this.nested._rule(stypRuleKeyText(key));\n\n    if (!found) {\n      return;\n    }\n\n    return found.rules.get(tail);\n  }\n\n  watch(selector: StypSelector): AfterEvent<[StypProperties]> {\n\n    const request = stypSelector(selector);\n\n    return afterEventBy<[StypProperties]>(receiver => {\n\n      const tracker = trackValue<StypProperties>({});\n      const propertiesSupply = this.read.do(consumeEvents(() => {\n\n        const found = this._get(request);\n\n        return found && found\n            .read(properties => tracker.it = properties)\n            .whenOff(() => tracker.it = {});\n      }));\n\n      return tracker.read(receiver).cuts(propertiesSupply);\n    }).do(shareAfter);\n  }\n\n  _add(rule: StypRule$, sendUpdate: boolean): void {\n    rule.rules.onUpdate((added, removed) => this._updates.send(added, removed));\n    if (sendUpdate) {\n      this._updates.send(itsElements(rule.rules), []);\n    }\n  }\n\n  _remove(reason?: any): void {\n\n    const removed = itsElements(this);\n\n    this._updates.send([], removed);\n    removed.forEach(rule => {\n      rule.rules._updates.supply.off(reason);\n      rule._spec.supply.off(reason);\n    });\n  }\n\n}\n\nfunction selfRuleList(rule: StypRule$, all: AllRules): StypRuleList {\n\n  const onUpdate = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  const rules = [rule];\n\n  all.onUpdate((_added, removed) => {\n    if (removed[0] === rule) {\n      rules.length = 0;\n      onUpdate.send([], [rule]);\n    }\n  }).cuts(onUpdate);\n\n  class Self implements StypRules {\n\n    [OnEvent__symbol](): OnEvent<[StypRule$[], StypRule$[]]> {\n      return onUpdate.on;\n    }\n\n    [Symbol.iterator](): IterableIterator<StypRule$> {\n      return itsIterator(rules);\n    }\n\n  }\n\n  return new Rules(new Self());\n}\n\nfunction iterateAllRules(rule: StypRule$): PushIterable<StypRule$> {\n  return overElementsOf(\n      overOne(rule),\n      flatMapIt(\n          rule.rules.nested,\n          nested => iterateAllRules(nested),\n      ),\n  );\n}\n\nclass NestedRules extends StypRuleList {\n\n  readonly read: AfterEvent<[NestedRules]>;\n  readonly _all: AllRules;\n  private readonly _updates = new EventEmitter<[StypRule$[], StypRule$[]]>();\n  private readonly _byKey = new Map<string, StypRule$>();\n\n  constructor(root: StypRule$) {\n    super();\n    this._all = new AllRules(root, this);\n\n    const returnSelf = valueProvider(this);\n\n    this.read = this._updates.on.do(mapAfter(returnSelf, returnSelf));\n  }\n\n  get onUpdate(): OnEvent<[StypRule[], StypRule[]]> {\n    return this._updates.on;\n  }\n\n  [Symbol.iterator](): IterableIterator<StypRule$> {\n    return this._byKey.values();\n  }\n\n  grab(query: StypQuery): StypRuleList {\n    return grabRules(this, query);\n  }\n\n  _rule(key: string): StypRule$ | undefined {\n    return this._byKey.get(key);\n  }\n\n  _add(key: string, rule: StypRule$, sendUpdate: boolean): void {\n    this._byKey.set(key, rule);\n    rule.rules.onUpdate((_added, removed) => {\n      if (removed[0] === rule) {\n        this._byKey.delete(key);\n        this._updates.send([], [rule]);\n      }\n    });\n    if (sendUpdate) {\n      this._updates.send([rule], []);\n    }\n    this._all._add(rule, sendUpdate);\n  }\n\n}\n\n/**\n * @internal\n */\nexport class StypRule$ extends StypRule {\n\n  readonly read: AfterEvent<[StypProperties]>;\n  private readonly _root: StypRule$;\n  private _outer?: StypRule$ | null;\n  private readonly _selector: StypSelector.Normalized;\n  private readonly _key: StypRuleKey;\n  readonly _spec: ValueTracker<StypProperties.Builder>;\n  private readonly _nested: NestedRules;\n\n  get root(): StypRule$ {\n    return this._root;\n  }\n\n  get outer(): StypRule$ | null {\n    if (this._outer !== undefined) {\n      return this._outer;\n    }\n\n    const outerSelector = stypOuterSelector(this.selector);\n\n    return this._outer = outerSelector && this.root.rules.get(outerSelector) || null;\n  }\n\n  get selector(): StypSelector.Normalized {\n    return this._selector;\n  }\n\n  get key(): StypRuleKey {\n    return this._key;\n  }\n\n  get empty(): boolean {\n    return this._spec.it === noStypPropertiesSpec;\n  }\n\n  get rules(): AllRules {\n    return this._nested._all;\n  }\n\n  constructor(\n      root: StypRule$ | undefined,\n      selector: StypSelector.Normalized,\n      key: StypRuleKey,\n      spec: StypProperties.Builder = noStypPropertiesSpec,\n  ) {\n    super();\n    this._root = root || this;\n    this._selector = selector;\n    this._key = key;\n    this._spec = trackValue(spec);\n    this.read = this._spec.read.do(digAfter(builder => builder(this)));\n    this._nested = new NestedRules(this);\n  }\n\n  set(properties?: StypProperties.Spec): this {\n    this._spec.it = properties ? r => stypPropertiesBySpec(r, properties) : noStypPropertiesSpec;\n    return this;\n  }\n\n  remove(reason?: any): this {\n    this.rules._remove(reason);\n    return this;\n  }\n\n}\n\nfunction extendRule(\n    rule: StypRule$,\n    targetSelector: StypSelector.Normalized,\n    properties: StypProperties.Spec | undefined,\n    sendUpdate: boolean,\n): StypRule$ {\n\n  const [key, tail] = stypRuleKeyAndTail(targetSelector);\n\n  if (!tail) {\n    // Target rule\n    rule._spec.it = extendSpec(rule, properties);\n    return rule;\n  }\n\n  const keyText = stypRuleKeyText(key);\n  const found = rule.rules.nested._rule(keyText);\n\n  if (found) {\n    return extendRule(found, tail, properties, sendUpdate);\n  }\n\n  const newNested = new StypRule$(rule.root, [...rule.selector, ...key], key);\n  const result = extendRule(newNested, tail, properties, false); // Send only a top-level update\n\n  rule.rules.nested._add(keyText, newNested, sendUpdate);\n\n  return result;\n}\n\nfunction extendSpec(rule: StypRule$, properties: StypProperties.Spec | undefined): StypProperties.Builder {\n\n  const oldSpec = rule._spec.it;\n\n  if (!properties) {\n    return oldSpec;\n  }\n\n  if (rule.empty) {\n    return r => stypPropertiesBySpec(r, properties);\n  }\n\n  return r => mergeStypProperties(oldSpec(r), stypPropertiesBySpec(r, properties));\n}\n","import { StypSelector } from '../selector';\nimport { StypProperties } from './properties';\nimport { stypPropertiesBySpec } from './properties.impl';\nimport { StypRule } from './rule';\nimport { StypRule$ } from './rule.impl';\n\n/**\n * @internal\n */\nconst rootSelector: StypSelector.Normalized = [];\n\n/**\n * Constructs root CSS rule representing global CSS declarations.\n *\n * All other rules are nested within single root.\n *\n * The root CSS rule selector is empty.\n *\n * @category CSS Rule\n * @param properties - Initial CSS rule properties specifier.\n *\n * @returns New root CSS rule.\n */\nexport function stypRoot(properties?: StypProperties.Spec): StypRule {\n  return new StypRule$(undefined, rootSelector, [], properties ? r => stypPropertiesBySpec(r, properties) : undefined);\n}\n","import {\n  afterAll,\n  AfterEvent,\n  AfterEvent__symbol,\n  afterThe,\n  EventKeeper,\n  isEventKeeper,\n  mapAfter,\n} from '@proc7ts/fun-events';\nimport { valueProvider } from '@proc7ts/primitives';\nimport { StypSelector } from '../selector';\nimport { StypMapper } from '../value';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\n\n/**\n * A type safe reference to CSS rule.\n *\n * Allows to access an modify CSS properties of the rule in a type safe manner.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties structure of referenced rule.\n */\nexport abstract class StypRuleRef<T extends StypProperties<T>> implements EventKeeper<[T]> {\n\n  /**\n   * An `AfterEvent` keeper of CSS properties.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  abstract readonly read: AfterEvent<[T]>;\n\n  [AfterEvent__symbol](): AfterEvent<[T]> {\n    return this.read;\n  }\n\n  /**\n   * Sets CSS properties of the referenced rule.\n   *\n   * @param properties - CSS properties specifier. Or nothing to clear them.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract set(properties?: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Appends CSS properties to the references CSS rule.\n   *\n   * @param properties - CSS properties specifier.\n   *\n   * @returns `this` rule instance.\n   */\n  abstract add(properties: Partial<StypProperties<T>> | EventKeeper<[Partial<StypProperties<T>>]>): this;\n\n  /**\n   * Clears CSS properties of the referenced rule.\n   *\n   * Calling this method is the same as calling `set()` without properties.\n   *\n   * @returns `this` rule instance.\n   */\n  clear(): this {\n    return this.set();\n  }\n\n}\n\n/**\n * CSS rule referrer.\n *\n * This is a function that obtains CSS rule reference relative to the given root.\n *\n * @category CSS Rule\n * @typeparam T  CSS properties interface of referenced rule.\n */\nexport type RefStypRule<T extends StypProperties<T>> =\n/**\n * @param root - Root CSS rule the constructed reference will be relative to.\n *\n * @returns CSS rule reference.\n */\n    (this: void, root: StypRule) => StypRuleRef<T>;\n\n\n/**\n * @internal\n */\nclass StypRuleRef$<T extends StypProperties<T>> extends StypRuleRef<T> {\n\n  readonly read: AfterEvent<[T]>;\n\n  constructor(\n      private readonly _root: StypRule,\n      private readonly _selector: StypSelector,\n      private readonly _map: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>,\n  ) {\n    super();\n    this.read = afterAll({\n      ms: this._map(this._root),\n      ps: this._root.rules.watch(this._selector),\n    }).do(mapAfter(\n        ({\n          ms: [_mappings],\n          ps: [_properties],\n        }) => StypMapper.map<T>(_mappings, _properties),\n    ));\n  }\n\n  add(properties: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n    this._root.rules.add(this._selector, properties);\n    return this;\n  }\n\n  set(properties?: EventKeeper<[Partial<StypProperties<T>>]> | Partial<StypProperties<T>>): this {\n    this._root.rules.add(this._selector).set(properties);\n    return this;\n  }\n\n}\n\n/**\n * @category CSS Rule\n */\nexport const RefStypRule = {\n\n  /**\n   * Constructs a CSS rule referrer that maps original CSS properties accordingly to the given `mappings`.\n   *\n   * @typeparam T  CSS properties structure of referenced rule.\n   * @param selector - CSS selector of target rule.\n   * @param mappings - Either a mappings of CSS properties, an event keeper sending such mappings, or a function\n   * returning one of them and accepting a root CSS rule as its only argument.\n   * The constructed reference will be relative to as its only parameter.\n   *\n   * @returns New CSS rule key instance.\n   */\n  by<T extends StypProperties<T>>(\n      selector: StypSelector,\n      mappings:\n          | StypMapper.Mappings<T>\n          | EventKeeper<[StypMapper.Mappings<T>]>\n          | ((this: void, root: StypRule) => StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>),\n  ): RefStypRule<T> {\n\n    let map: (root: StypRule) => EventKeeper<[StypMapper.Mappings<T>]>;\n\n    if (typeof mappings === 'function') {\n      map = root => mappingsKeeper(mappings(root));\n    } else {\n      map = valueProvider(mappingsKeeper(mappings));\n    }\n\n    return root => new StypRuleRef$(root, selector, map);\n  },\n\n};\n\n/**\n * @internal\n */\nfunction mappingsKeeper<T extends StypProperties<T>>(\n    mappings: StypMapper.Mappings<T> | EventKeeper<[StypMapper.Mappings<T>]>,\n): EventKeeper<[StypMapper.Mappings<T>]> {\n  return isEventKeeper(mappings) ? mappings : afterThe(mappings);\n}\n","import { afterAll, AfterEvent, AfterEvent__symbol, EventKeeper, mapAfter } from '@proc7ts/fun-events';\nimport { StypProperties } from './properties';\nimport { StypRule } from './rule';\nimport { RefStypRule, StypRuleRef } from './rule-ref';\n\n/**\n * Named CSS rule references complying to the CSS properties structure.\n *\n * Implements an event keeper interface by sending named CSS properties structures for each CSS rule reference.\n *\n * @category CSS Rule\n * @typeParam TRefMap - A type of target map of named CSS properties structures.\n */\nexport class StypRuleRefs<TRefMap extends StypRuleRefs.Struct<TRefMap>> implements EventKeeper<[TRefMap]> {\n\n  /**\n   * Constructs named CSS rules by resolving CSS rule referrers.\n   *\n   * @typeParam TRefMap - A type of target map of named CSS properties structures.\n   * @param referrers - Named CSS rule referrers to resolve.\n   * @param root - A root CSS rule the references will be relative to.\n   *\n   * @returns New names CSS rules instance.\n   */\n  static by<TRefMap extends StypRuleRefs.Struct<TRefMap>>(\n      referrers: { readonly [K in keyof TRefMap]: RefStypRule<TRefMap[K]> },\n      root: StypRule,\n  ): StypRuleRefs<TRefMap>;\n\n  static by<TRefMap extends StypRuleRefs.Struct<TRefMap>>(\n      referrers: { readonly [name: string]: RefStypRule<any> },\n      root: StypRule,\n  ): StypRuleRefs<TRefMap> {\n\n    const refs: { [K in keyof TRefMap]?: StypRuleRef<any> } = {};\n\n    for (const key of Object.keys(referrers)) {\n      refs[key as keyof TRefMap] = referrers[key](root);\n    }\n\n    return new StypRuleRefs<TRefMap>(refs as { [K in keyof TRefMap]: StypRuleRef<TRefMap[K]> });\n  }\n\n  /**\n   * CSS rule references by name.\n   *\n   * Each property in this map is a CSS rule reference corresponding to the same named property in properties structure.\n   * I.e. it has the same name and the same properties structure of referenced rule.\n   */\n  readonly refs: { readonly [K in keyof TRefMap]: StypRuleRef<TRefMap[K]> };\n\n  /**\n   * An `AfterEvent` keeper of named CSS properties structures for each CSS rule reference.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   */\n  readonly read: AfterEvent<[TRefMap]>;\n\n  /**\n   * Constructs named CSS rules.\n   *\n   * @param refs - A map of named CSS rule references.\n   */\n  constructor(refs: { readonly [K in keyof TRefMap]: StypRuleRef<TRefMap[K]> }) {\n    this.refs = refs;\n\n    const fromAll: AfterEvent<[{ [K in keyof TRefMap]: [StypProperties<any>] }]> = afterAll(this.refs);\n\n    this.read = fromAll.do(mapAfter(flattenProperties)) as AfterEvent<[TRefMap]>;\n  }\n\n  [AfterEvent__symbol](): AfterEvent<[TRefMap]> {\n    return this.read;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction flattenProperties<TRefMap extends StypRuleRefs.Struct<TRefMap>>(\n    propertiesMap: { readonly [name: string]: [StypProperties<any>] },\n): TRefMap {\n\n  const result: { [name: string]: StypProperties<any> } = {};\n\n  for (const name of Object.keys(propertiesMap)) {\n    result[name] = propertiesMap[name][0];\n  }\n\n  return result as TRefMap;\n}\n\n/**\n * @category CSS Rule\n */\nexport namespace StypRuleRefs {\n\n  /**\n   * A map of named CSS properties structures.\n   *\n   * Each property in this map corresponds to CSS rule reference with the same CSS properties structure.\n   *\n   * @typeParam TRefMap - A type of target map of named CSS properties structures.\n   */\n  export type Struct<TRefMap = { readonly [name: string]: StypProperties<any> }> = {\n    readonly [K in keyof TRefMap]: StypProperties<any>;\n  };\n\n  /**\n   * A map of named CSS rule referrers.\n   *\n   * These referrers then resolved to the same named CSS rule references.\n   *\n   * @typeParam TRefMap - A type of target map of named CSS properties structures.\n   */\n  export type Referrers<TRefMap extends Struct<TRefMap>> = {\n    readonly [K in keyof TRefMap]: RefStypRule<TRefMap[K]>;\n  };\n\n}\n","import {\n  EventNotifier,\n  EventReceiver,\n  EventSender,\n  isEventSender,\n  OnEvent,\n  OnEvent__symbol,\n  onEventBy,\n  onNever,\n  onSupplied,\n  shareOn,\n} from '@proc7ts/fun-events';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { neverSupply, Supply } from '@proc7ts/supply';\nimport { StypRule, StypRuleList } from './rule';\nimport { Rules } from './rules.impl';\n\n/**\n * Dynamically updated CSS rule set.\n *\n * This is an iterable of rules, and an `EventSender` of their updates.\n *\n * @category CSS Rule\n */\nexport interface StypRules extends Iterable<StypRule>, EventSender<[StypRule[], StypRule[]]> {\n\n  [Symbol.iterator](): IterableIterator<StypRule>;\n\n}\n\n/**\n * @category CSS Rule\n */\nexport namespace StypRules {\n\n  /**\n   * A source of CSS rules.\n   *\n   * A dynamically updated CSS rule set can be constructed out of one or more sources by {@link stypRules} and\n   * {@link lazyStypRules} functions.\n   *\n   * This can be one of:\n   * - Single `StypRule` instance.\n   *   A `StypRule.rules.self` is used instead. I.e. a list containing only the rule itself.\n   * - A `StypRules` instance.\n   *   It is used as is.\n   * - A promise of one of the above.\n   *   The resolved value is used as an actual source.\n   *   No rules are available until resolution.\n   * - A function returning one of the above.\n   *   The function call result is used as an actual source.\n   *   The function will be called lazily upon rules access.\n   */\n  export type Source =\n      | StypRule\n      | StypRules\n      | Promise<StypRule | StypRules>\n      | ((this: void) => StypRule | StypRules | Promise<StypRule | StypRules>);\n\n}\n\n/**\n * @internal\n */\nconst noStypRules: StypRuleList = (/*#__PURE__*/ new Rules({\n  [OnEvent__symbol]() {\n    return onNever;\n  },\n  [Symbol.iterator](): IterableIterator<StypRule> {\n    return [][Symbol.iterator]();\n  },\n}));\n\n/**\n * Constructs dynamically updated CSS rule list out of rule sources.\n *\n * @category CSS Rule\n * @param sources - CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function stypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(rulesFromSource)) : noStypRules;\n}\n\n/**\n * @internal\n */\nfunction rulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? evalRules(source) : rulesByValue(source);\n}\n\n/**\n * Constructs lazily updated CSS rule list out of rule sources.\n *\n * In contrast to {@link stypRules} this one does not evaluate sources (e.g. does not call source functions) until there\n * is an updates receiver registered.\n *\n * This means that the constructed rule set won't necessary contain the rules from all sources originally. It will\n * report them as updates instead.\n *\n * @category CSS Rule\n * @param sources - CSS rule sources.\n *\n * @returns Dynamic CSS rule list.\n */\nexport function lazyStypRules(...sources: StypRules.Source[]): StypRuleList {\n  return sources.length ? rulesByList(sources.map(lazyRulesFromSource)) : noStypRules;\n}\n\n/**\n * @internal\n */\nfunction lazyRulesFromSource(source: StypRules.Source): StypRules {\n  return typeof source === 'function' ? lazyRules(source) : rulesByValue(source);\n}\n\n/**\n * @internal\n */\nfunction rulesByList(sources: StypRules[]): StypRuleList {\n  if (sources.length === 1) {\n\n    const source = sources[0];\n\n    return source instanceof StypRuleList ? source : new Rules(source);\n  }\n  return new Rules({\n    *[Symbol.iterator](): IterableIterator<StypRule> {\n      for (const rules of sources) {\n        yield* rules;\n      }\n    },\n    [OnEvent__symbol](): OnEvent<[StypRule[], StypRule[]]> {\n      return onEventBy<[StypRule[], StypRule[]]>(receiver => {\n        sources.forEach(source => onSupplied(source)({\n          supply: new Supply().needs(receiver.supply),\n          receive(context, added, removed) {\n            receiver.receive(context, added, removed);\n          },\n        }));\n      }).do(shareOn);\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction evalRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  let rules: StypRules | undefined;\n  const getRules = (): StypRules => rules || (rules = rulesByValue(source()));\n\n  return {\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return getRules()[Symbol.iterator]();\n    },\n    [OnEvent__symbol]() {\n      return getRules()[OnEvent__symbol]();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction lazyRules(source: (this: void) => StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    const rules = rulesByValue(source());\n\n    reportExistingRules(rules, ruleSet, receiver);\n    rules[OnEvent__symbol]()({\n      supply: receiver.supply.whenOff(() => ruleSet.clear()),\n      receive(context, added, removed) {\n        removed.forEach(rule => ruleSet.delete(rule));\n        added.forEach(rule => ruleSet.add(rule));\n        receiver.receive(context, added, removed);\n      },\n    });\n  }).do(shareOn);\n\n  return {\n    [OnEvent__symbol]() {\n      return onEvent;\n    },\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction rulesByValue(source: StypRule | StypRules | Promise<StypRule | StypRules>): StypRules {\n  return source instanceof StypRule ? source.rules.self : isEventSender(source) ? source : asyncRules(source);\n}\n\n/**\n * @internal\n */\nfunction asyncRules(source: Promise<StypRule | StypRules>): StypRules {\n\n  const ruleSet = new Set<StypRule>();\n  const onEvent = onEventBy<[StypRule[], StypRule[]]>(receiver => {\n\n    let sourceSupply = neverSupply();\n    const { supply } = receiver;\n\n    supply.cuts(sourceSupply)\n        .whenOff(() => ruleSet.clear());\n\n    source.then(\n        resolution => {\n          if (!supply.isOff) {\n\n            const rules = resolution instanceof StypRule ? resolution.rules : resolution;\n\n            reportExistingRules(rules, ruleSet, receiver);\n\n            sourceSupply = onSupplied(rules)({\n              receive(context, added, removed) {\n                removed.forEach(rule => ruleSet.delete(rule));\n                added.forEach(rule => ruleSet.add(rule));\n                receiver.receive(context, added, removed);\n              },\n            }).needs(supply);\n          }\n        },\n    ).catch(\n        error => supply.off(error),\n    );\n  }).do(shareOn);\n\n  return {\n    [OnEvent__symbol]() {\n      return onEvent;\n    },\n    [Symbol.iterator](): IterableIterator<StypRule> {\n      return ruleSet.values();\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction reportExistingRules(\n    rules: StypRules,\n    ruleSet: Set<StypRule>,\n    receiver: EventReceiver.Generic<[StypRule[], StypRule[]]>,\n): void {\n\n  const existing: StypRule[] = [];\n\n  itsEach(rules, rule => {\n    existing.push(rule);\n    ruleSet.add(rule);\n  });\n  if (existing.length) {\n\n    const dispatcher = new EventNotifier<[StypRule[], StypRule[]]>();\n\n    dispatcher.on(receiver);\n    dispatcher.send(existing, []); // Report existing rules as just added\n  }\n}\n","import { produceBasicStyle, StypFormat, StypRules } from '@frontmeans/style-producer';\nimport { SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { Supply } from '@proc7ts/supply';\nimport { bootstrapDefault } from '@wesib/wesib';\n\n/**\n * Component style producer signature.\n */\nexport type ComponentStyleProducer =\n/**\n * @param rules - CSS rules to produce stylesheets for. This can be e.g. a `StypRule.rules` to render all rules,\n * or a result of `StypRuleList.grab()` method call to render only matching ones.\n * @param format - Style production format.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\n    (\n        this: void,\n        rules: StypRules,\n        format: StypFormat,\n    ) => Supply;\n\n/**\n * A key of bootstrap, definition, or component context value containing a component style producer.\n *\n * Utilizes `produceBasicStyle()` by default. I.e. it does not enable default renderers. To enable them all a\n * {@link StyleProducerSupport} can be used.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n */\nexport const ComponentStyleProducer: SingleContextRef<ComponentStyleProducer> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentStyleProducer>(\n        'component-style-producer',\n        {\n          byDefault: bootstrapDefault(() => produceBasicStyle),\n        },\n    )\n);\n","import { nodeDocument } from '@frontmeans/dom-primitives';\nimport { StypDomFormatConfig } from '@frontmeans/style-producer';\nimport { ComponentContext, ComponentRenderScheduler, DefaultNamespaceAliaser, RenderDef } from '@wesib/wesib';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * Builds configuration of DOM style production format.\n *\n * Schedules style rendering in `ComponentRenderScheduler` by default.\n *\n * Utilizes `DefaultNamespaceAliaser` by default.\n *\n * @param format - Target component style production format.\n * @param config - Original component style production format configuration.\n * @param render - Element render definition to apply to style render schedule, unless render scheduler specified\n * explicitly in `config`.\n *\n * @returns Configuration of DOM style production format.\n */\nexport function componentStypDomFormatConfig(\n    format: ComponentStypFormat,\n    config: ComponentStypFormatConfig & StypDomFormatConfig = {},\n    render?: RenderDef,\n): StypDomFormatConfig {\n\n  const { context } = format;\n\n  return {\n    ...config,\n    document: config.document || nodeDocument(context.element),\n    parent: config.parent || context.contentRoot,\n    rootSelector: [],\n    scheduler: config.scheduler || defaultStypRenderScheduler(context, render),\n    nsAlias: config.nsAlias || context.get(DefaultNamespaceAliaser),\n    renderer: format.renderer(config),\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultStypRenderScheduler(\n    context: ComponentContext,\n    render: RenderDef = {},\n): ComponentRenderScheduler {\n\n  const scheduler = context.get(ComponentRenderScheduler);\n\n  return (opts = {}) => scheduler({ ...opts, ...render });\n}\n","import { StypRenderer } from '@frontmeans/style-producer';\nimport { MultiContextKey, MultiContextRef } from '@proc7ts/context-values';\n\n/**\n * A CSS renderer that will be enabled by default by {@link ComponentStypFormat component style production format}.\n */\nexport type ComponentStypRenderer = StypRenderer;\n\n/**\n * A key of component context value containing component CSS renderers.\n */\nexport const ComponentStypRenderer: MultiContextRef<ComponentStypRenderer> = (\n    /*#__PURE__*/ new MultiContextKey<ComponentStypRenderer>('component-styp-renderer')\n);\n","import { css__naming, html__naming, NamespaceDef, QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { ContextValues, SingleContextKey, SingleContextRef } from '@proc7ts/context-values';\nimport { ComponentContext, DefaultNamespaceAliaser, ElementDef } from '@wesib/wesib';\n\n/**\n * @internal\n */\nexport type ElementIdClass = QualifiedName;\n\n/**\n * @internal\n */\nexport const ElementIdClass__NS = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns/element-id-class',\n    'elic',\n    'element-id-class',\n));\n\n/**\n * @internal\n */\nexport const ElementIdClass: SingleContextRef<ElementIdClass> = (/*#__PURE__*/ new SingleContextKey(\n    'unique-element-class',\n    { byDefault: assignElementId },\n));\n\n/**\n * @internal\n */\nlet uniqueClassSeq = 0;\n\n/**\n * @internal\n */\nfunction assignElementId(contextValues: ContextValues): ElementIdClass {\n\n  const aliaser = contextValues.get(DefaultNamespaceAliaser);\n  const context = contextValues.get(ComponentContext);\n  const elementDef = context.get(ElementDef);\n  const name: string = elementDef.name ? html__naming.name(elementDef.name, aliaser) : 'component';\n  const local = `${name}#${++uniqueClassSeq}`;\n  const qualified = ElementIdClass__NS.name(aliaser(ElementIdClass__NS), local, css__naming);\n  const element = context.element as Element;\n\n  element.classList.add(qualified);\n\n  return qualified;\n}\n","import { NamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { RenderScheduler } from '@frontmeans/render-scheduler';\nimport {\n  lazyStypRules,\n  StypFormat,\n  StypFormatConfig,\n  stypObjectFormat,\n  StypObjectFormatConfig,\n  StypPureSelector,\n  StypRenderer,\n  StypRules,\n  StypSelector,\n  stypSelector,\n  StypSubSelector,\n} from '@frontmeans/style-producer';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { elementOrArray, extendSetOfElements, setOfElements, valueProvider } from '@proc7ts/primitives';\nimport { Supply } from '@proc7ts/supply';\nimport { ComponentContext, ShadowContentRoot } from '@wesib/wesib';\nimport { ComponentStyleProducer } from './component-style-producer';\nimport { componentStypDomFormatConfig } from './component-styp-dom.format-config';\nimport { ComponentStypRenderer } from './component-styp-renderer';\nimport { ElementIdClass } from './element-id-class.impl';\n\n/**\n * Configuration of {@link ComponentStypFormat component style production format}.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n */\nexport interface ComponentStypFormatConfig extends StypFormatConfig {\n\n  /**\n   * Structured CSS selector to use for custom element's host.\n   *\n   * It modifies the selectors of produced CSS rules.\n   *\n   * For custom element with shadow root:\n   * - Replaces root CSS rule selector with `:host(<hostSelector>).\n   * - When `hostSelector` is omitted, then replaces root CSS rule selector with `:host`.\n   * - If CSS rule selector starts with `:host`, then replaces `:host` with `:host(<hostSelector>)`\n   * - If CSS rule selector starts with `:host(<selector>)`, then extends `<selector>` by `hostSelector`.\n   *   I.e. appends CSS classes and sub-selectors to it, and fulfills missing element and identifier selectors.\n   *\n   * For custom element without shadow root either uses provided `hostSelector`, or generates a unique one when omitted.\n   * And additionally:\n   * - Replaces root CSS rule selector it with `hostSelector`.\n   * - If CSS rule selector starts with `:host`, then replaces `:host` with `hostSelector`.\n   * - If CSS rule selector starts with `:host(<selector>), then replaces `:host(<selector>)` with `<selector>` extended\n   *   by `hostSelector`. I.e. appends CSS classes and sub-selectors to it, and fulfills missing element and identifier\n   *   selectors.\n   * - Otherwise prepends CSS rule selector with `hostSelector`.\n   *\n   * This selector should not contain a `:host` sub-selector.\n   */\n  readonly hostSelector?: StypPureSelector.Part | string;\n\n  /**\n   * Root CSS selector is never used for custom elements. A `hostSelector` is applied instead.\n   */\n  readonly rootSelector?: undefined;\n\n  /**\n   * DOM rendering operations scheduler.\n   *\n   * Creates a render schedule per rule.\n   *\n   * `ElementRenderScheduler` is used when omitted.\n   */\n  readonly scheduler?: RenderScheduler;\n\n  /**\n   * Namespace aliaser to use.\n   *\n   * `DefaultNamespaceAliaser` is used when omitted.\n   */\n  readonly nsAlias?: NamespaceAliaser;\n\n}\n\nconst ComponentStypFormat__symbol = (/*#__PURE__*/ new SingleContextKey<ComponentStypFormat>(\n    'component-styp-format',\n    {\n      byDefault(context) {\n        return new ComponentStypObjectFormat(context.get(ComponentContext));\n      },\n    },\n));\n\n/**\n * Component style production format.\n *\n * This format can be obtained from component context.\n *\n * The formats implemented:\n * - {@link ComponentStypObjectFormat} (the default) renders CSS using CSS object model.\n * - {@link ComponentStypDomFormat} renders CSS as text. May render CSS of disconnected element.\n */\nexport abstract class ComponentStypFormat {\n\n  /**\n   * A key of component context value containing its style production format.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentStypFormat> {\n    return ComponentStypFormat__symbol;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext;\n\n  /**\n   * Produces and dynamically updates component's CSS stylesheets based on the given CSS rules.\n   *\n   * Utilizes {@link newProducer component's producer function}.\n   *\n   * @param rules - A source of CSS rules to produce stylesheets for.\n   * @param config - Style production format configuration.\n   *\n   * @returns CSS rules supply. Once cut off the produced stylesheets are removed.\n   */\n  produce(\n      rules: StypRules.Source,\n      config?: ComponentStypFormatConfig,\n  ): Supply {\n\n    const producer = this.newProducer(rules, config);\n    const supply = new Supply();\n\n    this.context.whenSettled(() => producer().as(supply));\n\n    return supply;\n  }\n\n  /**\n   * Creates component's CSS stylesheets producer based on the given CSS rules.\n   *\n   * Utilizes {@link ComponentStyleProducer}.\n   *\n   * @param rules - A source of CSS rules to produce stylesheets for.\n   * @param config - Style production format configuration.\n   *\n   * @returns CSS rules producer function returning CSS rules supply. Once cut off the produced stylesheets are removed.\n   */\n  newProducer(\n      rules: StypRules.Source,\n      config?: ComponentStypFormatConfig,\n  ): (this: void) => Supply {\n\n    const css = lazyStypRules(rules);\n    let producer: () => Supply;\n    const componentSupply = this.context.supply;\n\n    producer = () => {\n\n      const produceStyle = this.context.get(ComponentStyleProducer);\n\n      return produceStyle(css, this.format(config)).needs(componentSupply);\n    };\n\n    // In case the component destroyed already, the producer will be reassigned here _before_ return.\n    componentSupply.whenOff(() => {\n      // Prevent style production once component destroyed.\n      producer = valueProvider(componentSupply);\n    });\n\n    return () => producer();\n  }\n\n  /**\n   * Builds CSS style production format to by its config.\n   *\n   * This method is called by {@link produce} one.\n   *\n   * @param config - Component style production format configuration.\n   *\n   * @returns Component style production format.\n   */\n  abstract format(config?: ComponentStypFormatConfig): StypFormat;\n\n  /**\n   * Builds component-specific style renderer.\n   *\n   * This renderer applies {@link ComponentStypFormatConfig.hostSelector host selector} to generated CSS rules.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config - Component style production format configuration.\n   *\n   * @returns Component style renderer(s).\n   */\n  renderer(\n      config: ComponentStypFormatConfig,\n  ): StypRenderer | readonly StypRenderer[] | undefined {\n\n    const shadowRoot = this.context.get(ShadowContentRoot, { or: null });\n    const { renderer } = config;\n    const renderers = extendSetOfElements(\n        setOfElements<StypRenderer>(renderer),\n        this.context.get(ComponentStypRenderer),\n    );\n\n    const hostSelector = config.hostSelector\n        ? stypSelector(config.hostSelector)[0] as StypPureSelector.NormalizedPart\n        : undefined;\n\n    renderers.add(shadowRoot\n        ? shadowRenderer(hostSelector)\n        : noShadowRenderer(hostSelector || { c: [this.context.get(ElementIdClass)] }));\n\n    return elementOrArray(renderers);\n  }\n\n}\n\n\n/**\n * @internal\n */\nfunction shadowRenderer(hostSelector: StypPureSelector.NormalizedPart | undefined): StypRenderer {\n  return {\n    order: -100,\n    render(producer, properties) {\n\n      let { selector } = producer;\n\n      if (!selector.length) {\n        selector = [hostSelector || { u: [[':', 'host']] }];\n      } else if (hostSelector) {\n\n        const [rest, host] = extractHostSelector(selector);\n\n        if (host) {\n          if (host.length) {\n            selector = [{ u: [[':', 'host', extendHostSelector(host, hostSelector)]] }, ...rest];\n          } else {\n            selector = [{ u: [[':', 'host', [hostSelector]]] }, ...rest];\n          }\n        }\n      }\n\n      producer.render(properties, { selector });\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction noShadowRenderer(hostSelector: StypPureSelector.NormalizedPart): StypRenderer {\n  return {\n    order: -100,\n    render(producer, properties) {\n\n      let { selector } = producer;\n\n      if (!selector.length) {\n        selector = [hostSelector];\n      } else {\n\n        const [rest, host] = extractHostSelector(selector);\n\n        if (host && host.length) {\n          selector = [...extendHostSelector(host, hostSelector), ...rest];\n        } else {\n          selector = [hostSelector, ...rest];\n        }\n      }\n\n      producer.render(properties, { selector });\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction extractHostSelector(\n    selector: StypSelector.Normalized,\n): [StypSelector.Normalized, StypSelector.Normalized?] {\n  if (typeof selector[0] !== 'string') {\n\n    const [{ ns, e, i, c, u, s, $ }, ...restParts] = selector;\n\n    if (!ns && !e && !i && !c && !s && u) {\n\n      const [[prefix, name, ...params]] = u;\n\n      if (prefix === ':' && name === 'host') {\n\n        let host: StypSelector.Mutable;\n\n        if (params.length) {\n          host = (params[0] as StypSubSelector.NormalizedParameter).slice();\n          (host[0] as { $?: string | readonly string[] }).$ = $;\n        } else {\n          host = $ ? [{ $ }] : [];\n        }\n\n        return [restParts, host];\n      }\n    }\n  }\n  return [selector];\n}\n\n/**\n * @internal\n */\nfunction extendHostSelector(\n    selector: StypSelector.Normalized,\n    {\n      ns,\n      e,\n      i,\n      c,\n      u,\n      s,\n    }: StypPureSelector.NormalizedPart,\n): StypSelector.Normalized {\n\n  const [first, ...rest] = selector as [StypSelector.NormalizedPart, ...StypSelector.Normalized];\n\n  return [\n    {\n      ns: first.e || first.ns ? first.ns : ns,\n      e: first.e || first.ns ? first.e : e,\n      i: first.i || i,\n      c: first.c ? (c ? [...first.c, ...c] : first.c) as typeof c : c,\n      u: first.u ? (u ? [...first.u, ...u] : first.u) as typeof u : u,\n      s: ((first.s || '') + (s || '')) || undefined,\n      $: first.$,\n    },\n    ...rest,\n  ];\n}\n\n/**\n * Component's CSS object model production format.\n *\n * Renders CSS when component's element connected to document.\n *\n * This format is used by default.\n */\nexport class ComponentStypObjectFormat extends ComponentStypFormat {\n\n  /**\n   * Constructs CSS object model production format.\n   *\n   * @param context - Target component context.\n   */\n  constructor(readonly context: ComponentContext) {\n    super();\n  }\n\n  format(config?: ComponentStypFormatConfig & StypObjectFormatConfig): StypFormat {\n    return stypObjectFormat(this.config(config));\n  }\n\n  /**\n   * Builds configuration of CSS object model production format.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config - Original component style production format configuration.\n   *\n   * @returns Configuration of CSS object model production format.\n   */\n  config(config?: ComponentStypFormatConfig & StypObjectFormatConfig): StypObjectFormatConfig {\n    return componentStypDomFormatConfig(this, config, { when: 'connected' });\n  }\n\n}\n\n","import { stypDomFormat, StypDomFormatConfig, StypFormat } from '@frontmeans/style-producer';\nimport { ComponentContext } from '@wesib/wesib';\nimport { componentStypDomFormatConfig } from './component-styp-dom.format-config';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * Component's DOM style production format.\n *\n * Renders CSS styles as text.\n *\n * This format is generally slower than {@link ComponentStypObjectFormat}, but allows to render styles before element\n * is connected to document.\n */\nexport class ComponentStypDomFormat extends ComponentStypFormat {\n\n  /**\n   * When to start component style rendering.\n   *\n   * One of:\n   * `settled` (the default) - to start rendering when component is settled.\n   * `connected` - to start rendering when component's element is connected to document.\n   */\n  readonly when: 'settled' | 'connected';\n\n  /**\n   * Constructs DOM style production format.\n   *\n   * @param context - Target component context.\n   * @param when - When to start style rendering. `settled` by default.\n   */\n  constructor(\n      readonly context: ComponentContext,\n      {\n        when = 'settled',\n      }: {\n        readonly when?: 'settled' | 'connected';\n      } = {},\n  ) {\n    super();\n    this.when = when;\n  }\n\n  format(config?: ComponentStypFormatConfig & StypDomFormatConfig): StypFormat {\n    return stypDomFormat(this.config(config));\n  }\n\n  /**\n   * Builds configuration of DOM style production format.\n   *\n   * This method is called by {@link format} one.\n   *\n   * @param config - Original component style production format configuration.\n   *\n   * @returns Configuration of DOM style production format.\n   */\n  config(\n      config?: ComponentStypFormatConfig & StypDomFormatConfig,\n  ): StypDomFormatConfig {\n    return componentStypDomFormatConfig(this, config, { when: this.when });\n  }\n\n}\n","import { StypRule, StypRules } from '@frontmeans/style-producer';\nimport {\n  AeComponentMember,\n  AeComponentMemberTarget,\n  ComponentClass,\n  ComponentMember,\n  ComponentMemberAmendment,\n} from '@wesib/wesib';\nimport { ComponentStypFormat, ComponentStypFormatConfig } from './component-styp-format';\n\n/**\n * Creates an amendment (and decorator) of component member producing CSS rules to apply to component.\n *\n * An amended member should either contain a CSS rules source of type `StypRules.Source` or be a method returning it.\n *\n * Produces CSS using {@link ComponentStypFormat component style production format}.\n *\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param config - Non-mandatory component style production format config.\n *\n * @returns Component property decorator.\n */\nexport function ProduceStyle<\n    TClass extends ComponentClass,\n    TAmended extends AeComponentMember<ProduceStyleDef.Source, TClass> =\n        AeComponentMember<ProduceStyleDef.Source, TClass>>(\n    config?: ComponentStypFormatConfig,\n): ComponentMemberAmendment<ProduceStyleDef.Source, TClass, ProduceStyleDef.Source, TAmended> {\n  return ComponentMember<ProduceStyleDef.Source, TClass, ProduceStyleDef.Source, TAmended>((\n      { get, amend }: AeComponentMemberTarget<ProduceStyleDef.Source, TClass>,\n  ) => amend({\n    componentDef: {\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(({ component }) => {\n\n            const value = get(component);\n            const source: StypRules.Source = typeof value === 'function' ? value.bind(component) : value;\n            const format = context.get(ComponentStypFormat);\n\n            format.produce(source, config);\n          });\n        });\n      },\n    },\n  }));\n}\n\nexport namespace ProduceStyleDef {\n\n  /**\n   * The source of produced style.\n   *\n   * Either a `StypRules.Source` or be a method returning it.\n   *\n   * A component member amended by {@link ProduceStyle @ProduceStyle} expected to have a value of this type.\n   */\n  export type Source =\n      | StypRules.Source\n      | (() => StypRule | StypRules | Promise<StypRule | StypRules>);\n\n}\n","import { produceStyle } from '@frontmeans/style-producer';\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { ComponentStyleProducer } from './component-style-producer';\n\n/**\n * @internal\n */\nconst StyleProducerSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: ComponentStyleProducer, is: produceStyle });\n  },\n};\n\n/**\n * Style producer support feature.\n *\n * This feature enables default CSS renderers.\n *\n * It is _not_ enabled automatically by {@link ProduceStyle @ProduceStyle} decorator.\n *\n * Depends on [@frontmeans/style-producer].\n *\n * [@frontmeans/style-producer]: https://www.npmjs.com/package/@frontmeans/style-producer\n */\nexport class StyleProducerSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StyleProducerSupport__feature;\n  }\n\n}\n","import { stypRules, StypRules } from '@frontmeans/style-producer';\nimport { ContextRef, ContextValueSlot, IterativeContextKey } from '@proc7ts/context-values';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { Theme } from './theme';\n\n/**\n * Theme style provides part of the theme styling information.\n *\n * Theme style(s) can be provided in bootstrap context. They are applied to the theme at most once, when requested\n * by calling {@link Theme.style} method.\n *\n * Theme style is either a function, or an extension of another theme style.\n */\nexport type ThemeStyle = ThemeStyle.Provider | ThemeStyle.Extension;\n\nexport namespace ThemeStyle {\n\n  /**\n   * Theme style provider function.\n   *\n   * This function is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n   *\n   * This function is used as an identifier of particular style and can be extended using {@link ThemeStyle.Extension}.\n   *\n   * It is not absolutely necessary to register style provider. It will be applied on request anyway.\n   *\n   * @param theme - A theme to apply styling to.\n   *\n   * @returns Dynamically updated CSS rule set containing the applied styling.\n   */\n  export type Provider = (this: void, theme: Theme) => StypRules;\n\n  /**\n   * Theme style extension.\n   *\n   * An extension should be registered in bootstrap context in order to be applied.\n   */\n  export interface Extension {\n\n    /**\n     * A theme style provider to extend.\n     */\n    readonly style: ThemeStyle.Provider;\n\n    /**\n     * Extends the theme style.\n     *\n     * This method is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n     *\n     * It will be called after the style provider it extends.\n     *\n     * @param theme - A theme to apply styling to.\n     *\n     * @returns Dynamically updated CSS rule set containing the applied styling.\n     */\n    provide(theme: Theme): StypRules;\n\n  }\n\n  /**\n   * A function obtaining combined style provider. I.e. the one that applies the style along with all extensions.\n   *\n   * @param A - provider of theme style to apply.\n   *\n   * @returns A combined theme style provider.\n   */\n  export type ById = (this: void, style: ThemeStyle.Provider) => ThemeStyle.Provider;\n\n}\n\n/**\n * @internal\n */\nclass ThemeStyleKey extends IterativeContextKey<ThemeStyle.ById, ThemeStyle> {\n\n  constructor() {\n    super('theme-style');\n  }\n\n  grow(\n      slot: ContextValueSlot<ThemeStyle.ById, ThemeStyle, Iterable<ThemeStyle>>,\n  ): void {\n\n    const providers = new Map<ThemeStyle.Provider, [ThemeStyle.Provider, boolean]>();\n\n    itsEach(\n        slot.seed,\n        style => {\n\n          let key: ThemeStyle.Provider;\n          let provider: ThemeStyle.Provider;\n          let isId: boolean;\n\n          if (typeof style === 'function') {\n            key = provider = style;\n            isId = true;\n          } else {\n            key = style.style;\n            provider = style.provide.bind(style);\n            isId = false;\n          }\n\n          const prev = providers.get(key);\n\n          if (!prev) {\n            providers.set(key, [provider, isId]);\n          } else {\n\n            const [prevProvider, hasId] = prev;\n\n            providers.set(\n                key,\n                [\n                  isId ? combineStyles(provider, prevProvider) : combineStyles(prevProvider, provider),\n                  isId || hasId,\n                ],\n            );\n          }\n        },\n    );\n\n    if (providers.size || !slot.hasFallback) {\n      slot.insert(byId);\n    }\n\n    function byId(id: ThemeStyle.Provider): ThemeStyle.Provider {\n\n      const existing = providers.get(id);\n\n      if (!existing) {\n        return id;\n      }\n\n      const [provider, hasId] = existing;\n\n      return hasId ? provider : combineStyles(id, provider);\n    }\n  }\n\n}\n\n/**\n * A key of bootstrap context value containing theme styles.\n */\nexport const ThemeStyle: ContextRef<ThemeStyle.ById, ThemeStyle> = (/*#__PURE__*/ new ThemeStyleKey());\n\n/**\n * @internal\n */\nfunction combineStyles(first: ThemeStyle.Provider, second: ThemeStyle.Provider): ThemeStyle.Provider {\n  return theme => stypRules(first(theme), second(theme));\n}\n","import {\n  lazyStypRules,\n  RefStypRule,\n  StypProperties,\n  stypRoot,\n  StypRule,\n  StypRuleRef,\n  StypRules,\n} from '@frontmeans/style-producer';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from '@proc7ts/context-values';\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { ThemeStyle } from './theme-style';\n\nexport interface ThemeFactory {\n\n  newTheme(): Theme;\n\n}\n\n/**\n * @internal\n */\nconst Theme__key = (/*#__PURE__*/ new SingleContextKey<Theme>(\n    'theme',\n    {\n      byDefault: bootstrapDefault(context => new Theme$(context.get(ThemeStyle))),\n    },\n));\n\n/**\n * A hierarchy of CSS rules within single root.\n *\n * A component may use it to extract styling information.\n *\n * Current theme is available in bootstrap, definition, or component context. By default, only one theme is declared\n * per bootstrap. But this can be overridden.\n */\nexport abstract class Theme {\n\n  /**\n   * A key of bootstrap, definition, or component context value containing current theme instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<Theme> {\n    return Theme__key;\n  }\n\n  /**\n   * Root CSS rule.\n   *\n   * All theme styling is represented as rules within this root.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * Obtains CSS rule reference by its `referrer`.\n   *\n   * This is a helper method that resolves the given `referrer` against the `root` CSS rule of this theme.\n   *\n   * @param referrer - Target CSS rule referrer.\n   *\n   * @returns CSS rule reference.\n   */\n  ref<T extends StypProperties<T>>(referrer: RefStypRule<T>): StypRuleRef<T> {\n    return referrer(this.root);\n  }\n\n  /**\n   * Obtains a styling for the given theme styles.\n   *\n   * This method requests the registered {@link ThemeStyle theme styles} for CSS rules they provide.\n   * If some of the styles are not registered then uses the given style as provider.\n   *\n   * @param styles - The styles to obtain styling information for.\n   *\n   * @returns Dynamically updated CSS rule set containing the requested styling.\n   */\n  abstract style(...styles: ThemeStyle.Provider[]): StypRules;\n\n}\n\n/**\n * @internal\n */\nclass Theme$ extends Theme {\n\n  readonly root: StypRule = stypRoot();\n  private readonly _rules = new Map<ThemeStyle.Provider, StypRules>();\n\n  constructor(private readonly _styles: ThemeStyle.ById) {\n    super();\n  }\n\n  style(...styles: ThemeStyle.Provider[]): StypRules {\n\n    const theme = this;\n\n    return lazyStypRules(...styles.reduce<StypRules[]>(addStyleRules, []));\n\n    function addStyleRules(target: StypRules[], style: ThemeStyle.Provider): StypRules[] {\n\n      const existing = theme._rules.get(style);\n\n      if (existing) {\n        target.push(existing);\n      } else {\n\n        const constructed = theme._styles(style)(theme);\n\n        theme._rules.set(style, constructed);\n        target.push(constructed);\n      }\n\n      return target;\n    }\n  }\n\n}\n","import { NamespaceDef } from '@frontmeans/namespace-aliaser';\n\nexport const Examples__NS = new NamespaceDef(\n    'https://wesib.github.io/examples',\n    'bex',\n    'wesib-examples',\n);\n","import { RefStypRule, StypColor, StypLength, StypLengthPt, StypProperties, StypRGB } from '@frontmeans/style-producer';\n\nexport interface ThemeSettings {\n  $color: StypColor;\n  $bgColor: StypColor;\n  $fontFace: string;\n  $fontSize: StypLengthPt;\n  $lineHeight: number;\n  $fontWeight: string;\n  $linkFontWeight: string;\n  $layoutBreakpoint: StypLength;\n}\n\nexport const ThemeSettings: RefStypRule<ThemeSettings> = RefStypRule.by(\n    { $: 'settings' },\n    {\n      $color: new StypRGB({ r: 161, g: 185, b: 142 }),\n      $bgColor: new StypRGB({ r: 40, g: 43, b: 36 }),\n      $fontFace: `'Exo 2', sans-serif`,\n      $fontSize: StypLengthPt.of(1, 'em'),\n      $lineHeight: 1.2,\n      $fontWeight: '400',\n      $linkFontWeight: '600',\n      $layoutBreakpoint: StypLength.of(576, 'px'),\n    },\n);\n\nexport function mediaStyle({ $layoutBreakpoint }: ThemeSettings): StypProperties {\n  return {\n    '@media:sm': `(max-width: ${$layoutBreakpoint})`,\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { Theme } from '@wesib/generic/styp';\nimport { ThemeSettings } from './theme-settings';\n\nexport function LinkStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read;\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add({ e: 'a' }, settings.do(mapAfter(linkStyle))),\n      rules.add({ e: 'a', s: ':visited' }, settings.do(mapAfter(linkStyle))),\n      rules.add({ e: 'a', s: ':hover' }, { textDecoration: 'underline' }),\n      rules.add({ e: 'a', s: ':active' }, { textDecoration: 'underline dotted' }),\n      rules.add({ e: 'a', s: ':focus' }, { textDecoration: 'underline dotted' }),\n  );\n}\n\nfunction linkStyle(\n    {\n      $color,\n      $linkFontWeight,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    fontWeight: $linkFontWeight,\n    textDecoration: 'none',\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { Theme } from '@wesib/generic/styp';\nimport { LinkStyle } from './link.style';\nimport { mediaStyle, ThemeSettings } from './theme-settings';\n\nexport function DefaultStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read;\n\n  return stypRules(\n      theme.root\n          .add(settings.do(mapAfter(defaultStyle)))\n          .add(settings.do(mapAfter(mediaStyle))),\n      theme.style(LinkStyle),\n  );\n}\n\nfunction defaultStyle(\n    {\n      $color,\n      $fontFace,\n      $fontSize,\n      $lineHeight,\n      $fontWeight,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    font: `normal ${$fontWeight} ${$fontSize}/${$lineHeight} ${$fontFace}`,\n  };\n}\n","import { StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { Theme } from '@wesib/generic/styp';\nimport { DefaultStyle } from './default.style';\nimport { ThemeSettings } from './theme-settings';\n\nexport function BodyStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read;\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add(\n          { e: 'html' },\n          {\n            height: '100%',\n            margin: 0,\n            padding: 0,\n          },\n      ),\n      rules.add(\n          { e: 'body' },\n          settings.do(mapAfter(bodyStyle)),\n      ),\n      theme.style(DefaultStyle),\n  );\n}\n\nfunction bodyStyle(\n    {\n      $bgColor,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    backgroundColor: $bgColor,\n    height: '100%',\n    margin: 0,\n    padding: 0,\n  };\n}\n","import { RefStypRule, StypColor, StypLength, StypLengthPt, StypMapper, StypRuleRefs } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { ThemeSettings } from '../theme';\n\nexport interface FormThemeSettings {\n  $color: StypColor;\n  $bgColor: StypColor;\n  $roBgColor: StypColor;\n  $fontFace: string;\n  $fontSize: StypLengthPt;\n  $errorFontSize: StypLengthPt;\n  $lineHeight: number;\n  $fontWeight: string;\n  $borderColor: StypColor;\n  $marginV: StypLengthPt;\n  $marginH: StypLengthPt;\n  $paddingV: StypLengthPt;\n  $paddingH: StypLengthPt;\n  $borderW: StypLength;\n}\n\nexport const FormThemeSettings: RefStypRule<FormThemeSettings> = RefStypRule.by(\n    { $: 'settings:form' },\n    root => StypRuleRefs.by<{ global: ThemeSettings }>(\n        {\n          global: ThemeSettings,\n        },\n        root,\n    ).read.do(mapAfter(formMappings)),\n);\n\nfunction formMappings(\n    {\n      global: {\n        $color,\n        $bgColor,\n        $fontFace,\n        $fontSize,\n        $lineHeight,\n        $fontWeight,\n      },\n    }: {\n      global: ThemeSettings;\n    },\n): StypMapper.Mappings<FormThemeSettings> {\n  return {\n    $color,\n    $bgColor: $bgColor.hsl.set(({ l }) => ({ l: l * 0.8 })),\n    $roBgColor: $bgColor.hsl.set(({ l }) => ({ l: l * 0.94 })),\n    $fontFace,\n    $fontSize,\n    $errorFontSize: $fontSize.mul(0.8),\n    $lineHeight,\n    $fontWeight,\n    $borderColor: $bgColor,\n    $marginV: $fontSize.div(4),\n    $marginH: $fontSize.div(4),\n    $paddingV: $fontSize.div(2),\n    $paddingH: $fontSize,\n    $borderW: StypLength.of(1, 'px'),\n  };\n}\n","import { InCssClasses, inCssError, inCssInfo, InputAspects__NS, InStyledElement } from '@frontmeans/input-aspects';\nimport { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { StypLengthPt, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { AfterEvent, mapAfter, mapAfter_, trackValue, translateAfter_ } from '@proc7ts/fun-events';\nimport { adjacentToField, Field, FieldShare, SharedField } from '@wesib/generic/forms';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { Attribute, Component, ComponentContext } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { FormThemeSettings } from './form.theme-settings';\n\nclass FieldErrorShare extends FieldShare {\n\n  constructor() {\n    super('field-error');\n  }\n\n}\n\n@Component(['field-error', Examples__NS])\nexport class FieldErrorComponent {\n\n  private readonly _code = trackValue<string | null>();\n\n  @SharedField({\n    share: {\n      share: FieldErrorShare,\n      local: true,\n    },\n    name: '',\n  })\n  readonly indicator: Field<void>;\n\n  constructor(private readonly _context: ComponentContext) {\n\n    const when: AfterEvent<string[]> = this._code.read\n        .do(\n            translateAfter_((send, code) => code ? send(...code.trim().split(/\\s+/)) : send()),\n        );\n\n    this.indicator = adjacentToField<void>(builder => when.do(\n        mapAfter_((...when) => ({\n          control: builder.adjusted.control\n              .convert<void>(InStyledElement.to(_context.element))\n              .setup(InCssClasses, css => css.add(inCssInfo()))\n              .setup(InCssClasses, css => css.add(inCssError({ when }))),\n        })),\n    ));\n  }\n\n  @Attribute({ updateState: false })\n  get code(): string | null | undefined {\n    return this._code.it;\n  }\n\n  set code(code: string | null | undefined) {\n    this._code.it = code;\n  }\n\n  @ProduceStyle()\n  style(): StypRules {\n    return this._context.get(Theme).style(InErrorStyle);\n  }\n\n}\n\nconst InError__qualifier = 'bex:in-error';\nconst hasError__cssClass: QualifiedName = ['has-error', InputAspects__NS];\n\nfunction InErrorStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(FormThemeSettings).read;\n  const { root: { rules } } = theme;\n  const borderW = StypLengthPt.of(4, 'px');\n\n  return stypRules(\n      rules.add(\n          { u: [':', 'host'], $: InError__qualifier },\n          settings.do(mapAfter(({ $color, $errorFontSize }) => ({\n            display: 'none',\n            fontSize: $errorFontSize,\n            padding: $errorFontSize.div(2),\n            borderLeft: `${borderW} dotted ${$color}`,\n            paddingLeft: $errorFontSize.sub(borderW),\n          }))),\n      ),\n      rules.add(\n          {\n            u: [\n              ':',\n              'host',\n              {\n                c: [hasError__cssClass, ['touched', InputAspects__NS]],\n                u: [':', 'not', { c: ['has-focus', InputAspects__NS] }],\n              },\n            ],\n            $: InError__qualifier,\n          },\n          {\n            display: 'block',\n          },\n      ),\n      rules.add(\n          {\n            u: [\n              ':',\n              'host',\n              {\n                c: hasError__cssClass,\n                u: [\n                  [':', 'not', { u: ['code', '~=', 'missing'] }],\n                  [':', 'not', { u: ['code', '~=', 'incomplete'] }],\n                ],\n              },\n            ],\n            $: InError__qualifier,\n          },\n          {\n            display: 'block',\n          },\n      ),\n  );\n}\n","import { FormCssPreset, FormModePreset } from '@wesib/generic/forms';\nimport { Feature } from '@wesib/wesib';\nimport { FieldErrorComponent } from './field-error.component';\n\n@Feature({\n  needs: [\n    FormModePreset,\n    FormCssPreset,\n    FieldErrorComponent,\n  ],\n})\nexport class FormsSupport {\n}\n","import { InControl, InMode, inModeByValidity, InParents } from '@frontmeans/input-aspects';\nimport { consumeEvents } from '@proc7ts/fun-events';\nimport { itsEach } from '@proc7ts/push-iterator';\nimport { Supply } from '@proc7ts/supply';\nimport { Field } from '../field';\nimport { Form } from '../form';\nimport { FormScope } from '../form-scope';\nimport { ScopedFormConfig } from '../scoped-form-config';\nimport { AbstractFormPreset } from './abstract-form-preset';\n\n/**\n * Form preset that enables default form and field mode management.\n *\n * - Makes form mode depend on its validity (`inModeByValidity()`).\n * - Derives form field's mode from form element's one.\n */\nexport class FormModePreset extends AbstractFormPreset {\n\n  /**\n   * @internal\n   */\n  private readonly _byValidity: (control: InControl<any>) => Supply;\n\n  /**\n   * @internal\n   */\n  private readonly _byForm: (control: InControl<any>) => Supply;\n\n  /**\n   * Constructs customized form mode preset.\n   *\n   * @param options - Custom form mode preset options.\n   */\n  constructor(options: FormModePreset.Options = {}) {\n    super();\n    this._byValidity = ScopedFormConfig.createSetup(\n        options.byValidity,\n        opts => {\n\n          const src = inModeByValidity(opts);\n\n          return control => control.aspect(InMode).derive(src);\n        },\n    );\n    this._byForm = FormScope.createSetup(\n        options.byForm,\n        control => control.aspect(InParents).read.do(\n            consumeEvents(parents => {\n\n              const supply = new Supply();\n\n              itsEach(\n                  parents,\n                  ({ parent }) => {\n\n                    const form = parent.aspect(Form);\n\n                    if (form) {\n                      control.aspect(InMode).derive(form.element.aspect(InMode)).as(supply);\n                    }\n                  },\n              );\n\n              return supply;\n            }),\n        ),\n    );\n  }\n\n  setupField<TValue, TSharer extends object>(\n      builder: Field.Builder<TValue, TSharer>,\n  ): void {\n    builder.control.setup(this._byForm);\n  }\n\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      builder: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    builder.control.setup(this._byValidity);\n  }\n\n}\n\nexport namespace FormModePreset {\n\n  /**\n   * Form mode preset options.\n   */\n  export interface Options {\n\n    /**\n     * Whether to build a form mode by its validity options.\n     *\n     * `false` to disable.\n     */\n    readonly byValidity?: ScopedFormConfig<Parameters<typeof inModeByValidity>[0]>;\n\n    /**\n     * Whether form field mode should be derived from form element's one.\n     *\n     * `true` by default. `false` to disable.\n     */\n    readonly byForm?: FormScope;\n\n  }\n\n}\n","import { mapAfter } from '@proc7ts/fun-events';\nimport { InValidation } from '../../validation';\nimport { InMode } from '../mode.aspect';\n\n/**\n * Creates an {@link InMode input mode} source depending on control's {@link InValidation validity}.\n *\n * This can be applied to form control to prevent submission of invalid input.\n *\n * @category Aspect\n * @param invalid - Input mode to set when the input is invalid. `-on` (not submittable) by default. This\n * should not be set to disabled, as the latter would make it impossible to fix input errors.\n * @param ignore - Ignored message codes. If all validation messages have this code the form is not marked as invalid.\n * `submit` by default, as this code intended to be server-side.\n *\n * @returns A source of input mode.\n */\nexport function inModeByValidity(\n    {\n      invalid = '-on',\n      ignore = 'submit',\n    }: {\n      invalid?: InMode.Value;\n      ignore?: string | string[];\n    } = {},\n): InMode.Source {\n  return control => control.aspect(InValidation).read.do(mapAfter(\n      validity => validity.hasBut(...(typeof ignore === 'string' ? [ignore] : ignore)) ? invalid : 'on',\n  ));\n}\n","import { InControl, InCssClasses, inCssError, inCssInfo } from '@frontmeans/input-aspects';\nimport { Supply } from '@proc7ts/supply';\nimport { Field } from '../field';\nimport { Form } from '../form';\nimport { ScopedFormConfig } from '../scoped-form-config';\nimport { AbstractFormPreset } from './abstract-form-preset';\n\n/**\n * Form preset that enables CSS class indication of form and field states.\n *\n * - Enables CSS info classes (`inCssInfo()`) for forms and fields.\n * - Enables error indication (`inCssError()`) for fields.\n */\nexport class FormCssPreset extends AbstractFormPreset {\n\n  /**\n   * @internal\n   */\n  private readonly _info: (control: InControl<any>) => Supply;\n\n  /**\n   * @internal\n   */\n  private readonly _error: (control: InControl<any>) => Supply;\n\n  /**\n   * Constructs customized form CSS preset.\n   *\n   * @param options - Custom form CSS preset options.\n   */\n  constructor(options: FormCssPreset.Options = {}) {\n    super();\n    this._info = ScopedFormConfig.createSetup(\n        options.info,\n        opts => {\n\n          const src = inCssInfo(opts);\n\n          return control => control.aspect(InCssClasses).add(src);\n        },\n    );\n    this._error = ScopedFormConfig.createSetup(\n        options.error,\n        opts => {\n\n          const src = inCssError(opts);\n\n          return control => control.aspect(InCssClasses).add(src);\n        },\n    );\n  }\n\n  setupField<TValue, TSharer extends object>(\n      builder: Field.Builder<TValue, TSharer>,\n  ): void {\n    builder.control.setup(this._info).setup(this._error);\n  }\n\n  setupForm<TModel, TElt extends HTMLElement, TSharer extends object>(\n      builder: Form.Builder<TModel, TElt, TSharer>,\n  ): void {\n    builder.control.setup(this._info);\n    builder.element.setup(\n        InCssClasses,\n        (css, element) => css.add(\n            element.aspect(Form)!.control.aspect(InCssClasses),\n        ),\n    );\n  }\n\n}\n\nexport namespace FormCssPreset {\n\n  /**\n   * Form CSS preset options.\n   */\n  export interface Options {\n\n    /**\n     * CSS info options.\n     *\n     * `false` to disable.\n     */\n    readonly info?: ScopedFormConfig<Parameters<typeof inCssInfo>[0]>;\n\n    /**\n     * CSS error indication options.\n     *\n     * `false` to disable.\n     */\n    readonly error?: ScopedFormConfig<Parameters<typeof inCssError>[0]>;\n\n  }\n\n}\n","import { nodeDocument } from '@frontmeans/dom-primitives';\nimport { drekReplacer } from '@frontmeans/drek';\nimport { StypProperties } from '@frontmeans/style-producer';\nimport { PageRendererExecution, RenderPage } from '@wesib/generic';\nimport { Component } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { ThemeSettings } from '../theme';\n\n@Component(['main', Examples__NS])\nexport class MainComponent {\n\n  @RenderPage({\n    target: ({ contentRoot }) => drekReplacer(contentRoot),\n  })\n  renderPage({ content, response }: PageRendererExecution): void {\n    if (!response.ok) {\n\n      const doc = nodeDocument(content);\n\n      if (response.ok == null) {\n        content.appendChild(doc.createTextNode('Loading...'));\n      } else {\n        content.appendChild(doc.createTextNode(`Error. ${response.error}`));\n      }\n    }\n  }\n\n}\n\nexport function mainStyle(\n    {\n      $fontSize,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    flex: '1 1 auto',\n    padding: 0,\n    margin: `0 0 0 ${$fontSize.div(2)}`,\n  };\n}\n","import {\n  AeComponentMember,\n  AeComponentMemberTarget,\n  ComponentClass,\n  ComponentMember,\n  ComponentMemberAmendment,\n} from '@wesib/wesib';\nimport { PageLoadSupport } from '../page-load';\nimport { PageRenderCtl } from './page-render-ctl';\nimport { RenderPageDef } from './render-page-def';\n\n/**\n * Creates a {@link RenderPageDef.Method page renderer} method amendment (and decorator).\n *\n * Renders pages using {@link PageRenderCtl page render control}.\n *\n * Utilizes {@link PageLoadParam} navigation parameter.\n *\n * Enables {@link PageLoadSupport} feature.\n *\n * @typeParam TClass - Amended component class type.\n * @typeParam TAmended - Amended component member entity type.\n * @param def - Page inclusion definition.\n *\n * @returns New component method amendment.\n */\nexport function RenderPage<\n    TClass extends ComponentClass,\n    TAmended extends AeComponentMember<RenderPageDef.Method, TClass> =\n        AeComponentMember<RenderPageDef.Method, TClass>>(\n    def?: RenderPageDef,\n): ComponentMemberAmendment<RenderPageDef.Method, TClass, RenderPageDef.Method, TAmended> {\n  return ComponentMember<RenderPageDef.Method, TClass, RenderPageDef.Method, TAmended>((\n      { get, amend }: AeComponentMemberTarget<RenderPageDef.Method, TClass>,\n  ) => amend({\n    componentDef: {\n      feature: {\n        needs: [PageLoadSupport],\n      },\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(context => {\n\n            const { component } = context;\n            const renderer = get(component).bind(component);\n\n            context.get(PageRenderCtl).renderPageBy(renderer, def);\n          });\n        });\n      },\n    },\n  }));\n}\n","import { removeNodeContent } from '@frontmeans/dom-primitives';\nimport { DrekContext } from '../context';\nimport { drekContextOf } from '../context-of';\nimport { DrekTarget } from './target';\n\n/**\n * Creates a rendering target that replaces content of the `host` node.\n *\n * @param host - A node to replace the content of.\n * @param context - Custom rendering context. Defaults to `host` node context.\n *\n * @returns Rendering target.\n */\nexport function drekReplacer(host: Node, context: DrekContext = drekContextOf(host)): DrekTarget {\n  return {\n    context,\n    host,\n    placeContent(content: Node) {\n      removeNodeContent(host);\n      host.appendChild(content);\n      return context;\n    },\n  };\n}\n","/**\n * Removes all child nodes from the given one.\n *\n * @param node - DOM node to remove the content of.\n */\nexport function removeNodeContent(node: Node): void {\n  node.textContent = null;\n}\n","import { StypColor, StypLengthPt, StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { mapIndexed } from '@proc7ts/push-iterator';\nimport { navAnchor, NavMenu } from '@wesib/generic';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { Component, ComponentContext, Wesib__NS } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { ThemeSettings } from '../theme';\n\n@Component(['nav', Examples__NS])\nexport class NavComponent {\n\n  private readonly _theme: Theme;\n\n  constructor(context: ComponentContext) {\n    this._theme = context.get(Theme);\n    new NavMenu(({ element }: { element: Element }) => mapIndexed(\n        element.querySelectorAll('a'),\n        el => navAnchor(el),\n    )).bindTo(context);\n  }\n\n  @ProduceStyle()\n  style(): StypRules {\n    return this._theme.style(NavStyle);\n  }\n\n}\n\nconst Nav__qualifier = 'bex:nav';\n\nfunction NavStyle(theme: Theme): StypRules {\n\n  const settings = theme.ref(ThemeSettings).read;\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add(\n          { u: [':', 'host'], $: Nav__qualifier },\n          settings.do(mapAfter(navStyle)),\n      ),\n      rules.add(\n          { u: [':', 'host'], $: Nav__qualifier },\n          settings.do(mapAfter(sts => ({\n            flex: '0 1 200px',\n            height: '100%',\n            background: navLinkBackground(sts),\n          }))),\n      ),\n      rules.add(\n          { u: [':', 'host'], $: [Nav__qualifier, '@media:sm'] },\n          {\n            flex: '0 1 100%',\n          },\n      ),\n      rules.add(\n          [{ u: [':', 'host'], $: Nav__qualifier }, { e: 'a', $: Nav__qualifier }],\n          settings.do(mapAfter(navLinkStyle)),\n      ),\n      rules.add(\n          [{ u: [':', 'host'], $: Nav__qualifier }, { e: 'a', c: ['active', Wesib__NS], $: Nav__qualifier }],\n          settings.do(mapAfter(activeNavLinkStyle)),\n      ),\n  );\n}\n\nfunction navStyle(\n    {\n      $fontSize,\n    }: ThemeSettings,\n): StypProperties {\n  return {\n    padding: 0,\n    margin: `0 ${$fontSize.div(2)} 0 0`,\n  };\n}\n\nexport function navLinkBackground({ $bgColor }: ThemeSettings): StypColor {\n  return $bgColor.hsl.set(({ l }) => ({ l: l * 0.8 }));\n}\n\nfunction navLinkStyle(\n    settings: ThemeSettings,\n): StypProperties {\n\n  const { $fontSize } = settings;\n\n  return {\n    display: 'block',\n    margin: 0,\n    padding: `${$fontSize.div(2)} ${$fontSize}`,\n    border: 0,\n    outline: 0,\n    background: navLinkBackground(settings),\n  };\n}\n\nfunction activeNavLinkStyle(\n    {\n      $fontSize,\n      $color,\n      $bgColor,\n    }: ThemeSettings,\n): StypProperties {\n\n  const borderW = StypLengthPt.of(4, 'px');\n\n  return {\n    background: $bgColor,\n    borderLeft: `${borderW} solid ${$color}`,\n    paddingLeft: $fontSize.sub(borderW),\n  };\n}\n","import { makePushIterable } from '../base';\nimport { iterateOverIndexed } from '../base/iterate-over-indexed.impl';\nimport type { IndexedItemList } from '../construction';\nimport type { PushIterable } from '../push-iterable';\n\n/**\n * Creates a {@link PushIterable | push iterable} with the results of calling a provided function on every item of the\n * given indexed list.\n *\n * @typeParam TSrc - A type of indexed list items.\n * @typeParam TConv - A type of converted elements.\n * @param indexed - A source indexed items list.\n * @param convert - A function that produces an element of new iterable, taking list item as the only parameter.\n *\n * @returns New push iterable of transformed elements.\n */\nexport function mapIndexed<TSrc, TConv>(\n    indexed: IndexedItemList<TSrc>,\n    convert: (this: void, element: TSrc) => TConv,\n): PushIterable<TConv> {\n  return makePushIterable(iterateOverIndexed(\n      indexed,\n      (list, index) => convert(list.item(index) as TSrc /* The index is always valid */),\n  ));\n}\n","import { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { RenderDef } from '@wesib/wesib';\nimport { navElement } from './nav-element';\nimport { NavLink } from './nav-link';\n\ntype GenericElement = Element;\n\nexport namespace NavAnchor {\n\n  /**\n   * Anchor element.\n   */\n  export interface Element extends GenericElement {\n\n    /**\n     * Hyper-reference of this anchor.\n     */\n    readonly href: string;\n\n  }\n\n  /**\n   * Navigation anchor construction options.\n   */\n  export interface Options {\n\n    /**\n     * Type or types of events to handle.\n     *\n     * `click` by default.\n     */\n    readonly event?: string | readonly string[];\n\n    /**\n     * Qualified name of CSS class to mark the active anchor element with.\n     *\n     * The `active` class in Wesib namespace is used by default.\n     */\n    readonly active?: QualifiedName;\n\n    /**\n     * Rendering definition options to pass to nav links render scheduler.\n     */\n    readonly render?: RenderDef.Options;\n\n  }\n\n}\n\n/**\n * Creates navigation link for the given anchor element.\n *\n * @param element - Either an anchor element, or a function returning one by the given navigation link owner.\n * @param options - Custom anchor options.\n *\n * @returns Navigation link provider.\n */\nexport function navAnchor(\n    element:\n        | NavAnchor.Element\n        | ((this: void, owner: NavLink.Owner) => NavAnchor.Element),\n    options?: NavAnchor.Options,\n): (this: void, owner: NavLink.Owner) => NavLink;\n\n/**\n * Optionally creates navigation link for the given anchor element.\n *\n * @param element - Either an anchor element, or a function returning one by the given navigation link owner,\n * or nothing.\n * @param options - Custom anchor options.\n *\n * @returns Navigation link provider.\n */\nexport function navAnchor(\n    element:\n        | NavAnchor.Element\n        | ((this: void, owner: NavLink.Owner) => NavAnchor.Element | null | undefined)\n        | null\n        | undefined,\n    options?: NavAnchor.Options,\n): NavLink.Provider;\n\nexport function navAnchor(\n    element:\n        | NavAnchor.Element\n        | ((this: void, owner: NavLink.Owner) => NavAnchor.Element | null | undefined)\n        | null\n        | undefined,\n    options: NavAnchor.Options = {},\n): NavLink.Provider {\n  return navElement(\n      element,\n      {\n        ...options,\n        href(element) {\n          return element.href;\n        },\n      },\n  );\n}\n","import { QualifiedName } from '@frontmeans/namespace-aliaser';\nimport { stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { ProduceStyle, Theme } from '@wesib/generic/styp';\nimport { BootstrapContext, Component, ComponentContext } from '@wesib/wesib';\nimport { Examples__NS } from '../examples.ns';\nimport { mediaStyle, ThemeSettings } from '../theme';\nimport { MainComponent, mainStyle } from './main.component';\nimport { NavComponent } from './nav.component';\n\n@Component({\n  name: ['container', Examples__NS],\n  feature: {\n    needs: [\n      MainComponent,\n      NavComponent,\n    ],\n  },\n})\nexport class ContainerComponent {\n\n  constructor(private readonly _context: ComponentContext) {\n  }\n\n  @ProduceStyle()\n  async style(): Promise<StypRules> {\n\n    const { elementDef: { name: mainName } } = await this._context.get(BootstrapContext).whenDefined(MainComponent);\n\n    return this._context.get(Theme).style(ContainerStyle(mainName!));\n  }\n\n}\n\nconst Container__qualifier = 'bex:container';\n\nfunction ContainerStyle(mainName: QualifiedName): (theme: Theme) => StypRules {\n  return theme => {\n\n    const settings = theme.ref(ThemeSettings).read;\n    const { root: { rules } } = theme;\n\n    return stypRules(\n        rules.add(\n            { u: [':', 'host'], $: Container__qualifier },\n            {\n              height: '100%',\n              display: 'flex',\n              flexFlow: 'row wrap',\n              alignItems: 'stretch',\n              alignContent: 'flex-start',\n            },\n        ).add(\n            settings.do(mapAfter(mediaStyle)),\n        ),\n        rules.add(\n            { u: [':', 'host'], $: [Container__qualifier, '@media:sm'] },\n            {\n              height: 'auto',\n            },\n        ),\n        rules.add(\n            [{ u: [':', 'host'], $: Container__qualifier }, { e: mainName, $: Container__qualifier }],\n            settings.do(mapAfter(mainStyle)),\n        ),\n    );\n  };\n}\n","import { PageLoadSupport } from '@wesib/generic';\nimport { StyleProducerSupport } from '@wesib/generic/styp';\nimport { Feature } from '@wesib/wesib';\nimport { ContainerComponent } from './container.component';\n\n@Feature({\n  needs: [\n    ContainerComponent,\n    PageLoadSupport,\n    StyleProducerSupport,\n  ],\n})\nexport class LayoutSupportFeature {\n}\n","import { produceBasicStyle, stypDomFormat } from '@frontmeans/style-producer';\nimport { ComponentStypDomFormat, ComponentStypFormat, Theme } from '@wesib/generic/styp';\nimport { Feature } from '@wesib/wesib';\nimport { BodyStyle } from './body.style';\n\n@Feature({\n  setup(setup) {\n    setup.perComponent({ a: ComponentStypFormat, as: ComponentStypDomFormat });\n  },\n  init(context) {\n    context.whenReady(() => {\n      produceBasicStyle(context.get(Theme).style(BodyStyle), stypDomFormat());\n    });\n  },\n})\nexport class BodyStyleSupport {}\n\n","import { Feature } from '@wesib/wesib';\nimport { FormsSupport } from './forms/forms-support.feature';\nimport { LayoutSupportFeature } from './layout';\nimport { BodyStyleSupport } from './theme/body-style-support.feature';\n\n@Feature({\n  needs: [\n    BodyStyleSupport,\n    FormsSupport,\n    LayoutSupportFeature,\n  ],\n})\nexport class AppFeature {}\n","import { InputAspects__NS } from '@frontmeans/input-aspects';\nimport { mixStypColors, StypProperties, stypRules, StypRules } from '@frontmeans/style-producer';\nimport { mapAfter } from '@proc7ts/fun-events';\nimport { Theme } from '@wesib/generic/styp';\nimport { FormThemeSettings } from './form.theme-settings';\n\nexport function FormStyle(theme: Theme): StypRules {\n\n  const formSettings = theme.ref(FormThemeSettings).read;\n  const { root: { rules } } = theme;\n\n  return stypRules(\n      rules.add({ e: 'input' }, formSettings.do(mapAfter(inStyle))),\n      rules.add({ e: 'input', s: '[readonly]' }, formSettings.do(mapAfter(readonlyInStyle))),\n      rules.add({ e: 'input', s: '[disabled]' }, formSettings.do(mapAfter(readonlyInStyle))),\n      rules.add({ e: 'input', s: ':focus' }, formSettings.do(mapAfter(focusedInStyle))),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['invalid', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          formSettings.do(mapAfter(invalidInStyle)),\n      ),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['missing', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          {\n            outlineStyle: 'dotted',\n          },\n      ),\n      rules.add(\n          {\n            e: 'input',\n            c: [\n              ['incomplete', InputAspects__NS],\n              ['touched', InputAspects__NS],\n            ],\n          },\n          {\n            outlineStyle: 'dotted',\n          },\n      ),\n  );\n}\n\nexport function inStyle(\n    {\n      $color,\n      $fontFace,\n      $fontSize,\n      $lineHeight,\n      $fontWeight,\n      $marginV,\n      $marginH,\n      $paddingV,\n      $paddingH,\n      $bgColor,\n      $borderColor,\n      $borderW,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    color: $color,\n    font: `normal ${$fontWeight} ${$fontSize}/${$lineHeight} ${$fontFace}`,\n    padding: `${$paddingV} ${$paddingH}`,\n    margin: `${$marginV} ${$marginH}`,\n    backgroundColor: $bgColor,\n    border: '0 none',\n    outline: `${$borderW} solid ${$borderColor}`,\n    boxShadow: 'inset 1px 1px 2px -2px black',\n    boxSizing: 'border-box',\n    width: '100%',\n  };\n}\n\nexport function readonlyInStyle(\n    {\n      $roBgColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    backgroundColor: $roBgColor,\n  };\n}\n\nfunction focusedInStyle(\n    {\n      $color,\n      $borderColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    outlineColor: mixStypColors($borderColor, $color, 0.5),\n  };\n}\n\nfunction invalidInStyle(\n    {\n      $color,\n      $borderW,\n      $borderColor,\n    }: FormThemeSettings,\n): StypProperties {\n  return {\n    outline: `${$borderW.mul(2)} dashed ${mixStypColors($borderColor, $color, 0.25)}`,\n  };\n}\n","import { bootstrapComponents } from '@wesib/wesib';\nimport { AppFeature } from './app.feature';\n\nexport * from './app.feature';\nexport * from './examples.ns';\nexport * from './forms';\nexport * from './theme';\n\nexport const examplesContext = bootstrapComponents(AppFeature);\n","import { newNamespaceAliaser } from '@frontmeans/namespace-aliaser';\nimport { ContextModule } from '@proc7ts/context-values/updatable';\nimport { AfterEvent, AfterEvent__symbol, onceOn, OnEvent, trackValue, valueOn, valueOn_ } from '@proc7ts/fun-events';\nimport { Class, valueProvider } from '@proc7ts/primitives';\nimport { SupplyPeer } from '@proc7ts/supply';\nimport { ComponentClass, DefinitionContext } from '../../component/definition';\nimport { FeatureDef, FeatureRef, FeatureStatus } from '../../feature';\nimport { FeatureModule } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapContextRegistry } from '../impl';\nimport { whenDefined } from '../impl/when-defined.impl';\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features - Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapContextRegistry = BootstrapContextRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.load(feature)\n      .read\n      .do(\n          valueOn_(({ ready }) => ready),\n          onceOn,\n      )\n      .then(complete)\n      .catch(console.error);\n\n  return bootstrapContext;\n}\n\n/**\n * @internal\n */\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\n/**\n * @internal\n */\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n\n/**\n * @internal\n */\nfunction initBootstrap(\n    bootstrapContextRegistry: BootstrapContextRegistry,\n): {\n  bootstrapContext: BootstrapContext;\n  complete(): void;\n} {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const values = bootstrapContextRegistry.values;\n\n  class BootstrapContext$ extends BootstrapContext {\n\n    readonly whenReady: OnEvent<[BootstrapContext]>;\n    readonly get = values.get;\n\n    constructor() {\n      super();\n      this.whenReady = stage.read.do(\n          valueOn(bsStage => !!bsStage && this),\n          onceOn,\n      );\n      bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    whenDefined<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionContext<T>]> {\n      return whenDefined(this, componentType);\n    }\n\n    load(feature: Class, user?: SupplyPeer): FeatureRef {\n\n      const module = FeatureModule.of(feature);\n      const supply = bootstrapContextRegistry.provide(module);\n\n      if (user) {\n        supply.needs(user);\n      } else {\n        user = supply;\n      }\n\n      const use = this.get(module).use(user);\n      const read = FeatureRef$read(feature, use);\n\n      return {\n        read,\n        whenReady: read.do(\n            valueOn_(status => status.ready && status),\n            onceOn,\n        ),\n        [AfterEvent__symbol]: valueProvider(read),\n        supply,\n      };\n    }\n\n  }\n\n  const bootstrapContext = new BootstrapContext$();\n\n  return {\n    bootstrapContext,\n    complete(): void {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n\nfunction FeatureRef$read(\n    feature: Class,\n    use: ContextModule.Use,\n): AfterEvent<[FeatureStatus]> {\n\n  const status = trackValue<FeatureStatus>({ feature, ready: false });\n\n  use.read(({ module, ready }) => {\n\n    const feature = (module as FeatureModule).feature;\n    const lastStatus = status.it;\n\n    if (!lastStatus || lastStatus.feature !== feature || lastStatus.ready !== ready) {\n      status.it = {\n        feature,\n        ready,\n      };\n    }\n  }).needs(use);\n  status.supply.needs(use);\n\n  return status.read;\n}\n"],"names":["arrayOfElements","value","Array","isArray","areTheSame","first","second","valueProvider","valuesProvider","values","lazyValue","provider","get","lazyValue$recurrent","TypeError","valueByRecipe","recipe","args","valueRecipe","arrayElementsAreEqual","elementsAreEqual","fromOrLength","to","start","end","undefined","Math","max","length","i","elementOrArray","source","array","from","setOfElements","elements","Set","extendSetOfElements","set","forEach","element","add","superClassOf","type","satisfying","prototype","Reflect","getPrototypeOf","superType","constructor","asis","countArgs","len","idx","mergeFunctions","merge","_f","s","apply","this","noop","hasOwnProperty$","Object","hasOwnProperty","target","key","call","isPresent","isDefined","PushIterator__symbol","Symbol","isPushIterable","iterable","iteratorOf","iterator","makePushIterable","iterate","[object Object]","PushIterable$iterator","pushIterated","accept","isOver","makePushIterator","forNext","over","PushIterator$dontIterate","PushIterator$iterator","next","PushIterator$next","result","done","PushIterator$noNext","_accept","emptyPushIterator","pushHead","iterateOverIndexed","indexed","elementOf","goOn","arrayElementOf","index","iterateOverArray","overArray","itsIterated","it","status","itsEach","action","itsElements$defaultConverter","itsElements","convert","pushedElements","push","pushedEmpty","isEmpty","_element","itsEvery","test","allMatch","itsFirst","pushedFirst","rawFirst","toPushIterator","res","rawIteratorPusher","itsHead","arrayHead","rawIterableHead","itsIterator","itsReduction","reducer","initialValue","reduced","overNone","overIterator","iterateOverRawIterator","overElementsOf","sources","src","srcTail","iterateOverSubElements","overOne","iterateOverOneValue","overKeys","ownKeys","filterArray","iterateOverFilteredIndexed","filterIt","filterPusher","filterRawPusher","tail","flatMapArray","elementsOf","flatMapArray$defaultElementOf","subs","subsTail","flatMapIt","flatMapIt$defaultConverter","flatMapPusher","flatMapRawPusher","lastSrc","sourceTail","mapIt","mapPusher","mapRawPusher","valueIt","valueOf","valuePusher","valueRawPusher","overEntries","Supply$unexpectedAbort","Supply$unexpectedAbort$byDefault","reason","console","error","Supply$off$unexpected$reasons","Supply$off","Supply$off$start","prevOff","Supply$off$end","reasons","SupplyState__symbol","SupplyState$done","isOff","off","SupplyState$done$off","_supply","callback","SupplyState$off","_reason","SupplyState$noCallback","supply","Supply$off$unexpected","SupplyState$withCallback","prev","Supply","handler","Supply$unexpectedAbort$handle","whenOff","Promise","resolve","reject","another","needs","cuts","AlwaysSupply","_callback","_another","alwaysSupply$","alwaysSupply","isAlwaysSupply","NeverSupply","neverSupply$","neverSupply","ContextKeyError","Error","message","super","ContextKey__symbol","ContextKey","name","ContextSeedKey","seedKey","opts","seeder","seed","hasFallback","insert","ContextValues","Contextual__symbol","isContextual","IterativeContextSeeder","Map","_providers","delete","context","initial","providers","bind","iterativeSeed","itsEmpty","IterativeSeedKey","IterativeContextKey","MultiContextKey","byDefault","slot","defaultSources","SimpleContextSeeder","entry","unshift","splice","lastIndexOf","makeSeed","seeds","map","combineSimpleSeeds","SimpleSeedKey","SimpleContextKey","SingleContextKey","ContextSupplyKey","or","ContextSupply","ContextBuilder__symbol","ContextSeeders","_initial","found","_issuers","issuer","factory","isValueSpecWithDeps","spec","ContextValueSlot$","seeders","_opts","newSeed","_constructed","grow","setup","prevSetup","_setup","ContextRegistry","_seeders","isContextBuilder","a","by","isValueSpecByProvider","with","deps","dep","isConstantValueSpec","is","isValueSpecViaAlias","via","ctx","isValueSpecAsInstance","isSelfInstanceValueSpec","as","toAsInstance","Type","DepType","JSON","stringify","contextValueSpec","provide","newValues","registry","cached","constructed","_grow","newContextValues","other","otherSeeds","combine","amenderOf","amendment","isAmendatoryAmendment","applyAmendment","isAmendatory","noopAmender","_target","allAmender","amendments","amender","amendBy","amend","request","nextTarget","newAmendTarget","options","base","baseAmend","createBase","nextBase","nextRequest","modify","AmendTarget$default$modify","AeClass$target","AeClass$target$amend","_base","AeClass","decorateAmended","decorator","amendedClass","autoAmended","WeakSet","has","superClass","autoAmend","AeProp$notReadable","host","_instance","kind","pName","cls","AmendProp$accessString","AeProp$notWritable","_update","AeProp$idPattern","String","AeProp","createHost","hostClass","decorated","descriptor","getValue","setValue","toAccessor","instance","update","valueKey","vDesc","writeValue","writable","superProto","hostInstance","createAePropAccessor","init","enumerable","configurable","readable","baseTarget","$key","$readable","$writable","$get","$set","baseRequest","createBaseTarget","createAePropApplicator","desc","classTarget","newDescriptor","defineProperty","targetHost","aeClass","AeMember$HostKind","AeMember$createHost","AeMember$hostClass","proto","Naming","nsAlias","local","ns","DefaultNaming","alias","default__naming","html__naming","XmlNaming","id__naming","CssNaming","css__naming","NamespaceDef","url","aliases","naming","applyAlias","isQualifiedName","isNameAndNamespace","compareNames","compareStrings","firstName","firstUrl","newNamespaceAliaser","aliasesByNs","nsNumPerAlias","mostPreferred","nsNumRegistered","preferred","ids","generated","AfterEvent__symbol","isEventKeeper","eventReceiver","receiver","receive","_context","event","EventReceiver$doDonReceive","_event","receiveByEach","receivers","send","sendNonRecurrent","actualReceivers","received","recurrent","processEvent","shift","recurrentReceivers","recurrentReceiver","recurrentEvent","EventNotifier","rcs","_rcs","clear","size","generic","OnEvent__symbol","isEventSender","NoEventsError","sendEventsTo","AfterEvent$noFallback","digEvents","input","extract","nestedSupply","prevSupply","extracted","OnEvent$do","processors","reduce","arg","OnEvent$supplier","onceEvent","supplier","OnEvent$then","onEvent","onCutOff","e","_ctx","shareEvents","sharer","EventSharer","on","_on","_onInit","initialEvents","sharedSupply","onFirst","_onFirst","dispatch","_onNext","_addReceiver","supplyEvents","required","dependentSupply","translateEvents","translate","neverReceive","onEventBy","register","do","then","afterEventBy","fallback","cleanup","AfterEvent$noCleanup","lastEvent","numReceivers","afterEvent","dest","reported","isAfterEvent","isOnEvent","afterAll","keys","afterEach","afterSent","sender","afterSupplied","afterThe","afterValue","consumeEvents","consume","consumerSupply","shareAfter","deduplicateAfter$default","deduplicateAfter_$default","deduplicateAfter","isSimilar","getCue","deduplicateAfter$create","processor","deduplicateAfter_","deduplicateAfter_$create","deduplicateAfter$noPrior","deduplicateAfter$isDuplicate","prior","nextEvent","_","compareOrFromOrLength","digAfter","digAfter_","extractKeeper","events","EventEmitter","onNever","onSupplied","onAny","suppliers","remained","removeSupplier","onPromise","promise","alwaysReceiveValue","catch","shareOn","digOn_","extractSender","translateOn","mapper","translateOn_","mapAfter","mapAfter_","mapOn","mapOn_","onceAfter","onceOn","supplyOn","resolveOnOrdered","sourceSupply","numInProcess","numSent","numReceived","lastIndex","resolveOn","toSend","supplyAfter","translateAfter","translateAfter_","valueOn","valueOn_","statePath","path","PathEntry","_drop","emitter","newValue","oldValue","nested","_nested","slice","_dropIfEmpty","dontCreateMissing","created","_remove","Trackers","_entry","_root","nest","SubStateTracker","_trackers","_path","_tracker","onUpdate","StateTracker","subTracker","track","ValueTracker","valueReceiver","onRecurrent","recurrentValue","read","acceptValuesFrom","byNone","container","_by","TrackedValue","_it","trackValue","trackValueBy","ValueSync","old","third","syncWithTracker","tracker","syncTrackers","extractTracker","tracker1","tracker2","supply1","supply2","OnDomEvent$sample","OnDomEvent$context","DomEventDispatcher","onDomEvent","listener","onDomEventBy","domListener","addEventListener","removeEventListener","dispatchEvent","contextDestroyed","flatUpSources","ContextUpSeeder","providersTracker","prov","toUpSrcKeeper","upSrcKeepers","ContextSeed$UpKey","upKey","ContextUpKey$UpKey","_key","fillBy","ContextUpKey","applyContextAfter","applyContextAfter_","FnContextKey","createUpKey","fns","delegated","fn","ContextModuleDependencyError","module","dependencies","out","contextModuleDependencyErrorMessage","ContextModuleUsage","_impl","_rev","provided","used","settled","ready","contextSupply","_load","handle","use","user","_use","rev","_updateStatus","async","moduleInit","ContextModuleInit","initBy","loadContextModule","whenReady","impl","_useCounter","whenSettled","ContextModule$Use$when","isContextModuleSettled","isContextModuleReady","_module","_ready","_whenDone","finally","_done","_init","ContextModuleKey","usage","createHandle","implementBy","candidates","ContextModule$impl__symbol","ContextModule$","replaced","contextModuleDeps","loadContextModuleDeps","whenContextModuleSettled","whenContextModuleReady","whenLoaded","notLoaded","whenDone","race","all","results","failures","filter","ContextModule","replace","nodeDocument","node","ownerDocument","isElementNode","nodeType","importNode","beforeOrImport","importContent","importNodeContent","before","doc","elementClone","createElement","tagName","toLowerCase","getAttributeNames","attr","setAttribute","getAttribute","insertBefore","nodeClone","childNodes","nodeHost","parentNode","getRootNode","RenderScheduleConfig","win","window","defaultView","RenderQ__symbol","RenderQ","q","ref","schedule","doSchedule","execute","recur","execRecurring","execNonRecurring","queue","shot","config","RenderQ$doNotSchedule","postponed","execution","reset","suspend","postpone","post","exec","resume","pull","scheduled","_config","customRenderScheduler","scheduleOptions","queueRef","newQueue","enqueued","lastQueue","executed","nextQueue","activeQueue","nextEnqueued","RenderQueue","scheduleRecurrent","RenderQueue$doNotReplace","task","replaceQueue","_replacement","animationRenderQueues","WeakMap","animationRenderScheduler","existing","requestAnimationFrame","replacement","asyncRenderQueue$schedule","asyncRenderQueue","asyncRenderScheduler","immediateRenderScheduler","last","pop","immediateRenderQueue","queuedRenderScheduler","defaultRenderScheduler","newRenderSchedule","DrekContext$registrar","DrekContext$autoRegister","DrekContext$dontRegister","DrekContext$autoRegistrar","DrekContext$autoRegisterFirst","registered","DrekContext$createAutoRegistrar","lift","drekBuild","builder","resetRegistrar","registrar","priorRegistrar","DrekContext$setRegistrar","DrekPlacement$Status__symbol","DrekPlacement$Status","placement","onceConnected","readStatus","connected","eventCtx","whenConnected","DrekPlacement","DrekContext","DrekContext__symbol","DrekContext$State","scheduler","_nsAlias","_scheduler","DrekContext$ofDocument","document","state","view","fragment","DrekContext$ofRootNode","root","derivedCtx","getFragment","newRoot","composed","lifted","DrekContext$Unrooted","DrekContext$register","DrekContext$unrooted","drekContextOf","DrekCssClasses__symbol","DrekCssClasses$","className","_add","render","n","classList","remove","_uses","contains","_has","renderIn","newContext","DrekFragment$Context__symbol","DrekFragment$Context","_fragment","_content","withinFragment","_getFragment","_lift","_status","_state","_createSchedule","_whenSettled","_settled","content","createDocumentFragment","placeContent","_rendered","_whenRendered","_createExecution","fragmentExecution","_execution","DrekFragment","attach","innerContext","whenRendered","_settle","_render","drekAppender","appendChild","drekCharger","charger","DrekCharger$custom","charge","DrekCharger$commentWrapper","random","toString","substr","rem","wrapContent","createComment","range","createRange","setStartAfter","setEndBefore","deleteContents","insertNode","append","WorkDoneError","workload","work","workName","Workload","allocator","_work","OrderedTasks","_allotment","_queues","TaskQueue","enqueue","run","_tasks","_runNext","WorkOrdering","allotment","WorkStage","workbench","runner","WorkStageRunner","stage","_whenAllDone","_end","_task","_start","_addTask","taskPromise","taskDone","_whenTaskDone","whenStarted","_awaitDeps","addDep","$","runAfter","after","Workbench$impl__symbol","Workbench$","_run","Workbench$run","_works","ensureWorking","runWorkTask","setWork","runTask","whenWork","newWork","_workload","Workbench","escapeCSS","text","charCodeAt","c","escapeCSSVal","uppercasePattern","toHyphenLower","letters","offset","str","lowerCase","hyphenateCSSName$cache","hyphenateName","hyphenateDecapName","hyphenated","startsWith","BootstrapContext__key","BootstrapContext","bootstrapDefault","bootstrapContext","MetaAccessor","symbol","ownDef","own","superDef","of","metas","prevMeta","newMeta","mergeInitMethods","target1","method1","target2","method2","m1","m2","FeatureDef__symbol","FeatureMeta","defs","def","featureMeta","FeatureDef","featureType","define","Feature","featureDefs","featureAmendments","isFeatureAmendment","featureDef","Feature$toAmender","defRequest","FeatureContext__key","FeatureContext","componentType","whenDefined","feature","load","BootstrapWorkbench","featureSetupStage","featureInitStage","componentDefStage","ComponentDef__symbol","ComponentMeta","meta","componentMeta","ComponentDef","Component","componentDefs","componentAmendments","isComponentAmendment","componentDef","Component$toAmender","ComponentContext__key","ComponentEventDispatcher__key","dispatcher","ContentRoot","StateUpdaterKey","combined","StateUpdater","ComponentContext__symbol","ComponentContext","updateState","component","contentRoot","ComponentMember","AeMember","ComponentSlot$empty","unbind","rebind","drop","ComponentSlot$","_provider","ComponentSlot$known","binder","getContext","newSupply","bindContext","ComponentSlot$bound","ComponentSlot__symbol","ComponentSlot","BootstrapContextRegistry__key","BootstrapContextRegistry","PerComponentRegistry","ComponentContextRegistry","PerDefinitionRegistry","bsContext","DefinitionContextRegistry","PostDefSetup__symbol","postDefSetup","superPostDefSetup","BootstrapWindow","DefaultNamespaceAliaser","RenderScheduler$Key","RenderScheduler$adopt","DefaultPreRenderScheduler","DefaultRenderScheduler","DocumentRenderKit","docs","DefinitionContext__symbol","definitionContextOf","CustomElements__key","customElements","CustomElements","componentTypeOrName","elementType","defContext","extend","elementDef","extends","componentResolver","ComponentResolver__symbol","resolvePromise","rejectPromise","buildPromise","settle","resolution","newPromiseResolver","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","ComponentConstructor__symbol","newComponent","context__symbol","defaultContext","prevContext","newComponentConstructor","ComponentStatus","_val","onceReady","ComponentStatus$once","onceSettled","_canSettle","componentCtx","ComponentContext$","_definitionContext","_newComponentRegistry","_component","componentDestroyed","isReady","isSettled","isConnected","whenComponent","_whenComponent","lastRev","readNotifier","notifier","_elementBuilder","components","connect","create","ComponentContext$Mounted","mounted","ComponentContext$Custom","WhenComponent","currentRev","onCreated","receiverRev","eventContext","componentContext","notifiedRev","recurrentContext","DefinitionContext$","_bsContext","_whenReady","_def","definitionContextRegistry","parentPerComponentRegistry","_perComponentRegistry","definitionSetup","perDefinition","perComponent","_elementType","_createComponent","drekContext","contextOf","_connect","_created","definitions","renderKit","CustomElement$","bindBy","connectedCallback","disconnectedCallback","customElementType","ElementBuilder","definitionContext","_define","ComponentRegistry","_components","_defineAll","elementBuilder","buildElement","FeatureContext$","_componentRegistry","onDefinition","_onDefinition","onComponent","_onComponent","onPostDefSetup","FeatureModule__symbol","FeatureModule","featureContext","whenInit","FeatureModule$options","WhenDefined__symbol","AttributePath__root","attributePathTo","attributeStateUpdate","updateAttributeState","AttributeRegistry","AttributeRegistry$","mount","change","attrs","observedAttributes","attributeChangedCallback","attributeFilter","MutationObserver","records","record","attributeName","observe","attributes","attributeOldValue","alreadyObserved","newAttrs","prevCallback","attrChanged","Attribute","propertyKey","parseAttributeDescriptor","declareAttribute","removeAttribute","ComponentStateKey","ComponentState","ComponentState__key","AttributeTracker","_name","trackAttribute","RenderPath__root","RenderDef","trigger","ComponentRenderCtl$","renderer","ComponentRenderer$State","preRenderer","ComponentPreRenderer$State","ComponentRenderer$BaseState","_ctl","_renderer","_spec","when","_scheduleRenderer","_cancel","_scheduleBy","rendererExecution","currentRenderer","_over","renderBy","ComponentPreRenderer$done","_preSupply","_nextRenderer","preScheduler","preRendererExecution","preRenderBy","ComponentRenderCtl","ComponentRenderScheduler","renderCtl","recentShot","ShadowContentRoot","ShadowRootBuilder","attachShadow","shadowRoot","shadowRootOf","defaultShadowContentDef","mode","AttachShadow","Wesib__NS","DeltaSet","_added","_removed","deltaSetDeltaReceiver","removed","added","nullInAspect$","convertTo","nullInAspect","knownInAspect","inconvertibleInAspect","control","aspectKey","builtInAspect$","builtInAspect","build","origin","attachTo","aspect","InAspect__symbol","InputAspects__NS","InNamespaceAliaser__aspect","applyTo","InNamespaceAliaser","applyAspect","InRenderScheduler__aspect","InRenderScheduler","InRole__aspect","InControlRole","InRole","InRole$Active","roles","active","role","_defaultSupply","isDefault","named","defaultSupply","activateBy","activator","prevActivator","_activate","_control","_active","activate","activators","_activators","activatedSupply","isAspectKey","noopInConversion","_aspect","noopInConverter","intoConvertedBy","valueOrAspectConverter","converters","converter","inConverter","aspectConverters","conversion","acf","cv","isInAspectConversion","intoConvertedAspects","aspects","InBuilder$Impl__symbol","InBuilder$Impl","_aspectsByKey","_commonAspects","_aspects","byKey","intoConvertedByKey","InBuilder","addAspect","addAspects","aspectKeyOrSetup","aspectSetup","InControl$Aspects__symbol","InControl$Aspects","applied","_byKey","application","_applyAspect","InControl","aspectList","InControl$SameValued","and","InControl$Converted","backward","convertAspect","prevValue","prevRev","InContainer__aspect","InContainer","InParents__aspect","InControlParents","InParents","allParents","_map","existingSupply","parent","InElement__aspect","InElement","InMode__aspect","InMode","ctrl","InControlMode","OwnModeTracker","initialInMode","DerivedInModes","_all","mergeInModes","derive","InParentsAspect","parentsInMode","derived","_derived","substring","lastUpdate","applyInMode","parents","parentList","modes","inModeValue","ro","InData__aspect","InData","hasData","InGroup__aspect","InGroup","RequireNothing$","requireNothing","dontRemove","InValidationMessages","validators","validatorMessages","validate","_messages","resultSupply","validator","validatorSupply","messages","entries","inValidator","InValidation__aspect","InValidation","validation","InControlValidation","noInValidationErrors","ok","hasBut","InValidationErrors","nonEmpty","code","codePresent","_byCode","codes","some","every","inValidationResult","controls","nestedInValidationMessages","numValidators","requireAll","requirePresent","missing","InSubmit__aspect","InSubmit","InControlSubmit","InSubmitError","errors","submit","InSubmitRejectedError","rejected","submitted","busy","flags","_flags","data","_errors","submitter","d","submitData","toInSubmitMessages","AbstractInElement","self","_get","_set","_value","doUpdate","correction","_input","listenForInput","onInput","inText","InFocus__aspect","InFocus","InControlFocus","inElement","owner","activeElement","focus","blur","InStatus__aspect","InStatus","InContainerStatus","InControlStatus","defaultInStatusFlags","hasFocus","touched","edited","updateInStatusFlags","elementInStatusFlags","_container","snapshot","inControlStatuses","combineInStatusFlags","markEdited","markTouched","inFormElement","form","notReady","invalid","inModeByForm","InStyledElement__aspect","InStyledElement","InCssClasses__aspect","InControlCssClasses","InCssClasses","UnsubscribeReason__symbol","isUnsubscribeReason","_sources","classes","mergeInCssClassesMap","classesSent","flag","delta","redelta","undelta","_schedule","controlSchedule","specs","names","inSupply","classesSupply","updateClasses","inCssError","mark","hasError","defaultInCssHasError","defaultInCssErrorMarks","marks","inCssErrorMarks","inCssInfo","md","vl","st","valid","hthvItem","t","v","x","p","pl","addParam","param","parseNone","datePattern","dateTimeParser","dateTime","parseDateTime","nextInItem","delimiterOf","itemParser","tagged","extra","parseAngleBrackets","angleBracketsParser","parseQuotedString","unquoted","quotedStringParser","parseExtra","tag","item","extraItem","nextInComment","spacesParser","paramParser","skipSpaces","parseItem","defaultDelimit"," ","\t",",",";","\"","\\","<",">","=","(",")","/",":","?","@","[","]","{","}","buildParserConfig","delimit","delimitConfig","defaultParserConfig","commentParserConfig","newHthvParser","parserConfig","parseItemDelimit","itemDelimitParser","parseParam","parseComment","comments","commentParser","headerValue","hthvParse","hthvQuote","string","escaped","quote","delimiter","FetchAgentKey","agents","fetch","agentIdx","agentRequest","agent","combineFetchAgents","defaultFetchAgent","HttpFetchAgent","HttpFetchAborted","HttpFetch","Request","responseEmitter","abortController","AbortController","signal","abort","response","customSignal","aborted","FragmentRenderCtl","FragmentRenderCtl$","RenderFragment$done","doRenderFragment","RenderFragment$justRender","RenderFragment$settleThenRender","RenderFragment$defaultTarget","getTarget","renderSupply","preExec","retainContent","renderExec","retain","renderFragment","upgrade","RenderFragment","renderFragmentBy","RenderFragment$defaultRem","RenderFragment$def","getHashURL","URL","hash","PageParam__symbol","PageParam","_page","NavigationAgentKey","navigate","agentTo","nextURL","title","nextTitle","nextData","baseURI","visited","current","put","defaultNavigationAgent","_when","_from","NavigationAgent","PageParamContext","NavHistory__key","NavHistory","extractNavData","_document","_location","location","_history","history","_uid","btoa","newEntry","href","_entries","id","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","page","pushState","_enter","fromEntry","_forget","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","wesib:navigation:data","_params","newHandle","_newContext","transferred","at","stay","EnterPageEvent","Event","cancelable","LeavePageEvent","StayOnPageEvent","Navigation__key","navHistory","nav","nextEntry","hashChange","Navigation","onEnter","onLeave","onStay","go","toURL","withParam","applyParams","open","targetOrCallback","navTarget","navTargetOf","applyAgent","whenLeave","doNavigate","prepared","leavePage","prepare","navigated","NavElement$activeClass","navElement","getHref","activeClass","anchor","ownerSupply","navigation","handleClick","pageURL","preventDefault","eventDispatcher","css","drekCssClassesOf","initialNsAlias","initialScheduler","deriveDrekContext","NavMenu$Links__symbol","NavMenu","links","NavMenu$Links","bindTo","_menu","_navLinks","_links","weigh","_weigh","defaultNavLinkWeight","afterLinks","linkValues","_replace","_updateActive","toAdd","linkOrProvider","link","toRemove","_deactivate","toDeactivate","toActivate","_selectActive","deactivated","activated","maxWeight","weight","menu","calcNavLinkWeight","linkURL","linkDir","navLinkPath2dir","pageDir","searchParamWeight","navLinkSearchParamsWeight","pathname","endsWith","searchParams","linkParams","pageParams","isIgnoredSearchParam","getAll","includes","PageLoadAgent","cachingPageLoader","loader","pageUrl","sup","tracked","onLoad","trackSupply","resp","num","requested","PageLoadAbortError","PageLoadRequestsParam","requests","PageLoadRequests","_navigation","_loader","_requests","fragments","pageSupply","loadSupply","_transfer","responseReceiver","getElementsByTagName","getElementById","onFragment","req","list","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","header","requestPageFragments","batch","parsePageDocument","parseFromString","head","querySelector","newBase","PageLoadParam$","PageLoadParam","PageCacheBuster__key","PageCacheBuster","appRev","urlModifier","newRev","reload","pageScriptsAgent","allScripts","externalScripts","scripts","querySelectorAll","script","pageStyleAgent","newStyles","oldStyles","oldStylesByHref","firstOldStyle","newStyle","oldStyle","nextSibling","style","removeChild","pageTitleAgent","textContent","PageLoadSupport__feature","buster","PageLoadSupport","PageRenderCtl","PageRenderCtl$","contentKey","RenderPage$contentKey$default","detectFragment","RenderPage$fragmentDetector","lastPageKey","responseTracker","fragExec","responseAndKey","pageKey","handleResponse","Share__symbol","isShareRef","ShareRegistry__key","ShareRegistry","share","elementName","sharers","_sharers","Sharers$addSharer","Sharers$addName","Sharers$new","counter","ShareKey","_share","selectValue","Share$impl__symbol","Share$","_aliases","addSharer","shareAs","priorityOffset","priority","shareValue","withPriority","SharedValue__symbol","SharedValue","hasDetails","SharedValue$Registrar","SharedValue$BoundRegistrar","applyContextTo","SharedValue$bindProvider","newPriority","SharedValue$detailedProvider","SharedValue$bareProvider","Share","consumer","b","Share$consumerStatus","Share$sharedValue","selected","details","shareLocator","locator","defaultSpec","valueFor","hostByDefault","localByDefault","shareByDefault","shareRef","Shareable$Internals__symbol","Shareable","body","Shareable$Internals","_source","_notBound","ShareAccessor","dynSync","val","_syncDyn","_syncVal","_valSupply","Shared","share$default","localShare$default","accessorKey","lastTarget","accessorOf","getShared","createRegistrar","SharedValue$ContextBuilder","localShare","$getShared","DefaultFormPreset","DefaultFormPreset$setup","nsAliaser","renderScheduler","FormPresetKey","FormPreset","FormPreset__key","FormPreset$rules__symbol","rules","setupField","FormPreset$setupField","setupForm","FormPreset$setupForm","FormPreset$noFieldSetup","_builder","FormPreset$noFormSetup","FormUnit","Field","providerBy","field","preset","Field$isDuplicateControls","FieldShare$map","FieldShare","FormShare$map","FormShare","adjacentField","adjacentTo","adjacentLocator","_sharer","adjusted","Field$nameByKey","FieldName","locateForm","defaultForm","defaultName","fieldName","autoName","unit","group","FormUnitName","Form__aspect","Form","elementFactory","formAspect","Form$isDuplicateControls","Form$provider","duplicate","FormScope","scope","defaultRole","AbstractFormPreset$map","AbstractFormPreset","ScopedFormConfig","createSetup","rest","ScopedFormConfig$isOptions","SharedField","defOrAmendment","locateForm$default","isReadonlyArray","isNotEmptyArray","StypValueStruct","prioritize","stypValuesEqual","StypColorStruct","StypRGB","coords","r","intCoord","g","coord","rgb","hsl","min","l","round","StypHSL","h","StypColor","hueAsFraction","hueToRgb","newT","mixStypColors","color1","color2","w","rgba1","rgba2","aDiff","w1","w2","StypNumericStruct","dim","toFormula","StypMapper","mappings","mapped","mappedValue","mapping","mappingBy","stypSplitPriority","trim","StypDimension","thisDim","pt","noPt","addendum","stypDimension","stypAddSub","subtrahend","multiplier","divisor","zero","StypCalcBase","left","op","right","usual","stypMul","stypDiv","StypAddSub","toDim","negate","StypMulDiv","Zero","_byPriority","important","ZeroByPriority","unitlessZeroDimensionKind","dimension","StypDimension_","isStypNumeric","StypLength","StypLengthPt","StypURL","noStypProperties","noStypPropertiesSpec","stypPropertiesBySpec","rule","preventDuplicates","propertiesKeeper","senderOrProperties","propertiesMap","properties","isDuplicateProperties","cloneProperties","$$css","propertyEntries","sentry","mergeStypProperties","baseProperties","addendumProperties","k","priorityOf","addValue","addValues","isCombinator","normalizeStypSelector","selector","normalizeKey","normalized","combinator","prevCombinator","part","normalizeStypSelectorPart","sort","normalizeClasses","u","isSubSelectorsArray","normalizeSubSelector","normalizeSubSelectors","isPseudoSubSelector","normalizeQualifiers","sub","prefix","params","qualifiers","exposeQualifier","noQualifiers","qualifier","eqIdx","indexOf","exposed","lastExposed","split","noKeyAndTail","stypRuleKeyAndTail","rootSelector","classesMatch","query","qClass","find","mClass","namesEqual","stypSelector","ruleKeyTextOpts","qualify","stypRuleKeyText","formatStypSelector","defaultFormat","format","hasProperties","subFormat","attrName","attrOp","attrVal","attrFlag","formatSubSelector","xmlNs","qualifyElement","formatItem","AtRulesRenderer","_rule","outer","onlyAtProperties","producer","writer","isGroup","sheet","atSelectors","extractPartAtSelectors","extractAtSelectors","restSelector","atSelector","buildAtSelector","addStyle","addGroup","customQuery","addQuery","namedQuery","stypRenderAtRules","order","isAtEntry","restQualifies","addAtSelector","colonIdx","prevQuery","stypRenderGlobals","FIRST_RENDER_ORDER","rootRule","importIndex","nsIndex","importDelta","renderImport","renderDefaultNamespace","renderNamespacePrefix","addGlobal","stypRenderProperties","notCustomProperty","hyphenateCSSName","stypRenderText","stypRenderXmlNs","xmlNsDefs","declareNs","rendererFactory","isRendererFactory","rendererSpec","compareRenderers","firstOrder","secondOrder","stypRenderScheduler","removeStyleElement","defaultPrettyPrint","indent","compactStypTextFormatter","nv","eol","pre","StypTextFormatter$","StypStyleTextWriter","f","nf","afterBody","AbstractStypGroupTextWriter","StypGroupTextWriter","StypSheetTextWriter","stypDomFormat","textFormat","pretty","formatter","idSeq","onSheet","addSheet","stypTextFormat","StypStyleObjectWriter","setProperty","cssText","StypGroupObjectWriter","ruleText","cssRules","insertRule","StypSheetObjectWriter","deleteRule","produceBasicStyle","selectorFormat","factories","addRenderers","renderers","addRenderer","stypRenderFactories","renderRule","trackRules","styleProducer","production","_selector","stypSelectorText","reader","renderAt","nextIndex","nextRenderer","nextProducer","rendererForRule","ruleSelector","lastSheet","defaultStypRenderers","produceStyle","StypRule","StypRuleList","StypRuleHierarchy","Rules","_list","ruleMatches","_buildList","_ruleSet","returnSelf","grabRules","stypQuery","stypSelectorMatches","AllRules","Self","selfRuleList","iterateAllRules","_updates","extendRule","propertiesSupply","sendUpdate","NestedRules","StypRule$","_outer","outerSelector","stypOuterSelector","empty","targetSelector","oldSpec","extendSpec","keyText","newNested","StypRuleRef","StypRuleRef$","ms","ps","watch","_mappings","_properties","RefStypRule","mappingsKeeper","StypRuleRefs","refs","fromAll","flattenProperties","referrers","noStypRules","stypRules","rulesByList","rulesFromSource","getRules","rulesByValue","evalRules","lazyStypRules","lazyRulesFromSource","ruleSet","reportExistingRules","lazyRules","asyncRules","ComponentStyleProducer","componentStypDomFormatConfig","defaultStypRenderScheduler","ComponentStypRenderer","ElementIdClass__NS","ElementIdClass","contextValues","aliaser","uniqueClassSeq","qualified","ComponentStypFormat__symbol","ComponentStypObjectFormat","ComponentStypFormat","newProducer","componentSupply","hostSelector","extractHostSelector","extendHostSelector","shadowRenderer","noShadowRenderer","restParts","createTextNode","stypObjectFormat","ComponentStypDomFormat","ProduceStyle","produce","StyleProducerSupport__feature","ThemeStyleKey","isId","prevProvider","hasId","combineStyles","ThemeStyle","theme","Theme__key","Theme$","Theme","referrer","_styles","styles","_rules","Examples__NS","ThemeSettings","$color","$bgColor","$fontFace","$fontSize","$lineHeight","$fontWeight","$linkFontWeight","$layoutBreakpoint","mediaStyle","@media:sm","LinkStyle","settings","linkStyle","textDecoration","color","fontWeight","DefaultStyle","defaultStyle","font","BodyStyle","height","margin","padding","bodyStyle","backgroundColor","FormThemeSettings","global","formMappings","$roBgColor","$errorFontSize","mul","$borderColor","$marginV","div","$marginH","$paddingV","$paddingH","$borderW","FieldErrorComponent","_code","indicator","adjacentToField","InErrorStyle","__decorate","hasError__cssClass","borderW","display","fontSize","borderLeft","paddingLeft","FormsSupport","_byValidity","byValidity","ignore","validity","inModeByValidity","_byForm","byForm","_info","info","_error","MainComponent","mainStyle","flex","drekReplacer","renderPageBy","NavComponent","_theme","mapIndexed","el","navAnchor","NavStyle","navStyle","sts","background","navLinkBackground","navLinkStyle","activeNavLinkStyle","border","outline","ContainerComponent","mainName","flexFlow","alignItems","alignContent","ContainerStyle","LayoutSupportFeature","BodyStyleSupport","AppFeature","FormStyle","formSettings","inStyle","readonlyInStyle","focusedInStyle","invalidInStyle","outlineStyle","boxShadow","boxSizing","width","outlineColor","examplesContext","features","bootstrapContextRegistry","complete","BootstrapContext$","bsStage","lastStatus","FeatureRef$read","initBootstrap","bootstrapComponents"],"mappings":"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"}