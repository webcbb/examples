{"version":3,"file":"wesib.45ff9dcd.m.js","sources":["../../node_modules/@wesib/wesib/src/boot/bootstrap-context.key.impl.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap-context.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap-default.ts","../../node_modules/@wesib/wesib/src/component/definition/component-factory.ts","../../node_modules/@wesib/wesib/src/boot/globals/bootstrap-window.ts","../../node_modules/@wesib/wesib/src/boot/globals/bootstrap-root.ts","../../node_modules/@wesib/wesib/src/boot/globals/default-namespace-aliaser.ts","../../node_modules/@wesib/wesib/src/boot/globals/default-render-scheduler.ts","../../node_modules/@wesib/wesib/src/common/types.impl.ts","../../node_modules/@wesib/wesib/src/common/array-set.ts","../../node_modules/@wesib/wesib/src/common/classes.ts","../../node_modules/@wesib/wesib/src/common/decorators.ts","../../node_modules/@wesib/wesib/src/common/reflect.ts","../../node_modules/@wesib/wesib/src/common/functions.ts","../../node_modules/@wesib/wesib/src/common/is-element.ts","../../node_modules/@wesib/wesib/src/common/meta-accessor.ts","../../node_modules/@wesib/wesib/src/common/promises.ts","../../node_modules/@wesib/wesib/src/feature/feature-def.ts","../../node_modules/@wesib/wesib/src/feature/feature.decorator.ts","../../node_modules/@wesib/wesib/src/feature/feature-context.ts","../../node_modules/@wesib/wesib/src/feature/feature-needs-error.ts","../../node_modules/@wesib/wesib/src/component/component-def.ts","../../node_modules/@wesib/wesib/src/component/component.decorator.ts","../../node_modules/@wesib/wesib/src/component/component-context.key.impl.ts","../../node_modules/@wesib/wesib/src/component/component-event.key.impl.ts","../../node_modules/@wesib/wesib/src/component/content-root.ts","../../node_modules/@wesib/wesib/src/component/state-updater.ts","../../node_modules/@wesib/wesib/src/component/component-context.ts","../../node_modules/@wesib/wesib/src/component/component-event.ts","../../node_modules/@wesib/wesib/src/component/component-property.decorator.ts","../../node_modules/@wesib/wesib/src/boot/globals/element-adapter.ts","../../node_modules/@wesib/wesib/src/boot/globals/element-observer.ts","../../node_modules/@wesib/wesib/src/boot/impl/component-factory.symbol.impl.ts","../../node_modules/@wesib/wesib/src/component/definition/custom-elements.ts","../../node_modules/@wesib/wesib/src/component/definition/definition.context.key.impl.ts","../../node_modules/@wesib/wesib/src/component/definition/element-def.ts","../../node_modules/@wesib/wesib/src/component/definition/definition-context.ts","../../node_modules/@wesib/wesib/src/boot/impl/bootstrap-context-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/component-context-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/definition-context-registry.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/post-def-setup.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/when-component.impl.ts","../../node_modules/@wesib/wesib/src/boot/impl/element-builder.impl.ts","../../node_modules/@wesib/wesib/src/component/component-mount.ts","../../node_modules/@wesib/wesib/src/boot/impl/unloader.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/component-registry.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-loader.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-request.impl.ts","../../node_modules/@wesib/wesib/src/feature/loader/feature-requester.impl.ts","../../node_modules/@wesib/wesib/src/boot/bootstrap/bootstrap-components.ts","../../node_modules/@wesib/wesib/src/feature/feature-ref.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-descriptor.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-path.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-state-update.impl.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-registry.impl.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attributes-support.feature.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute.decorator.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attribute-descriptor.impl.ts","../../node_modules/@wesib/wesib/src/feature/attributes/attributes.decorator.ts","../../node_modules/@wesib/wesib/src/feature/state/component-state.ts","../../node_modules/@wesib/wesib/src/feature/state/state-support.feature.ts","../../node_modules/@wesib/wesib/src/feature/attributes/track-attribute.ts","../../node_modules/@wesib/wesib/src/feature/dom-properties/dom-property-path.ts","../../node_modules/@wesib/wesib/src/feature/render/element-renderer.ts","../../node_modules/@wesib/wesib/src/feature/render/render.decorator.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-content-root.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-dom-event.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-root-builder.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/shadow-dom-support.feature.ts","../../node_modules/@wesib/wesib/src/feature/shadow-dom/attach-shadow.decorator.ts","../../node_modules/@wesib/wesib/src/wesib.ns.ts","../../node_modules/@wesib/generic/src/fetch/fetch-agent-key.impl.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch-agent.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch.impl.ts","../../node_modules/@wesib/generic/src/fetch/http-fetch.ts","../../node_modules/@wesib/generic/src/hierarchy/hierarchy-updates.impl.ts","../../node_modules/@wesib/generic/src/hierarchy/hierarchy-context.ts","../../node_modules/@wesib/generic/src/hierarchy/hierarchy-registry.impl.ts","../../node_modules/@wesib/generic/src/tree/element-node.ts","../../node_modules/@wesib/generic/src/tree/element-node-list.ts","../../node_modules/@wesib/generic/src/tree/element-node-list.impl.ts","../../node_modules/@wesib/generic/src/tree/node-attributes.impl.ts","../../node_modules/@wesib/generic/src/tree/node-properties.impl.ts","../../node_modules/@wesib/generic/src/tree/element-node.impl.ts","../../node_modules/@wesib/generic/src/tree/component-tree-support.feature.ts","../../node_modules/@wesib/generic/src/navigation/hash-url/hash-url.ts","../../node_modules/@wesib/generic/src/navigation/page-param.ts","../../node_modules/@wesib/generic/src/navigation/navigation-agent.ts","../../node_modules/@wesib/generic/src/navigation/navigation.ts","../../node_modules/@wesib/generic/src/navigation/page-param-context.ts","../../node_modules/@wesib/generic/src/navigation/nav-history.impl.ts","../../node_modules/@wesib/generic/src/navigation/navigation.event.ts","../../node_modules/@wesib/generic/src/navigation/navigation.impl.ts","../../node_modules/@wesib/generic/src/navigation/navigation-support.feature.ts","../../node_modules/@wesib/generic/src/navigation/activate-nav-link.decorator.ts","../../node_modules/@wesib/generic/src/navigation/handle-nav-links.decorator.ts","../../node_modules/@wesib/generic/src/util/import-node.ts","../../node_modules/@wesib/generic/src/navigation/page-load/caching-page-loader.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-requests.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-agent.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-url-modifier.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-loader.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-param.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-cache-buster.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-scripts-agent.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-style-agent.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-title-agent.impl.ts","../../node_modules/@wesib/generic/src/navigation/page-load/page-load-support.feature.ts","../../node_modules/@wesib/generic/src/navigation/page-load/include-page.decorator.ts","../../node_modules/@wesib/generic/src/styp/component-style-producer.ts","../../node_modules/@wesib/generic/src/styp/component-styp-renderer.ts","../../node_modules/@wesib/generic/src/styp/element-id-class.impl.ts","../../node_modules/@wesib/generic/src/styp/component-style-producer.impl.ts","../../node_modules/@wesib/generic/src/styp/basic-style-producer-support.feature.ts","../../node_modules/@wesib/generic/src/styp/component-styp-options.ts","../../node_modules/@wesib/generic/src/styp/produce-style.decorator.ts","../../node_modules/@wesib/generic/src/styp/style-producer-support.feature.ts","../../node_modules/@wesib/generic/src/theme/theme.ts","../../node_modules/@wesib/generic/src/theme/theme-factory.ts","../../node_modules/@wesib/generic/src/theme/theme-style.ts","../../node_modules/@wesib/generic/src/theme/theme.impl.ts","../../node_modules/@wesib/generic/src/theme/theme-factory.impl.ts","../../node_modules/@wesib/generic/src/theme/theme-support.feature.ts","../../node_modules/@wesib/generic/src/input/default-in-aspects.ts","../../node_modules/@wesib/generic/src/input/input-from-control.ts","../../node_modules/@wesib/generic/src/input/convert-input.decorator.ts"],"sourcesContent":["import { SingleContextKey } from 'context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * @internal\n */\nexport const BootstrapContext__key = (/*#__PURE__*/ new SingleContextKey<BootstrapContext>('bootstrap-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from 'context-values';\nimport { EventReceiver, EventSupply, OnEvent } from 'fun-events';\nimport { Class } from '../common';\nimport { ComponentClass, ComponentFactory } from '../component/definition';\nimport { FeatureRef } from '../feature';\nimport { BootstrapContext__key } from './bootstrap-context.key.impl';\n\n/**\n * Components bootstrap context.\n *\n * An instance of this class is passed to [[FeatureDef.Options.init]] method so that the feature can configure itself.\n *\n * Extends `BootstrapValues` interface. The values could be {@link BootstrapSetup.provide pre-configured} in feature\n * definitions.\n *\n * @category Core\n */\nexport abstract class BootstrapContext extends ContextValues {\n\n  /**\n   * A key of bootstrap context value containing the bootstrap context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<BootstrapContext> {\n    return BootstrapContext__key;\n  }\n\n  /**\n   * Builds an `OnEvent` sender of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of ready bootstrap context.\n   */\n  abstract whenReady(): OnEvent<[BootstrapContext]>;\n\n  /**\n   * Registers a `receiver` of bootstrap readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete.\n   *\n   * If bootstrap is complete already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of reay bootstrap context.\n   *\n   * @returns Bootstrap readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[BootstrapContext]>): EventSupply;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentType  Component class constructor.\n   *\n   * @return A promise that is resolved to component factory when the given `componentType` is registered.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>>;\n\n  /**\n   * Allows to loads the given `feature`.\n   *\n   * @param feature  The feature to load.\n   *\n   * @returns  Loaded feature reference.\n   */\n  abstract load(feature: Class): FeatureRef;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKeyDefault } from 'context-values';\nimport { BootstrapContext } from './bootstrap-context';\n\n/**\n * Provides a default value for bootstrap context key.\n *\n * @category Core\n * @param provide  A function accepting bootstrap context and target key as parameters, and returning either a default\n * value, or `null`/`undefined` if unknown.\n *\n * @returns A provider of default value for bootstrap context value key.\n */\nexport function bootstrapDefault<Value, Key extends ContextKey<any, any, any>>(\n    provide: (this: void, context: BootstrapContext, key: Key) => Value | null | undefined,\n): ContextKeyDefault<Value, Key> {\n  return (context, key) => {\n\n    const bootstrapContext = context.get(BootstrapContext);\n\n    return context === bootstrapContext ? provide(bootstrapContext, key) : bootstrapContext.get(key);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { Class } from '../../common';\nimport { ComponentMount } from '../component-mount';\nimport { ComponentClass } from './component-class';\nimport { ElementDef } from './element-def';\n\n/**\n * @internal\n */\nconst ComponentFactory__key = (/*#__PURE__*/ new SingleContextKey<ComponentFactory>('component-factory'));\n\n/**\n * A factory of components of particular type.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentFactory<T extends object = any> {\n\n  /**\n   * A key of definition context value containing a component factory.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentFactory> {\n    return ComponentFactory__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  abstract readonly elementDef: ElementDef;\n\n  /**\n   * Mounts a component to arbitrary element.\n   *\n   * This method creates a component, but instead of creating a custom element for, it mounts it to the target\n   * `element`.\n   *\n   * It is up to the features to update the target element. They can use a `ComponentContext.mount` property to check\n   * whether the component is mounted or is constructed in standard way.\n   *\n   * The constructed component will be in disconnected state. To update its connection state either update a\n   * `ComponentMount.connected` property, or use a `connectTo()` method.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  abstract mountTo(element: any): ComponentMount<T>;\n\n  /**\n   * Connects a component to arbitrary element.\n   *\n   * This method does the same as `mountTo()`, but also marks the mounted component as connected.\n   *\n   * @param element  Target element to mount new component to.\n   *\n   * @returns New component mount.\n   *\n   * @throws Error If target element is already bound to some component.\n   */\n  connectTo(element: any): ComponentMount<T> {\n\n    const mount = this.mountTo(element);\n\n    mount.connected = true;\n\n    return mount;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\n\n/**\n * A window the components bootstrap is performed against.\n *\n * @category Core\n */\nexport type BootstrapWindow = Window & typeof globalThis;\n\n/**\n * A key of bootstrap context value containing a window instance the bootstrap is performed against.\n *\n * Target value defaults to current window.\n *\n * @category Core\n */\nexport const BootstrapWindow: SingleContextRef<BootstrapWindow> = (/*#__PURE__*/ new SingleContextKey(\n    'window',\n    {\n      byDefault() {\n        return window;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * A window (e.g. DOM) element all bootstrapped components belong to.\n *\n * @category Core\n */\nexport type BootstrapRoot = any;\n\n/**\n * A key of bootstrap context value containing a bootstrap root.\n *\n * Target value defaults to document body of [[BootstrapWindow]].\n *\n * @category Core\n */\nexport const BootstrapRoot: SingleContextRef<BootstrapRoot> = (/*#__PURE__*/ new SingleContextKey(\n    'bootstrap-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(BootstrapWindow).document.body;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { NamespaceAliaser } from 'namespace-aliaser';\n\n/**\n * Namespace aliaser used by default.\n *\n * Maps namespaces to their unique aliases.\n *\n * @category Core\n */\nexport type DefaultNamespaceAliaser = NamespaceAliaser;\n\n/**\n * A key of bootstrap context value containing the default namespace aliaser.\n *\n * @category Core\n */\nexport const DefaultNamespaceAliaser: SingleContextRef<DefaultNamespaceAliaser> = (\n    /*#__PURE__*/ new SingleContextKey<DefaultNamespaceAliaser>('default-namespace-aliaser')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { newRenderSchedule, RenderScheduler } from 'render-scheduler';\nimport { BootstrapWindow } from './bootstrap-window';\n\n/**\n * Default rendering tasks scheduler.\n *\n * @category Core\n */\nexport type DefaultRenderScheduler = RenderScheduler;\n\nclass DefaultRenderSchedulerKey extends ContextUpKey<DefaultRenderScheduler, RenderScheduler> {\n\n  readonly upKey: ContextUpKey.UpKey<DefaultRenderScheduler, RenderScheduler>;\n\n  constructor() {\n    super('default-render-scheduler');\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru(\n            (...fns) => {\n              if (fns.length) {\n                return toDefaultRenderScheduler(opts.context, fns[fns.length - 1]);\n              }\n\n              const defaultProvider = (): AfterEvent<[DefaultRenderScheduler]> => afterThe(\n                  toDefaultRenderScheduler(opts.context, newRenderSchedule),\n              );\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          DefaultRenderScheduler,\n          EventKeeper<RenderScheduler[]> | RenderScheduler,\n          AfterEvent<RenderScheduler[]>>,\n      ): DefaultRenderScheduler {\n\n    let delegated!: DefaultRenderScheduler;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(scheduler => delegated = toDefaultRenderScheduler(opts.context, scheduler));\n\n    return (...args) => delegated(...args);\n  }\n\n}\n\nfunction toDefaultRenderScheduler(\n    context: ContextValues,\n    scheduler: RenderScheduler,\n): DefaultRenderScheduler {\n  return (options = {}) => scheduler({\n    ...options,\n    window: options.window || context.get(BootstrapWindow),\n  });\n}\n\n/**\n * A key of bootstrap, definition, or component context value containing [[DefaultRenderScheduler]] instance.\n *\n * Uses the default `RenderScheduler` (`newRenderSchedule()`) for {@link BootstrapWindow bootstrap window}.\n *\n * @category Core\n */\nexport const DefaultRenderScheduler: ContextUpRef<DefaultRenderScheduler, RenderScheduler> = (\n    /*#__PURE__*/ new DefaultRenderSchedulerKey()\n);\n","/**\n * @internal\n */\nexport function isArray<T>(value: T | T[]): value is T[];\n\n/**\n * @internal\n */\nexport function isArray<T>(value: T | readonly T[]): value is readonly T[];\n\nexport function isArray<T>(value: T | readonly T[]): value is T[] {\n  return Array.isArray(value);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { AIterable } from 'a-iterable';\nimport { isArray } from './types.impl';\n\n/**\n * @category Utility\n */\nexport class ArraySet<T> extends AIterable<T> {\n\n  readonly items: Set<T>;\n\n  constructor(value?: T | readonly T[]) {\n    super();\n    this.items = value == null ? new Set() : isArray(value) ? new Set(value) : new Set([value]);\n  }\n\n  get value(): T | T[] | undefined {\n    switch (this.items.size) {\n    case 0: return;\n    case 1: return this.items[Symbol.iterator]().next().value;\n    default: return [...this.items];\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.items[Symbol.iterator]();\n  }\n\n  add(...items: T[]): this {\n    items.forEach(item => this.items.add(item));\n    return this;\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  merge(items: readonly T[] | T | undefined): this {\n    if (items == null) {\n      return this;\n    }\n    if (isArray(items)) {\n      return this.add(...items);\n    }\n    return this.add(items);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Arbitrary class constructor.\n *\n * @category Utility\n * @typeparam T  A type of object.\n */\nexport interface Class<T extends object = any> extends Function {\n  new(...args: any[]): T;\n  prototype: T;\n}\n\n/**\n * Detects super class of the given class optionally satisfying the given criteria.\n *\n * Traverses all class ancestors until reaches the one satisfying the given criteria, or stops when there is no more\n * ancestors.\n *\n * @category Utility\n * @param type  The class constructor to find super class of.\n * @param satisfying  The criteria of super class matching. It is a function accepting a super class constructor\n * as the only parameter and returning `true` if the given super class matches, or `false` otherwise. Always returns\n * `true` by default.\n *\n * @return A super class `satisfying` the given criteria, or `undefined` if there is no such super class, or there is no\n * super class at all (e.g. when `Object` is passed in).\n */\nexport function superClassOf(type: Class, satisfying: (type: Class) => boolean = () => true): Class | undefined {\n\n  const prototype = Object.getPrototypeOf(type.prototype);\n\n  if (prototype == null) {\n    return;\n  }\n\n  const superType = prototype.constructor as Class;\n\n  if (satisfying(superType)) {\n    return superType;\n  }\n\n  return superClassOf(superType, satisfying);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from './classes';\nimport { fieldAccessorDescriptor, PropertyAccessorDescriptor, toPropertyAccessorDescriptor } from './reflect';\n\n/**\n * Typed class decorator.\n *\n * @category Utility\n * @typeparam T  A type of class to decorate.\n */\nexport type TypedClassDecorator<T extends Class> = (type: T) => T | void;\n\n/**\n * Typed property decorator.\n *\n * @category Utility\n * @typeparam T  A type of class the decorated property belongs to.\n */\nexport type TypedPropertyDecorator<T extends Class> =\n    <V>(target: InstanceType<T>, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<V>) => any | void;\n\n/**\n * Property decorator helper converting a field or property to the one with accessor (`get` and optionally `set`).\n *\n * @category Utility\n * @typeparam T  A type of target object.\n * @typeparam V  A property value type.\n * @param target  Target object containing the property.\n * @param propertyKey  Target property key.\n * @param desc  Target property descriptor, or `undefined` for object fields.\n * @param updateDescriptor  Descriptor updater. Accepts the accessor descriptor as the only argument. If returns\n * a descriptor, then it is applied to the property. Otherwise the target property descriptor is never updated.\n *\n * @returns Updated property descriptor to return from decorator to apply to the property, or `undefined` if there is\n * nothing to update.\n */\nexport function decoratePropertyAccessor<T, V>(\n    target: T,\n    propertyKey: string | symbol,\n    desc: TypedPropertyDescriptor<V> | undefined,\n    updateDescriptor: (desc: PropertyAccessorDescriptor<V>) => PropertyAccessorDescriptor<V>,\n): PropertyAccessorDescriptor<V> | undefined {\n\n  const isField = !desc;\n  const accessorDesc: PropertyAccessorDescriptor<V> = desc\n      ? toPropertyAccessorDescriptor(desc)\n      : fieldAccessorDescriptor(target, propertyKey as keyof T) as any;\n  const updatedDesc = updateDescriptor(accessorDesc);\n\n  if (isField && updatedDesc) {\n    Object.defineProperty(target, propertyKey, updatedDesc);\n    return;\n  }\n\n  return updatedDesc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Converts an object field to property accessor.\n *\n * Defines a new property with the given name in the target object and returns its descriptor.\n *\n * The converted descriptor is always configurable, enumerable, and writable.\n *\n * @category Utility\n * @typeparam T  The type of target object.\n * @typeparam K  Target object property keys type.\n * @param target  The object containing target field.\n * @param fieldKey  Target field key.\n *\n * @return New property accessor descriptor.\n */\nexport function field2accessor<T, K extends keyof T>(\n    target: T,\n    fieldKey: K,\n): PropertyAccessorDescriptor<T[K]> {\n\n  const desc = fieldAccessorDescriptor(target, fieldKey);\n\n  Object.defineProperty(target, fieldKey, desc);\n\n  return desc;\n}\n\n/**\n * Creates an property accessor descriptor for the given field.\n *\n * @category Utility\n * @typeparam T  The type of target object.\n * @typeparam K  Target object property keys type.\n * @param target  The object containing target field.\n * @param fieldKey  Target field key.\n */\nexport function fieldAccessorDescriptor<T, K extends keyof T>(\n    target: T,\n    fieldKey: K,\n): PropertyAccessorDescriptor<T[K]> {\n\n  const value__symbol = Symbol(`${String(fieldKey)}:value`);\n  const initial: T[K] = target[fieldKey];\n\n  return {\n    configurable: true,\n    enumerable: true,\n    get(this: any) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n    set(this: any, newValue) {\n      this[value__symbol] = newValue;\n    },\n  };\n}\n\n/**\n * Property accessor descriptor. I.e. the one with `get` and `set` functions.\n *\n * @category Utility\n * @typeparam V  Property value type.\n */\nexport interface PropertyAccessorDescriptor<V> extends TypedPropertyDescriptor<V> {\n  enumerable?: boolean;\n  configurable?: boolean;\n  writable?: undefined;\n  value?: undefined;\n  get?: () => V;\n  set?: (value: V) => void;\n}\n\n/**\n * Detects whether the given property descriptor is the one of property accessor.\n *\n * @category Utility\n * @typeparam V  Property value type.\n * @param desc  Target property descriptor.\n *\n * @return `true` if the descriptor has no `value` or `writable` attributes set.\n */\nexport function isPropertyAccessorDescriptor<V>(\n    desc: TypedPropertyDescriptor<V>,\n): desc is PropertyAccessorDescriptor<V> {\n  return desc.value === undefined && desc.writable === undefined;\n}\n\n/**\n * Converts a property descriptor to property accessor descriptor.\n *\n * @category Utility\n * @typeparam V  Property value type.\n * @param desc  Target property descriptor.\n *\n * @return Either an accessor descriptor constructed from data descriptor, or `desc` if it is an accessor descriptor\n * already.\n */\nexport function toPropertyAccessorDescriptor<V>(\n    desc: TypedPropertyDescriptor<V>,\n): PropertyAccessorDescriptor<V> {\n  if (isPropertyAccessorDescriptor(desc)) {\n    return desc;\n  }\n\n  const value__symbol = Symbol('value');\n  const initial = desc.value as V;\n\n  const accessorDesc: PropertyAccessorDescriptor<V> = {\n    ...desc,\n    writable: undefined,\n    value: undefined,\n    get(this: any) {\n      return value__symbol in this ? this[value__symbol] : initial;\n    },\n  };\n\n  if (desc.writable) {\n    accessorDesc.set = function (this: any, newValue: V) {\n      this[value__symbol] = newValue;\n    };\n  }\n\n  delete accessorDesc.writable;\n  delete accessorDesc.value;\n\n  return accessorDesc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Merges two functions by calling one after another.\n *\n * Optionally merges function call results.\n *\n * @category Utility\n * @typeparam P  Function parameter types as tuple.\n * @typeparam R  A type of function result.\n * @typeparam T  A type if `this` object expected by function.\n * @param first  The first function to call.\n * @param second  The second function to call.\n * @param merge  Optional function call results merger. Accepts two function results as arguments and returns the final\n * result. When omitted the first function call result is ignored and the second function's call result is returned.\n *\n * @return A function that calls both of the given ones and merges their results. If one of the functions is absent,\n * then just returns another one. If both are absent, then returns `undefined`.\n */\nexport function mergeFunctions<P extends any[], R, T>(\n    first: (this: T, ...args: P) => R,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: (this: T, ...args: P) => R,\n    merge?: (first: R, second: R) => R,\n): (this: T, ...args: P) => R;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge?: (first: R, second: R) => R,\n): ((this: T, ...args: P) => R) | undefined;\n\nexport function mergeFunctions<P extends any[], R, T>(\n    first: ((this: T, ...args: P) => R) | undefined,\n    second: ((this: T, ...args: P) => R) | undefined,\n    merge: (first: R, second: R) => R = (_f, s) => s,\n): ((this: T, ...args: P) => R) | undefined {\n  if (!first) {\n    return second;\n  }\n  if (!second) {\n    return first;\n  }\n  return function (this: T, ...args: P): R {\n    return merge(\n        first.apply(this, args),\n        second.apply(this, args),\n    );\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * Checks whether the given DOM node is element.\n *\n * @category Utility\n * @param node  A DOM node to check.\n *\n * @returns `true` is `node` is element, or `false` otherwise.\n */\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { flatMapIt, mapIt } from 'a-iterable';\nimport { Class, superClassOf } from './classes';\n\n/**\n * @category Utility\n */\nexport abstract class MetaAccessor<M, S = M> {\n\n  readonly symbol: symbol;\n\n  protected constructor(symbol: symbol) {\n    this.symbol = symbol;\n  }\n\n  own(type: Class): M | undefined {\n    // eslint-disable-next-line no-prototype-builtins\n    return type.hasOwnProperty(this.symbol) ? (type as any)[this.symbol] : undefined;\n  }\n\n  of(type: Class): M | undefined {\n\n    const ownDef: M | undefined = this.own(type);\n    const superType = superClassOf(type);\n    const superDef = superType && this.of(superType);\n\n    return ownDef ? (superDef ? this.merge([superDef, ownDef]) : ownDef) : superDef;\n  }\n\n  define<C extends Class>(type: C, sources: Iterable<S>): C {\n\n    const prevMeta = this.own(type);\n    const updates = mapIt(sources, source => this.meta(source, type));\n    const newMeta: M = this.merge(prevMeta ? flatMapIt([[prevMeta], updates]) : updates);\n\n    Object.defineProperty(\n        type,\n        this.symbol,\n        {\n          configurable: true,\n          value: newMeta,\n        },\n    );\n\n    return type;\n  }\n\n  abstract merge(metas: Iterable<M>): M;\n\n  protected abstract meta(source: S, type: Class): M;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * @category Utility\n */\nexport class PromiseResolver<T = void> {\n\n  readonly promise: Promise<T>;\n  private _resolve!: (value: T) => void;\n  private _reject!: (error: any) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  resolve(value: T): void {\n    this._resolve(value);\n  }\n\n  reject(error: any): void {\n    this._reject(error);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from 'a-iterable';\nimport { BootstrapSetup } from '../boot';\nimport { ArraySet, Class, mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureContext } from './feature-context';\n\n/**\n * A key of a property holding a feature definition within its class constructor.\n *\n * @category Core\n */\nexport const FeatureDef__symbol = (/*#__PURE__*/ Symbol('feature-def'));\n\n/**\n * Feature definition.\n *\n * This can be one of:\n * - feature definition options object,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n */\nexport type FeatureDef =\n    | FeatureDef.Options\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace FeatureDef {\n\n  /**\n   * Feature definition options.\n   */\n  export interface Options {\n\n    readonly [FeatureDef__symbol]?: undefined;\n\n    /**\n     * Features this one requires.\n     */\n    readonly needs?: Class | readonly Class[];\n\n    /**\n     * Features this one provides.\n     *\n     * The feature always provides itself.\n     */\n    readonly has?: Class | readonly Class[];\n\n    /**\n     * Sets up bootstrap.\n     *\n     * This method is called before bootstrap context created.\n     *\n     * @param setup  Bootstrap setup.\n     */\n    setup?(setup: BootstrapSetup): void;\n\n    /**\n     * Bootstraps this feature by calling the given bootstrap context constructed.\n     *\n     * @param context  Feature initialization context.\n     */\n    init?(context: FeatureContext): void;\n\n  }\n\n  /**\n   * Feature definition holder.\n   */\n  export interface Holder {\n\n    /**\n     * The feature definition this holder contains.\n     */\n    readonly [FeatureDef__symbol]: FeatureDef;\n\n  }\n\n  /**\n   * Feature definition factory.\n   */\n  export interface Factory {\n\n    /**\n     * Builds feature definition.\n     *\n     * @param featureType  A feature class constructor to build definition for.\n     *\n     * @returns Built feature definition.\n     */\n    [FeatureDef__symbol](featureType: Class): FeatureDef;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass FeatureMeta extends MetaAccessor<FeatureDef.Options, FeatureDef> {\n\n  constructor() {\n    super(FeatureDef__symbol);\n  }\n\n  merge(defs: Iterable<FeatureDef.Options>): FeatureDef.Options {\n    return itsReduction<FeatureDef.Options, FeatureDef.Options>(\n        defs,\n        (prev, def) => ({\n          needs: new ArraySet(prev.needs).merge(def.needs).value,\n          has: new ArraySet(prev.has).merge(def.has).value,\n          setup: mergeFunctions<[BootstrapSetup], void, Class>(prev.setup, def.setup),\n          init: mergeFunctions<[FeatureContext], void, Class>(prev.init, def.init),\n        }),\n        {},\n    );\n  }\n\n  meta(source: FeatureDef, type: Class): FeatureDef.Options {\n\n    const def = source[FeatureDef__symbol];\n\n    return def == null\n        ? source as FeatureDef.Options\n        : this.meta(\n            typeof def === 'function' ? (source as FeatureDef.Factory)[FeatureDef__symbol](type) : def,\n            type,\n        );\n  }\n\n}\n\n/**\n * @internal\n */\nconst featureMeta = (/*#__PURE__*/ new FeatureMeta());\n\n/**\n * @internal\n */\nconst noFeatureDef: FeatureDef.Factory = {\n  [FeatureDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const FeatureDef = {\n\n  /**\n   * Extracts feature definition options from its type.\n   *\n   * @param featureType  Target feature class constructor.\n   *\n   * @returns Feature definition options. May be empty when there is no feature definition found in the given\n   * `featureType`.\n   */\n  of(this: void, featureType: Class): FeatureDef.Options {\n    return featureMeta.of(featureType) || {};\n  },\n\n  /**\n   * Builds feature definition options for the given feature class.\n   *\n   * @param featureType  Target feature class constructor.\n   * @param def  A feature definition.\n   *\n   * @returns Feature definition options.\n   */\n  for(this: void, featureType: Class, def: FeatureDef): FeatureDef.Options {\n    return featureMeta.meta(def, featureType);\n  },\n\n  /**\n   * Merges multiple feature definition options.\n   *\n   * @param defs  Feature definition options to merge.\n   *\n   * @returns Merged feature definition options.\n   */\n  merge(this: void, ...defs: readonly FeatureDef.Options[]): FeatureDef.Options {\n    return featureMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple feature definitions.\n   *\n   * @param defs  Feature definitions to merge.\n   *\n   * @returns Merged feature definition.\n   */\n  all(this: void, ...defs: readonly FeatureDef[]): FeatureDef {\n    return itsReduction<FeatureDef, FeatureDef.Factory>(\n        defs,\n        (prev, def) => ({\n          [FeatureDef__symbol](featureType: Class) {\n            return FeatureDef.merge(\n                FeatureDef.for(featureType, prev),\n                FeatureDef.for(featureType, def),\n            );\n          },\n        }),\n        noFeatureDef,\n    );\n  },\n\n  /**\n   * Defines a feature.\n   *\n   * Either creates new or extends an existing feature definition and stores it under `[FeatureDef__symbol]` key.\n   *\n   * @typeparam T  Feature type.\n   * @param featureType  Feature class constructor.\n   * @param defs  Feature definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends Class>(this: void, featureType: T, ...defs: readonly FeatureDef[]): T {\n    return featureMeta.define(featureType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class, TypedClassDecorator } from '../common';\nimport { FeatureDef } from './feature-def';\n\n/**\n * Feature class decorator.\n *\n * Decorate a class with this decorator to define it as a feature like this:\n * ```TypeScript\n * @Feature({ needs: [OtherFeature, MyComponent] })\n * class MyFeature {\n *   // ...\n * }\n * ```\n *\n * Such feature can be passed to [[bootstrapComponents]] function or referenced by other features.\n *\n * This is an alternative to direct call to [[FeatureDef.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated feature class.\n * @param defs  Feature definitions.\n *\n * @returns A feature class decorator.\n */\nexport function Feature<T extends Class = any>(...defs: FeatureDef[]): TypedClassDecorator<T> {\n  return (type: T) => FeatureDef.define(type, ...defs);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValueSpec, SingleContextKey } from 'context-values';\nimport { EventReceiver, EventSupply, OnEvent } from 'fun-events';\nimport { BootstrapContext, BootstrapSetup } from '../boot';\nimport { Class } from '../common';\nimport { ComponentContext } from '../component';\nimport { ComponentClass, ComponentFactory, DefinitionContext, DefinitionSetup } from '../component/definition';\nimport { FeatureRef } from './feature-ref';\n\n/**\n * @internal\n */\nconst FeatureContext__key = (/*#__PURE__*/ new SingleContextKey<FeatureContext>('feature-context'));\n\n/**\n * Feature initialization context.\n *\n * @category Core\n */\nexport abstract class FeatureContext extends BootstrapContext implements BootstrapSetup {\n\n  /**\n   * A key of feature context value containing the feature context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<FeatureContext> {\n    return FeatureContext__key;\n  }\n\n  /**\n   * Feature class this context is created for.\n   */\n  abstract readonly feature: Class;\n\n  /**\n   * Builds an `OnEvent` sender of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of ready feature context.\n   */\n  abstract whenReady(): OnEvent<[FeatureContext]>;\n\n  /**\n   * Registers a receiver of feature readiness event.\n   *\n   * The registered receiver will be notified once bootstrap is complete and the feature is loaded.\n   *\n   * If the above conditions satisfied already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of ready feature context.\n   *\n   * @returns Feature readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[FeatureContext]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component definition events.\n   *\n   * The registered receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   *\n   * @returns `OnEvent` sender of component definition contexts.\n   */\n  abstract onDefinition(): OnEvent<[DefinitionContext]>;\n\n  /**\n   * Starts sending component definition events to the given `receiver`.\n   *\n   * The receiver will be notified when new component class is defined, but before its custom element class\n   * constructed.\n   *\n   * @param receiver  Target receiver of component definition contexts.\n   *\n   * @returns Component definition events supply.\n   */\n  abstract onDefinition(receiver: EventReceiver<[DefinitionContext]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component construction events.\n   *\n   * The registered receiver will be notified right before component is constructed.\n   *\n   * @returns `OnEvent` sender of constructed component contexts.\n   */\n  abstract onComponent(): OnEvent<[ComponentContext]>;\n\n  /**\n   * Starts sending component construction events to the given `receiver`.\n   *\n   * @param receiver  Target receiver of constructed component contexts.\n   *\n   * @returns Component construction events supply.\n   */\n  abstract onComponent(receiver: EventReceiver<[ComponentContext]>): EventSupply;\n\n  /**\n   * Provides bootstrap context value.\n   *\n   * Note that this happens when bootstrap context already exists. To provide a value before bootstrap context created\n   * a [[BootstrapSetup.provide]] method can be used.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perDefinition<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n  ): () => void;\n\n  abstract setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]>;\n\n  /**\n   * Defines a component.\n   *\n   * Creates a custom element according to component definition, and registers it with custom elements registry.\n   *\n   * Note that custom element definition will happen only when all features configuration complete.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   *\n   * @return Custom element class constructor registered as custom element.\n   *\n   * @throws TypeError  If `componentType` does not contain a component definition.\n   */\n  abstract define<T extends object>(componentType: ComponentClass<T>): void;\n\n  whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>> {\n    return this.get(BootstrapContext).whenDefined(componentType);\n  }\n\n  load(feature: Class): FeatureRef {\n    return this.get(BootstrapContext).load(feature);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\n\n/**\n * Feature need.\n *\n * Indicates why one feature needs another one. The reason can be one of:\n *\n * - `needs` when feature {@link FeatureDef.Options.needs depends} on another one, or\n * - `has` when feature {@link FeatureDef.Options.has provides} another one.\n *\n * @category Core\n */\nexport type FeatureNeed = [Class, 'needs' | 'has', Class];\n\n/**\n * An error in feature needs. I.e. circular dependency.\n *\n * @category Core\n */\nexport class FeatureNeedsError extends Error {\n\n  /**\n   * Feature needs causing this error.\n   */\n  readonly needs: readonly FeatureNeed[];\n\n  /**\n   * Constructs feature needs error.\n   *\n   * @param needs  Feature needs causing the error.\n   */\n  constructor(needs: readonly FeatureNeed[]) {\n    super(\n        'Circular feature needs: ' + needs.reduce(\n        (\n            prev,\n            [feature, reason, need],\n        ) => (prev ? prev : feature.name) + ` ${reason} ${need.name}`,\n        '',\n        ),\n    );\n    this.needs = needs;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { itsReduction } from 'a-iterable';\nimport { isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { mergeFunctions, MetaAccessor } from '../common';\nimport { FeatureDef, FeatureDef__symbol } from '../feature';\nimport { ComponentClass, DefinitionContext, DefinitionSetup, ElementDef } from './definition';\n\n/**\n * A key of a property holding a component definition within its class constructor.\n *\n * @category Core\n */\nexport const ComponentDef__symbol = (/*#__PURE__*/ Symbol('component-def'));\n\n/**\n * Component definition.\n *\n * A custom element class will be created for each registered component in accordance to this definition.\n *\n * This can be one of:\n * - custom element name (possibly qualified),\n * - component definition options,\n * - component definition holder,\n * - component definition factory,\n * - feature definition holder, or\n * - feature definition factory.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport type ComponentDef<T extends object = any> =\n    | QualifiedName\n    | ComponentDef.Options<T>\n    | ComponentDef.Holder<T>\n    | ComponentDef.Factory<T>\n    | FeatureDef.Holder\n    | FeatureDef.Factory;\n\nexport namespace ComponentDef {\n\n  /**\n   * Component definition options.\n   */\n  export interface Options<T extends object = any> {\n\n    readonly [ComponentDef__symbol]?: undefined;\n\n    /**\n     * Custom element name.\n     *\n     * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n     * name/namespace tuple.\n     *\n     * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n     * still can be mounted.\n     */\n    readonly name?: QualifiedName;\n\n    /**\n     * Existing element to extend by custom one.\n     */\n    readonly extend?: ElementDef.Extend;\n\n    /**\n     * Additional feature definition options.\n     */\n    readonly feature?: FeatureDef.Options;\n\n    /**\n     * Sets up component definition.\n     *\n     * This method is called before component definition context constructed.\n     *\n     * @param setup  Component definition setup.\n     */\n    setup?(setup: DefinitionSetup<T>): void;\n\n    /**\n     * Defines this component by calling the given component definition context methods.\n     *\n     * This function is called before the custom element is defined.\n     *\n     * @param context  Component definition context.\n     */\n    define?(context: DefinitionContext<T>): void;\n\n  }\n\n  /**\n   * Component definition holder.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Holder<T extends object = any> {\n\n    /**\n     * The component definition this holder contains.\n     */\n    readonly [ComponentDef__symbol]: ComponentDef<T>;\n\n  }\n\n  /**\n   * Component definition factory.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Factory<T extends object = any> {\n\n    /**\n     * Builds component definition.\n     *\n     * @param componentType  A component class constructor to build definition for.\n     *\n     * @returns Built component definition.\n     */\n    [ComponentDef__symbol](componentType: ComponentClass<T>): ComponentDef<T>;\n\n  }\n\n}\n\n/**\n * @internal\n */\nclass ComponentMeta extends MetaAccessor<ComponentDef.Options, ComponentDef> {\n\n  constructor() {\n    super(ComponentDef__symbol);\n  }\n\n  merge<T extends object>(defs: Iterable<ComponentDef.Options<T>>): ComponentDef.Options<T> {\n    return itsReduction<ComponentDef.Options<T>, ComponentDef.Options<T>>(\n        defs,\n        (prev, def) => ({\n          ...prev,\n          ...def,\n          setup: mergeFunctions(prev.setup, def.setup),\n          define: mergeFunctions(prev.define, def.define),\n          feature: prev.feature\n              ? def.feature ? FeatureDef.merge(prev.feature, def.feature) : prev.feature\n              : def.feature,\n        }),\n        {},\n    );\n  }\n\n  meta<T extends object>(source: ComponentDef<T>, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n\n    const def = (source as any)[ComponentDef__symbol];\n\n    if (def != null) {\n      return this.meta(\n          typeof def === 'function' ? (source as ComponentDef.Factory<T>)[ComponentDef__symbol](componentType) : def,\n          componentType,\n      );\n    }\n    if ((source as any)[FeatureDef__symbol] != null) {\n      return {\n        feature: FeatureDef.for(componentType, source as FeatureDef),\n      };\n    }\n    if (isQualifiedName(source)) {\n      return { name: source };\n    }\n\n    return source as ComponentDef.Options;\n  }\n\n}\n\n/**\n * @internal\n */\nconst componentMeta = (/*#__PURE__*/ new ComponentMeta());\n\n/**\n * @internal\n */\nconst noComponentDef: ComponentDef.Factory = {\n  [ComponentDef__symbol]() {\n    return {};\n  },\n};\n\n/**\n * @category Core\n */\nexport const ComponentDef = {\n\n  /**\n   * Extracts component definition options from its type.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Target component class constructor.\n   *\n   * @returns Component definition options. May be empty if there is not definition attached to component type.\n   */\n  of<T extends object>(this: void, componentType: ComponentClass<T>): ComponentDef.Options<T> {\n    return componentMeta.of(componentType) as ComponentDef.Options<T> || {};\n  },\n\n  /**\n   * Builds component definition options for the given component class.\n   *\n   * @param componentType  Target component class constructor.\n   * @param source  A source of component definition.\n   *\n   * @returns Component definition.\n   */\n  for<T extends object>(\n      this: void,\n      componentType: ComponentClass<T>,\n      source: ComponentDef<T>,\n  ): ComponentDef.Options<T> {\n    return componentMeta.meta(source, componentType);\n  },\n\n  /**\n   * Merges multiple component definition options.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definition options to merge.\n   *\n   * @returns Merged component definition options.\n   */\n  merge<T extends object>(this: void, ...defs: ComponentDef.Options<T>[]): ComponentDef.Options<T> {\n    return componentMeta.merge(defs);\n  },\n\n  /**\n   * Merges multiple component definitions.\n   *\n   * @typeparam T  A type of component.\n   * @param defs  Component definitions to merge.\n   *\n   * @returns Merged component definition.\n   */\n  all<T extends object>(this: void, ...defs: ComponentDef<T>[]): ComponentDef<T> {\n    return itsReduction<ComponentDef<T>, ComponentDef.Factory<T>>(\n        defs,\n        (prev, def) => ({\n          [ComponentDef__symbol](componentType: ComponentClass<T>) {\n            return ComponentDef.merge(\n                ComponentDef.for(componentType, prev),\n                ComponentDef.for(componentType, def),\n            );\n          },\n        }),\n        noComponentDef,\n    );\n  },\n\n  /**\n   * Defines a component.\n   *\n   * Either assigns new or extends existing component definition and stores it under [[ComponentDef__symbol]] key.\n   *\n   * Each component can be passed directly to [[bootstrapComponents]] function or added as a requirement\n   * of another feature.\n   *\n   * @typeparam T  A type of component.\n   * @param componentType  Component class constructor.\n   * @param defs  Component definitions.\n   *\n   * @returns The `type` instance.\n   */\n  define<T extends ComponentClass>(\n      this: void,\n      componentType: T,\n      ...defs: ComponentDef<InstanceType<T>>[]\n  ): T {\n    return componentMeta.define(componentType, defs);\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { ComponentClass } from './definition';\n\n/**\n * Component decorator interface.\n *\n * In addition to being a decorator for component class, it may also serve as {@link ComponentDef component definition}.\n * Thus it can be added as parameter to {@link Component @Component} decorator, or used as class decorator by itself.\n *\n * Constructed by [[Component]] function.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n */\nexport type ComponentDecorator<T extends ComponentClass = Class> =\n    & ((this: void, type: T) => T | void)\n    & ComponentDef<InstanceType<T>>;\n\n/**\n * Decorator of component class.\n *\n * Decorated class becomes component:\n * ```TypeScript\n * @Component({ name: 'my-element' })\n * class MyComponent {\n *   // ...\n * }\n * ```\n *\n * Such component can be registered with [[FeatureContext.define]] method or used as a feature, e.g. passed to\n * [[bootstrapComponents]] function, or added to [[FeatureDef.Options.needs]] property of another feature.\n *\n * This is an alternative to direct call to [[ComponentDef.Options.define]] method.\n *\n * @category Core\n * @typeparam T  A type of decorated component class.\n * @param defs  Component definitions.\n *\n * @returns A component class decorator.\n */\nexport function Component<T extends ComponentClass = Class>(\n    ...defs: ComponentDef<InstanceType<T>>[]\n): ComponentDecorator<T> {\n\n  const decorator = ((type: T) => ComponentDef.define(type, ...defs)) as ComponentDecorator<T>;\n  const def = decorator as ComponentDef.Factory<InstanceType<T>>;\n\n  def[ComponentDef__symbol] = () => ComponentDef.all(...defs);\n\n  return decorator;\n}\n","import { SingleContextKey } from 'context-values';\nimport { ComponentContext } from './component-context';\n\n/**\n * @internal\n */\nexport const ComponentContext__key = (/*#__PURE__*/ new SingleContextKey<ComponentContext>('component-context'));\n","import { SingleContextKey } from 'context-values';\nimport { eventSupplyOf } from 'fun-events';\nimport { DomEventDispatcher, OnDomEvent } from 'fun-events/dom';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher } from './component-event';\n\n/**\n * @internal\n */\nexport const ComponentEventDispatcher__key = (/*#__PURE__*/ new SingleContextKey<ComponentEventDispatcher>(\n    'component-event-dispatcher',\n    {\n      byDefault(values) {\n\n        const context = values.get(ComponentContext__key);\n        const dispatcher = new DomEventDispatcher(context.element);\n\n        eventSupplyOf(dispatcher).needs(context);\n\n        return {\n          dispatch(event: Event): boolean {\n            return dispatcher.dispatch(event);\n          },\n          on<E extends Event>(type: string): OnDomEvent<E> {\n            return dispatcher.on(type);\n          },\n        };\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { ComponentContext__key } from './component-context.key.impl';\n\n/**\n * Component content root node.\n *\n * @category Core\n */\nexport type ContentRoot = any;\n\n/**\n * A key of component context value containing a component root element.\n *\n * This is an element itself by default. But can be overridden e.g. by {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Core\n */\nexport const ContentRoot: SingleContextRef<ContentRoot> = (/*#__PURE__*/ new SingleContextKey<ContentRoot>(\n    'content-root',\n    {\n      byDefault(ctx) {\n        return ctx.get(ComponentContext__key).element;\n      },\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { FnContextKey, FnContextRef } from 'context-values/updatable';\nimport { StatePath } from 'fun-events';\n\n/**\n * Component state updater function.\n *\n * @category Core\n */\nexport type StateUpdater =\n/**\n * @typeparam V  Updated value type\n * @param path  Updated state node path.\n * @param newValue  New value.\n * @param oldValue  Replaced value.\n */\n    <V>(this: void, path: StatePath, newValue: V, oldValue: V) => void;\n\n/**\n * A key of component context value containing a component state updates receiver function.\n *\n * Features are calling this function by default when component state changes, e.g. attribute value or DOM property\n * modified.\n *\n * Note that this value is not provided, unless the `StateSupport` feature is enabled.\n *\n * @category Core\n */\nexport const StateUpdater: FnContextRef<Parameters<StateUpdater>> = (/*#__PURE__*/ new FnContextKey(\n    'state-updater',\n    {\n      byDefault: valueProvider(noop),\n    },\n));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues } from 'context-values';\nimport { EventReceiver, EventSupply, EventSupply__symbol, EventSupplyPeer, OnEvent, StatePath } from 'fun-events';\nimport { OnDomEvent } from 'fun-events/dom';\nimport { ComponentContext__key } from './component-context.key.impl';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\nimport { ComponentMount } from './component-mount';\nimport { ContentRoot } from './content-root';\nimport { ComponentClass } from './definition';\nimport { StateUpdater } from './state-updater';\n\n/**\n * A key of a custom element and component properties containing a reference to component context.\n *\n * @category Core\n */\nexport const ComponentContext__symbol = (/*#__PURE__*/ Symbol('component-context'));\n\n/**\n * Component context.\n *\n * Passed to component constructor as its only parameter.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perComponent]] and [[DefinitionSetup.perComponent]] methods.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentContext<T extends object = any> extends ContextValues implements EventSupplyPeer {\n\n  /**\n   * A key of component context value containing the component context instance itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<ComponentContext> {\n    return ComponentContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element constructed for the component according to its type.\n   *\n   * E.g. `HTMLElement` instance.\n   */\n  abstract readonly element: any;\n\n  /**\n   * A component instance.\n   *\n   * It is an error accessing this property before the component is created, e.g. from inside of component constructor\n   * or {@link DefinitionContext.whenComponent component instantiation event} receiver. A [[whenReady]] callback could\n   * be utilized to work this around.\n   */\n  abstract readonly component: T;\n\n  /**\n   * Component mount.\n   *\n   * This is defined when component is mounted to arbitrary element by [[ComponentFactory.mountTo]]. Ot is `undefined`\n   * for components created in standard way.\n   */\n  abstract readonly mount: ComponentMount<T> | undefined;\n\n  /**\n   * Whether the custom element is connected.\n   *\n   * This becomes `true` right before [[whenOn]] event is sent, and becomes `false` right before [[whenOff]] event is\n   * sent.\n   */\n  abstract readonly connected: boolean;\n\n  /**\n   * An event supply that {@link destroy destroys} component when cut off.\n   */\n  abstract readonly [EventSupply__symbol]: EventSupply;\n\n  /**\n   * Updates component's state.\n   *\n   * This is a shorthand for invoking a component {@link StateUpdater state updater} .\n   *\n   * Note that state update has no effect unless [[StateSupport]] feature is enabled or [[StateUpdater]] context value\n   * is provided by other means.\n   *\n   * @typeparam V  A type of changed value.\n   * @param key  Changed value key.\n   * @param newValue  New value.\n   * @param oldValue  Previous value.\n   */\n  readonly updateState: StateUpdater = updateComponentState.bind(this);\n\n  /**\n   * Extracts component context from its custom element or from component itself.\n   *\n   * @param element  Custom element instance created for the component or the component itself.\n   *\n   * @return Component context reference stored under [[ComponentContext__symbol]] key.\n   *\n   * @throws TypeError  When the given `element` does not contain component context reference.\n   */\n  static of<T extends object>(element: any): ComponentContext<T> {\n\n    const context = element[ComponentContext__symbol];\n\n    if (!context) {\n      throw TypeError(`No component context found in ${element}`);\n    }\n\n    return context;\n  }\n\n  /**\n   * Component content root.\n   *\n   * This is a shorthand for requesting a {@link ContentRoot content root} from component context.\n   */\n  get contentRoot(): any {\n    return this.get(ContentRoot);\n  }\n\n  /**\n   * Builds an `OnEvent` sender of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * If the component is constructed already, the receiver will be notified immediately.\n   *\n   * @returns An `OnEvent` sender of this context upon component readiness.\n   */\n  abstract whenReady(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component readiness event.\n   *\n   * The component is constructed shortly after custom element. So the component may not exist when requested\n   * e.g. inside component constructor or {@link DefinitionContext.whenComponent component instantiation event}\n   * receiver. The registered receiver will be notified when the component is constructed.\n   *\n   * @param receiver  Target receiver of this component upon component readiness.\n   *\n   * @returns Component readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of custom element connection events.\n   *\n   * The registered receiver is called when custom element is connected, i.e. its `connectedCallback()` method is\n   * called. If component is connected already the receiver is called immediately.\n   *\n   * @returns An `OnEvent` sender of connection supply that is cut off once custom element is disconnected.\n   */\n  abstract whenOn(): OnEvent<[EventSupply]>;\n\n  /**\n   * Registers a receiver of custom element connection events.\n   *\n   * The registered receiver is called when custom element is connected, i.e. its `connectedCallback()` method is\n   * called. If component is connected already the receiver is called immediately.\n   *\n   * @param receiver  Target receiver of connection supply that is cut off once custom element is disconnected.\n   *\n   * @returns Custom element connection events supply.\n   */\n  abstract whenOn(receiver: EventReceiver<[EventSupply]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of custom element disconnection events.\n   *\n   * The registered receiver is called when custom element is disconnected, i.e. its `disconnectedCallback()` method\n   * is called. If component is ready but disconnected, the receiver is called immediately.\n   *\n   * @returns An `OnEvent` sender of custom element disconnection events.\n   */\n  abstract whenOff(): OnEvent<[]>;\n\n  /**\n   * Registers a receiver of custom element disconnection events.\n   *\n   * The registered receiver is called when custom element is disconnected, i.e. its `disconnectedCallback()` method\n   * is called. If component is ready but disconnected, the receiver is called immediately.\n   *\n   * @param receiver  Target receiver of custom element disconnection events.\n   *\n   * @returns Custom element disconnection events supply.\n   */\n  abstract whenOff(receiver: EventReceiver<[]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component destruction event.\n   *\n   * The registered receiver is notified when [[destroy]] method is called. If the component is destroyed already\n   * the receiver is notified immediately.\n   *\n   * @returns An `OnEvent` sender of component destruction reason.\n   */\n  abstract whenDestroyed(): OnEvent<[any]>;\n\n  /**\n   * Registers a receiver of component destruction event.\n   *\n   * The registered receiver is notified when [[destroy]] method is called. If the component is destroyed already\n   * the receiver is notified immediately.\n   *\n   * @param receiver  Target receiver of component destruction reason.\n   *\n   * @returns Component destruction event supply.\n   */\n  abstract whenDestroyed(receiver: EventReceiver<[any]>): EventSupply;\n\n  /**\n   * Returns a `super` property value inherited from custom element parent.\n   *\n   * @param key  Target property key.\n   */\n  abstract elementSuper(key: PropertyKey): any;\n\n  /**\n   * Returns a DOM event producer for the given event type.\n   *\n   * This is a shorthand for invoking a component event producer function available under\n   * `[ComponentEventProducer.key]` key.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E> {\n    return this.get(ComponentEventDispatcher__key).on(type);\n  }\n\n  /**\n   * Dispatches an event to component element.\n   *\n   * This is a shorthand for invoking a component {@link ComponentEventDispatcher event dispatcher}.\n   *\n   * @param event  An event to dispatch.\n   */\n  dispatchEvent(event: Event): void {\n    this.get(ComponentEventDispatcher__key).dispatch(event);\n  }\n\n  /**\n   * Destroys the component.\n   *\n   * Removes element from the DOM tree. I.e. disconnects custom element first.\n   *\n   * After this method call the component should no longer be used.\n   *\n   * Note that component destruction is virtual. It is up to developer to decide when component is no longer needed.\n   *\n   * @param reason  Optional reason of destruction.\n   */\n  abstract destroy(reason?: any): void;\n\n}\n\n/**\n * @internal\n */\nfunction updateComponentState<V>(this: ComponentContext<any>, key: StatePath, newValue: V, oldValue: V): void {\n  this.get(StateUpdater)(key, newValue, oldValue);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextRef } from 'context-values';\nimport { OnDomEvent } from 'fun-events/dom';\nimport { ComponentContext } from './component-context';\nimport { ComponentEventDispatcher__key } from './component-event.key.impl';\n\n/**\n * Component event.\n *\n * Events of this type are thrown by various services to inform on component status changes.\n *\n * It is illegal to dispatch such events for elements not bound to components. It is reasonable to dispatch events\n * using [[ComponentEventDispatcher]] available in component context.\n *\n * The following event types supported:\n * - `wesib:component` is dispatched when component is bound to element. I.e. when HTML element is upgraded to custom\n *   one defined by component, or component is mounted to element. The event is dispatched when component is connected\n *   for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Core\n * @event ComponentEvent#wesib:component\n */\nexport class ComponentEvent extends Event {\n\n  /**\n   * Target component context.\n   */\n  get context(): ComponentContext {\n    return ComponentContext.of(this.target);\n  }\n\n}\n\n/**\n * Component event dispatcher is used to listen for and dispatch component events.\n *\n * It is available in bootstrap context context.\n *\n * By default treats a component element as event target.\n *\n * @category Core\n */\nexport interface ComponentEventDispatcher {\n\n  /**\n   * Dispatches the DOM event for the given component.\n   *\n   * @param event  An event to dispatch.\n   *\n   * @returns `true` if either event's `cancelable` attribute value is `false` or its `preventDefault()` method was not\n   * invoked, or `false` otherwise.\n   */\n  dispatch(event: Event): boolean;\n\n  /**\n   * Returns an `OnDomEvent` sender of DOM events of the given type.\n   *\n   * @param type  An event type to listen for.\n   *\n   * @returns A producer of DOM event events of the given type.\n   */\n  on<E extends Event>(type: string): OnDomEvent<E>;\n\n}\n\n/**\n * A key of component context value containing component event dispatcher.\n *\n * @category Core\n */\nexport const ComponentEventDispatcher: SingleContextRef<ComponentEventDispatcher> = ComponentEventDispatcher__key;\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { valueProvider } from 'call-thru';\nimport { Class, decoratePropertyAccessor, PropertyAccessorDescriptor } from '../common';\nimport { ComponentDef, ComponentDef__symbol } from './component-def';\nimport { Component, ComponentDecorator } from './component.decorator';\nimport { ComponentClass } from './definition';\n\n/**\n * Component property decorator interface.\n *\n * Allows to construct a {@link ComponentDecorator component decorator} by declaring a virtual property to use instead\n * of decorated one.\n *\n * Constructed by [[ComponentProperty]] function.\n *\n * @category Core\n * @typeparam V  Property value type.\n * @typeparam T  A type of decorated component class.\n */\nexport interface ComponentPropertyDecorator<V, T extends ComponentClass = Class> {\n\n  /**\n   * Decorates component method.\n   *\n   * @typeparam P  Property value type.\n   * @param proto  Decorated class prototype.\n   * @param propertyKey  Decorated property key.\n   * @param descriptor  Decorated property descriptor.\n   *\n   * @returns  Either updated property descriptor, or nothing.\n   */\n  // eslint-disable-next-line\n  <P extends V>(\n      this: void,\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<P>,\n  ): any | void;\n\n  /**\n   * Builds component decorator assuming the virtual property has the given value.\n   *\n   * @param value  Virtual property value.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  As(\n      this: void,\n      value: V,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the virtual property value is provided by the given `provider`.\n   *\n   * @param provider  Virtual property read-only value provider.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  By(\n      this: void,\n      provider: ComponentProperty.Provider<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is available via the given `accessor`.\n   *\n   * @param accessor  Virtual property accessor.\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]].\n   *\n   * @returns New component decorator.\n   */\n  With(\n      this: void,\n      accessor: ComponentProperty.Accessor<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n  /**\n   * Builds component decorator assuming the decorated property is bound to component with by the given `binder`.\n   *\n   * @param binder  A binder of virtual property accessor\n   * @param key  Virtual property key. Defaults to [[AnonymousComponentProperty__symbol]]..\n   *\n   * @returns New component decorator.\n   */\n  Bind(\n      this: void,\n      binder: ComponentProperty.Binder<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T>;\n\n}\n\nexport namespace ComponentProperty {\n\n  /**\n   * Component property value provider signature.\n   *\n   * This function will be called each time the property value is requested.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export type Provider<V, T extends object = any> =\n  /**\n   * @param component  Component instance.\n   * @param key  Target property key.\n   *\n   * @returns Property value.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => V;\n\n  /**\n   * Component property accessor.\n   *\n   * Allows to read and write property value.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export interface Accessor<V, T extends object = any> {\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component  Target component instance.\n     * @param key  Property key.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: T, key: string | symbol): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     * @param key  Property key.\n     */\n    set(this: void, component: T, value: V, key: string | symbol): void;\n\n  }\n\n  /**\n   * Property accessor binder signature.\n   *\n   * This is a function that binds a {@link BoundAccessor property accessor} to target component.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component.\n   */\n  export type Binder<V, T extends object = any> =\n  /**\n   * @param component  Target component to bind property accessor to.\n   * @param key  Property key.\n   *\n   * @returns Property accessor bound to `component`.\n   */\n      (\n          this: void,\n          component: T,\n          key: string | symbol,\n      ) => BoundAccessor<V>;\n\n  export interface BoundAccessor<V> {\n\n    /**\n     * Reads bound component's property value.\n     *\n     * An attempt to read the value would throw when omitted.\n     *\n     * @returns Property value.\n     */\n    get?(): V;\n\n    /**\n     * Assigns bound component's new property value.\n     *\n     * An attempt to assign the value would throw when omitted.\n     *\n     * @param value  New property value.\n     */\n    set?(value: V): void;\n\n  }\n\n  /**\n   * Component property descriptor.\n   *\n   * Passed to {@link Definer property definer} by [[ComponentProperty]] function to construct a {@link Definition\n   * property definition}.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export interface Descriptor<V, T extends ComponentClass = Class> {\n\n    /**\n     * Component class constructor.\n     */\n    readonly type: T;\n\n    /**\n     * Component property key.\n     */\n    readonly key: string | symbol;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.get property read definition}.\n     */\n    readonly readable: boolean;\n\n    /**\n     * Whether the property is initially writable.\n     *\n     * This can be changed by {@link Definition.set property assignment definition}.\n     */\n    readonly writable: boolean;\n\n    /**\n     * Whether the property is initially enumerable.\n     *\n     * This can be changed by {@link Definition.enumerable property definition}.\n     */\n    readonly enumerable: boolean;\n\n    /**\n     * Whether the property is initially configurable.\n     *\n     * This can be changed by {@link Definition.configurable property definition}.\n     */\n    readonly configurable: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * May throw if the property is not readable.\n     *\n     * @param component  Target component instance.\n     *\n     * @returns Property value.\n     */\n    get(this: void, component: InstanceType<T>): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * May throw is the property is not writable.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     */\n    set(this: void, component: InstanceType<T>, value: V): void;\n\n  }\n\n  /**\n   * Component property definition builder signature.\n   *\n   * This is a function called by [[ComponentProperty]] to define the property.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export type Definer<V, T extends ComponentClass = Class> =\n  /**\n   * @param descriptor  Component property descriptor.\n   *\n   * @returns Component property definition. Or nothing if the property definition is not to be changed.\n   */\n      (\n          this: void,\n          descriptor: Descriptor<V, T>,\n      ) => Definition<V, T> | void;\n\n  /**\n   * Property definition to apply to existing property.\n   *\n   * When applying to decorated property, this definition updates its definition.\n   *\n   * When applying to virtual property assumed by one of [[ComponentPropertyDescriptor]] methods, most of returned\n   * values ignored. Except for {@link Definition.componentDef component definition}, {@link Definition.get value\n   * reader}, and {@link Definition.set value setter}.\n   *\n   * @typeparam V  Property value type.\n   * @typeparam T  A type of component class.\n   */\n  export interface Definition<V, T extends ComponentClass = Class> {\n\n    /**\n     * Component definition to apply to component.\n     *\n     * When specified, it is used to enable certain functionality for decorated (or virtual) property.\n     */\n    readonly componentDef?: ComponentDef<InstanceType<T>>;\n\n    /**\n     * Whether to make the property enumerable.\n     *\n     * When specified, it is used as `enumerable` attribute value of decorated property descriptor.\n     */\n    readonly enumerable?: boolean;\n\n    /**\n     * Whether to make the property configurable.\n     *\n     * When specified, it is used as `configurable` attribute value of decorated property descriptor.\n     */\n    readonly configurable?: boolean;\n\n    /**\n     * Reads property value.\n     *\n     * When specified it changes how the property value is read.\n     *\n     * When neither [[get]], nor [[set]] specified, the property access does not change.\n     *\n     * @param component  Target component instance.\n     * @param key  Property key.\n     *\n     * @returns Property value.\n     */\n    get?(this: void, component: InstanceType<T>, key: string | symbol): V;\n\n    /**\n     * Assigns new property value.\n     *\n     * When specified it changes how the property value is assigned.\n     *\n     * When neither [[get]], nor [[set]] specified, the property access does not change.\n     *\n     * @param component  Target component instance.\n     * @param value  New property value.\n     * @param key  Property key.\n     */\n    set?(this: void, component: InstanceType<T>, value: V, key: string | symbol): void;\n\n  }\n\n}\n\n/**\n * Anonymous component property key.\n *\n * Used as a default virtual property key.\n *\n * @category Core\n */\nexport const AnonymousComponentProperty__symbol = (/*#__PURE__*/ Symbol('anonymous-component-property'));\n\n/**\n * Decorator of component property.\n *\n * Updates decorated property and component definition. Can be converted to {@link ComponentDecorator component\n * decorator} by calling appropriate method of returned decorator instance.\n *\n * @category Core\n * @typeparam V  Decorated property value type.\n * @typeparam T  A type of decorated component class.\n * @param define  Component property definition builder.\n *\n * @returns Component property decorator.\n */\nexport function ComponentProperty<V, T extends ComponentClass = Class>(\n    define: ComponentProperty.Definer<V, T>,\n): ComponentPropertyDecorator<V, T> {\n\n  const decorator = (\n      proto: InstanceType<T>,\n      propertyKey: string | symbol,\n      descriptor?: TypedPropertyDescriptor<V>,\n  ): any | void => decoratePropertyAccessor(\n      proto,\n      propertyKey,\n      descriptor,\n      desc => {\n\n        const { get: getValue, set: setValue } = desc;\n        const type = proto.constructor;\n        const { get, set, configurable, enumerable, componentDef = {} } = define({\n          type,\n          key: propertyKey,\n          readable: !!desc.get,\n          writable: !!desc.set,\n          enumerable: !!desc.enumerable,\n          configurable: !!desc.configurable,\n          get: getValue\n              ? ((component: InstanceType<T>) => getValue.call(component))\n              : notReadableAccessor(propertyKey),\n          set: setValue\n              ? ((component, value) => setValue.call(component, value))\n              : notWritableAccessor(propertyKey),\n        }) || {};\n\n        ComponentDef.define(type, componentDef);\n\n        const updated: PropertyAccessorDescriptor<V> = {\n          ...desc,\n          configurable: configurable ?? desc.configurable,\n          enumerable: enumerable ?? desc.enumerable,\n        };\n\n        if (get || set) {\n          updated.get = get && function (this: InstanceType<T>) {\n            return get(this, propertyKey);\n          };\n          updated.set = set && function (this: InstanceType<T>, value: V) {\n            set(this, value, propertyKey);\n          };\n        }\n\n        return updated;\n      },\n  );\n  const decorateWith = (\n      { get, set }: ComponentProperty.Accessor<V, InstanceType<T>>,\n      key: string | symbol = AnonymousComponentProperty__symbol,\n      writable: boolean,\n  ): ComponentDecorator<T> => Component({\n    [ComponentDef__symbol](type: InstanceType<T>) {\n\n      const def = define({\n        type,\n        key,\n        readable: true,\n        writable,\n        enumerable: false,\n        configurable: false,\n        get: component => get(component, key),\n        set: (component, value) => set(component, value, key),\n      });\n\n      return (def && def.componentDef) || {};\n    },\n  });\n  const By = (\n      provider: ComponentProperty.Provider<V, InstanceType<T>>,\n      key?: string | symbol,\n  ): ComponentDecorator<T> => decorateWith(\n      {\n        get(component, key) {\n          return provider(component, key);\n        },\n      } as ComponentProperty.Accessor<V>,\n      key,\n      false,\n  );\n\n  const result = decorator as ComponentPropertyDecorator<V, T>;\n\n  result.With = (access, key) => decorateWith(access, key, true);\n  result.By = By;\n  result.As = (value, key?) => By(valueProvider(value), key);\n  result.Bind = (binder, key = AnonymousComponentProperty__symbol) => {\n\n    const accessor__symbol = Symbol(`${String(key)}:accessor`);\n    const accessor = (component: any): {\n      get(): V;\n      set(value: V): void;\n    } => {\n\n      const existing = component[accessor__symbol];\n\n      if (existing) {\n        return existing;\n      }\n\n      const accessor = binder(component, key);\n\n      return component[accessor__symbol] = {\n        get: accessor.get ? accessor.get.bind(accessor) : notReadableAccessor(key),\n        set: accessor.set ? accessor.set.bind(accessor) : notWritableAccessor(key),\n      };\n    };\n\n    return decorateWith(\n        {\n          get(component) {\n            return accessor(component).get();\n          },\n          set(component, value) {\n            return accessor(component).set(value);\n          },\n        },\n        key,\n        true,\n    );\n  };\n\n  return result;\n}\n\n/**\n * @internal\n */\nfunction notReadableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not readable`); };\n}\n\n/**\n * @internal\n */\nfunction notWritableAccessor(propertyKey: string | symbol): () => never {\n  return () => { throw new TypeError(`\"${String(propertyKey)}\" is not writable`); };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\n\n/**\n * Element adapter is a function able to convert a raw element to component. E.g. mount a component to it.\n *\n * Features may use it internally. E.g. an `AutoConnectSupport` applies it to each added DOM element.\n *\n * Multiple element adapters can be registered in bootstrap context.\n *\n * @category Core\n */\nexport type ElementAdapter =\n/**\n * @param element  Target raw element to adapt.\n *\n * @returns An adapted component's context, or `undefined` if element can not be adapted.\n */\n    (this: void, element: any) => ComponentContext | undefined;\n\n/**\n * @internal\n */\nclass ElementAdapterKey extends ContextUpKey<ElementAdapter, ElementAdapter> {\n\n  readonly upKey: ContextUpKey.UpKey<ElementAdapter, ElementAdapter>;\n\n  constructor() {\n    super('element-adapter');\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru((...adapters) => {\n\n          const combined: ElementAdapter = adapters.reduce(\n              (prev, adapter) => element => prev(element) || adapter(element),\n              defaultElementAdapter,\n          );\n\n          const defaultProvider = (): AfterEvent<[ElementAdapter]> => afterThe(defaultElementAdapter);\n\n          return combined !== defaultElementAdapter\n              ? combined\n              : nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n        }),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          ElementAdapter,\n          EventKeeper<ElementAdapter[]> | ElementAdapter,\n          AfterEvent<ElementAdapter[]>>,\n  ): ElementAdapter {\n\n    let delegated: ElementAdapter;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(adapter => delegated = adapter);\n\n    return element => delegated(element);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultElementAdapter(element: any): ComponentContext {\n  return element[ComponentContext__symbol];\n}\n\n/**\n * A key of bootstrap context value containing combined [[ElementAdapter]] instance.\n *\n * @category Core\n */\nexport const ElementAdapter: ContextUpRef<ElementAdapter, ElementAdapter> = (/*#__PURE__*/ new ElementAdapterKey());\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { filterIt, itsEach, overArray } from 'a-iterable';\nimport { FnContextKey } from 'context-values/updatable';\nimport { isElement } from '../../common';\nimport { ComponentContext__symbol, ComponentMount } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ElementAdapter } from './element-adapter';\n\n/**\n * Element mutations observer.\n *\n * It is a `MutationObserver` implementation that:\n * - always observes target's children,\n * - applies {@link ElementAdapter element adapter} to added elements,\n * - tracks mounted components {@link ComponentMount.connected connection state}.\n *\n * A function constructing element observer instance could be obtained from bootstrap context.\n *\n * @category Core\n */\nexport interface ElementObserver extends MutationObserver {\n\n  /**\n   * Configures the observer callback to begin receiving notifications of changes to the DOM that match the given\n   * options.\n   * To stop the MutationObserver (so that none of its callbacks will be triggered any longer), call\n   * [[disconnect]].\n   *\n   * @param target  A DOM node within the DOM tree to watch for changes, and to be the root of a subtree of nodes\n   * to be watched.\n   * @param options  An options that describe what DOM mutations should be reported to the observer's callback.\n   */\n  observe(target: Node, options?: ElementObserverInit): void;\n\n}\n\n/**\n * A key of bootstrap context value containing a function constructing a new [[ElementObserver]] instance.\n *\n * @category Core\n */\nexport const ElementObserver: FnContextKey<[MutationCallback], ElementObserver> = (/*#__PURE__*/ new FnContextKey(\n    'element-observer',\n    {\n      byDefault: bootstrapDefault(bsContext => {\n\n        const adapter = bsContext.get(ElementAdapter);\n        class DefaultElementObserver extends MutationObserver implements ElementObserver {\n\n          constructor(callback: MutationCallback) {\n            super(mutations => {\n              mutations.forEach(mutation => {\n                itsEach(\n                    overArray(mutation.removedNodes),\n                    node => mountOf(node)?.checkConnected(),\n                );\n                itsEach(\n                    filterIt(\n                        overArray(mutation.addedNodes),\n                        isElement,\n                    ),\n                    element => adapter(element)?.mount?.checkConnected(),\n                );\n              });\n              callback(mutations, this);\n            });\n          }\n\n          observe(target: Node, options?: ElementObserverInit): void {\n            super.observe(target, { ...options, childList: true });\n          }\n\n        }\n\n        return callback => new DefaultElementObserver(callback);\n      }),\n    },\n));\n\n/**\n * Element observer initialization options.\n *\n * @category Core\n */\nexport interface ElementObserverInit extends MutationObserverInit {\n\n  /**\n   * Whether mutations to target's children are to be observed.\n   *\n   * Always `true`.\n   */\n  childList?: true;\n\n}\n\n/**\n * @internal\n */\nfunction mountOf(node: any): ComponentMount | undefined {\n  return node[ComponentContext__symbol]?.mount;\n}\n","import { ComponentClass, ComponentFactory } from '../../component/definition';\n\n/**\n * @internal\n */\nexport const ComponentFactory__symbol = (/*#__PURE__*/ Symbol('component-factory'));\n\n/**\n * @internal\n */\nexport function componentFactoryOf<T extends object>(componentType: ComponentClass<T>): ComponentFactory<T> {\n\n  const factory = (componentType as any)[ComponentFactory__symbol];\n\n  if (!factory) {\n    throw new TypeError(`Component is not defined: ${componentType}`);\n  }\n\n  return factory;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, SingleContextKey } from 'context-values';\nimport { html__naming, isQualifiedName, QualifiedName } from 'namespace-aliaser';\nimport { BootstrapWindow, DefaultNamespaceAliaser } from '../../boot/globals';\nimport { componentFactoryOf } from '../../boot/impl/component-factory.symbol.impl';\nimport { Class, PromiseResolver } from '../../common';\nimport { ComponentClass } from './component-class';\n\n/**\n * @internal\n */\nconst CustomElements__key = (/*#__PURE__*/ new SingleContextKey<CustomElements>(\n    'custom-elements',\n    {\n      byDefault: createCustomElements,\n    },\n));\n\n/**\n * Custom elements registry.\n *\n * This is used to register custom elements.\n *\n * Typically implemented by `window.customElements`.\n *\n * @category Core\n */\nexport abstract class CustomElements {\n\n  /**\n   * A key of bootstrap context value containing a `CustomElements` instance used to register custom\n   * elements.\n   *\n   * Target value defaults to `window.customElements` from the window provided under `[BootstrapWindow.key]`.\n   */\n  static get [ContextKey__symbol](): ContextKey<CustomElements> {\n    return CustomElements__key;\n  }\n\n  /**\n   * Defines custom element.\n   *\n   * @param componentTypeOrName  A component class constructor or custom element name. The latter may belong to\n   * namespace to avoid naming conflicts.\n   * @param elementType  A constructor of custom element to define.\n   */\n  abstract define(componentTypeOrName: ComponentClass | QualifiedName, elementType: Class): void;\n\n  /**\n   * Allows to wait for component definition.\n   *\n   * This corresponds to `window.customElements.whenDefined()` method.\n   *\n   * @param componentTypeOrName  Component class constructor or custom element name possibly belonging to some\n   * namespace.\n   *\n   * @return A promise that is resolved when custom element is registered.\n   *\n   * @throws TypeError If `componentType` does not contain a component definition.\n   */\n  abstract whenDefined(componentTypeOrName: ComponentClass | QualifiedName): Promise<void>;\n\n}\n\n/**\n * @internal\n */\nfunction createCustomElements(values: ContextValues): CustomElements {\n\n  const customElements: CustomElementRegistry = values.get(BootstrapWindow).customElements;\n  const nsAlias = values.get(DefaultNamespaceAliaser);\n\n  class WindowCustomElements extends CustomElements {\n\n    define(componentTypeOrName: ComponentClass | string, elementType: Class): void {\n      if (isQualifiedName(componentTypeOrName)) {\n        customElements.define(html__naming.name(componentTypeOrName, nsAlias), elementType);\n        return;\n      }\n\n      const factory = componentFactoryOf(componentTypeOrName);\n      const { name, extend } = factory.elementDef;\n\n      if (!name) {\n        componentResolver(componentTypeOrName).resolve(undefined);\n        return; // Anonymous component.\n      }\n      if (extend && extend.name) {\n        customElements.define(\n            html__naming.name(name, nsAlias),\n            elementType,\n            {\n              extends: extend.name,\n            },\n        );\n      } else {\n        customElements.define(html__naming.name(name, nsAlias), elementType);\n      }\n    }\n\n    whenDefined(componentTypeOrName: ComponentClass | string): Promise<void> {\n      if (isQualifiedName(componentTypeOrName)) {\n        return customElements.whenDefined(html__naming.name(componentTypeOrName, nsAlias));\n      }\n\n      const factory = componentFactoryOf(componentTypeOrName);\n      const { name } = factory.elementDef;\n\n      if (!name) {\n        return componentResolver(componentTypeOrName).promise;\n      }\n\n      return customElements.whenDefined(html__naming.name(name, nsAlias));\n    }\n\n  }\n\n  return new WindowCustomElements();\n}\n\n/**\n * @internal\n */\nconst ComponentResolver__symbol = (/*#__PURE__*/ Symbol('component-resolver'));\n\n/**\n * @internal\n */\nfunction componentResolver(componentType: ComponentClass): PromiseResolver<void> {\n  return (componentType as any)[ComponentResolver__symbol]\n      || ((componentType as any)[ComponentResolver__symbol] = new PromiseResolver());\n}\n","import { SingleContextKey } from 'context-values';\nimport { DefinitionContext } from './definition-context';\n\n/**\n * @internal\n */\nexport const DefinitionContext__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContext>('definition-context'));\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { QualifiedName } from 'namespace-aliaser';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class } from '../../common';\nimport { ComponentDef } from '../component-def';\nimport { DefinitionContext__key } from './definition.context.key.impl';\n\n/**\n * Custom element definition meta.\n *\n * @category Core\n */\nexport interface ElementDef {\n\n  /**\n   * Custom element name.\n   *\n   * The name may belong to some namespace to avoid naming conflicts. I.e. it can be either a string, or\n   * name/namespace tuple.\n   *\n   * When omitted an anonymous component will be registered. Such component is not bound to custom element, but it\n   * still can be mounted.\n   */\n  readonly name?: QualifiedName;\n\n  /**\n   * Existing element to extend by custom one.\n   */\n  readonly extend: ElementDef.Extend;\n\n}\n\n/**\n * A key of definition context value containing a custom element definition.\n *\n * Target value defaults to `HTMLElement` from the window provided under `[BootstrapWindow.key]`,\n * unless `ComponentDef.extend.type` is specified.\n */\nexport const ElementDef: SingleContextRef<ElementDef> = (/*#__PURE__*/ new SingleContextKey<ElementDef>(\n    'element-def',\n    {\n      byDefault(values) {\n\n        const componentType = values.get(DefinitionContext__key).componentType;\n        const { name, extend } = ComponentDef.of(componentType);\n\n        const elementExtend: ElementDef.Extend = {\n          get type() {\n            return extend && extend.type || values.get(BootstrapWindow).HTMLElement;\n          },\n          get name() {\n            return extend && extend.name;\n          },\n        };\n\n        return {\n          get name() {\n            return name;\n          },\n          get extend() {\n            return elementExtend;\n          },\n        };\n      },\n    },\n));\n\n/**\n * @category Core\n */\nexport namespace ElementDef {\n\n  /**\n   * The definition of element to extend by custom one.\n   */\n  export interface Extend {\n\n    /**\n     * The class constructor of element to extend.\n     */\n    readonly type: Class;\n\n    /**\n     * The name of element to extend.\n     *\n     * This is to support `as` attribute of standard HTML element. Note that this is not supported by polyfills.\n     */\n    readonly name?: string;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, ContextValues, ContextValueSpec } from 'context-values';\nimport { EventReceiver, EventSupply, OnEvent } from 'fun-events';\nimport { Class } from '../../common';\nimport { ComponentContext } from '../component-context';\nimport { ComponentClass } from './component-class';\nimport { DefinitionContext__key } from './definition.context.key.impl';\nimport { ElementDef } from './element-def';\n\n/**\n * Component definition context.\n *\n * Extends `ContextValues` interface. The values are provided by corresponding providers registered with\n * [[BootstrapSetup.perDefinition]] and [[DefinitionSetup.perDefinition]] methods. All [[BootstrapContext]] values\n * are available too.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class DefinitionContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of definition context value containing the definition context itself.\n   */\n  static get [ContextKey__symbol](): ContextKey<DefinitionContext> {\n    return DefinitionContext__key;\n  }\n\n  /**\n   * Component class constructor.\n   */\n  abstract readonly componentType: ComponentClass<T>;\n\n  /**\n   * Custom element class constructor.\n   *\n   * It is an error accessing this property before the element class is created, e.g. from inside of\n   * `DefinitionListener` or `ComponentDef.define()` function. In these cases you may wish to add a `whenReady()`\n   * callback.\n   */\n  abstract readonly elementType: Class;\n\n  /**\n   * Custom element definition.\n   */\n  get elementDef(): ElementDef {\n    return this.get(ElementDef);\n  }\n\n  /**\n   * Builds an `OnEvent` sender of component definition context upon its readiness.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   *\n   * @returns `OnEvent` sender of this component definition context upon its readiness.\n   */\n  abstract whenReady(): OnEvent<[this]>;\n\n  /**\n   * Registers a receiver of component definition readiness event.\n   *\n   * The custom element class is not constructed until component definition is complete.\n   * The registered receiver will be notified when the custom element class is constructed.\n   *\n   * If the custom element class is constructed already, the receiver will be notified immediately.\n   *\n   * @param receiver  Target receiver of this component definition context upon its readiness.\n   *\n   * @returns Component definition readiness event supply.\n   */\n  abstract whenReady(receiver: EventReceiver<[this]>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of component context upon its instantiation.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenOn connected}. This is to prevent resource leaking\n   * on disconnected components that may be never used again.\n   *\n   * @returns `OnEvent` sender of instantiated component context.\n   */\n  abstract whenComponent(): OnEvent<[ComponentContext<T>]>;\n\n  /**\n   * Starts sending component instantiation events to the given `receiver`.\n   *\n   * If component instantiated after the receiver is registered, that receiver would receive an instantiated component's\n   * context immediately.\n   *\n   * If component already exists when the receiver is registered, that receiver would receive instantiated component's\n   * context only when/if component is {@link ComponentContext.whenOn connected}. This is to prevent resource leaking\n   * on disconnected components that may be never used again.\n   *\n   * @param receiver  Target receiver of instantiate component contexts.\n   *\n   * @returns Component instantiation events supply.\n   */\n  abstract whenComponent(receiver: EventReceiver<[ComponentContext<T>]>): EventSupply;\n\n  /**\n   * Provides a value available in the context of each component of the defined component type.\n   *\n   * @typeparam Deps  A type of dependencies.\n   * @typeparam Src  The type of context value sources.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Component context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract perComponent<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<ComponentContext<T>, any, Deps, Src, Seed>,\n  ): () => void;\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, ContextValues, SingleContextKey } from 'context-values';\nimport { BootstrapContext } from '../bootstrap-context';\n\nconst BootstrapContextRegistry__key = (\n    /*#__PURE__*/ new SingleContextKey<BootstrapContextRegistry>('bootstrap-context-registry')\n);\n\n/**\n * @internal\n */\nexport class BootstrapContextRegistry extends ContextRegistry<BootstrapContext> {\n\n  static get [ContextKey__symbol](): ContextKey<BootstrapContextRegistry> {\n    return BootstrapContextRegistry__key;\n  }\n\n  readonly values: ContextValues;\n\n  static create(): BootstrapContextRegistry {\n    return new BootstrapContextRegistry();\n  }\n\n  private constructor() {\n    super();\n    this.provide({ a: BootstrapContextRegistry, is: this });\n    this.values = this.newValues();\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { ComponentContext } from '../../component';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst ComponentContextRegistry__key = (/*#__PURE__*/ new SingleContextKey<ComponentContextRegistry>(\n    'component-context-registry',\n    {\n      byDefault: bootstrapDefault(() => new ComponentContextRegistry()),\n    },\n));\n\n/**\n * @internal\n */\nexport class ComponentContextRegistry extends ContextRegistry<ComponentContext> {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentContextRegistry> {\n    return ComponentContextRegistry__key;\n  }\n\n}\n","import { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { DefinitionContext } from '../../component/definition';\nimport { bootstrapDefault } from '../bootstrap-default';\n\nconst DefinitionContextRegistry__key = (/*#__PURE__*/ new SingleContextKey<DefinitionContextRegistry>(\n    'definition-context-registry',\n    {\n      byDefault: bootstrapDefault(context => new DefinitionContextRegistry(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class DefinitionContextRegistry extends ContextRegistry<DefinitionContext> {\n\n  static get [ContextKey__symbol](): ContextKey<DefinitionContextRegistry> {\n    return DefinitionContextRegistry__key;\n  }\n\n}\n","import { nextArgs, nextSkip } from 'call-thru';\nimport { EventEmitter, onAny, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { superClassOf } from '../../common';\nimport { ComponentDef__symbol } from '../../component';\nimport { ComponentClass, DefinitionSetup } from '../../component/definition';\nimport { Unloader } from './unloader.impl';\n\n/**\n * @internal\n */\nexport function onPostDefSetup(\n    componentType: ComponentClass,\n    unloader: Unloader,\n): OnEvent<[DefinitionSetup]> {\n\n  const { on } = postDefSetup(componentType);\n\n  return onEventBy(receiver => {\n    on.to({\n      supply: receiver.supply.needs(unloader.supply),\n      receive(ctx, setup) {\n\n        const whenReady = setup.whenReady().tillOff(unloader.supply).F;\n        const whenComponent = setup.whenComponent().tillOff(unloader.supply).F;\n\n        receiver.receive(ctx, {\n          get componentType() {\n            return setup.componentType;\n          },\n          get whenReady() {\n            return whenReady;\n          },\n          get whenComponent() {\n            return whenComponent;\n          },\n          perDefinition(spec) {\n            return unloader.add(() => setup.perDefinition(spec));\n          },\n          perComponent(spec) {\n            return unloader.add(() => setup.perComponent(spec));\n          },\n        });\n      },\n    });\n  });\n}\n\n/**\n * @internal\n */\nexport interface PostDefSetup<T extends object = any> {\n  readonly on: OnEvent<[DefinitionSetup<T>]>;\n  send(setup: DefinitionSetup): void;\n  setup(setup: DefinitionSetup<T>): void;\n}\n\nconst PostDefSetup__symbol = (/*#__PURE__*/ Symbol('post-def-setup'));\n\n/**\n * @internal\n */\nexport function postDefSetup<T extends object>(componentType: ComponentClass<T>): PostDefSetup<T> {\n  // eslint-disable-next-line no-prototype-builtins\n  if (componentType.hasOwnProperty(PostDefSetup__symbol)) {\n    return (componentType as any)[PostDefSetup__symbol];\n  }\n\n  const tracker = trackValue<DefinitionSetup<T>>();\n  const emitter = new EventEmitter<[DefinitionSetup]>();\n  const onSetup: OnEvent<[DefinitionSetup<T>]> = tracker.read().thru(setup => setup ? nextArgs(setup) : nextSkip());\n  const on = onAny(onSetup, emitter);\n  const superType = superClassOf(componentType, type => ComponentDef__symbol in type);\n\n  if (superType) {\n\n    const superPostDefSetup = postDefSetup(superType);\n\n    on.to(setup => superPostDefSetup.send(setup));\n  }\n\n  const result: PostDefSetup<T> = {\n    on,\n    send(setup) {\n      emitter.send(setup);\n    },\n    setup(setup) {\n      tracker.it = setup;\n    },\n  };\n\n  Object.defineProperty(componentType, PostDefSetup__symbol, { value: result });\n\n  return result;\n}\n","import { AfterEvent, EventEmitter, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { ComponentContext } from '../../component';\n\nexport class WhenComponent<T extends object> {\n\n  readonly onCreated: OnEvent<[ComponentContext<T>]>;\n  readonly readNotifier: AfterEvent<[ComponentNotifier<T>]>;\n\n  constructor() {\n\n    const currentRev = trackValue(0);\n    const created = new EventEmitter<[ComponentContext<T>, number]>();\n\n    this.onCreated = onEventBy(receiver => {\n\n      const receiverRev = currentRev.it + 1;\n\n      created.on({\n        supply: receiver.supply,\n        receive: (eventContext, componentContext, notifiedRev) => {\n          if (notifiedRev < receiverRev) {\n            // Notify only receivers added after the last notification\n            receiver.receive(\n                {\n                  onRecurrent(recurrentReceiver) {\n                    eventContext.onRecurrent(recurrentContext => recurrentReceiver(recurrentContext));\n                  },\n                },\n                componentContext,\n            );\n          }\n        },\n      });\n\n      ++currentRev.it;\n    });\n    this.readNotifier = currentRev.read().keepThru_(\n        rev => (context, notifiedRev) => {\n          created.send(context, notifiedRev);\n          return rev;\n        },\n    );\n  }\n\n}\n\nexport type ComponentNotifier<T extends object> = (\n    this: void,\n    context: ComponentContext<T>,\n    notifiedRev: number,\n) => number;\n","import { nextArgs, nextSkip, noop, valueProvider } from 'call-thru';\nimport { ContextRegistry, ContextValues, ContextValueSpec, SingleContextKey, SingleContextRef } from 'context-values';\nimport {\n  EventEmitter,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  trackValue,\n  ValueTracker,\n} from 'fun-events';\nimport { Class } from '../../common';\nimport {\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentDef,\n  ComponentEvent,\n  ComponentMount,\n} from '../../component';\nimport {\n  ComponentClass,\n  ComponentFactory,\n  DefinitionContext,\n  DefinitionSetup,\n  ElementDef,\n} from '../../component/definition';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { bootstrapDefault } from '../bootstrap-default';\nimport { ComponentContextRegistry } from './component-context-registry.impl';\nimport { DefinitionContextRegistry } from './definition-context-registry.impl';\nimport { postDefSetup } from './post-def-setup.impl';\nimport { WhenComponent } from './when-component.impl';\n\n/**\n * @internal\n */\nexport interface ElementBuilder {\n  readonly definitions: EventEmitter<[DefinitionContext]>;\n  readonly components: EventEmitter<[ComponentContext]>;\n  buildElement<T extends object>(this: void, componentType: ComponentClass<T>): ComponentFactory<T>;\n}\n\n/**\n * @internal\n */\nexport const ElementBuilder: SingleContextRef<ElementBuilder> = (/*#__PURE__*/ new SingleContextKey<ElementBuilder>(\n    'element-builder',\n    {\n      byDefault: bootstrapDefault(newElementBuilder),\n    },\n));\n\nconst enum ComponentStatus {\n  Building,\n  Ready,\n  Off,\n  On,\n}\n\nconst ComponentStatus__symbol = (/*#__PURE__*/ Symbol('component-status'));\n\nfunction newElementBuilder(bsContext: BootstrapContext): ElementBuilder {\n\n  const definitionContextRegistry$global = bsContext.get(DefinitionContextRegistry);\n  const componentContextRegistry$global = bsContext.get(ComponentContextRegistry);\n  const definitions = new EventEmitter<[DefinitionContext]>();\n  const components = new EventEmitter<[ComponentContext]>();\n\n  return {\n    definitions,\n    components,\n    buildElement<T extends object>(componentType: ComponentClass<T>) {\n\n      const def = ComponentDef.of(componentType);\n      const whenComponent = new WhenComponent<T>();\n      let componentContextRegistry$perType!: ComponentContextRegistry;\n      const ready = trackValue(false);\n      const whenReady: OnEvent<[]> = ready.read().thru(cls => cls ? nextArgs() : nextSkip());\n      // eslint-disable-next-line prefer-const\n      let definitionContext: DefinitionContext$;\n\n      function createComponentContextRegistry(): ContextRegistry<ComponentContext<T>> {\n        return componentContextRegistry$global.append(componentContextRegistry$perType);\n      }\n\n      class ComponentFactory$ extends ComponentFactory < T > {\n\n        get componentType(): ComponentClass<T> {\n          return definitionContext.componentType;\n        }\n\n        get elementType(): Class {\n          return definitionContext.elementType;\n        }\n\n        get elementDef(): ElementDef {\n          return definitionContext.elementDef;\n        }\n\n        mountTo(element: any): ComponentMount<T> {\n          if (element[ComponentContext__symbol]) {\n            throw new Error(`Element ${element} already bound to component`);\n          }\n\n          const mount = createComponent({\n            definitionContext,\n            whenComponent,\n            registry: createComponentContextRegistry(),\n            element,\n            elementSuper(key) {\n              return element[key];\n            },\n            createMount(context: ComponentContext<T>) {\n\n              class ComponentMount$ extends ComponentMount<T> {\n\n                get context(): ComponentContext<T> {\n                  return context;\n                }\n\n                get connected(): boolean {\n                  return elementStatus(element).it === ComponentStatus.On;\n                }\n\n                set connected(value: boolean) {\n                  elementStatus(element).it = value ? ComponentStatus.On : ComponentStatus.Off;\n                }\n\n                checkConnected(): boolean {\n\n                  const el: Element = element;\n                  const doc = el.ownerDocument;\n\n                  return this.connected = doc != null && doc.contains(el);\n                }\n\n              }\n\n              return new ComponentMount$();\n            },\n          }).mount as ComponentMount<T>;\n\n          mount.checkConnected();\n          componentCreated(mount.context);\n\n          return mount;\n        }\n\n      }\n\n      const componentFactory = new ComponentFactory$();\n\n      class DefinitionContext$ extends DefinitionContext<T> {\n\n        readonly get: ContextValues['get'];\n\n        get componentType(): ComponentClass<T> {\n          return componentType;\n        }\n\n        get elementType(): Class {\n          throw new Error('Custom element class is not constructed yet. Consider to use a `whenReady()` callback');\n        }\n\n        constructor() {\n          super();\n\n          const definitionContextRegistry = new DefinitionContextRegistry(\n              definitionContextRegistry$global.seedIn(this),\n          );\n\n          definitionContextRegistry.provide({ a: DefinitionContext, is: this });\n          definitionContextRegistry.provide({ a: ComponentFactory, is: componentFactory });\n          this.get = definitionContextRegistry.newValues().get;\n          componentContextRegistry$perType = new ComponentContextRegistry(definitionContextRegistry.seedIn(this));\n\n          const whenReady = this.whenReady().F;\n          const whenComponent = this.whenComponent().F;\n\n          const definitionSetup: DefinitionSetup<T> = {\n            get componentType() {\n              return componentType;\n            },\n            get whenReady() {\n              return whenReady;\n            },\n            get whenComponent() {\n              return whenComponent;\n            },\n            perDefinition(spec) {\n              return definitionContextRegistry.provide(spec);\n            },\n            perComponent(spec) {\n              return componentContextRegistry$perType.provide(spec);\n            },\n          };\n\n          def.setup?.(definitionSetup);\n          postDefSetup(componentType).setup(definitionSetup);\n        }\n\n        whenReady(): OnEvent<[this]>;\n        whenReady(receiver: EventReceiver<[this]>): EventSupply;\n        whenReady(receiver?: EventReceiver<[this]>): EventSupply | OnEvent<[this]> {\n          return (this.whenReady = (whenReady.thru_(valueProvider(this)).once() as OnEvent<[this]>).F)(receiver);\n        }\n\n        whenComponent(): OnEvent<[ComponentContext<T>]>;\n        whenComponent(receiver: EventReceiver<[ComponentContext<T>]>): EventSupply;\n        whenComponent(receiver?: EventReceiver<[ComponentContext<T>]>): OnEvent<[ComponentContext<T>]> | EventSupply {\n          return (this.whenComponent = whenComponent.onCreated.F)(receiver);\n        }\n\n        perComponent<Deps extends any[], Src, Seed>(\n            spec: ContextValueSpec<ComponentContext<T>, any, Deps, Src, Seed>,\n        ): () => void {\n          return componentContextRegistry$perType.provide(spec);\n        }\n\n      }\n\n      definitionContext = new DefinitionContext$();\n\n      def.define?.(definitionContext);\n      definitions.send(definitionContext);\n\n      const elementType = createElementType(definitionContext, whenComponent, createComponentContextRegistry);\n\n      Object.defineProperty(definitionContext, 'elementType', {\n        configurable: true,\n        enumerable: true,\n        value: elementType,\n      });\n\n      ready.it = true;\n\n      return componentFactory;\n    },\n  };\n\n  function createElementType<T extends object>(\n      definitionContext: DefinitionContext<T>,\n      whenComponent: WhenComponent<T>,\n      createRegistry: () => ContextRegistry<ComponentContext<T>>,\n  ): Class {\n\n    const elementDef = definitionContext.get(ElementDef);\n\n    class Element extends elementDef.extend.type {\n\n      // Component context reference\n      [ComponentContext__symbol]: ComponentContext<T>;\n\n      constructor() {\n        super();\n\n        const context = createComponent({\n          definitionContext,\n          whenComponent,\n          registry: createRegistry(),\n          element: this,\n          createMount: noop,\n          elementSuper: key => super[key],\n        });\n\n        componentCreated(context);\n      }\n\n      connectedCallback(): void {\n        elementStatus(this).it = ComponentStatus.On;\n      }\n\n      disconnectedCallback(): void {\n        elementStatus(this).it = ComponentStatus.Off;\n      }\n\n    }\n\n    return Element;\n  }\n\n  function createComponent<T extends object>(\n      {\n        definitionContext,\n        whenComponent,\n        registry,\n        element,\n        createMount,\n        elementSuper,\n      }: {\n        definitionContext: DefinitionContext<T>;\n        whenComponent: WhenComponent<T>;\n        registry: ComponentContextRegistry;\n        element: any;\n        elementSuper(name: PropertyKey): any;\n        createMount(context: ComponentContext<T>): ComponentMount<T> | undefined;\n      },\n  ): ComponentContext<T> {\n\n    const status = trackValue<ComponentStatus>(ComponentStatus.Building);\n    const destructionReason = trackValue<[any] | undefined>();\n\n    eventSupplyOf(status).whenOff(reason => destructionReason.it = [reason]);\n\n    let mount: ComponentMount<T> | undefined;\n    const values = registry.newValues();\n\n    class ComponentContext$ extends ComponentContext<T> {\n\n      readonly get = values.get;\n      readonly elementSuper = elementSuper;\n\n      get componentType(): ComponentClass<T> {\n        return definitionContext.componentType;\n      }\n\n      get element(): any {\n        return element;\n      }\n\n      get component(): T {\n        throw new Error('The component is not constructed yet. Consider to use a `whenReady()` callback');\n      }\n\n      get mount(): ComponentMount<T> | undefined {\n        return mount || (mount = createMount(this));\n      }\n\n      get connected(): boolean {\n        return status.it === ComponentStatus.On;\n      }\n\n      get [EventSupply__symbol](): EventSupply {\n        return eventSupplyOf(status);\n      }\n\n      whenReady(): OnEvent<[this]>;\n      whenReady(receiver: EventReceiver<[this]>): EventSupply;\n      whenReady(receiver?: EventReceiver<[this]>): OnEvent<[this]> | EventSupply {\n        return (this.whenReady = status.read().thru(sts => sts ? nextArgs(this) : nextSkip()).once().F)(receiver);\n      }\n\n      whenOn(): OnEvent<[EventSupply]>;\n      whenOn(receiver: EventReceiver<[EventSupply]>): EventSupply;\n      whenOn(receiver?: EventReceiver<[EventSupply]>): OnEvent<[EventSupply]> | EventSupply {\n        return (this.whenOn = status.read().thru_(\n            sts => {\n              if (sts !== ComponentStatus.On) {\n                return nextSkip();\n              }\n\n              const offSupply = eventSupply();\n\n              this.whenOff().once(() => offSupply.off()).cuts(offSupply);\n\n              return nextArgs(offSupply);\n            },\n        ).F)(receiver);\n      }\n\n      whenOff(): OnEvent<[]>;\n      whenOff(receiver: EventReceiver<[]>): EventSupply;\n      whenOff(receiver?: EventReceiver<[]>): EventSupply | OnEvent<[]> {\n        return (this.whenOff = status.read().thru_(\n            sts => sts === ComponentStatus.Off ? nextArgs() : nextSkip(),\n        ).F)(receiver);\n      }\n\n      whenDestroyed(): OnEvent<[any]>;\n      whenDestroyed(receiver: EventReceiver<[any]>): EventSupply;\n      whenDestroyed(receiver?: EventReceiver<[any]>): OnEvent<[any]> | EventSupply {\n        return (this.whenDestroyed = destructionReason.read().thru(\n            reason => reason ? nextArgs(reason[0]) : nextSkip(),\n        ).once().F)(receiver);\n      }\n\n      destroy(reason?: any): void {\n        status.done(reason);\n      }\n\n    }\n\n    const context = new ComponentContext$();\n    let lastRev = 0;\n\n    context.whenDestroyed(() => removeElement(context));\n    registry.provide({ a: ComponentContext, is: context });\n\n    augmentElement();\n\n    whenComponent.readNotifier.once(notifier => lastRev = notifier(context, lastRev));\n    context.whenOn(supply => {\n      whenComponent.readNotifier.to({\n        supply,\n        receive(_, notifier) {\n          lastRev = notifier(context, lastRev);\n        },\n      });\n    });\n    components.send(context);\n\n    const component = newComponent(definitionContext.componentType, context);\n\n    Object.defineProperty(context, 'component', {\n      configurable: true,\n      enumerable: true,\n      value: component,\n    });\n\n    status.it = ComponentStatus.Ready;\n\n    return context;\n\n    function augmentElement(): void {\n      Object.defineProperty(element, ComponentContext__symbol, { value: context });\n      Object.defineProperty(element, ComponentStatus__symbol, { writable: true, value: status });\n    }\n  }\n\n}\n\n/**\n * Creates new component of the given type.\n *\n * It makes component context available under `[ComponentContext__symbol]` key in constructed component.\n * The component context is also available inside component constructor by temporarily assigning it to component\n * prototype.\n *\n * @typeparam T  A type of component.\n * @param type  Component class constructor.\n * @param context  Target component context.\n */\nfunction newComponent<T extends object>(type: ComponentClass<T>, context: ComponentContext<T>): T {\n\n  const proto = type.prototype as any;\n  const prevContext = proto[ComponentContext__symbol];\n\n  proto[ComponentContext__symbol] = context;\n  try {\n\n    const component = new type(context);\n\n    Object.defineProperty(component, ComponentContext__symbol, { value: context });\n\n    return component;\n  } finally {\n    proto[ComponentContext__symbol] = prevContext;\n  }\n}\n\nfunction elementStatus(element: any): ValueTracker<ComponentStatus> {\n  return element[ComponentStatus__symbol];\n}\n\nfunction componentCreated(context: ComponentContext): void {\n  context.whenOn().once(\n      () => context.dispatchEvent(new ComponentEvent('wesib:component', { bubbles: true })),\n  );\n}\n\nfunction removeElement(context: ComponentContext): void {\n\n  const { element, mount } = context;\n\n  if (mount) {\n    mount.connected = false; // Disconnect mounted element\n  }\n\n  const parentNode: Element = element.parentElement;\n\n  if (parentNode) {\n    parentNode.removeChild(element);\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext } from './component-context';\n\n/**\n * A mount of the component to an element.\n *\n * This is constructed when a component is mounted to arbitrary element by [[ComponentFactory.mountTo]] method.\n *\n * Mounted components do not maintain their connection state automatically. It is a calling code responsibility to set\n * their connection state by updating [[ComponentMount.connected]] property. E.g. by calling a\n * [[ComponentMount.checkConnected]] method. An [[ElementObserver]] and [[AutoConnectSupport]] feature could be used to\n * do it automatically.\n *\n * @category Core\n * @typeparam T  A type of component.\n */\nexport abstract class ComponentMount<T extends object = any> {\n\n  /**\n   * Mounted component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Component connection state.\n   *\n   * Updating this property triggers appropriate listeners registered in [[ComponentContext]].\n   *\n   * The initial state is set by [[checkConnected]] method.\n   */\n  abstract connected: boolean;\n\n  /**\n   * Mounted component.\n   */\n  get component(): T {\n    return this.context.component;\n  }\n\n  /**\n   * An element the component is mounted to.\n   */\n  get element(): any {\n    return this.context.element;\n  }\n\n  /**\n   * Checks whether the mounted component element is actually connected to its owning document.\n   *\n   * Updates the `connected` property and returns its value.\n   *\n   * @returns `true` if the component element is connected, or `false` otherwise.\n   */\n  abstract checkConnected(): boolean;\n\n}\n","import { itsEach, overArray } from 'a-iterable';\nimport { noop, valueProvider } from 'call-thru';\nimport { EventSupply, eventSupply } from 'fun-events';\n\n/**\n * @internal\n */\nexport interface Unloader {\n  readonly supply: EventSupply;\n  add(adder: () => () => void): () => void;\n}\n\nconst doNotAdd = valueProvider(noop);\n\n/**\n * @internal\n */\nexport function newUnloader(): Unloader {\n\n  const unloads: (() => void)[] = [];\n  let add = (adder: () => () => void): () => void => {\n\n    const unload = adder();\n\n    unloads.push(unload);\n\n    return unload;\n  };\n  const supply = eventSupply(() => {\n    add = doNotAdd;\n    itsEach(\n        overArray(unloads).reverse(),\n        unload => unload(),\n    );\n    unloads.length = 0;\n  });\n\n  return {\n    supply,\n    add(adder) {\n      return add(adder);\n    },\n  };\n}\n","import { ElementBuilder } from '../../boot/impl';\nimport { ComponentFactory__symbol } from '../../boot/impl/component-factory.symbol.impl';\nimport { ComponentClass, CustomElements } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\n\n/**\n * @internal\n */\nexport class ComponentRegistry {\n\n  private _definitionQueue: (() => void)[] = [];\n\n  constructor(private readonly _context: FeatureContext) {\n    _context.whenReady(() => {\n      this._definitionQueue.forEach(definition => definition());\n      delete this._definitionQueue;\n    });\n  }\n\n  get customElements(): CustomElements {\n    return this._context.get(CustomElements);\n  }\n\n  define<T extends object>(componentType: ComponentClass<T>): void {\n    this._definitionQueue.push(() => {\n\n      const elementBuilder = this._context.get(ElementBuilder);\n      const factory = elementBuilder.buildElement(componentType);\n\n      (componentType as any)[ComponentFactory__symbol] = factory;\n\n      this.customElements.define(componentType, factory.elementType);\n    });\n  }\n\n}\n","import { filterIt, mapIt } from 'a-iterable';\nimport { isPresent, nextArg, nextArgs, NextCall, NextSkip, nextSkip } from 'call-thru';\nimport { ContextRegistry, ContextValueOpts, ContextValues, ContextValueSpec } from 'context-values';\nimport { ContextUpKey } from 'context-values/updatable';\nimport {\n  afterAll,\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterThe,\n  EventKeeper,\n  EventReceiver,\n  EventSupply,\n  nextAfterEvent,\n  OnEvent,\n  OnEventCallChain,\n  trackValue,\n} from 'fun-events';\nimport { BootstrapContext } from '../../boot';\nimport {\n  BootstrapContextRegistry,\n  ComponentContextRegistry,\n  DefinitionContextRegistry,\n  ElementBuilder,\n  newUnloader,\n  onPostDefSetup,\n} from '../../boot/impl';\nimport { ArraySet, Class } from '../../common';\nimport { ComponentContext } from '../../component';\nimport { ComponentClass, DefinitionContext, DefinitionSetup } from '../../component/definition';\nimport { FeatureContext } from '../feature-context';\nimport { ComponentRegistry } from './component-registry.impl';\nimport { FeatureClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureKey__symbol = (/*#__PURE__*/ Symbol('feature-key'));\n\n/**\n * @internal\n */\nexport class FeatureKey extends ContextUpKey<AfterEvent<[FeatureLoader?]>, FeatureClause> {\n\n  static of(feature: Class): FeatureKey {\n    // eslint-disable-next-line no-prototype-builtins\n    return feature.hasOwnProperty(FeatureKey__symbol)\n        ? (feature as any)[FeatureKey__symbol]\n        : ((feature as any)[FeatureKey__symbol] = new FeatureKey(feature));\n  }\n\n  get upKey(): this {\n    return this;\n  }\n\n  private constructor(feature: Class) {\n    super(`feature:${feature.name}`);\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[FeatureLoader?]>,\n          EventKeeper<FeatureClause[]> | FeatureClause,\n          AfterEvent<FeatureClause[]>>,\n  ): AfterEvent<[FeatureLoader?]> | null | undefined {\n    return loadFeature(\n        opts.context.get(BootstrapContext),\n        opts.seed.keepThru(preferredFeatureClause),\n    );\n  }\n\n}\n\nfunction preferredFeatureClause(...clauses: FeatureClause[]): FeatureClause | undefined {\n\n  let required = false;\n  let preferred: FeatureClause | undefined;\n\n  for (const clause of clauses) {\n    switch (clause[1]) {\n      case 'is':\n        required = true;\n        if (!preferred) {\n          preferred = clause;\n        }\n        break;\n      case 'has':\n        preferred = clause;\n        break;\n      case 'needs':\n        required = true;\n    }\n  }\n\n  return required ? preferred : undefined;\n}\n\nfunction loadFeature(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<[FeatureLoader?]> {\n  return afterEventBy<[FeatureLoader?]>(receiver => {\n\n    let origin: Class | undefined;\n    let source: AfterEvent<[FeatureLoader?]> = afterThe();\n    let stageId: Promise<FeatureStageId> = Promise.resolve('idle');\n\n    return afterAll({\n      clause: from,\n      deps: loadFeatureDeps(bsContext, from),\n    }).keepThru_(({ clause: [clause], deps }): NextCall<OnEventCallChain, [FeatureLoader?]> => {\n      if (!clause) {\n        return nextArgs();\n      }\n\n      const [request, , target] = clause;\n\n      if (request.feature === origin) {\n        return nextAfterEvent(source); // Origin didn't change. Reuse the source.\n      }\n\n      origin = request.feature;\n\n      if (target !== origin) {\n        // Originated from replacement feature provider. Reuse its loader.\n        return nextAfterEvent(source = bsContext.get(FeatureKey.of(origin)).keepThru_(\n            loader => {\n              loader!.to(stageId);\n              stageId = loader!.stage;\n              return loader;\n            },\n        ));\n      }\n\n      // Create feature's own loader\n      const ownLoader = new FeatureLoader(bsContext, request, deps).to(stageId);\n      const ownSource = afterThe(ownLoader);\n\n      return nextAfterEvent(source = afterEventBy<[FeatureLoader]>(\n          rcv => ownSource.to(rcv).whenOff(() => {\n            stageId = ownLoader.unload();\n          }),\n      ).share()); // Can be accessed again when reused\n    }).to(receiver);\n  }).keepThru(\n      preventDuplicateLoader(),\n  );\n}\n\nfunction preventDuplicateLoader():\n    (\n        loader?: FeatureLoader,\n    ) => NextCall<OnEventCallChain, [FeatureLoader?]> | NextSkip {\n\n  let lastLoader: FeatureLoader | null | undefined = null; // Initially `null` to differ from `undefined`\n\n  return (loader?: FeatureLoader) => {\n    if (lastLoader === loader) {\n      return nextSkip();\n    }\n    lastLoader = loader;\n\n    if (!loader) {\n      return nextArgs<[FeatureLoader?]>();\n    }\n\n    return nextArgs<[FeatureLoader?]>(loader);\n  };\n}\n\nfunction loadFeatureDeps(\n    bsContext: BootstrapContext,\n    from: AfterEvent<[FeatureClause?]>,\n): AfterEvent<FeatureLoader[]> {\n  return from.keepThru_(clause => {\n    if (!clause) {\n      return nextArgs();\n    }\n\n    const [{ def }] = clause;\n    const needs = new ArraySet(def.needs);\n\n    if (!needs.size) {\n      return nextArgs();\n    }\n\n    return nextAfterEvent(\n        afterEach(\n            ...mapIt(\n                needs,\n                dep => bsContext.get(FeatureKey.of(dep)),\n            ),\n        ).keepThru_(presentFeatureDeps),\n    );\n  });\n}\n\nfunction presentFeatureDeps(...deps: [FeatureLoader?][]): NextCall<OnEventCallChain, FeatureLoader[]> {\n  return nextArgs<FeatureLoader[]>(\n      ...filterIt<FeatureLoader | undefined, FeatureLoader>(\n          mapIt(deps, dep => dep[0]),\n          isPresent,\n      ),\n  );\n}\n\n/**\n * @internal\n */\nexport class FeatureLoader {\n\n  readonly down: Promise<void>;\n  private _stage: Promise<FeatureStage>;\n  private _down!: () => void;\n  readonly state = trackValue(false);\n\n  constructor(\n      readonly bsContext: BootstrapContext,\n      readonly request: FeatureRequest,\n      readonly deps: FeatureLoader[],\n  ) {\n    this.down = new Promise(resolve => this._down = resolve);\n    this._stage = Promise.resolve(new SetupFeatureStage(this));\n  }\n\n  get stage(): Promise<FeatureStageId> {\n    return this._stage.then(stage => stage.after);\n  }\n\n  get ready(): boolean {\n    return this.state.it;\n  }\n\n  to(stageId: Promise<FeatureStageId>): this {\n\n    const lastStage = this._stage;\n\n    this._stage = stageId.then(id => lastStage.then(stage => stage[id]()));\n\n    return this;\n  }\n\n  async setup(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.setup()));\n  }\n\n  async init(): Promise<void> {\n    await (this._stage = this._stage.then(stage => stage.init()));\n  }\n\n  async unload(): Promise<FeatureStageId> {\n\n    const prevStage = this._stage;\n\n    delete this._stage; // Unloaded feature should never be accessed again.\n\n    const stage = await prevStage;\n    const stageId = await stage.stop();\n\n    this._down();\n\n    return stageId;\n  }\n\n}\n\ntype FeatureStageId = 'idle' | 'setup' | 'init';\ntype FeatureStageStop = (this: void) => Promise<any>;\n\nabstract class FeatureStage {\n\n  abstract readonly after: FeatureStageId;\n\n  constructor(\n      readonly loader: FeatureLoader,\n      private readonly _stop: FeatureStageStop = () => Promise.resolve(),\n  ) {}\n\n  idle(): Promise<this> {\n    return Promise.resolve(this);\n  }\n\n  abstract setup(): Promise<FeatureStage>;\n\n  abstract init(): Promise<FeatureStage>;\n\n  stop(): Promise<FeatureStageId> {\n    return this._stop().then(() => this.after);\n  }\n\n  protected perDep(action: (dep: FeatureLoader) => Promise<void>): Promise<any> {\n\n    const { deps } = this.loader;\n\n    return Promise.all(deps.map(dep => action(dep)));\n  }\n\n}\n\nclass SetupFeatureStage extends FeatureStage {\n\n  get after(): 'idle' {\n    return 'idle';\n  }\n\n  async setup(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.setup());\n\n    const { bsContext, request: { def } } = this.loader;\n    const [context, supply] = newFeatureContext(bsContext, this.loader);\n\n    def.setup?.(context);\n\n    return new InitFeatureStage(\n        this.loader,\n        context,\n        () => Promise.resolve(supply.off()),\n    );\n  }\n\n  init(): Promise<FeatureStage> {\n    return this.setup().then(stage => stage.init());\n  }\n\n}\n\nclass InitFeatureStage extends FeatureStage {\n\n  get after(): 'setup' {\n    return 'setup';\n  }\n\n  constructor(\n      state: FeatureLoader,\n      private readonly _context: FeatureContext,\n      stop: FeatureStageStop,\n  ) {\n    super(state, stop);\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  async init(): Promise<FeatureStage> {\n    await this.perDep(loader => loader.init());\n\n    const { request: { def } } = this.loader;\n\n    def.init?.(this._context);\n\n    return new ActiveFeatureStage(this);\n  }\n\n}\n\nclass ActiveFeatureStage extends FeatureStage {\n\n  get after(): 'init' {\n    return 'init';\n  }\n\n  constructor(prev: InitFeatureStage) {\n    super(prev.loader, () => prev.stop());\n    prev.loader.state.it = true;\n  }\n\n  setup(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n  init(): Promise<FeatureStage> {\n    return Promise.resolve(this);\n  }\n\n}\n\nfunction newFeatureContext(\n    bsContext: BootstrapContext,\n    loader: FeatureLoader,\n): [FeatureContext, EventSupply] {\n\n  const unloader = newUnloader();\n  let componentRegistry: ComponentRegistry;\n  const definitionContextRegistry = bsContext.get(DefinitionContextRegistry);\n  const componentContextRegistry = bsContext.get(ComponentContextRegistry);\n  const registry = new ContextRegistry<FeatureContext>(bsContext);\n  const elementBuilder = bsContext.get(ElementBuilder);\n\n  class FeatureContext$ extends FeatureContext {\n\n    readonly get = registry.newValues().get;\n\n    constructor() {\n      super();\n      registry.provide({ a: FeatureContext, is: this });\n      componentRegistry = new ComponentRegistry(this);\n    }\n\n    get feature(): Class {\n      return loader.request.feature;\n    }\n\n    whenReady(): OnEvent<[FeatureContext]>;\n    whenReady(receiver: EventReceiver<[FeatureContext]>): EventSupply;\n    whenReady(receiver?: EventReceiver<[FeatureContext]>): OnEvent<[FeatureContext]> | EventSupply {\n      return (this.whenReady = afterAll({\n        st: loader.state,\n        bs: trackValue<BootstrapContext>().by(bsContext.whenReady()),\n      }).thru(\n          ({\n            st: [ready],\n            bs: [bs],\n          }) => bs && ready ? nextArg(this) : nextSkip(),\n      ).once().F)(receiver);\n    }\n\n    onDefinition(): OnEvent<[DefinitionContext]>;\n    onDefinition(receiver: EventReceiver<[DefinitionContext]>): EventSupply;\n    onDefinition(receiver?: EventReceiver<[DefinitionContext]>): OnEvent<[DefinitionContext]> | EventSupply {\n      return (this.onDefinition = elementBuilder.definitions.on().tillOff(unloader.supply).F)(receiver);\n    }\n\n    onComponent(): OnEvent<[ComponentContext]>;\n    onComponent(receiver: EventReceiver<[ComponentContext]>): EventSupply;\n    onComponent(receiver?: EventReceiver<[ComponentContext]>): EventSupply | OnEvent<[ComponentContext]> {\n      return (this.onComponent = elementBuilder.components.on().tillOff(unloader.supply).F)(receiver);\n    }\n\n    provide<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<BootstrapContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => bsContext.get(BootstrapContextRegistry).provide(spec));\n    }\n\n    perDefinition<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<DefinitionContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => definitionContextRegistry.provide(spec));\n    }\n\n    perComponent<Deps extends any[], Src, Seed>(\n        spec: ContextValueSpec<ComponentContext, any, Deps, Src, Seed>,\n    ): () => void {\n      return unloader.add(() => componentContextRegistry.provide(spec));\n    }\n\n    setupDefinition<T extends object>(componentType: ComponentClass<T>): OnEvent<[DefinitionSetup]> {\n      return onPostDefSetup(componentType, unloader);\n    }\n\n    define<T extends object>(componentType: ComponentClass<T>): void {\n      componentRegistry.define(componentType);\n    }\n\n  }\n\n  return [new FeatureContext$(), unloader.supply];\n}\n","import { ArraySet, Class, mergeFunctions } from '../../common';\nimport { ComponentDef, ComponentDef__symbol } from '../../component';\nimport { FeatureDef } from '../feature-def';\nimport { FeatureNeedsError } from '../feature-needs-error';\nimport { FeatureKey } from './feature-loader.impl';\nimport { FeatureRequester } from './feature-requester.impl';\n\n/**\n * @internal\n */\nexport type FeatureClause = [FeatureRequest, 'is' | 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport type FeatureNeedClause = [FeatureRequest, 'needs' | 'has', Class];\n\n/**\n * @internal\n */\nexport class FeatureRequest {\n\n  readonly def: FeatureDef.Options;\n  private _uses = 0;\n\n  constructor(\n      private readonly _requester: FeatureRequester,\n      readonly feature: Class,\n      private _revoke: () => void,\n  ) {\n    this.def = featureDef(feature);\n  }\n\n  request(clauses: readonly FeatureNeedClause[]): this {\n\n    const requester = this._requester;\n    const { registry } = requester;\n    const isClause: FeatureClause = [this, 'is', this.feature];\n\n    this._revokeBy(registry.provide({\n      a: FeatureKey.of(this.feature),\n      is: isClause,\n    }));\n\n    new ArraySet(this.def.has).forEach(feature => {\n\n      const clause: FeatureNeedClause = [this, 'has', feature];\n\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n\n      // Request the provided feature _after_ provider\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n    });\n\n    new ArraySet(this.def.needs).forEach(feature => {\n\n      const clause: FeatureNeedClause = [this, 'needs', feature];\n\n      const request = requester.request(feature, [...clauses, clause]);\n\n      this._revokeBy(() => request.unuse());\n      this._revokeBy(registry.provide({ a: FeatureKey.of(feature), is: clause }));\n    });\n\n    this._uses = 1;\n\n    return this;\n  }\n\n  reuse(clauses: readonly FeatureNeedClause[]): this {\n    if (!this._uses) {\n      throw new FeatureNeedsError(clauses.map(([{ feature }, reason, need]) => [feature, reason, need]));\n    }\n\n    ++this._uses;\n\n    return this;\n  }\n\n  unuse(): void {\n    if (!--this._uses) {\n      this._revoke();\n    }\n  }\n\n  private _revokeBy(revoke: () => void): void {\n    this._revoke = mergeFunctions(revoke, this._revoke);\n  }\n\n}\n\nfunction featureDef(featureType: Class): FeatureDef.Options {\n\n  let def = FeatureDef.of(featureType);\n\n  if (ComponentDef__symbol in featureType) {\n    def = FeatureDef.merge(\n        def,\n        {\n          init(context) {\n            context.define(featureType);\n          },\n        },\n    );\n\n    const { feature } = ComponentDef.of(featureType);\n\n    if (feature) {\n      def = FeatureDef.merge(def, feature);\n    }\n\n  }\n\n  return def;\n}\n\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { BootstrapContext, bootstrapDefault } from '../../boot';\nimport { BootstrapContextRegistry } from '../../boot/impl';\nimport { Class } from '../../common';\nimport { FeatureNeedClause, FeatureRequest } from './feature-request.impl';\n\nconst FeatureRequester__key = (/*#__PURE__*/ new SingleContextKey<FeatureRequester>(\n    'feature-requester',\n    {\n      byDefault: bootstrapDefault(context => new FeatureRequester(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport class FeatureRequester {\n\n  static get [ContextKey__symbol](): ContextKey<FeatureRequester> {\n    return FeatureRequester__key;\n  }\n\n  readonly registry: BootstrapContextRegistry;\n  private readonly _map = new Map<Class, FeatureRequest>();\n\n  constructor(context: BootstrapContext) {\n    this.registry = context.get(BootstrapContextRegistry);\n  }\n\n  request(feature: Class, clauses: readonly FeatureNeedClause[] = []): FeatureRequest {\n\n    const existing = this._map.get(feature);\n\n    if (existing) {\n      return existing.reuse(clauses);\n    }\n\n    const request = new FeatureRequest(this, feature, () => this._map.delete(feature));\n\n    this._map.set(feature, request);\n\n    return request.request(clauses);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs, nextSkip } from 'call-thru';\nimport { AfterEvent, afterEventBy, EventReceiver, EventSupply, OnEvent, trackValue } from 'fun-events';\nimport { newNamespaceAliaser } from 'namespace-aliaser';\nimport { Class } from '../../common';\nimport { ComponentClass, ComponentFactory, CustomElements } from '../../component/definition';\nimport { FeatureDef, FeatureRef, FeatureStatus } from '../../feature';\nimport { FeatureKey, FeatureLoader, FeatureRequester } from '../../feature/loader';\nimport { BootstrapContext } from '../bootstrap-context';\nimport { DefaultNamespaceAliaser } from '../globals';\nimport { BootstrapContextRegistry } from '../impl';\nimport { componentFactoryOf } from '../impl/component-factory.symbol.impl';\n\n/**\n * Bootstraps components.\n *\n * Both features and components can be passed as parameters to this function.\n *\n * @category Core\n * @param features  Features and components to enable.\n *\n * @returns Bootstrap context instance.\n */\nexport function bootstrapComponents(...features: Class[]): BootstrapContext {\n\n  const bootstrapContextRegistry = BootstrapContextRegistry.create();\n  const { bootstrapContext, complete } = initBootstrap(bootstrapContextRegistry);\n  const feature = features.length === 1 ? features[0] : bootstrapFeature(features);\n\n  bootstrapContext.get(FeatureRequester).request(feature);\n  bootstrapContext.get(FeatureKey.of(feature)).to(loader => {\n    loader!.init().then(complete);\n  });\n\n  return bootstrapContext;\n}\n\n/**\n * @internal\n */\nfunction bootstrapFeature(needs: Class[]): Class {\n  return FeatureDef.define(class BootstrapFeature {}, { needs });\n}\n\n/**\n * @internal\n */\nconst enum BootstrapStage {\n  Init,\n  Ready,\n}\n\n/**\n * @internal\n */\nfunction initBootstrap(\n    bootstrapContextRegistry: BootstrapContextRegistry,\n): {\n  bootstrapContext: BootstrapContext;\n  complete(): void;\n} {\n\n  const stage = trackValue<BootstrapStage>(BootstrapStage.Init);\n  const values = bootstrapContextRegistry.values;\n\n  class BootstrapContext$ extends BootstrapContext {\n\n    readonly get = values.get;\n\n    constructor() {\n      super();\n      bootstrapContextRegistry.provide({ a: DefaultNamespaceAliaser, by: newNamespaceAliaser });\n      bootstrapContextRegistry.provide({ a: BootstrapContext, is: this });\n    }\n\n    async whenDefined<C extends object>(componentType: ComponentClass<C>): Promise<ComponentFactory<C>> {\n      await this.whenReady();\n      await this.get(CustomElements).whenDefined(componentType);\n      return componentFactoryOf(componentType);\n    }\n\n    whenReady(): OnEvent<[BootstrapContext]>;\n    whenReady(receiver: EventReceiver<[BootstrapContext]>): EventSupply;\n    whenReady(receiver?: EventReceiver<[BootstrapContext]>): OnEvent<[BootstrapContext]> | EventSupply {\n      return (this.whenReady = stage.read().thru(\n          s => s ? nextArgs(this) : nextSkip(),\n      ).once().F)(receiver);\n    }\n\n    load(feature: Class<any>): FeatureRef {\n\n      interface FeatureInfo {\n        status: FeatureStatus;\n        down?: Promise<void>;\n      }\n\n      const status = afterEventBy<[FeatureInfo]>(receiver => {\n\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const request = bootstrapContext.get(FeatureRequester).request(feature);\n        const info = trackValue<FeatureInfo>({\n          status: {\n            feature,\n            ready: false,\n          },\n        });\n\n        this.get(FeatureKey.of(feature)).to({\n          supply: receiver.supply,\n          receive(_ctx, ldr) {\n\n            // Present until `request` revoked\n            // But that happens only when supply is cut off.\n            const loader = ldr as FeatureLoader;\n\n            info.it = {\n              status: {\n                feature: loader.request.feature,\n                ready: loader.ready,\n              },\n              down: loader.down,\n            };\n            if (!loader.ready) {\n              loader.init().then(() => {\n                info.it = {\n                  status: {\n                    feature: loader.request.feature,\n                    ready: true,\n                  },\n                  down: loader.down,\n                };\n              });\n            }\n          },\n        }).whenOff(() => {\n          request.unuse(); // Apply this callback _after_ registration complete,\n                           // to prevent receiver call.\n        });\n\n        info.read(receiver);\n      }).share();\n\n      let whenDown: Promise<void>;\n      const supply = status.to(({ down }) => {\n        whenDown = down!;\n      });\n\n      class Ref extends FeatureRef {\n\n        get down(): Promise<void> {\n          return whenDown;\n        }\n\n        read(): AfterEvent<[FeatureStatus]>;\n        read(receiver: EventReceiver<[FeatureStatus]>): EventSupply;\n        read(receiver?: EventReceiver<[FeatureStatus]>): AfterEvent<[FeatureStatus]> | EventSupply {\n          return (this.read = status.tillOff(supply).keepThru(\n              info => info.status,\n          ).F)(receiver);\n        }\n\n        dismiss(reason?: any): Promise<void> {\n          supply.off(reason);\n          return whenDown;\n        }\n\n      }\n\n      return new Ref();\n    }\n\n  }\n\n  const bootstrapContext = new BootstrapContext$();\n\n  return {\n    bootstrapContext,\n    complete(): void {\n      stage.it = BootstrapStage.Ready;\n    },\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { AfterEvent, AfterEvent__symbol, EventKeeper, EventReceiver, EventSupply } from 'fun-events';\nimport { FeatureStatus } from './feature-status';\n\n/**\n * Dynamically loaded feature reference.\n *\n * It is returned from [[BootstrapContext.load]] and can be used to read feature load status and unload it.\n *\n * Implements an `EventKeeper` interface by sending a feature load status updates.\n *\n * @category Core\n */\nexport abstract class FeatureRef implements EventKeeper<[FeatureStatus]> {\n\n  /**\n   * A promise resolved when feature is unloaded.\n   *\n   * This happens after all feature references dismissed.\n   */\n  abstract readonly down: Promise<void>;\n\n  /**\n   * Builds an `AfterEvent` keeper of feature load status.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `AfterEvent` sender of feature load status.\n   */\n  abstract read(): AfterEvent<[FeatureStatus]>;\n\n  /**\n   * Starts sending feature load status and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of feature load status.\n   *\n   * @returns Feature load status supply.\n   */\n  abstract read(receiver: EventReceiver<[FeatureStatus]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[FeatureStatus]> {\n    return this.read();\n  }\n\n  /**\n   * Dismisses feature reference.\n   *\n   * When all feature references dismissed, then unloads the feature. This removes everything set up by the\n   * feature via [[BootstrapSetup]] and [[DefinitionSetup]].\n   *\n   * @param reason  Arbitrary reason of feature reference dismiss. This will be reported by load status supplies\n   * as their cut off reason.\n   *\n   * @returns A promise resolved when feature is unloaded. This happens only after all feature references dismissed.\n   */\n  abstract dismiss(reason?: any): Promise<void>;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { MultiContextKey, MultiContextRef } from 'context-values';\n\n/**\n * Custom element attribute change callback signature.\n *\n * This function is called whenever a new attribute value assigned.\n *\n * @category Feature\n * @typeparam T  A type of component.\n */\nexport type AttributeChangedCallback<T extends object> =\n/**\n * @param component  Component instance.\n * @param newValue  New attribute value, or `null` when attribute removed.\n * @param oldValue  Previous attribute value, or `null` if attribute did not exist.\n */\n    (this: void, component: T, newValue: string | null, oldValue: string | null) => void;\n\n/**\n * Custom element attribute descriptor.\n *\n * Descriptors are to be registered in component's definition context in order to make them available to component.\n * The {@link Attribute @Attribute}, {@link Attributes @Attributes}, and {@link AttributeChanged @AttributeChanged}\n * decorators are doing so.\n *\n * @category Feature\n */\nexport interface AttributeDescriptor<T extends object = any> {\n\n  /**\n   * Attribute name.\n   */\n  readonly name: string;\n\n  /**\n   * Attribute change callback that will be called each time attribute value changes.\n   */\n  readonly change: AttributeChangedCallback<T>;\n\n}\n\n/**\n * A key of component definition context value containing attribute descriptors.\n *\n * @category Feature\n */\nexport const AttributeDescriptor: MultiContextRef<AttributeDescriptor> = (\n    /*#__PURE__*/ new MultiContextKey<AttributeDescriptor>('attribute-descriptor')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing element an attributes.\n *\n * Thus, an attribute state path is always something like `[AttributePath__root, 'attribute-name']`.\n *\n * @category Feature\n */\nexport const AttributePath__root = (/*#__PURE__*/ Symbol('attribute'));\n\n/**\n * A path to the named attribute state.\n *\n * @category Feature\n */\nexport type AttributePath = readonly [keyof AttributePath__rootKeys, string];\n\n/**\n * Constructs a named attribute state path.\n *\n * @category Feature\n * @param name  Target attribute name.\n *\n * @return Attribute state path.\n */\nexport function attributePathTo(name: string): AttributePath {\n  return [AttributePath__root, name];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface AttributePath__rootKeys {\n  [AttributePath__root]: true;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from 'call-thru';\nimport { StatePath } from 'fun-events';\nimport { ComponentContext } from '../../component';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeChangedCallback } from './attribute-descriptor';\nimport { attributePathTo } from './attribute-path';\n\n/**\n * @internal\n */\nexport function attributeStateUpdate<T extends object>(\n    name: string,\n    updateState: boolean | AttributeUpdateReceiver<T> | StatePath = true,\n): AttributeChangedCallback<T> {\n  if (updateState === false) {\n    return noop;\n  }\n  if (updateState === true || typeof updateState === 'function') {\n\n    const path = attributePathTo(name);\n    const update: AttributeUpdateReceiver<T> = updateState === true ? updateAttributeState : updateState;\n\n    return (component: T, newValue, oldValue) => update(component, path, newValue, oldValue);\n  }\n\n  return (component: T, newValue, oldValue) => updateAttributeState(component, updateState, newValue, oldValue);\n}\n\nfunction updateAttributeState<T extends object>(\n    component: T,\n    path: StatePath,\n    newValue: string | null,\n    oldValue: string | null,\n): void {\n  ComponentContext.of(component).updateState(path, newValue, oldValue);\n}\n","import { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { BootstrapWindow } from '../../boot/globals';\nimport { Class, mergeFunctions } from '../../common';\nimport { ComponentContext, ComponentMount } from '../../component';\nimport { DefinitionContext } from '../../component/definition';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\n\nconst AttributeRegistry__key = (/*#__PURE__*/ new SingleContextKey<AttributeRegistry>('attribute-registry'));\n\n/**\n * @internal\n */\nexport class AttributeRegistry<T extends object = any> {\n\n  static get [ContextKey__symbol](): ContextKey<AttributeRegistry> {\n    return AttributeRegistry__key;\n  }\n\n  private _attrs?: Map<string, AttributeChangedCallback<T>>;\n\n  constructor(private readonly _context: DefinitionContext) {\n  }\n\n  get attrs(): Map<string, AttributeChangedCallback<T>> {\n    if (this._attrs) {\n      return this._attrs;\n    }\n\n    const attrs = new Map<string, AttributeChangedCallback<T>>();\n\n    this._context.get(AttributeDescriptor).forEach(desc => {\n\n      const { name, change } = desc;\n\n      attrs.set(name, mergeFunctions(attrs.get(name), change));\n    });\n\n    return this._attrs = attrs;\n  }\n\n  define(elementType: Class): void {\n\n    const attrs = this.attrs;\n    const observedAttributes = Array.from(attrs.keys());\n\n    if (!observedAttributes.length) {\n      return; // No attributes defined\n    }\n\n    Object.defineProperty(elementType, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      value: observedAttributes,\n    });\n    Object.defineProperty(elementType.prototype, 'attributeChangedCallback', {\n      configurable: true,\n      enumerable: true,\n      value: function (name: string, oldValue: string | null, newValue: string) {\n        attrs.get(name)!(ComponentContext.of<T>(this).component, newValue, oldValue);\n      },\n    });\n  }\n\n  mount(mount: ComponentMount<T>): void {\n\n    const element = mount.element;\n    const attrs = this.attrs;\n    const attributeFilter = Array.from(attrs.keys());\n\n    if (!attributeFilter.length) {\n      return; // No attributes defined\n    }\n\n    const MutationObserver = this._context.get(BootstrapWindow).MutationObserver;\n    const observer = new MutationObserver(\n        records => records.forEach(\n            record => {\n\n              const attributeName = record.attributeName as string;\n\n              return attrs.get(attributeName)!(\n                  ComponentContext.of<T>(element).component,\n                  element.getAttribute(attributeName),\n                  record.oldValue,\n              );\n            },\n        ),\n    );\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter,\n      attributeOldValue: true,\n    });\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { AttributeRegistry } from './attribute-registry.impl';\n\n/**\n * @internal\n */\nconst AttributesSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perDefinition({ as: AttributeRegistry });\n    setup.onDefinition(definitionContext => {\n      // Define element prototype attributes\n      definitionContext.whenReady(\n          ({ elementType }) => definitionContext.get(AttributeRegistry).define(elementType),\n      );\n    });\n    setup.onComponent(componentContext => {\n\n      const mount = componentContext.mount;\n\n      if (mount) {\n        // Mount element attributes\n        componentContext.get(AttributeRegistry).mount(mount);\n      }\n    });\n  },\n};\n\n/**\n * A feature adding attributes to custom elements.\n *\n * This feature is enabled automatically whenever an `@Attribute`, `@Attributes`, or `@AttributeChanged` decorator\n * applied to component.\n *\n * @category Feature\n */\nexport class AttributesSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return AttributesSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeDescriptor } from './attribute-descriptor';\nimport { parseAttributeDescriptor } from './attribute-descriptor.impl';\nimport { AttributesSupport } from './attributes-support.feature';\n\n/**\n * Creates a decorator for component's property that accesses custom element's attribute.\n *\n * The decorated property accesses corresponding attribute on read, and updates it on setting. `null` value corresponds\n * to absent attribute. Setting to `null` removes corresponding attribute.\n *\n * This decorator automatically enables [[AttributesSupport]] feature.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Attribute definition or just an attribute name.\n *\n * @return Component property decorator.\n */\nexport function Attribute<T extends ComponentClass>(\n    def?: AttributeDef<InstanceType<T>> | string,\n): ComponentPropertyDecorator<string | null, T> {\n  return ComponentProperty(({ type, key }) => {\n\n    const descriptor = parseAttributeDescriptor(type.prototype, key, def);\n    const { name } = descriptor;\n\n    return {\n      componentDef: {\n        feature: {\n          needs: AttributesSupport,\n        },\n        setup(setup) {\n          setup.perDefinition({ a: AttributeDescriptor, is: descriptor });\n        },\n      },\n      get(component: InstanceType<T>): string | null {\n        return ComponentContext.of(component).element.getAttribute(name);\n      },\n      set(component: InstanceType<T>, newValue: string | null) {\n\n        const { element }: { element: Element } = ComponentContext.of(component);\n\n        if (newValue != null) {\n          element.setAttribute(name, newValue);\n        } else {\n          element.removeAttribute(name);\n        }\n      },\n    };\n  });\n}\n","import { ComponentClass } from '../../component/definition';\nimport { AttributeDef } from './attribute-def';\nimport { AttributeChangedCallback, AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\n\n/**\n * @internal\n */\nexport function parseAttributeDescriptor<T extends ComponentClass>(\n    target: InstanceType<T>,\n    propertyKey: string | symbol,\n    opts?: AttributeDef<InstanceType<T>> | string,\n): AttributeDescriptor<InstanceType<T>> {\n\n  let name: string;\n  let change: AttributeChangedCallback<InstanceType<T>>;\n\n  if (typeof opts === 'string') {\n    name = opts;\n    change = attributeStateUpdate(name);\n  } else {\n    if (opts && opts.name) {\n      name = opts.name;\n    } else if (typeof propertyKey !== 'string') {\n      throw new TypeError(\n          'Attribute name is required as property key is not a string: '\n          + `${target.constructor.name}.prototype.${String(propertyKey)}`,\n      );\n    } else {\n      name = propertyKey;\n    }\n\n    change = attributeStateUpdate(name, opts && opts.updateState);\n  }\n\n  return { name, change };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { StatePath } from 'fun-events';\nimport { Class } from '../../common';\nimport { isArray } from '../../common/types.impl';\nimport { Component, ComponentDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { AttributeUpdateReceiver } from './attribute-def';\nimport { AttributeDescriptor } from './attribute-descriptor';\nimport { attributeStateUpdate } from './attribute-state-update.impl';\nimport { AttributesSupport } from './attributes-support.feature';\n\n/**\n * Creates a component decorator declaring supported custom element's attributes.\n *\n * This decorator automatically enables [[AttributesSupport]] feature.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param items  Attributes definition options. Either an attribute definition item, or an array of such items.\n *\n * @return New component decorator.\n */\nexport function Attributes<T extends ComponentClass = Class>(\n    items: Attributes.Item<InstanceType<T>> | readonly Attributes.Item<InstanceType<T>>[],\n): ComponentDecorator<T> {\n  return Component({\n    feature: { needs: AttributesSupport },\n    setup(setup) {\n\n      const defineByItem = (item: Attributes.Item<InstanceType<T>>): void => {\n        if (typeof item === 'string') {\n          setup.perDefinition({\n            a: AttributeDescriptor,\n            is: {\n              name: item,\n              change: attributeStateUpdate(item),\n            },\n          });\n        } else {\n          Object.keys(item).forEach(name => {\n            setup.perDefinition({\n              a: AttributeDescriptor,\n              is: {\n                name,\n                change: attributeStateUpdate(name, item[name]),\n              },\n            });\n          });\n        }\n      };\n\n      if (isArray<Attributes.Item<InstanceType<T>>>(items)) {\n        items.forEach(defineByItem);\n      } else {\n        defineByItem(items);\n      }\n    },\n  });\n}\n\nexport namespace Attributes {\n\n  /**\n   * Attribute definition item.\n   *\n   * This is either an attribute name, or a per-attribute options map.\n   *\n   * @typeparam T  A type of component.\n   */\n  export type Item<T extends object> = Map<T> | string;\n\n  /**\n   * Per-attribute definition options.\n   *\n   * This is a map with attribute names as keys and their state update instructions as values.\n   *\n   * The state update instruction can be one of:\n   * - `false` to not update the component state,\n   * - `true` to update the component state with changed attribute key,\n   * - a state value key to update, or\n   * - an attribute update receiver function with custom state update logic.\n   *\n   * @typeparam T  A type of component.\n   */\n  export interface Map<T extends object> {\n    readonly [name: string]: boolean | StatePath | AttributeUpdateReceiver<T>;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { StateTracker } from 'fun-events';\n\n/**\n * @internal\n */\nconst ComponentState__key = (/*#__PURE__*/ new SingleContextKey<ComponentState>('component-state'));\n\n/**\n * Component state tracker.\n *\n * @category Feature\n */\nexport class ComponentState extends StateTracker {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentState> {\n    return ComponentState__key;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, StateUpdater } from '../../component';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { ComponentState } from './component-state';\n\n/**\n * @internal\n */\nconst StateSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentState,\n      by(context: ComponentContext) {\n\n        const state = new ComponentState();\n\n        context.whenDestroyed(reason => state.done(reason));\n\n        return state;\n      },\n    });\n    setup.perComponent({\n      a: StateUpdater,\n      by(state: ComponentState) {\n        return state.update;\n      },\n      with: [ComponentState],\n    });\n  },\n};\n\n/**\n * Component state support feature.\n *\n * When enabled, it registers the following component context values:\n *\n * - [[StateUpdater]] that allows to update the component state, and\n * - [[ComponentState]] that allows to track component state changes.\n *\n * Other features would use this to notify when the state changes. E.g. [[DomPropertiesSupport]]\n * and [[AttributesSupport]] features issue state updates when needed.\n *\n * @category Feature\n */\nexport class StateSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StateSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { nextArgs } from 'call-thru';\nimport {\n  EventReceiver,\n  EventSupply,\n  eventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  StatePath,\n  ValueTracker,\n} from 'fun-events';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { attributePathTo } from './attribute-path';\n\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  readonly [EventSupply__symbol] = eventSupply();\n\n  constructor(\n      private readonly _context: ComponentContext,\n      private readonly _name: string,\n      private readonly _path: StatePath,\n  ) {\n    super();\n  }\n\n  get it(): string | null {\n    return this._context.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (!eventSupplyOf(this).isOff) {\n      if (value == null) {\n        this._context.element.removeAttribute(this._name);\n      } else {\n        this._context.element.setAttribute(this._name, value);\n      }\n    }\n  }\n\n  on(): OnEvent<[string | null, string | null]>;\n  on(receiver: EventReceiver<[string | null, string | null]>): EventSupply;\n  on(\n      receiver?: EventReceiver<[string | null, string | null]>,\n  ): OnEvent<[string | null, string | null]> | EventSupply {\n    return (this.on = this._context.get(ComponentState).track(this._path).onUpdate().thru(\n        (_path, newValue, oldValue) => nextArgs(newValue, oldValue),\n    ).tillOff(this).F)(receiver);\n  }\n\n}\n\n/**\n * Creates a tracker of custom element's attribute value.\n *\n * Requires [[AttributesSupport]] feature to be enabled and attribute to be defined. E.g. with {@link Attribute\n * @Attribute}, {@link AttributeChanged @AttributeChanged}, or {@link Attributes @Attributes} decorator.\n *\n * @category Feature\n * @param context  Target component context.\n * @param name  Attribute name.\n * @param path  Custom attribute state path.\n *\n * @returns New attribute value tracker.\n */\nexport function trackAttribute(\n    context: ComponentContext,\n    name: string,\n    path: StatePath = attributePathTo(name),\n): ValueTracker<string | null> {\n  return new AttributeTracker(context, name, path);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * A path to sub-state containing DOM properties.\n *\n * Thus a property state path is always something like `[DomPropertyPath__root, 'property-name']`.\n *\n * @category Feature\n */\nexport const DomPropertyPath__root = (/*#__PURE__*/ Symbol('dom-property'));\n\n/**\n * A path to the named DOM property state.\n *\n * @category Feature\n */\nexport type DomPropertyPath<K extends PropertyKey = PropertyKey> = readonly [keyof DomPropertyPath__rootKeys, K];\n\n/**\n * Constructs a named DOM property state path.\n *\n * @category Feature\n * @param key  Target property key.\n *\n * @return DOM property state path.\n */\nexport function domPropertyPathTo<K extends PropertyKey = PropertyKey>(key: K): DomPropertyPath<K> {\n  return [DomPropertyPath__root, key];\n}\n\n/**\n * @category Feature\n */\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nexport interface DomPropertyPath__rootKeys {\n  [DomPropertyPath__root]: true;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { noop } from 'call-thru';\nimport { RenderExecution } from 'render-scheduler';\nimport { DefaultRenderScheduler } from '../../boot/globals';\nimport { ComponentContext } from '../../component';\nimport { ComponentState } from '../state';\nimport { RenderDef } from './render-def';\n\n/**\n * Component's element renderer signature.\n *\n * It has no arguments. It may return either nothing, or a function. In the latter case the returned function will be\n * called immediately to render the element. It may, in turn, return a renderer function, and so on.\n *\n * @category Feature\n */\nexport type ElementRenderer =\n/**\n * @param execution  Render shot execution context.\n *\n * @returns Either delegated renderer, or nothing.\n */\n    (\n        this: void,\n        execution: RenderExecution,\n    ) => void | ElementRenderer;\n\nconst enum RenderStatus {\n  Pending,\n  Scheduled,\n  Complete,\n  Cancelled = -1,\n}\n\n/**\n * @category Feature\n */\nexport const ElementRenderer = {\n\n  /**\n   * Enables component element rendering.\n   *\n   * A `renderer` function call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n   *\n   * @param context  Target component context.\n   * @param renderer  Element renderer function.\n   * @param def  Optional element rendering definition.\n   */\n  render(\n      this: void,\n      context: ComponentContext,\n      renderer: ElementRenderer,\n      def: RenderDef = {},\n  ): void {\n\n    const { offline, path = [] } = def;\n    const stateTracker = context.get(ComponentState).track(path);\n    const schedule = context.get(DefaultRenderScheduler)();\n\n    let status = RenderStatus.Pending;\n    const stateSupply = stateTracker.onUpdate(() => {\n      if (offline || context.connected) {\n        scheduleRenderer();\n      } else {\n        status = RenderStatus.Pending; // Require rendering next time online\n      }\n    });\n\n    if (offline) {\n      scheduleRenderer();\n    } else {\n      context.whenOn(supply => {\n        supply.whenOff(cancelRenderer); // Prevent rendering while offline\n        if (status <= 0) { // There is an update to render. Either pending or previously cancelled.\n          scheduleRenderer();\n        }\n      }).whenOff(reason => {\n        // Component destroyed\n        cancelRenderer();\n        stateSupply.off(reason);\n      });\n    }\n\n    function scheduleRenderer(): void {\n      status = RenderStatus.Scheduled;\n      schedule(renderElement);\n    }\n\n    function cancelRenderer(): void {\n      if (status === RenderStatus.Scheduled) { // Scheduled, but not rendered yet\n        schedule(noop);\n        status = RenderStatus.Cancelled;\n      }\n    }\n\n    function renderElement(execution: RenderExecution): void {\n      /* istanbul ignore next */\n      if (status < 0) {\n        // Prevent cancelled rendering\n\n        /*\n        Should never happen since render-scheduler v1.1\n        As disconnecting in another schedule would correctly cancel this one,\n        because it is not executed yet and thus will be replaced by `noop`.\n        */\n        return;\n      }\n      status = RenderStatus.Complete;\n      for (;;) {\n\n        const newRenderer = renderer(execution);\n\n        if (newRenderer === renderer || typeof newRenderer !== 'function') {\n          break;\n        }\n\n        renderer = newRenderer;\n      }\n    }\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { RenderExecution } from 'render-scheduler';\nimport { ComponentProperty, ComponentPropertyDecorator } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { StateSupport } from '../state';\nimport { ElementRenderer } from './element-renderer';\nimport { RenderDef } from './render-def';\n\n/**\n * Component property decorator that declares a rendering method for the component.\n *\n * The decorated method call will be scheduled by [[DefaultRenderScheduler]] once component state updated.\n *\n * The decorated method should have no arguments. It may return either nothing, or a function. In the latter case the\n * returned function will be called immediately to render the element. It may, in turn, return a renderer function,\n * and so on.\n *\n * This decorator automatically enables [[StateSupport]] feature.\n *\n * Utilizes [[ElementRenderer.render]] function to enable rendering.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Non-mandatory render definition.\n *\n * @returns Component method decorator.\n */\nexport function Render<T extends ComponentClass>(\n    def?: RenderDef,\n): ComponentPropertyDecorator<(execution: RenderExecution) => ElementRenderer | void, T> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      feature: {\n        needs: StateSupport,\n      },\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(() => {\n\n            const { component } = context;\n\n            ElementRenderer.render(context, get(component).bind(component), def);\n          });\n        });\n      },\n    },\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\n\n/**\n * Component shadow content root.\n *\n * @category Feature\n */\nexport type ShadowContentRoot = ShadowRoot;\n\n/**\n * A key of component context value containing a shadow content root instance.\n *\n * This is only available when the component is decorated with {@link AttachShadow @AttachShadow} decorator.\n *\n * @category Feature\n */\nexport const ShadowContentRoot: SingleContextRef<ShadowContentRoot> = (\n    /*#__PURE__*/ new SingleContextKey<ShadowContentRoot>('shadow-content-root')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\n/**\n * An event related to element's shadow DOM.\n *\n * The following event types supported:\n * - `wesib:shadowAttached` is dispatched when a shadow root is attached to element.\n *   In particular, it is dispatched for components decorated with {@link AttachShadow @AttachShadow}.\n *   The event is dispatched when component is connected for the first time. I.e. when element is added to the document.\n *   This event bubbles and is not cancelable.\n *\n * @category Feature\n */\nexport class ShadowDomEvent extends Event {\n\n  /**\n   * Shadow root this event relates to.\n   */\n  get shadowRoot(): ShadowRoot {\n    return (this.target as Element).shadowRoot as ShadowRoot;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { FnContextKey, FnContextRef } from 'context-values/updatable';\nimport { ComponentContext } from '../../component';\nimport { ShadowContentDef } from './attach-shadow.decorator';\n\n/**\n * Shadow root builder function type.\n *\n * An instance of this function is available in component context and is used by {@link AttachShadow @AttachShadow}\n * decorator to attach shadow root to decorated component's custom element.\n *\n * By default, if shadow root already exists for the component's element, it uses it.\n *\n * Dispatches a `wesib:shadowAttached` event for the found or attached shadow root.\n *\n * @category Feature\n */\nexport type ShadowRootBuilder =\n/**\n * @param context  Target component context.\n * @param init  Shadow root initialization options.\n *\n * @returns A shadow root instance for target component, or `null`/`undefined` if one can not be attached.\n */\n    (context: ComponentContext, init: ShadowContentDef) => ShadowRoot | null | undefined;\n\n/**\n * A key of component context value containing a shadow root builder instance.\n *\n * @category Feature\n */\nexport const ShadowRootBuilder: FnContextRef<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<ShadowRootBuilder>, ReturnType<ShadowRootBuilder>>(\n        'shadow-root-builder',\n    )\n);\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { ComponentContext, ComponentContext__symbol } from '../../component';\nimport { FeatureDef, FeatureDef__symbol } from '../feature-def';\nimport { ShadowDomEvent } from './shadow-dom-event';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * @internal\n */\nconst ShadowDomSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: ShadowRootBuilder, is: attachShadow });\n  },\n};\n\n/**\n * Shadow root support feature.\n *\n * This feature is automatically enabled when {@link AttachShadow @AttachShadow} decorator is used.\n *\n * @category Feature\n */\nexport class ShadowDomSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ShadowDomSupport__feature;\n  }\n\n}\n\n/**\n * @internal\n */\nfunction attachShadow(context: ComponentContext, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const element = context.element;\n  const shadowRoot = shadowRootOf(element, init);\n\n  if (shadowRoot) {\n    (shadowRoot as any)[ComponentContext__symbol] = context;\n    context.whenOn().once(() => context.dispatchEvent(new ShadowDomEvent('wesib:shadowAttached', { bubbles: true })));\n  }\n\n  return shadowRoot;\n}\n\n/**\n * @internal\n */\nfunction shadowRootOf(element: Element, init: ShadowRootInit): ShadowRoot | undefined {\n\n  const existing = element.shadowRoot;\n\n  if (existing) {\n    // Shadow root already attached. Using it.\n    return existing;\n  }\n  if ('attachShadow' in element) {\n    return element.attachShadow(init);\n  }\n\n  return; // Unable to attach shadow root.\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { Class } from '../../common';\nimport { Component, ComponentContext, ComponentDecorator, ContentRoot } from '../../component';\nimport { ComponentClass } from '../../component/definition';\nimport { ShadowContentRoot } from './shadow-content-root';\nimport { ShadowDomSupport } from './shadow-dom-support.feature';\nimport { ShadowRootBuilder } from './shadow-root-builder';\n\n/**\n * @internal\n */\nconst defaultShadowContentDef: ShadowContentDef = { mode: 'open' };\n\n/**\n * Shadow content root definition.\n *\n * This is a readonly component shadow root initialization options.\n *\n * @category Feature\n */\nexport type ShadowContentDef = Readonly<ShadowRootInit>;\n\n/**\n * Creates a component decorator that attaches shadow root to decorated component instance.\n *\n * The returned component decorator enables [[ShadowDomSupport]] feature and attaches shadow content root to the\n * component.\n *\n * @category Feature\n * @typeparam T  A type of decorated component class.\n * @param def  Shadow content root definition. Uses `mode: 'open'` by default.\n *\n * @returns New component decorator.\n */\nexport function AttachShadow<T extends ComponentClass = Class>(\n    def: ShadowContentDef = defaultShadowContentDef,\n): ComponentDecorator<T> {\n  return Component({\n    setup(setup) {\n      setup.perComponent(\n          {\n            a: ShadowContentRoot,\n            by(ctx: ComponentContext<InstanceType<T>>) {\n              return ctx.get(ShadowRootBuilder)(ctx, def);\n            },\n          },\n      );\n      setup.perComponent({ // Content root is an alias of shadow root when present.\n        a: ContentRoot,\n        by(context: ComponentContext<InstanceType<T>>) {\n          return context.get(ShadowContentRoot, { or: null });\n        },\n      });\n    },\n    feature: { needs: ShadowDomSupport },\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/wesib\n */\nimport { NamespaceDef } from 'namespace-aliaser';\n\n/**\n * Default Wesib namespace definition.\n *\n * @category Core\n */\nexport const Wesib__NS: NamespaceDef = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns',\n    'b',\n    'wesib',\n));\n","import { nextArg } from 'call-thru';\nimport { ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, EventSender, nextAfterEvent, OnEvent, onSupplied } from 'fun-events';\n\n/**\n * @internal\n */\ntype FetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request?: Request) => OnEvent<Res>,\n    request: Request,\n) => EventSender<Res>;\n\n/**\n * @internal\n */\ntype CombinedFetchAgent<Res extends any[]> = (\n    this: void,\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n) => OnEvent<Res>;\n\n/**\n * @internal\n */\nexport class FetchAgentKey<Res extends any[]>\n    extends ContextUpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>\n    implements ContextUpRef<CombinedFetchAgent<Res>, FetchAgent<Res>> {\n\n  readonly upKey: ContextUpKey.UpKey<CombinedFetchAgent<Res>, FetchAgent<Res>>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        opts => opts.seed.keepThru(\n            (...agents) => {\n              if (agents.length) {\n                return nextArg(combineFetchAgents(agents));\n              }\n\n              const defaultProvider = (): AfterEvent<[CombinedFetchAgent<Res>]> => afterThe(defaultFetchAgent);\n\n              return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n            },\n        ),\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          CombinedFetchAgent<Res>,\n          EventKeeper<FetchAgent<Res>[]> | FetchAgent<Res>,\n          AfterEvent<FetchAgent<Res>[]>>,\n  ): CombinedFetchAgent<Res> {\n\n    let delegated!: CombinedFetchAgent<Res>;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(agent => delegated = agent);\n\n    return (next, request) => delegated(next, request);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultFetchAgent<Res extends any[]>(\n    next: (this: void, request: Request) => OnEvent<Res>,\n    request: Request,\n): OnEvent<Res> {\n  return next(request);\n}\n\n/**\n * @internal\n */\nexport function combineFetchAgents<Res extends any[]>(agents: FetchAgent<Res>[]): CombinedFetchAgent<Res> {\n  return (next, request) => {\n\n    const fetch: (agentIdx: number, agentRequest: Request) => OnEvent<Res> = (agentIdx, agentRequest) => {\n\n      const agent = agents[agentIdx];\n\n      if (!agent) {\n        return next(agentRequest);\n      }\n\n      return onSupplied(\n          agent(\n              (nextRequest = agentRequest) => fetch(agentIdx + 1, nextRequest),\n              agentRequest,\n          ),\n      );\n    };\n\n    return fetch(0, request);\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from 'context-values/updatable';\nimport { EventSender, OnEvent } from 'fun-events';\nimport { FetchAgentKey } from './fetch-agent-key.impl';\n\n/**\n * HTTP fetch agent signature.\n *\n * The agent can be used to alter [[HttpFetch]] processing. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by [[HttpFetch]].\n */\nexport type HttpFetchAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of response object(s). It is returned either to preceding agent in chain, or as a result of\n * [[HttpFetch]] call.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[Response]>,\n        request: Request,\n    ) => EventSender<[Response]>;\n\nexport namespace HttpFetchAgent {\n\n  /**\n   * Combined HTTP fetch agent signature.\n   *\n   * This is what is available under [[HttpFetchAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually fetches the data if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of response object(s) receivers. It is returned as a result of [[HttpFetch]] call.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[Response]>,\n          request: Request,\n      ) => OnEvent<[Response]>;\n\n}\n\n/**\n * A key of context value containing an [[HttpFetchAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const HttpFetchAgent: ContextUpRef<HttpFetchAgent.Combined, HttpFetchAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[Response]>('http-fetch-agent')\n);\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { EventEmitter, EventSupply, eventSupply, OnEvent, onEventBy } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\nimport { HttpFetch } from './http-fetch';\nimport { HttpFetchAgent } from './http-fetch-agent';\n\nconst HttpFetchAborted = {};\n\n/**\n * @internal\n */\nexport function newHttpFetch(context: BootstrapContext): HttpFetch {\n\n  const window = context.get(BootstrapWindow);\n  const agent = context.get(HttpFetchAgent);\n\n  return (input, init) => agent(fetch, new Request(input, init));\n\n  function fetch(request: Request): OnEvent<[Response]> {\n    return onEventBy(receiver => {\n\n      const responseEmitter = new EventEmitter<[Response]>();\n      let supply: EventSupply;\n\n      if ('AbortController' in window) {\n\n        const abortController = new (window as any).AbortController();\n        const { signal } = abortController;\n\n        supply = eventSupply(reason => {\n          if (reason === HttpFetchAborted) {\n            abortController.abort();\n          }\n        });\n        receiver.supply.whenOff(() => supply.off(HttpFetchAborted)).needs(supply);\n        responseEmitter.on({\n          supply,\n          receive(ctx, response) {\n            receiver.receive(ctx, response);\n          },\n        });\n\n        const customSignal = request.signal;\n\n        if (customSignal) {\n          new DomEventDispatcher(customSignal).on('abort').once(() => abortController.abort());\n          if (customSignal.aborted) {\n            abortController.abort();\n          }\n        }\n\n        request = new Request(request, { signal });\n      } else {\n        supply = responseEmitter.on(receiver);\n      }\n\n      window.fetch(request)\n          .then(response => {\n            responseEmitter.send(response);\n            supply.off();\n          })\n          .catch(reason => supply.off(reason));\n    });\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { bootstrapDefault } from '@wesib/wesib';\nimport { FnContextKey, FnContextRef } from 'context-values/updatable';\nimport { OnEvent } from 'fun-events';\nimport { newHttpFetch } from './http-fetch.impl';\n\n/**\n * HTTP fetch function signature.\n *\n * This is a function that wraps browser's\n * [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) function and provides\n * additional functionality. E.g. request interception.\n *\n * This function returns an `OnEvent` sender instead of a `Promise`. This allows to report multiple responses.\n * E.g. when the resource refresh requested and delivered. The request is sent whenever a receiver is registered\n * in this sender. When the fetch completes the response supply is cut off, and callbacks registered with its\n * `whenOff()` method are notified. When fetch fails for whatever reason, this reason is passed to these callbacks.\n * The fetch can be aborted by cutting off the response supply. I.e. by calling its `off()` method.\n *\n * An instance of [[HttpFetch]] is available from bootstrap context.\n */\nexport type HttpFetch =\n/**\n * @param input  The resource to fetch. This can either an URL string, or a `Request` object.\n * @param init  Custom settings to apply to the request.\n *\n * @returns An `OnEvent` sender of responses.\n */\n    (this: void, input: RequestInfo, init?: RequestInit) => OnEvent<[Response]>;\n\n/**\n * A key of bootstrap context value containing an [[HttpFetch]] instance.\n */\nexport const HttpFetch: FnContextRef<Parameters<HttpFetch>, ReturnType<HttpFetch>> = (\n    /*#__PURE__*/ new FnContextKey<Parameters<HttpFetch>, ReturnType<HttpFetch>>(\n        'http-fetch',\n        {\n          byDefault: bootstrapDefault(newHttpFetch),\n        },\n    )\n);\n","import {\n  BootstrapContext,\n  BootstrapRoot,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n} from '@wesib/wesib';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { EventEmitter, OnEvent, trackValue, ValueTracker } from 'fun-events';\nimport { DomEventDispatcher } from 'fun-events/dom';\n\n/**\n * @internal\n */\nexport type HierarchyRoot = ValueTracker<ComponentContext | undefined>;\n\n/**\n * @internal\n */\nexport const HierarchyRoot = (/*#__PURE__*/ new SingleContextKey<HierarchyRoot>(\n    'hierarchy-root',\n    {\n      byDefault: bsContext => {\n\n        const root: Element = bsContext.get(BootstrapRoot);\n\n        new DomEventDispatcher(root).on<ComponentEvent>('wesib:component').to(\n            ({ context }: ComponentEvent) => context.get(HierarchyUpdates).issue(),\n        );\n\n        return trackValue();\n      },\n    },\n));\n\nconst HierarchyUpdates__key = (/*#__PURE__*/ new SingleContextKey<HierarchyUpdates>(\n    'hierarchy-updates',\n    {\n      byDefault: context => new HierarchyUpdates(context.get(ComponentContext)),\n    },\n));\n\n/**\n * @internal\n */\nexport class HierarchyUpdates {\n\n  static get [ContextKey__symbol](): ContextKey<HierarchyUpdates> {\n    return HierarchyUpdates__key;\n  }\n\n  readonly on: OnEvent<[ComponentContext]>;\n  readonly send: (this: void) => void;\n  readonly issue: () => void;\n\n  constructor(context: ComponentContext) {\n\n    const updates = new EventEmitter<[ComponentContext]>();\n    const hierarchyRoot = context.get(BootstrapContext).get(HierarchyRoot);\n\n    this.on = updates.on();\n    this.send = () => updates.send(context);\n    this.issue = () => {\n\n      const parent = findParentContext(context);\n\n      if (parent) {\n        parent[0].get(HierarchyUpdates).send();\n      } else {\n        hierarchyRoot.it = context;\n      }\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport function findParentContext(of: ComponentContext): [ComponentContext, boolean] | undefined {\n\n  const root = of.get(BootstrapContext).get(BootstrapRoot);\n  let element: Node = of.element;\n  let immediate = true;\n\n  if (element === root) {\n    return;\n  }\n  for (;;) {\n\n    const parent = element.parentNode;\n\n    if (!parent) {\n      return;\n    }\n\n    const ctx: ComponentContext = (parent as any)[ComponentContext__symbol];\n\n    if (ctx) {\n      return [ctx, immediate];\n    }\n    if (parent === root) {\n      return;\n    }\n\n    immediate = false;\n    element = parent;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapContext, ComponentContext } from '@wesib/wesib';\nimport {\n  ContextKey,\n  ContextKey__symbol,\n  ContextRegistry,\n  ContextValues,\n  ContextValueSpec,\n  SingleContextKey,\n} from 'context-values';\nimport { AfterEvent, afterEventBy, EventKeeper, EventReceiver, EventSupply, eventSupply, trackValue } from 'fun-events';\nimport { newHierarchyRegistry } from './hierarchy-registry.impl';\nimport { findParentContext, HierarchyRoot, HierarchyUpdates } from './hierarchy-updates.impl';\n\n/**\n * @internal\n */\nconst HierarchyContext__key = (/*#__PURE__*/ new SingleContextKey<HierarchyContext>(\n    'hierarchy-context',\n    {\n      byDefault: context => new HierarchyContext$(context.get(ComponentContext)),\n    },\n));\n\n/**\n * Component's hierarchy context.\n *\n * Passes provided values to hierarchy contexts of nested components.\n *\n * Available as component context value.\n *\n * @typeparam T  A type of component.\n */\nexport abstract class HierarchyContext<T extends object = any> extends ContextValues {\n\n  /**\n   * A key of component context value containing its hierarchy context instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<HierarchyContext> {\n    return HierarchyContext__key;\n  }\n\n  /**\n   * Component context.\n   */\n  abstract readonly context: ComponentContext<T>;\n\n  /**\n   * Builds an `AfterEvent` keeper of enclosing component's hierarchy context.\n   *\n   * May send `undefined` when component is outside of hierarchy. E.g. when it is disconnected.\n   *\n   * @returns An `AfterEvent` of enclosing hierarcy context.\n   */\n  abstract up(): AfterEvent<[HierarchyContext?]>;\n\n  /**\n   * Starts sending enclosing component's hierarchy context and updates to the given `receiver`\n   *\n   * May send `undefined` when component is outside of hierarchy. E.g. when it is disconnected.\n   *\n   * @param receiver  Target receiver of enclosing hierarchy context.\n   *\n   * @returns Enclosing hierarchy context supply.\n   */\n  abstract up(receiver: EventReceiver<[HierarchyContext?]>): EventSupply;\n\n  /**\n   * Provides hierarchy context value.\n   *\n   * The provided value will be available in context itself, as well as in all nested hierarchy contexts.\n   *\n   * Note that the provided value key has to `ContextUpKey`.\n   *\n   * @typeparam Deps  Dependencies tuple type.\n   * @typeparam Src  Source value type.\n   * @typeparam Seed  Value seed type.\n   * @param spec  Context value specifier.\n   *\n   * @returns A function that removes the given context value specifier when called.\n   */\n  abstract provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, Deps, Src | EventKeeper<Src[]>, Seed>,\n  ): () => void;\n\n}\n\nclass HierarchyContext$<T extends object> extends HierarchyContext<T> {\n\n  private readonly _registry: ContextRegistry<HierarchyContext<T>>;\n  readonly get: HierarchyContext<T>['get'];\n\n  constructor(readonly context: ComponentContext<T>) {\n    super();\n\n    const registry = this._registry = newHierarchyRegistry<T>(this.up());\n\n    this.get = registry.newValues().get;\n  }\n\n  provide<Deps extends any[], Src, Seed>(\n      spec: ContextValueSpec<HierarchyContext<T>, any, Deps, Src | EventKeeper<Src[]>, Seed>,\n  ): () => void {\n    return this._registry.provide(spec);\n  }\n\n  up(): AfterEvent<[HierarchyContext?]>;\n  up(receiver: EventReceiver<[HierarchyContext?]>): EventSupply;\n  up(receiver?: EventReceiver<[HierarchyContext?]>): AfterEvent<[HierarchyContext?]> | EventSupply {\n    return (this.up = afterEventBy<[HierarchyContext?]>(\n        receiver => {\n\n          const parentHierarchy = trackValue<HierarchyContext>();\n          const rootSupply = eventSupply().needs(receiver.supply);\n          const parentSupply = eventSupply().needs(receiver.supply);\n          const updateParent = (): void => {\n\n            const parent = findParentContext(this.context);\n\n            if (parent) {\n\n              const [parentCtx, immediate] = parent;\n\n              parentHierarchy.it = parentCtx.get(HierarchyContext);\n              rootSupply.off();\n              if (immediate) {\n                parentSupply.off();\n              }\n            } else {\n              parentHierarchy.it = undefined;\n            }\n          };\n\n          this.context.get(BootstrapContext).get(HierarchyRoot).read({\n            supply: rootSupply,\n            receive: () => this.context.connected && updateParent(),\n          });\n          parentHierarchy.read().tillOff(parentSupply).consume(\n              newParent => newParent && newParent.context.get(HierarchyUpdates).on.to(updateParent),\n          );\n          parentHierarchy.read(receiver);\n          this.context.whenOn({\n            supply: receiver.supply,\n            receive: (_, onSupply) => {\n              updateParent();\n              onSupply.whenOff(\n                  () => {\n                    Promise.resolve().then(\n                        () => this.context.connected || (parentHierarchy.it = undefined),\n                    );\n                  },\n              );\n            },\n          });\n        },\n    ).share().F)(receiver);\n  }\n\n}\n","import { nextArgs } from 'call-thru';\nimport { ContextRegistry } from 'context-values';\nimport { AfterEvent, nextAfterEvent } from 'fun-events';\nimport { HierarchyContext } from './hierarchy-context';\n\n/**\n * @internal\n */\nexport function newHierarchyRegistry<T extends object>(\n    up: AfterEvent<[HierarchyContext?]>,\n): ContextRegistry<HierarchyContext<T>> {\n  return new ContextRegistry(\n      key => up.keepThru(\n          upper => upper ? nextAfterEvent(upper.get(key as any)) : nextArgs(),\n      ) as any,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ComponentClass, ComponentContext } from '@wesib/wesib';\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { ValueTracker } from 'fun-events';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * Arbitrary element node within component tree. Either bound to some component or not.\n */\nexport type ElementNode =\n    | RawElementNode\n    | ComponentNode;\n\n/**\n * Component tree node representing arbitrary element.\n *\n * This is a base interface of all element node implementations.\n */\nexport interface ComponentTreeNode {\n\n  /**\n   * The element itself.\n   */\n  readonly element: any;\n\n  /**\n   * A context of component bound to this element, if any.\n   */\n  readonly context?: ComponentContext<any>;\n\n  /**\n   * Parent element node, or `null` if element has no parent.\n   */\n  readonly parent: ElementNode | null;\n\n  /**\n   * Selects component nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested components.\n   * @param mode  Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select(\n      selector: string,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode>;\n\n  /**\n   * Selects component nodes of the given type.\n   *\n   * @param componentType  Nested component type with custom element name.\n   * @param mode  Component nodes pick mode.\n   *\n   * @returns Dynamically updatable list of matching component nodes.\n   */\n  select<T extends object>(\n      componentType: ComponentClass<T>,\n      mode?: ComponentPickMode,\n  ): ElementNodeList<ComponentNode<T>>;\n\n  /**\n   * Selects element nodes matching the given selector.\n   *\n   * @param selector  Simple CSS selector of nested elements. E.g. CSS class selector.\n   * @param mode  A mode of node picking from component tree.\n   *\n   * @returns Dynamically updatable list of matching element nodes.\n   */\n  select(\n      selector: string,\n      mode: ElementPickMode,\n  ): ElementNodeList;\n\n  /**\n   * Tracks element attribute.\n   *\n   * `null` attribute value corresponds to its absence. Setting it to `null` removes attribute.\n   *\n   * @param name  Target attribute name.\n   *\n   * @returns Target attribute's value tracker.\n   */\n  attribute(name: string): ValueTracker<string | null>;\n\n  /**\n   * Tracks element element property.\n   *\n   * The changes are tracked with `StateTracker`. So it is expected that the target property notifies on its changes\n   * with state updater. E.g. when it is defined by `@DomProperty` decorator.\n   *\n   * @param key  Target property key.\n   *\n   * @returns Target property's value tracker.\n   */\n  property<V>(key: PropertyKey): ValueTracker<V>;\n\n}\n\n/**\n * Element node representing raw element not bound to any component.\n */\nexport interface RawElementNode extends ComponentTreeNode {\n\n  readonly context?: undefined;\n\n}\n\n/**\n * Element node representing an element bound to some component.\n */\nexport interface ComponentNode<T extends object = any> extends ComponentTreeNode {\n\n  readonly context: ComponentContext<T>;\n\n}\n\n/**\n * A key of component context value containing a component node instance.\n */\nexport const ComponentNode: SingleContextRef<ComponentNode> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentNode>('component-node')\n);\n\n/**\n * A mode of node picking from component tree.\n */\nexport interface ElementPickMode {\n\n  /**\n   * Set to `true` to select arbitrary nodes. Otherwise - select only component nodes.\n   */\n  all?: boolean;\n\n  /**\n   * Set to `true` to select from entire subtree. Otherwise - select from element child nodes only.\n   */\n  deep?: boolean;\n\n}\n\n/**\n * A mode that picks component nodes from component tree.\n */\nexport interface ComponentPickMode extends ElementPickMode {\n\n  all?: false;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { AIterable, ArrayLikeIterable } from 'a-iterable';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { ElementNode } from './element-node';\n\n/**\n * Dynamically updatable list of selected element nodes.\n *\n * It is an iterable of nodes.\n *\n * Implements an `EventSender` interface by sending added and removed nodes arrays.\n *\n * Implements an `EventKeeper` interface by sending updated node list.\n */\nexport abstract class ElementNodeList<N extends ElementNode = ElementNode>\n    extends AIterable<N>\n    implements EventSender<[N[], N[]]>, EventKeeper<[ElementNodeList<N>]> {\n\n  /**\n   * Builds an `OnEvent` sender of this list changes.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns An `OnEvent` sender of added an removed node arrays.\n   */\n  abstract onUpdate(): OnEvent<[N[], N[]]>;\n\n  /**\n   * Starts sending this list changes to the given `receiver`\n   *\n   * @param receiver  Target receiver of added an removed node arrays.\n   *\n   * @returns List changes supply.\n   */\n  abstract onUpdate(receiver: EventReceiver<[N[], N[]]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[N[], N[]]> {\n    return this.onUpdate();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of current node list.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns An `AfterEvent` keeper of this list.\n   */\n  abstract read(): AfterEvent<[ElementNodeList<N>]>;\n\n  /**\n   * Starts sending current node list and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of this node list.\n   *\n   * @returns Node list supply.\n   */\n  abstract read(receiver: EventReceiver<[ElementNodeList<N>]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[ElementNodeList<N>]> {\n    return this.read();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of tracked list changes.\n   *\n   * Sends current nodes immediately upon receiver registration as added ones.\n   *\n   * @returns An `AfterEvent` sender of iterables of added and removed nodes.\n   */\n  abstract track(): AfterEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>;\n\n  /**\n   * Starts sending tracked list changes to the given `receiver`.\n   *\n   * Sends current nodes immediately upon receiver registration as added ones.\n   *\n   * @param receiver  Target receiver of iterables of added and removed nodes.\n   *\n   * @returns Tracked list changes supply.\n   */\n  abstract track(receiver: EventReceiver<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>): EventSupply;\n\n  /**\n   * Builds an `AfterEvent` keeper of the first node in this list.\n   *\n   * @returns `AfterEvent` keeper of either the first node, or `undefined` when the list is empty.\n   */\n  abstract first(): AfterEvent<[N?]>;\n\n  /**\n   * Starts sending the first node of this list and updates to the given `receiver`.\n   *\n   * @param receiver  Target receiver of either the first node, or `undefined` when the list is empty.\n   *\n   * @returns The first node supply.\n   */\n  abstract first(receiver: EventReceiver<[N?]>): EventSupply;\n\n}\n","import {\n  BootstrapContext,\n  ComponentClass,\n  DefaultNamespaceAliaser,\n  ElementObserver,\n  ElementObserverInit,\n  isElement,\n} from '@wesib/wesib';\nimport {\n  AIterable,\n  ArrayLikeIterable,\n  filterIt,\n  flatMapIt,\n  itsEach,\n  itsFirst,\n  itsIterator,\n  mapIt,\n  overArray,\n} from 'a-iterable';\nimport { isPresent, nextArg, nextArgs, valuesProvider } from 'call-thru';\nimport {\n  AfterEvent,\n  afterEventBy,\n  afterSent,\n  afterSupplied,\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  OnEvent,\n  onEventBy,\n} from 'fun-events';\nimport { html__naming } from 'namespace-aliaser';\nimport { ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\n\n/**\n * @internal\n */\nconst WATCH_DEEP: ElementObserverInit = { subtree: true };\n\n/**\n * @internal\n */\nexport function elementNodeList<N extends ElementNode>(\n    bsContext: BootstrapContext,\n    root: Element,\n    selectorOrType: string | ComponentClass<any>,\n    nodeOf: (node: Element, optional?: boolean) => N | undefined,\n    { deep, all }: ElementPickMode,\n): ElementNodeList<N> {\n\n  const updates = new EventEmitter<[N[], N[]]>();\n  const init = deep ? WATCH_DEEP : undefined;\n  let cache = new Set<Element>();\n  let iterable: Iterable<N> | undefined;\n  let selector: string | undefined;\n  const overNodes: (nodes: NodeList) => Iterable<Node> = deep ? overNodeSubtree : overArray;\n\n  if (typeof selectorOrType === 'string') {\n    selector = selectorOrType;\n  } else {\n    bsContext.whenDefined(selectorOrType).then(({ elementDef: { name } }) => {\n      iterable = undefined;\n      if (name) {\n        selector = html__naming.name(name, bsContext.get(DefaultNamespaceAliaser));\n        if (updates.size) {\n\n          const selected = refresh();\n\n          if (selected.size) {\n\n            const added = Array.from(\n                filterIt<N | undefined, N>(\n                    mapIt(selected, node => nodeOf(node)),\n                    isPresent,\n                ),\n            );\n\n            if (added.length) {\n              updates.send(added, []);\n            }\n          }\n        }\n      }\n    });\n  }\n\n  if (!all) {\n    root.addEventListener('wesib:component', event => {\n\n      const element = event.target as Element;\n\n      if (cache.has(element)) {\n\n        const node = nodeOf(element) as N;\n\n        updates.send([node], []);\n      }\n    });\n  }\n\n  class ElementNodeList$ extends ElementNodeList<N> {\n\n    onUpdate(): OnEvent<[N[], N[]]>;\n    onUpdate(receiver: EventReceiver<[N[], N[]]>): EventSupply;\n    onUpdate(receiver?: EventReceiver<[N[], N[]]>): OnEvent<[N[], N[]]> | EventSupply {\n\n      const observer = bsContext.get(ElementObserver)(update);\n\n      return (this.onUpdate = onEventBy<[N[], N[]]>(receiver => {\n\n        const firstReceiver = !updates.size;\n        const supply = updates.on(receiver);\n\n        if (firstReceiver) {\n          refresh();\n          observer.observe(root, init);\n        }\n\n        return supply.whenOff(() => {\n          if (!updates.size) {\n            observer.disconnect();\n          }\n        });\n      }).F)(receiver);\n    }\n\n    read(): AfterEvent<[ElementNodeList<N>]>;\n    read(receiver: EventReceiver<[ElementNodeList<N>]>): EventSupply;\n    read(receiver?: EventReceiver<[ElementNodeList<N>]>): AfterEvent<[ElementNodeList<N>]> | EventSupply {\n      return (this.read = afterSent<[ElementNodeList<N>]>(\n          this.onUpdate().thru(() => this),\n          valuesProvider(this),\n      ).F)(receiver);\n    }\n\n    track(): AfterEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>;\n    track(receiver: EventReceiver<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>): EventSupply;\n    track(\n        receiver?: EventReceiver<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>,\n    ): AfterEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]> | EventSupply {\n\n      const onTrackUpdate: OnEvent<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]> = this.onUpdate().thru(\n          (added, removed) => nextArgs(AIterable.of(added), AIterable.of(removed)),\n      );\n\n      return (this.track = afterEventBy<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>(receiver => {\n\n        const initialEmitter = new EventEmitter<[ArrayLikeIterable<N>, ArrayLikeIterable<N>]>();\n\n        initialEmitter.on(receiver);\n        initialEmitter.send(this, AIterable.of([]));\n\n        onTrackUpdate.to(receiver);\n      }).F)(receiver);\n    }\n\n    first(): AfterEvent<[N?]>;\n    first(receiver: EventReceiver<[N?]>): EventSupply;\n    first(receiver?: EventReceiver<[N?]>): AfterEvent<[N?]> | EventSupply {\n      return (this.first = afterSupplied(this.read()).keepThru(\n          list => nextArg<N | undefined>(itsFirst(list)),\n      ).F)(receiver);\n    }\n\n    [Symbol.iterator](): Iterator<N> {\n      return itsIterator(iterable || (iterable = filterIt<N | undefined, N>(\n          mapIt(\n              elements(),\n              element => nodeOf(element),\n          ),\n          isPresent,\n      )));\n    }\n\n  }\n\n  return new ElementNodeList$();\n\n  function elements(): Set<Element> {\n    return updates.size ? cache : refresh();\n  }\n\n  function refresh(): Set<Element> {\n    iterable = undefined;\n    return cache = select();\n  }\n\n  function select(): Set<Element> {\n\n    const sel = selector;\n\n    if (!sel) {\n      return new Set();\n    }\n    if (deep) {\n      return new Set(overArray(root.querySelectorAll(sel)));\n    }\n    return new Set(\n        filterIt(\n            overArray(root.children),\n            item => item.matches(sel),\n        ),\n    );\n  }\n\n  function update(mutations: MutationRecord[]): void {\n\n    const added: N[] = [];\n    const removed: N[] = [];\n\n    mutations.forEach(mutation => {\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overNodes(mutation.removedNodes), removeNode),\n              isPresent,\n          ),\n          node => removed.push(node),\n      );\n      itsEach(\n          filterIt<N | undefined, N>(\n              mapIt(overNodes(mutation.addedNodes), addNode),\n              isPresent,\n          ),\n          node => added.push(node),\n      );\n    });\n    if (added.length || removed.length) {\n      updates.send(added, removed);\n    }\n  }\n\n  function addNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (selector && node.matches(selector) && !cache.has(node)) {\n      cache.add(node);\n      return nodeOf(node);\n    }\n    return;\n  }\n\n  function removeNode(node: Node): N | undefined {\n    if (!isElement(node)) {\n      return;\n    }\n    if (!cache.delete(node)) {\n      return;\n    }\n    return nodeOf(node, true);\n  }\n\n}\n\nfunction overNodeSubtree(nodes: NodeList): Iterable<Node> {\n  return flatMapIt(\n      overArray(nodes),\n      node => [node, ...overNodeSubtree(node.childNodes)],\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n  ValueTracker,\n} from 'fun-events';\n\n/**\n * @internal\n */\nclass AttributesObserver {\n\n  private readonly _emitters = new Map<string, EventEmitter<[string | null, string | null]>>();\n  private _observer?: MutationObserver;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n  }\n\n  private get observer(): MutationObserver {\n    if (this._observer) {\n      return this._observer;\n    }\n\n    const Observer: typeof MutationObserver = (this._bs.get(BootstrapWindow) as any).MutationObserver;\n\n    return this._observer = new Observer(mutations => this._update(mutations));\n  }\n\n  observe(name: string, receiver: EventReceiver<[string | null, string | null]>): EventSupply {\n\n    const self = this;\n    const observer = this.observer;\n    const emitter = this._emitter(name);\n    const rcv = eventReceiver(receiver);\n    const supply = emitter.on({\n      supply: eventSupply(() => {\n        this._emitters.delete(name);\n        observer.disconnect();\n        if (this._emitters.size) {\n          reconnect();\n        } else {\n          this._observer = undefined;\n        }\n      }).needs(rcv.supply),\n      receive: (ctx, newValue, oldValue) => rcv.receive(ctx, newValue, oldValue),\n    });\n\n    observer.disconnect();\n    reconnect();\n\n    return supply;\n\n    function reconnect(): void {\n      self._update(observer.takeRecords());\n      observer.observe(self.element, {\n        attributes: true,\n        attributeOldValue: true,\n        attributeFilter: Array.from(self._emitters.keys()),\n      });\n    }\n  }\n\n  private _update(mutations: MutationRecord[]): void {\n    mutations.forEach(mutation => {\n\n      const attributeName = mutation.attributeName as string;\n      const emitter = this._emitters.get(attributeName);\n\n      if (emitter) {\n        emitter.send(this.element.getAttribute(attributeName) as string, mutation.oldValue);\n      }\n    });\n  }\n\n  private _emitter(name: string): EventEmitter<[string | null, string | null]> {\n\n    const emitter = new EventEmitter<[string | null, string | null]>();\n\n    this._emitters.set(name, emitter);\n\n    return emitter;\n  }\n\n}\n\n/**\n * @internal\n */\nclass AttributeTracker extends ValueTracker<string | null> {\n\n  private readonly _updates = new EventEmitter<[string | null, string | null]>();\n\n  constructor(\n      private readonly _observer: AttributesObserver,\n      private readonly _name: string,\n  ) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._updates);\n  }\n\n  get it(): string | null {\n    return this._observer.element.getAttribute(this._name);\n  }\n\n  set it(value: string | null) {\n    if (value != null) {\n      this._observer.element.setAttribute(this._name, value);\n    } else {\n      this._observer.element.removeAttribute(this._name);\n    }\n  }\n\n  on(): OnEvent<[string | null, string | null]>;\n  on(receiver: EventReceiver<[string | null, string | null]>): EventSupply;\n  on(receiver?: EventReceiver<[string | null, string | null]>): OnEvent<[string | null, string | null]> | EventSupply {\n\n    let observeSupply = noEventSupply();\n\n    return (this.on = onEventBy(receiver => {\n      if (!this._updates.size) {\n        observeSupply = this._observer.observe(\n            this._name,\n            (newValue, oldValue) => this._updates.send(newValue, oldValue),\n        );\n      }\n      receiver.supply.needs(observeSupply);\n      this._updates.on(receiver).whenOff(reason => {\n        if (!this._updates.size) {\n          observeSupply.off(reason);\n        }\n      });\n    }).F)(receiver);\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeAttributes {\n\n  private readonly _attrs = new Map<string, AttributeTracker>();\n  private readonly _observer: AttributesObserver;\n\n  constructor(bs: BootstrapContext, element: any) {\n    this._observer = new AttributesObserver(bs, element);\n  }\n\n  get(name: string): ValueTracker<string | null> {\n\n    const existing = this._attrs.get(name);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new AttributeTracker(this._observer, name);\n\n    this._attrs.set(name, created);\n\n    return created;\n  }\n\n}\n","import { ComponentContext, ComponentState, domPropertyPathTo } from '@wesib/wesib';\nimport {\n  EventEmitter,\n  EventReceiver,\n  EventSupply,\n  EventSupply__symbol,\n  eventSupplyOf,\n  OnEvent,\n  ValueTracker,\n} from 'fun-events';\n\n/**\n * @internal\n */\nclass PropertyTracker<T> extends ValueTracker<T> {\n\n  private readonly _updates = new EventEmitter<[T, T]>();\n\n  constructor(\n      private readonly _element: any,\n      private readonly _key: PropertyKey,\n  ) {\n    super();\n  }\n\n  get [EventSupply__symbol](): EventSupply {\n    return eventSupplyOf(this._updates);\n  }\n\n  get it(): T {\n    return this._element[this._key];\n  }\n\n  set it(value: T) {\n    this._element[this._key] = value;\n  }\n\n  on(): OnEvent<[T, T]>;\n  on(receiver: EventReceiver<[T, T]>): EventSupply;\n  on(receiver?: EventReceiver<[T, T]>): OnEvent<[T, T]> | EventSupply {\n    return (this.on = this._updates.on().F)(receiver);\n  }\n\n  bind(context: ComponentContext): void {\n\n    const propertyState = context.get(ComponentState).track(domPropertyPathTo(this._key));\n\n    propertyState.onUpdate().to({\n      supply: eventSupplyOf(this),\n      receive: (_ctx, _path, newValue: any, oldValue: any) => this._updates.send(newValue, oldValue),\n    });\n  }\n\n}\n\n/**\n * @internal\n */\nexport class NodeProperties {\n\n  private readonly _props = new Map<PropertyKey, PropertyTracker<any>>();\n  private _context?: ComponentContext<any>;\n\n  constructor(private readonly _element: any) {\n  }\n\n  bind(context: ComponentContext): void {\n    this._context = context;\n    this._props.forEach(prop => prop.bind(context));\n  }\n\n  get<T>(key: PropertyKey): ValueTracker<T> {\n\n    const existing = this._props.get(key);\n\n    if (existing) {\n      return existing;\n    }\n\n    const created = new PropertyTracker<any>(this._element, key);\n\n    if (this._context) {\n      created.bind(this._context);\n    }\n    this._props.set(key, created);\n\n    return created;\n  }\n\n}\n","import {\n  BootstrapContext,\n  ComponentClass,\n  ComponentContext,\n  ComponentContext__symbol,\n  ComponentEvent,\n  ElementAdapter,\n} from '@wesib/wesib';\nimport { ValueTracker } from 'fun-events';\nimport { ComponentNode, ComponentTreeNode, ElementNode, ElementPickMode } from './element-node';\nimport { ElementNodeList } from './element-node-list';\nimport { elementNodeList } from './element-node-list.impl';\nimport { NodeAttributes } from './node-attributes.impl';\nimport { NodeProperties } from './node-properties.impl';\n\n/**\n * @internal\n */\nconst ElementNode__symbol = (/*#__PURE__*/ Symbol('element-node'));\n\n/**\n * @internal\n */\nclass ElementNode$ implements ComponentTreeNode {\n\n  private readonly _attrs: NodeAttributes;\n  private readonly _props: NodeProperties;\n\n  constructor(private readonly _bs: BootstrapContext, readonly element: Element) {\n    this._attrs = new NodeAttributes(_bs, element);\n    this._props = new NodeProperties(element);\n    (element as any)[ElementNode__symbol] = this;\n\n    const context = (element as any)[ComponentContext__symbol] as ComponentContext<any> | undefined;\n\n    if (context) {\n      this._bind(context);\n    } else {\n      element.addEventListener('wesib:component', event => this._bind((event as ComponentEvent).context));\n    }\n  }\n\n  get context(): ComponentContext<any> | undefined {\n    return (this.element as any)[ComponentContext__symbol];\n  }\n\n  get parent(): ElementNode | null {\n\n    const parent = this.element.parentNode;\n\n    return parent && elementNodeOf(this._bs, parent as Element);\n  }\n\n  select(selector: string | ComponentClass<any>, mode?: ElementPickMode): ElementNodeList<any> {\n    return selectNodes(this._bs, this.element, selector, mode);\n  }\n\n  attribute(name: string): ValueTracker<string | null> {\n    return this._attrs.get(name);\n  }\n\n  property<V>(key: PropertyKey): ValueTracker<V> {\n    return this._props.get(key);\n  }\n\n  private _bind(context: ComponentContext): void {\n    this._props.bind(context);\n  }\n\n}\n\n/**\n * @internal\n */\nexport function elementNodeOf(bsContext: BootstrapContext, element: Element, optional?: boolean): ElementNode {\n\n  const existing: ElementNode = (element as any)[ElementNode__symbol];\n\n  return (existing || optional) ? existing : new ElementNode$(bsContext, element);\n}\n\n/**\n * @internal\n */\nfunction selectNodes(\n    bsContext: BootstrapContext,\n    root: Element,\n    selector: string | ComponentClass<any>,\n    mode: ElementPickMode = {},\n): ElementNodeList<any> {\n  if (mode.all) {\n    return elementNodeList<ElementNode>(\n        bsContext,\n        root,\n        selector,\n        (element, optional) => elementNodeOf(bsContext, element, optional),\n        mode,\n    );\n  }\n\n  const adapter = bsContext.get(ElementAdapter);\n\n  return elementNodeList<ComponentNode>(\n      bsContext,\n      root,\n      selector,\n      (element, optional) => adapter(element) && elementNodeOf(bsContext, element, optional) as ComponentNode,\n      mode,\n  );\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapContext, ComponentContext, FeatureDef, FeatureDef__symbol, StateSupport } from '@wesib/wesib';\nimport { ComponentNode } from './element-node';\nimport { elementNodeOf } from './element-node.impl';\n\n/**\n * @internal\n */\nconst ComponentTreeSupport__feature: FeatureDef = {\n  needs: StateSupport,\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentNode,\n      by(context: ComponentContext) {\n        return elementNodeOf(context.get(BootstrapContext), context.element) as ComponentNode;\n      },\n    });\n  },\n};\n\n/**\n * Component tree support feature.\n *\n * Provides a [[ComponentNode]] instance for each component.\n */\nexport class ComponentTreeSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ComponentTreeSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\n/**\n * Extracts URL contained in the hash of another URL.\n *\n * Extracted hash URL is based on origin of the original URL. Still, it may be absolute one.\n *\n * Input URL is never altered.\n *\n * @param url  An URL to extract hash from.\n *\n * @returns URL extracted from hash.\n */\nexport function getHashURL(url: URL): URL {\n  return new URL(url.hash.substring(1), url.origin);\n}\n\n/**\n * Creates an URL based on original one, but with hash substituted by the given hash URL.\n *\n * The hash URL is substituted as following:\n *\n * 1. If the hash URL's origin is not the same as the one of the base one, or if it contains a username,\n *    then absolute hash URL is substituted:\n * 2. Otherwise:\n *    - pathname is substituted, unless it is equal to `/` and no hash and search parameters present,\n *    - search parameters are substituted when at least one present,\n *    - hash is substituted only when present.\n *\n * Input URLs are never altered.\n *\n * @param url  Base URL.\n * @param hashURL  Hash URL to substitute.\n *\n * @returns URL with updated hash.\n */\nexport function setHashURL(url: URL, hashURL: URL): URL {\n  if (hashURL.origin !== url.origin || hashURL.username) {\n    return new URL('#' + hashURL, url);\n  }\n\n  const { pathname, search, hash } = hashURL;\n  const result = new URL('', url);\n\n  result.hash = (search || hash || pathname.length > 1) ? (pathname + search + hash) : (search + hash);\n\n  return result;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Page } from './page';\nimport { PageParamContext } from './page-param-context';\n\n/**\n * A key of {@link PageParam.Ref page parameter request} property containing requested page parameter.\n */\nexport const PageParam__symbol = (/*#__PURE__*/ Symbol('page-param'));\n\n/**\n * Page navigation parameter.\n *\n * Can applied before navigation happened (i.e. to [[LeavePageEvent]]). Then it will be available to the target page\n * both before and after navigation.\n *\n * @typeparam T  Parameter value type.\n * @typeparam I  Parameter input type.\n */\nexport abstract class PageParam<T, I> implements PageParam.Ref<T, I> {\n\n  get [PageParam__symbol](): this {\n    return this;\n  }\n\n  /**\n   * Creates page parameter handle.\n   *\n   * This method is called when {@link Page.put assigning new page parameter}. It is called at most once per request,\n   * unless this parameter is assigned already. A {@link PageParam.Handle.put} method will be called instead\n   * in the latter case.\n   *\n   * @param page  A page to assign navigation parameter to.\n   * @param input  Parameter input used to construct its initial value.\n   * @param context  Page parameter context.\n   *\n   * @returns New page parameter value handle.\n   */\n  abstract create(page: Page, input: I, context: PageParamContext): PageParam.Handle<T, I>;\n\n  /**\n   * Creates default page parameter handle.\n   *\n   * This method is called when {@link Page.get requesting page parameter} which value is not present in the page.\n   * The value handle returned is assigned to the page.\n   *\n   * Returns nothing by default.\n   *\n   * @param _page  A page to assign navigation parameter to.\n   * @param _context  Page parameter context.\n   *\n   * @returns New page parameter value handle or nothing if there is no default value.\n   */\n  byDefault(_page: Page, _context: PageParamContext): PageParam.Handle<T, I> | undefined {\n    return;\n  }\n\n}\n\nexport namespace PageParam {\n\n  /**\n   * Page navigation parameter reference.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface Ref<T, I> {\n\n    /**\n     * Referred page navigation parameter instance.\n     */\n    readonly [PageParam__symbol]: PageParam<T, I>;\n\n  }\n\n  /**\n   * Page navigation parameter that has default value.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface WithDefaults<T, I> extends PageParam<T, I> {\n\n    byDefault(page: Page, context: PageParamContext): PageParam.Handle<T, I>;\n\n  }\n\n  export namespace WithDefaults {\n\n    /**\n     * A reference to page navigation parameter that has default value.\n     *\n     * @typeparam T  Parameter value type.\n     * @typeparam I  Parameter input type.\n     */\n    export interface Ref<T, I> {\n\n      /**\n       * Referred page navigation parameter instance.\n       */\n      readonly [PageParam__symbol]: WithDefaults<T, I>;\n\n    }\n\n  }\n\n  /**\n   * Page navigation parameter value handle.\n   *\n   * Holds and maintains parameter value.\n   *\n   * Created by {@link PageParam.create} method.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   */\n  export interface Handle<T, I> {\n\n    /**\n     * Returns current parameter value.\n     *\n     * @returns Parameter value.\n     */\n    get(): T;\n\n    /**\n     * Puts page parameter value.\n     *\n     * This method is called when {@link Page.put re-assigning page parameter}. It is called when page parameter\n     * is assigned already and can be used to update it. The update logic is up to the implementation.\n     *\n     * @param input  Parameter input to use when updating its value.\n     */\n    put(input: I): void;\n\n    /**\n     * Transfers parameter to target page.\n     *\n     * This is called right before [[LeavePageEvent]] is fired for each parameter handle of current page.\n     *\n     * @param to  A page to transfer parameter to.\n     * @param when  When the transfer happens. Either `pretend`, `pre-open`, `pre-replace`, `open`, or `return`.\n     * `return` is used when return to page generated by another app version. E.g. from the page that has been\n     * reloaded.\n     *\n     * @returns New parameter handle instance for target page, or `undefined` if nothing to transfer.\n     */\n    transfer?(to: Page, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): Handle<T, I> | undefined;\n\n    /**\n     * This method is called when the page this parameter created for is entered.\n     *\n     * @param page  Entered page.\n     * @param when  When the page is entered. Either `init`, `open`, `replace`, `enter`, or `return`.\n     */\n    enter?(page: Page, when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void;\n\n    /**\n     * This method is called when the page this parameter created for is left.\n     */\n    leave?(): void;\n\n    /**\n     * This method is called when page navigation aborted and target page won't be reached.\n     *\n     * The handle won't be accessed after this method call.\n     *\n     * @param at  The page the browser remains at.\n     */\n    stay?(at: Page): void;\n\n    /**\n     * This method is called when the page this parameter is created for is removed from navigation history.\n     *\n     * The handle won't be accessed after this method call.\n     */\n    forget?(): void;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { BootstrapWindow } from '@wesib/wesib';\nimport { nextArg } from 'call-thru';\nimport { ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { AfterEvent, afterThe, EventKeeper, nextAfterEvent } from 'fun-events';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\nimport Target = Navigation.Target;\n\n/**\n * Navigation agent signature.\n *\n * The agent is called by navigation methods when leaving current page and may alter navigation processing.\n * E.g. change navigation target. For that it should be registered in appropriate context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by navigation method.\n */\nexport type NavigationAgent =\n/**\n * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n * one. Not calling this function effectively prevents navigation.\n * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n * @param when  When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n * @param from  The page to leave.\n * @param to  Navigation target page.\n */\n    (\n        this: void,\n        next: (this: void, target?: Target) => void,\n        when: 'pretend' | 'pre-open' | 'pre-replace',\n        from: Page,\n        to: Page,\n    ) => void;\n\n/**\n * @internal\n */\nclass NavigationAgentKey\n    extends ContextUpKey<NavigationAgent.Combined, NavigationAgent>\n    implements ContextUpRef<NavigationAgent.Combined, NavigationAgent> {\n\n  readonly upKey: ContextUpKey.UpKey<NavigationAgent.Combined, NavigationAgent>;\n\n  constructor(name: string) {\n    super(name);\n    this.upKey = this.createUpKey(\n        opts => {\n\n          const { document } = opts.context.get(BootstrapWindow);\n\n          return opts.seed.keepThru(\n              (...agents) => {\n                if (agents.length) {\n                  return nextArg(combinedAgent);\n                }\n\n                const defaultProvider = (): AfterEvent<[NavigationAgent.Combined]> => afterThe(defaultNavigationAgent);\n\n                return nextAfterEvent(opts.byDefault(defaultProvider) || defaultProvider());\n\n                function combinedAgent(\n                    next: (this: void, target: Navigation.URLTarget) => void,\n                    when: 'pretend' | 'pre-open' | 'pre-replace',\n                    from: Page,\n                    to: Page,\n                ): void {\n\n                  return navigate(0, to);\n\n                  function navigate(agentIdx: number, agentTo: Page): void {\n\n                    const agent = agents[agentIdx];\n\n                    if (!agent) {\n                      return next(agentTo);\n                    }\n\n                    agent(\n                        (\n                            {\n                              url: nextURL = agentTo.url,\n                              title: nextTitle = agentTo.title,\n                              data: nextData = agentTo.data,\n                            }: Navigation.Target = agentTo,\n                        ) => navigate(\n                            agentIdx + 1,\n                            {\n                              url: new URL(String(nextURL), document.baseURI),\n                              title: nextTitle,\n                              data: nextData,\n                              get visited() {\n                                return agentTo.visited;\n                              },\n                              get current() {\n                                return agentTo.current;\n                              },\n                              get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n                                return agentTo.get(ref);\n                              },\n                              put(ref, input) {\n                                agentTo.put(ref, input);\n                              },\n                            },\n                        ),\n                        when,\n                        from,\n                        agentTo,\n                    );\n                  }\n                }\n              },\n          );\n        },\n    );\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          NavigationAgent.Combined,\n          EventKeeper<NavigationAgent[]> | NavigationAgent,\n          AfterEvent<NavigationAgent[]>>,\n  ): NavigationAgent.Combined {\n\n    let delegated: NavigationAgent.Combined;\n\n    opts.context.get(\n        this.upKey,\n        'or' in opts ? { or: opts.or != null ? afterThe(opts.or) : opts.or } : undefined,\n    )!.to(agent => delegated = agent);\n\n    return (next, when, from, to) => delegated(next, when, from, to);\n  }\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavigationAgent(\n    next: (this: void, target: Navigation.URLTarget) => void,\n    _when: 'pretend' | 'pre-open' | 'pre-replace',\n    _from: Page,\n    to: Page,\n): void {\n  next(to);\n}\n\nexport namespace NavigationAgent {\n\n  /**\n   * Combined navigation agent signature.\n   *\n   * This is what is available under [[NavigationAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or applies the final navigation target if this agent is the last\n   * one. Not calling this function effectively prevents navigation.\n   * Accepts an optional [[Navigation.Target]] parameter. The original target will be used instead when omitted.\n   * @param when  When navigation occurred. Either `pretend`, `pre-open`, or `pre-replace`.\n   * @param from  The page to leave.\n   * @param to  Navigation target page.\n   */\n      (\n          this: void,\n          next: (this: void, target: Navigation.URLTarget) => void,\n          when: 'pretend' | 'pre-open' | 'pre-replace',\n          from: Page,\n          to: Page,\n      ) => void;\n\n}\n\n/**\n * A key of context value containing an [[NavigationAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the navigation.\n */\nexport const NavigationAgent: ContextUpRef<NavigationAgent.Combined, NavigationAgent> = (\n    /*#__PURE__*/ new NavigationAgentKey('navigation-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport {\n  AfterEvent,\n  AfterEvent__symbol,\n  EventKeeper,\n  EventReceiver,\n  EventSender,\n  EventSupply,\n  OnEvent,\n  OnEvent__symbol,\n} from 'fun-events';\nimport { DomEventListener, OnDomEvent } from 'fun-events/dom';\nimport { EnterPageEvent, LeavePageEvent, NavigationEvent, StayOnPageEvent } from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\n/**\n * @internal\n */\nconst Navigation__key = (/*#__PURE__*/ new SingleContextKey<Navigation>('navigation'));\n\n/**\n * Browser navigation service.\n *\n * Expected to be used as a [History] and [Location] APIs replacement.\n *\n * Fires additional navigation events the browser does not support natively.\n *\n * Implements an `EventSender` interface by sending {@link NavigationEvent navigation events} to registered receivers.\n *\n * Implements an `EventKeeper` interface by sending current {@link Page page} to registered receivers.\n *\n * Available as bootstrap context value when [[NavigationSupport]] feature is enabled.\n *\n * [History]: https://developer.mozilla.org/en-US/docs/Web/API/History\n * [Location]: https://developer.mozilla.org/en-US/docs/Web/API/Location\n */\nexport abstract class Navigation implements EventSender<[NavigationEvent]>, EventKeeper<[Page]> {\n\n  static get [ContextKey__symbol](): ContextKey<Navigation> {\n    return Navigation__key;\n  }\n\n  /**\n   * Current page.\n   */\n  abstract readonly page: Page;\n\n  /**\n   * The number of element in navigation history.\n   */\n  abstract readonly length: number;\n\n  /**\n   * Build an `OnDomEvent` sender of {@link EnterPageEvent enter page events}.\n   *\n   * @returns An `OnDomEvent` sender of {@link EnterPageEvent enter page events}.\n   */\n  abstract onEnter(): OnDomEvent<EnterPageEvent>;\n\n  /**\n   * Starts sending {@link EnterPageEvent enter page events} to the given `listener`.\n   *\n   * @param listener  Target listener of {@link EnterPageEvent enter page events}.\n   *\n   * @returns {@link EnterPageEvent Enter page events} supply.\n   */\n  abstract onEnter(listener: DomEventListener<EnterPageEvent>): EventSupply;\n\n  /**\n   * Builds an `OnDomEvent` sender of {@link LeavePageEvent leave page events}.\n   *\n   * The registered listener may cancel navigation by calling `preventDefault()` method of received event.\n   *\n   * @returns `OnDomEvent` sender of {@link LeavePageEvent leave page events}.\n   */\n  abstract onLeave(): OnDomEvent<LeavePageEvent>;\n\n  /**\n   * Starts sending {@link LeavePageEvent leave page events} to the given `listener`.\n   *\n   * The registered listener may cancel navigation by calling `preventDefault()` method of received event.\n   *\n   * @param listener  Target listener of {@link LeavePageEvent leave page events}.\n   *\n   * @returns {@link LeavePageEvent Leave page events} supply.\n   */\n  abstract onLeave(listener: DomEventListener<LeavePageEvent>): EventSupply;\n\n  /**\n   * Builds an `OnDomEvent` {@link StayOnPageEvent stay on page events}.\n   *\n   * The registered listener is informed when navigation has been cancelled by one of leave page event receivers,\n   * navigation failed due to e.g. invalid URL, or when another navigation request initiated before the page left.\n   *\n   * @returns `OnDomEvent` sender of {@link StayOnPageEvent stay on page events}.\n   */\n  abstract onStay(): OnDomEvent<StayOnPageEvent>;\n\n  /**\n   * Starts sending {@link StayOnPageEvent stay on page events} to the given `listener`.\n   *\n   * @param listener  Target listener of {@link StayOnPageEvent stay on page events}.\n   *\n   * @returns {@link StayOnPageEvent Stay on page events} supply.\n   */\n  abstract onStay(listener: DomEventListener<StayOnPageEvent>): EventSupply;\n\n  /**\n   * Builds an `OnEvent` sender of {@link NavigationEvent navigation events}.\n   *\n   * The `[OnEvent__symbol]` property is an alias of this one.\n   *\n   * @returns `OnEvent` sender of {@link NavigationEvent navigation events}.\n   */\n  abstract on(): OnEvent<[NavigationEvent]>;\n\n  /**\n   * Starts sending of {@link NavigationEvent navigation events} to the given `receiver`.\n   *\n   * @param receiver  Target receiver of {@link NavigationEvent navigation events}.\n   *\n   * @returns {@link NavigationEvent Navigation events} supply.\n   */\n  abstract on(receiver: EventReceiver<[NavigationEvent]>): EventSupply;\n\n  [OnEvent__symbol](): OnEvent<[NavigationEvent]> {\n    return this.on();\n  }\n\n  /**\n   * Builds an `AfterEvent` keeper of {@link page current page}.\n   *\n   * The `[AfterEvent__symbol]` property is an alias of this one.\n   *\n   * @returns An `AfterEvent` keeper of {@link page current page}.\n   */\n  abstract read(): AfterEvent<[Page]>;\n\n  /**\n   * Starts sending {@link page current page} and updates to the given `receiver.\n   *\n   * @param receiver  Target receiver of {@link page current page}.\n   *\n   * @returns {@link page Current page} supply.\n   */\n  abstract read(receiver: EventReceiver<[Page]>): EventSupply;\n\n  [AfterEvent__symbol](): AfterEvent<[Page]> {\n    return this.read();\n  }\n\n  /**\n   * Goes to the previous page in navigation history.\n   *\n   * Calling this method is the same as calling `go(-1)`.\n   */\n  back(): void {\n    this.go(-1);\n  }\n\n  /**\n   * Goes to the next page in navigation history.\n   *\n   * Calling this method is the same as calling `go(1)`.\n   */\n  forward(): void {\n    this.go(1);\n  }\n\n  /**\n   * Loads a page from navigation history, identified by its relative location to the current page.\n   *\n   * For example `-1` navigates to previous page, while `1` navigates to the next one. If you specify an out-of-bounds\n   * value (for instance, specifying -1 when there are no previously-visited pages in navigation history), this method\n   * silently has no effect.\n   *\n   * @param delta  Relative location in navigation history to navigate to. The absent value or value of `0` reloads\n   * the current page.\n   */\n  abstract go(delta?: number): void;\n\n  /**\n   * Reloads current page.\n   *\n   * Calling this method is the same as calling `go()`.\n   */\n  reload(): void {\n    this.go();\n  }\n\n  /**\n   * Opens a page by navigating to the given `target`.\n   *\n   * Appends an entry to navigation history.\n   *\n   * @param target  Either navigation target or URL to navigate to.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract open(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current navigation history entry with the given `target`.\n   *\n   * @param target  Either navigation target or URL to replace current history entry with.\n   * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n   * Then navigates to the `target`, unless the event cancelled.\n   * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n   *\n   * @returns A promise resolved to navigated page, or to `null` otherwise.\n   */\n  abstract replace(target: Navigation.Target | string | URL): Promise<Page | null>;\n\n  /**\n   * Replaces current page URL with the given one.\n   *\n   * Does not alter current page state, and does not trigger any events.\n   *\n   * @param url  An URL to replace the the current one with.\n   *\n   * @returns Current page with updated URL.\n   */\n  abstract update(url: string | URL): Page;\n\n  /**\n   * Creates parameterized navigation instance and assigns a page parameter to apply to target page.\n   *\n   * @typeparam T  Parameter value type.\n   * @typeparam I  Parameter input type.\n   * @param ref  A reference to page navigation parameter to apply.\n   * @param input  Parameter input to use when constructing its value.\n   *\n   * @returns New parameterized navigation instance.\n   */\n  abstract with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation.Parameterized;\n\n}\n\nexport namespace Navigation {\n\n  /**\n   * Parameterized navigation.\n   *\n   * Allows to assign target page parameters prior to navigating to it.\n   */\n  export interface Parameterized {\n\n    /**\n     * Applies parameter to navigation target page.\n     *\n     * @typeparam T  Parameter value type.\n     * @typeparam I  Parameter input type.\n     * @param ref  A reference to page navigation parameter to apply.\n     * @param input  Parameter input to use when constructing its value.\n     *\n     * @returns New parameterized navigation instance.\n     */\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Parameterized;\n\n    /**\n     * Opens a page by navigating to the given `target` with provided page parameters.\n     *\n     * Appends an entry to navigation history.\n     *\n     * @param target  Either navigation target or URL to navigate to. Navigates to current page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually navigate.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when navigation succeed.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    open(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Replaces the most recent entry in navigation history with the given `target` and provided page parameters.\n     *\n     * @param target  Either navigation target or URL to replace the latest history entry with. Navigates to current\n     * page URL when omitted.\n     * @fires PreNavigateEvent#wesib:preNavigate  On window object prior to actually update the history.\n     * Then navigates to the `target`, unless the event cancelled.\n     * @fires NavigateEvent@wesib:navigate  On window object when history updated.\n     *\n     * @returns A promise resolved to navigated page, or to `null` otherwise.\n     */\n    replace(target?: Navigation.Target | string | URL): Promise<Page | null>;\n\n    /**\n     * Pretends navigation.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target  Either navigation target or URL to pretend navigation to.\n     * @param callback A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        target: Navigation.Target | string | URL,\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation to the same page.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param callback A callback function receiving two pages as parameters: the page to leave, and the page to open.\n     * The latter one is valid only inside callback, as its parameters will be cleaned up right after callback returns.\n     * The value returned from callback is then returned from this method call. It may be used to collect some data\n     * from target page.\n     *\n     * @returns Either the value returned by callback, or `undefined` when navigation failed.\n     */\n    pretend<T>(\n        callback: (this: void, from: Page, to: Page) => T,\n    ): T | undefined;\n\n    /**\n     * Pretends navigation and builds navigation target.\n     *\n     * Prepares navigation and parameters, but does not actually navigate. Instead it calls the provided callback\n     * function.\n     *\n     * This is useful e.g. to build target URL or evaluate target page parameter.\n     *\n     * @param target  Either navigation target or URL to pretend navigation to. Prepends navigation to current page\n     * when omitted.\n     *\n     * @returns Either Navigation target with URL value, or `undefined` when navigation failed.\n     */\n    pretend(\n        target?: Navigation.Target | string | URL,\n    ): URLTarget | undefined;\n\n  }\n\n  /**\n   * Navigation target.\n   *\n   * This is passed to [[Navigation.open]] and [[Navigation.replace]] methods.\n   */\n  export interface Target {\n\n    /**\n     * An URL to update the browser location string to.\n     */\n    readonly url?: string | URL;\n\n    /**\n     * Opaque data to apply to session history. I.e. either push or replace.\n     */\n    readonly data?: any;\n\n    /**\n     * New window title.\n     */\n    readonly title?: string;\n\n  }\n\n  /**\n   * Navigation target with URL value.\n   */\n  export interface URLTarget extends Target {\n\n    readonly url: URL;\n\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextValues } from 'context-values';\n\n/**\n * Page parameter context.\n *\n * Provides values available in bootstrap context.\n */\nexport abstract class PageParamContext extends ContextValues {\n}\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { itsEach } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport { ContextKey, ContextKey__symbol, ContextRegistry, SingleContextKey } from 'context-values';\nimport { ValueTracker } from 'fun-events';\nimport { Navigation } from './navigation';\nimport { Page } from './page';\nimport { PageParam, PageParam__symbol } from './page-param';\nimport { PageParamContext } from './page-param-context';\n\nconst NavHistory__key = (/*#__PURE__*/ new SingleContextKey<NavHistory>(\n    'nav-history',\n    {\n      byDefault: bootstrapDefault(ctx => new NavHistory(ctx)),\n    },\n));\n\n/**\n * @internal\n */\nexport const NAV_DATA_KEY = 'wesib:navigation:data' as const;\n\n/**\n * @internal\n */\nexport interface PartialNavData {\n  readonly uid?: string;\n  readonly id?: number;\n  readonly data: any;\n}\n\n/**\n * @internal\n */\nexport interface NavData extends PartialNavData {\n  readonly uid: string;\n  readonly id: number;\n}\n\n/**\n * @internal\n */\nexport interface NavDataEnvelope {\n  readonly [NAV_DATA_KEY]: NavData;\n}\n\nfunction extractNavData(state: any): PartialNavData {\n  return state == null || typeof state !== 'object' ? { data: state } : state[NAV_DATA_KEY];\n}\n\n/**\n * @internal\n */\nexport class NavHistory {\n\n  static get [ContextKey__symbol](): ContextKey<NavHistory> {\n    return NavHistory__key;\n  }\n\n  private readonly _document: Document;\n  private readonly _location: Location;\n  private readonly _history: History;\n  private readonly _entries = new Map<number, PageEntry>();\n  private readonly _uid: string;\n  private _lastId = 0;\n\n  constructor(private readonly _context: BootstrapContext) {\n    const window = _context.get(BootstrapWindow);\n\n    this._document = window.document;\n    this._location = window.location;\n    this._history = window.history;\n    this._uid = btoa(String(Math.random()));\n  }\n\n  init(): PageEntry {\n\n    const { data } = extractNavData(this._history.state);\n    const entry = this.newEntry({\n      url: new URL(this._location.href),\n      data,\n      title: this._document.title,\n    });\n\n    this._entries.set(entry.id, entry);\n    entry.schedule(() => {\n      entry.enter('init');\n      this._history.replaceState(this._historyState(entry), '');\n    });\n\n    return entry;\n  }\n\n  newEntry(target: Navigation.URLTarget): PageEntry {\n    return new PageEntry(this._context, ++this._lastId, target);\n  }\n\n  open(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.pushState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._enter('open', toEntry, tracker);\n  }\n\n  private _enter(\n      when: 'open' | 'enter',\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n\n    this._entries.set(toEntry.id, toEntry);\n\n    try {\n      // Forget all entries starting from next one\n      for (let e = fromEntry.next; e; e = e.next) {\n        this._forget(e);\n      }\n    } finally {\n      toEntry.prev = fromEntry;\n      fromEntry.next = toEntry;\n      toEntry.schedule(() => {\n        try {\n          fromEntry.leave();\n        } finally {\n          toEntry.enter(when);\n        }\n      });\n      tracker.it = toEntry;\n    }\n  }\n\n  replace(\n      toEntry: PageEntry,\n      tracker: ValueTracker<PageEntry>,\n  ): void {\n\n    const fromEntry = tracker.it;\n    const { page: { title = '', url } } = toEntry;\n\n    this._history.replaceState(\n        this._historyState(toEntry),\n        title,\n        url.href,\n    );\n\n    this._entries.set(toEntry.id, toEntry);\n\n    const prev = fromEntry.prev;\n\n    if (prev) {\n      toEntry.prev = prev;\n      prev.next = toEntry;\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        try {\n          this._forget(fromEntry);\n        } finally {\n          toEntry.enter('replace');\n        }\n      }\n    });\n    tracker.it = toEntry;\n  }\n\n  popState(\n      popState: PopStateEvent,\n      tracker: ValueTracker<PageEntry>,\n  ): PageEntry | undefined {\n\n    const { state } = popState;\n\n    if (state == null) {\n      // Hash change\n      if (this._history.state == null) {\n        // Not a return\n        return this._changeHash(tracker);\n      }\n      return; // Already handled by `hashchange` handler\n    }\n\n    const fromEntry = tracker.it;\n    const { uid, data, id: pageId } = extractNavData(state);\n    let toEntry: PageEntry;\n\n    const existingEntry = uid === this._uid && pageId != null ? this._entries.get(pageId) : undefined;\n\n    if (existingEntry) {\n      toEntry = existingEntry;\n    } else {\n      // Returning to page existed in previous app version\n      toEntry = this.newEntry({\n        url: new URL(this._location.href),\n        data,\n        title: this._document.title,\n      });\n      fromEntry.transfer(toEntry, 'return');\n      this._entries.set(toEntry.id, toEntry);\n      this._history.replaceState(this._historyState(toEntry), '');\n    }\n\n    toEntry.schedule(() => {\n      try {\n        fromEntry.leave();\n      } finally {\n        toEntry.enter('return');\n      }\n    });\n\n    tracker.it = toEntry;\n\n    return toEntry;\n  }\n\n  public hashChange(tracker: ValueTracker<PageEntry>): PageEntry | void {\n    if (this._history.state == null) {\n      // Not a return\n      return this._changeHash(tracker);\n    }\n    // Otherwise, a `popstate` event is also triggered,\n    // and its handler would do the job (or already did).\n  }\n\n  public update(tracker: ValueTracker<PageEntry>, url: URL): PageEntry {\n\n    const oldEntry = tracker.it;\n    const newEntry = new PageEntry(this._context, ++this._lastId, { ...oldEntry.page, url }, oldEntry);\n\n    this._entries.set(newEntry.id, newEntry);\n    this._history.replaceState(this._historyState(newEntry), '', url.href);\n    this._entries.delete(oldEntry.id);\n\n    return tracker.it = newEntry;\n  }\n\n  private _changeHash(tracker: ValueTracker<PageEntry>): PageEntry {\n\n    const fromEntry = tracker.it;\n    const toEntry = this.newEntry({\n      url: new URL(this._location.href),\n      data: null,\n      title: this._document.title,\n    });\n\n    try {\n      fromEntry.transfer(toEntry, 'enter');\n    } finally {\n      this._history.replaceState(this._historyState(toEntry), '');\n      this._enter('enter', toEntry, tracker);\n    }\n\n    return toEntry;\n  }\n\n  private _forget(entry: PageEntry): void {\n    this._entries.delete(entry.id);\n    entry.forget();\n  }\n\n  private _historyState({ id, page: { data } }: PageEntry): NavDataEnvelope {\n    return {\n      [NAV_DATA_KEY]: {\n        uid: this._uid,\n        id,\n        data,\n      },\n    };\n  }\n\n}\n\nconst enum PageStatus {\n  New,\n  Visited,\n  Current,\n}\n\n/**\n * @internal\n */\nexport class PageEntry {\n\n  next?: PageEntry;\n  prev?: PageEntry;\n  private _status: PageStatus = PageStatus.New;\n  readonly page: Page;\n  private readonly _params: Map<PageParam<any, any>, PageParam.Handle<any, any>>;\n  private _update: () => void = noop;\n\n  constructor(\n      private readonly _bsContext: BootstrapContext,\n      readonly id: number,\n      target: Navigation.URLTarget,\n      proto?: PageEntry,\n  ) {\n    this._params = proto ? proto._params : new Map<PageParam<any, any>, PageParam.Handle<any, any>>();\n\n    const entry = this;\n\n    this.page = {\n      get url() {\n        return target.url;\n      },\n      get title() {\n        return target.title;\n      },\n      get data() {\n        return target.data;\n      },\n      get visited() {\n        return !!entry._status;\n      },\n      get current() {\n        return entry._status === PageStatus.Current;\n      },\n      get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n        return entry.get(ref);\n      },\n      put(ref, input) {\n        entry.put(ref, input);\n      },\n    };\n  }\n\n  get<T>(ref: PageParam.Ref<T, unknown>): T | undefined {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, unknown> | undefined = this._params.get(param);\n\n    if (handle) {\n      return handle.get();\n    }\n\n    const newHandle = param.byDefault(this.page, this._newContext());\n\n    return newHandle && this._init(param, newHandle);\n  }\n\n  put<T, I>(ref: PageParam.Ref<T, I>, input: I): T {\n\n    const param = ref[PageParam__symbol];\n    const handle: PageParam.Handle<T, I> | undefined = this._params.get(param);\n\n    if (handle) {\n      handle.put(input);\n      return handle.get();\n    }\n\n    return this._init(param, param.create(this.page, input, this._newContext()));\n  }\n\n  private _newContext(): PageParamContext {\n\n    const registry = new ContextRegistry<ParamContext>(this._bsContext);\n\n    class ParamContext extends PageParamContext {\n\n      readonly get: PageParamContext['get'] = registry.newValues().get;\n\n    }\n\n    return new ParamContext();\n  }\n\n  private _init<T, I>(param: PageParam<T, I>, handle: PageParam.Handle<T, I>): T {\n    this._params.set(param, handle);\n\n    if (this.page.current && handle.enter) {\n      handle.enter(this.page, 'init');\n    }\n\n    return handle.get();\n  }\n\n  transfer(to: PageEntry, when: 'pretend' | 'pre-open' | 'pre-replace' | 'enter' | 'return'): void {\n    itsEach(this._params.entries(), ([param, handle]) => {\n      if (handle.transfer) {\n\n        const transferred = handle.transfer(to.page, when);\n\n        if (transferred) {\n          to._params.set(param, transferred);\n        }\n      }\n    });\n  }\n\n  stay(at: Page): void {\n    itsEach(this._params.values(), handle => handle.stay && handle.stay(at));\n  }\n\n  enter(when: 'init' | 'open' | 'replace' | 'enter' | 'return'): void {\n    this._status = PageStatus.Current;\n    itsEach(this._params.values(), handle => handle.enter && handle.enter(this.page, when));\n  }\n\n  leave(): void {\n    this._status = PageStatus.Visited;\n    itsEach(this._params.values(), handle => handle.leave && handle.leave());\n  }\n\n  forget(): void {\n    itsEach(this._params.values(), handle => handle.forget && handle.forget());\n    this._params.clear();\n  }\n\n  schedule(update: () => void): void {\n    this._update = update;\n  }\n\n  apply(): void {\n\n    const update = this._update;\n\n    this._update = noop;\n    update();\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from './navigation';\nimport { Page } from './page';\n\n/**\n * Navigation event.\n */\nexport type NavigationEvent = LeavePageEvent | EnterPageEvent | StayOnPageEvent;\n\n/**\n * Navigation event type.\n */\nexport const enum NavigationEventType {\n\n  /**\n   * {@link EnterPageEvent Enter page event} type.\n   */\n  EnterPage = 'wesib:enterPage',\n\n  /**\n   * {@link LeavePageEvent Leave page event} type.\n   */\n  LeavePage = 'wesib:leavePage',\n\n  /**\n   * {@link StayOnPageEvent Stay on page event} type.\n   */\n  StayOnPage = 'wesib:stayOnPage',\n\n}\n\n/**\n * An event fired when navigation target reached by entering destination page.\n *\n * @event EnterPageEvent#wesib:enterPage\n */\nexport class EnterPageEvent extends Event {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs enter page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: EnterPageEventInit) {\n    super(type, { ...init, cancelable: false });\n    this.when = init.when;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link EnterPageEvent Enter page event} initialization options.\n */\nexport interface EnterPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred.\n   *\n   * Can be one of:\n   * - `open` when opening a new page,\n   * - `replace` when replacing navigation history entry,\n   * - `enter` when entering new page by user action (e.g. hashchange event),\n   * - `return` when navigated to previously visited entry in navigation history.\n   */\n  readonly when: 'open' | 'replace' | 'enter' | 'return';\n\n  /**\n   * Entered page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired right before leaving the page in order to navigate to another one.\n *\n * This event can be cancelled in order to prevent actual navigation or history update. The navigation is also\n * cancelled when another navigation initiated by one of the handlers of this event.\n *\n * @event LeavePageEvent#wesib:leavePage\n */\nexport class LeavePageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n  /**\n   * Constructs leave page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: LeavePageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.when = init.when;\n    this.from = init.from;\n    this.to = init.to;\n  }\n\n}\n\n/**\n * {@link LeavePageEvent Leave page event} initialization options.\n */\nexport interface LeavePageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * When navigation event occurred. Either `pre-open` when leaving a page to open a new one, or `pre-replace` when\n   * leaving a page to replace it with another history entry.\n   */\n  readonly when: 'pre-open' | 'pre-replace';\n\n  /**\n   * The page to leave.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target page.\n   */\n  readonly to: Page;\n\n}\n\n/**\n * An event fired when navigation cancelled or failed.\n *\n * @event StayOnPageEvent#wesib:stayOnPage\n */\nexport class StayOnPageEvent extends Event {\n\n  /**\n   * When navigation event occurred. Always `stay`.\n   */\n  get when(): 'stay' {\n    return 'stay';\n  }\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n  /**\n   * Constructs stay on page event.\n   *\n   * @param type  Event type.\n   * @param init  Initialization options.\n   */\n  constructor(type: string, init: StayOnPageEventInit) {\n    super(type, { ...init, cancelable: true });\n    this.from = init.from;\n    this.to = init.to;\n    this.reason = init.reason;\n  }\n\n}\n\n/**\n * {@link StayOnPageEvent Stay on page event} initialization options.\n */\nexport interface StayOnPageEventInit extends Omit<EventInit, 'cancelable'> {\n\n  /**\n   * The page to stay at.\n   */\n  readonly from: Page;\n\n  /**\n   * Navigation target.\n   */\n  readonly to: Navigation.URLTarget;\n\n  /**\n   * A reason of navigation failure. This is set when navigation failed due to some error.\n   */\n  readonly reason?: any;\n\n}\n","import { BootstrapContext, BootstrapWindow, mergeFunctions } from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { AfterEvent, EventReceiver, EventSupply, onAny, OnEvent, trackValue } from 'fun-events';\nimport { DomEventDispatcher, DomEventListener, OnDomEvent } from 'fun-events/dom';\nimport { NavHistory, PageEntry } from './nav-history.impl';\nimport { Navigation as Navigation } from './navigation';\nimport { NavigationAgent } from './navigation-agent';\nimport {\n  EnterPageEvent,\n  LeavePageEvent,\n  NavigationEvent,\n  NavigationEventType,\n  StayOnPageEvent,\n} from './navigation.event';\nimport { Page } from './page';\nimport { PageParam } from './page-param';\n\nexport function createNavigation(context: BootstrapContext): Navigation {\n\n  const window = context.get(BootstrapWindow);\n  const { document, history } = window;\n  const dispatcher = new DomEventDispatcher(window);\n  const navHistory = context.get(NavHistory);\n  const agent = context.get(NavigationAgent);\n  const nav = trackValue<PageEntry>(navHistory.init());\n\n  nav.read(nextEntry => nextEntry.apply()); // The very first page entry receiver applies scheduled updates to page\n\n  let next: Promise<any> = Promise.resolve();\n\n  dispatcher.on<PopStateEvent>('popstate').to(popState => {\n\n    const entry = navHistory.popState(popState, nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: popState.state != null ? 'return' : 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  dispatcher.on('hashchange').to(() => {\n\n    const entry = navHistory.hashChange(nav);\n\n    if (entry) {\n      dispatcher.dispatch(new EnterPageEvent(\n          NavigationEventType.EnterPage,\n          {\n            when: 'enter',\n            to: entry.page,\n          },\n      ));\n    }\n  });\n\n  type NavTarget = { -readonly [K in keyof Navigation.URLTarget]: Navigation.URLTarget[K] };\n\n  class Navigation$ extends Navigation {\n\n    get page(): Page {\n      return nav.it.page;\n    }\n\n    get length(): number {\n      return history.length;\n    }\n\n    onEnter(): OnDomEvent<EnterPageEvent>;\n    onEnter(listener: DomEventListener<EnterPageEvent>): EventSupply;\n    onEnter(listener?: DomEventListener<EnterPageEvent>): OnDomEvent<EnterPageEvent> | EventSupply {\n      return (this.onEnter = dispatcher.on<EnterPageEvent>(NavigationEventType.EnterPage).F)(listener);\n    }\n\n    onLeave(): OnDomEvent<LeavePageEvent>;\n    onLeave(listener: DomEventListener<LeavePageEvent>): EventSupply;\n    onLeave(listener?: DomEventListener<LeavePageEvent>): OnDomEvent<LeavePageEvent> | EventSupply {\n      return (this.onLeave = dispatcher.on<LeavePageEvent>(NavigationEventType.LeavePage).F)(listener);\n    }\n\n    onStay(): OnDomEvent<StayOnPageEvent>;\n    onStay(listener: DomEventListener<StayOnPageEvent>): EventSupply;\n    onStay(listener?: DomEventListener<StayOnPageEvent>): OnDomEvent<StayOnPageEvent> | EventSupply {\n      return (this.onStay = dispatcher.on<StayOnPageEvent>(NavigationEventType.StayOnPage).F)(listener);\n    }\n\n    /**\n     * Builds an `OnEvent` sender of {@link NavigationEvent navigation events}.\n     *\n     * The `[OnEvent__symbol]` property is an alias of this one.\n     *\n     * @returns `OnEvent` sender of {@link NavigationEvent navigation events}.\n     */\n    on(): OnEvent<[NavigationEvent]>;\n    on(receiver: EventReceiver<[NavigationEvent]>): EventSupply;\n    on(receiver?: EventReceiver<[NavigationEvent]>): OnEvent<[NavigationEvent]> | EventSupply {\n      return (this.on = onAny<[NavigationEvent]>(this.onEnter(), this.onLeave(), this.onStay()).F)(receiver);\n    }\n\n    read(): AfterEvent<[Page]>;\n    read(receiver: EventReceiver<[Page]>): EventSupply;\n    read(receiver?: EventReceiver<[Page]>): AfterEvent<[Page]> | EventSupply {\n      return (this.read = nav.read().keepThru(entry => entry.page).F)(receiver);\n    }\n\n    go(delta?: number): void {\n      history.go(delta);\n    }\n\n    open(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-open', 'open', target);\n    }\n\n    replace(target: Navigation.Target | string | URL): Promise<Page | null> {\n      return navigate('pre-replace', 'replace', target);\n    }\n\n    update(url: string | URL): Page {\n      return navHistory.update(nav, toURL(url)).page;\n    }\n\n    with<T, I>(ref: PageParam.Ref<T, I>, input: I): Navigation.Parameterized {\n      return withParam(page => page.put(ref, input));\n    }\n\n  }\n\n  return new Navigation$();\n\n  function withParam(applyParams: (page: Page) => void): Navigation.Parameterized {\n    return {\n      with<TT, II>(ref: PageParam.Ref<TT, II>, input: II): Navigation.Parameterized {\n        return withParam(mergeFunctions(applyParams, page => page.put(ref, input)));\n      },\n      open(target?: Navigation.Target | string | URL) {\n        return navigate('pre-open', 'open', target, applyParams);\n      },\n      replace(target?: Navigation.Target | string | URL) {\n        return navigate('pre-replace', 'replace', target, applyParams);\n      },\n      pretend<T>(\n          targetOrCallback?: Navigation.Target | string | URL | ((this: void, from: Page, to: Page) => T),\n          callback: (this: void, from: Page, to: Page) => T = (_from, to) => to as unknown as T,\n      ): T | undefined {\n\n        let target: Navigation.Target | string | URL | undefined;\n\n        if (typeof targetOrCallback === 'function') {\n          callback = targetOrCallback;\n          target = undefined;\n        } else {\n          target = targetOrCallback;\n        }\n\n        const navTarget = navTargetOf(target);\n        const fromEntry = nav.it;\n        const toEntry = newEntry('pretend', fromEntry, navTarget, applyParams);\n\n        try {\n          return applyAgent('pretend', fromEntry, navTarget, toEntry)\n              ? callback(fromEntry.page, toEntry.page)\n              : undefined;\n        } finally {\n          toEntry.stay(nav.it.page);\n        }\n      },\n    };\n  }\n\n  function toURL(url: string | URL | undefined): URL {\n    if (typeof url === 'string') {\n      return new URL(url, document.baseURI);\n    }\n    return url || nav.it.page.url;\n  }\n\n  function navTargetOf(target?: Navigation.Target | string | URL): NavTarget {\n    if (target == null || typeof target === 'string' || target instanceof URL) {\n      return { url: toURL(target) };\n    }\n    if (target.url instanceof URL) {\n      return target as Navigation.URLTarget;\n    }\n    return { ...target, url: toURL(target.url) };\n  }\n\n  function navigate(\n      whenLeave: 'pre-open' | 'pre-replace',\n      when: 'open' | 'replace',\n      target?: Navigation.Target | string | URL,\n      applyParams: (page: Page) => void = noop,\n  ): Promise<Page | null> {\n\n    const navTarget = navTargetOf(target);\n    const promise = next = next.then(doNavigate, doNavigate);\n\n    return promise;\n\n    function doNavigate(): Page | null {\n\n      let toEntry: PageEntry | undefined = undefined;\n\n      try {\n\n        const prepared = prepare();\n\n        if (!prepared) {\n          return prepared; // Navigation cancelled\n        }\n\n        toEntry = prepared;\n        navHistory[when](toEntry, nav);\n        dispatcher.dispatch(new EnterPageEvent(\n            NavigationEventType.EnterPage,\n            {\n              when,\n              to: toEntry.page,\n            },\n        ));\n\n        return toEntry.page;\n      } catch (e) {\n        stay(toEntry, e);\n        throw e;\n      }\n    }\n\n    function prepare(): PageEntry | null {\n      if (next !== promise) {\n        return stay();\n      }\n\n      const fromEntry = nav.it;\n      const toEntry = newEntry(whenLeave, fromEntry, navTarget, applyParams);\n      const leavePage = new LeavePageEvent(\n          NavigationEventType.LeavePage,\n          {\n            when: whenLeave,\n            from: fromEntry.page,\n            to: toEntry.page,\n          },\n      );\n\n      if (!dispatcher.dispatch(leavePage)\n          || next !== promise\n          || !applyAgent(whenLeave, fromEntry, navTarget, toEntry)) {\n        return stay(toEntry);\n      }\n\n      return toEntry;\n    }\n\n    function stay(toEntry?: PageEntry, reason?: any): null {\n      if (toEntry) {\n        toEntry.stay(nav.it.page);\n      }\n\n      dispatcher.dispatch(new StayOnPageEvent(\n          NavigationEventType.StayOnPage,\n          {\n            from: nav.it.page,\n            to: navTarget,\n            reason,\n          },\n      ));\n\n      return null;\n    }\n\n  }\n\n  function newEntry(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      applyParams: (page: Page) => void,\n  ): PageEntry {\n\n    const toEntry = navHistory.newEntry(navTarget);\n\n    try {\n      fromEntry.transfer(toEntry, whenLeave);\n      applyParams(toEntry.page);\n    } catch (e) {\n      toEntry.stay(nav.it.page);\n      throw e;\n    }\n\n    return toEntry;\n  }\n\n  function applyAgent(\n      whenLeave: 'pretend' | 'pre-open' | 'pre-replace',\n      fromEntry: PageEntry,\n      navTarget: NavTarget,\n      toEntry: PageEntry,\n  ): boolean {\n\n    let navigated = false;\n\n    agent(\n        ({ url, data, title }) => {\n          navigated = true;\n          navTarget.url = url;\n          navTarget.data = data;\n          navTarget.title = title;\n        },\n        whenLeave,\n        fromEntry.page,\n        toEntry.page,\n    );\n\n    return navigated;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { createNavigation } from './navigation.impl';\n\n/**\n * @internal\n */\nconst NavigationSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.provide({ a: Navigation, by: createNavigation });\n  },\n};\n\n/**\n * Browser navigation support feature.\n *\n * Makes [[Navigation]] available in bootstrap context.\n */\nexport class NavigationSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return NavigationSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  Class,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultNamespaceAliaser,\n  DefaultRenderScheduler,\n  Wesib__NS,\n} from '@wesib/wesib';\nimport { nextArgs, noop } from 'call-thru';\nimport {\n  afterEach,\n  AfterEvent,\n  afterEventBy,\n  afterSupplied,\n  afterThe,\n  EventKeeper,\n  eventSupply,\n  EventSupply,\n  nextAfterEvent,\n} from 'fun-events';\nimport { css__naming, QualifiedName } from 'namespace-aliaser';\nimport { ComponentNode, ComponentTreeSupport, ElementNode, ElementPickMode } from '../tree';\nimport { getHashURL } from './hash-url';\nimport { Navigation } from './navigation';\nimport { NavigationSupport } from './navigation-support.feature';\nimport { Page } from './page';\n\n/**\n * @internal\n */\ninterface ActiveNavLink {\n  supply(): EventSupply;\n}\n\n/**\n * @internal\n */\ntype ActiveNavLinks = Map<ElementNode, ActiveNavLink>;\n\n/**\n * Creates component decorator that marks navigation link(s) inside decorated component active.\n *\n * Marks navigation links with highest weight.\n *\n * Enables [[ComponentTreeSupport]], and [[NavigationSupport]] features.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Navigation link activation definition.\n *\n * @returns New component decorator.\n */\nexport function ActivateNavLink<T extends ComponentClass = Class>(\n    def: ActivateNavLinkDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const { select = 'a', pick = { all: true, deep: true } } = def;\n\n  return Component({\n    feature: {\n      needs: [ComponentTreeSupport, NavigationSupport],\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const activate = activateNavLink(context, def);\n        const weigh = navLinkWeight(def);\n        const navigation = context.get(Navigation);\n        const componentNode = context.get(ComponentNode);\n\n        context.whenOn(connectSupply => {\n\n          let active: ActiveNavLinks = new Map();\n\n          navigation.read().tillOff(connectSupply).consume(\n              page => componentNode.select(select, pick).read().keepThru_(\n                  nodes => nextAfterEvent(afterEach(\n                      ...nodes.map(node => weigh({ node, context, page })),\n                  )),\n              ).consume(\n                  (...weights: NavLinkWeight[]) => {\n\n                    const selected = selectActiveNavLinks(weights);\n                    const newActive: ActiveNavLinks = new Map();\n                    const result = eventSupply();\n\n                    selected.forEach(node => {\n\n                      let activeLink: ActiveNavLink;\n                      const existing = active.get(node);\n\n                      if (existing) {\n                        newActive.set(node, existing);\n                        activeLink = existing;\n                      } else {\n                        activeLink = activate({ node, context, page });\n                        newActive.set(node, activeLink);\n                      }\n\n                      activeLink.supply().needs(result);\n                    });\n\n                    active = newActive;\n\n                    return result;\n                  },\n              ),\n          );\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation link activation definition.\n *\n * Defines a set of element nodes considered to be navigation links. Each matching node is {@link weigh weighed}\n * against {@link Navigation.read current page}, and the link with highest weight is marked [[active]].\n *\n * @typeparam T  A type of component.\n */\nexport interface ActivateNavLinkDef<T extends object = any> {\n\n  /**\n   * Navigation links CSS selector.\n   *\n   * `a` by default.\n   */\n  readonly select?: string;\n\n  /**\n   * A mode of navigation link node picking from component tree.\n   *\n   * By default picks any matching element from entire subtree.\n   */\n  readonly pick?: ElementPickMode;\n\n  /**\n   * Qualified name of CSS class to mark the active element with.\n   *\n   * The `active` class in Wesib namespace is used by default.\n   */\n  readonly active?: QualifiedName;\n\n  /**\n   * Weighs matching navigation link.\n   *\n   * This method will be called for each navigation link on each current page update.\n   *\n   * By default:\n   * 1. If the link path has neither hash, nor search parameters, then:\n   * 1.1. Checks whether page URL path starts with the link's one.\n   * 1.2. If so, then uses link path length as weight.\n   * 2. If the link path has search parameters, but has no hash, then requires the page path to be the same as link's\n   *    one, and page search parameters include all of the link's ones. The number of link search parameters plus the\n   *    link path length is used as weight.\n   * 3. If the link path has a hash, then requires the page path and search parameters to be the same as link's ones,\n   *    and their hashes are treated as {@link getHashURL URLs}. The weight is calculated by applying steps 1, 2, and 3\n   *    to hash URLs increased by the link path length and the number of search parameters.\n   *\n   * Ignores search parameters with names starting and ending with double underscores. Like `__wesib_app_rev__`.\n   *\n   * @param node  Navigation link node to weigh.\n   * @param page  Current navigation page.\n   * @param context  Decorated component context.\n   *\n   * @returns Either navigation link weight, or its keeper. Non-positive wights means the page URL doesn't match\n   * the link at all.\n   */\n  weigh?(\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): number | EventKeeper<[number]>;\n\n  /**\n   * Changes navigation link activity state.\n   *\n   * This method is called each time the active link changed.\n   *\n   * @param active  Whether to make target link active (`true`), or inactive (`false`).\n   * @param node  Navigation link node to update activity state of.\n   * @param page  Current navigation page.\n   * @param context  Decorated component context.\n   */\n  activate?(\n      active: boolean,\n      {\n        node,\n        page,\n        context,\n      }: {\n        node: ElementNode;\n        page: Page;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n}\n\n/**\n * @internal\n */\ntype NavLinkWeight = [ElementNode, number];\n\n/**\n * @internal\n */\ninterface NavLinkOpts {\n  node: ElementNode;\n  page: Page;\n  context: ComponentContext;\n}\n\n/**\n * @internal\n */\nfunction selectActiveNavLinks(weights: NavLinkWeight[]): ElementNode[] {\n\n  let maxWeight = 0;\n  let active: ElementNode[] = [];\n\n  weights.forEach(([node, weight]) => {\n    if (weight > maxWeight) {\n      maxWeight = weight;\n      active = [node];\n    } else if (weight === maxWeight) {\n      active.push(node);\n    }\n  });\n\n  return active;\n}\n\n/**\n * @internal\n */\nfunction navLinkWeight(\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => AfterEvent<NavLinkWeight> {\n  if (!def.weigh) {\n    return defaultNavLinkWeight;\n  }\n  return opts => {\n\n    const weight = def.weigh!(opts);\n\n    if (typeof weight === 'number') {\n      return afterThe(opts.node, weight);\n    }\n\n    let supplier: AfterEvent<NavLinkWeight> = afterSupplied(weight).keepThru_(\n        weight => nextArgs(opts.node, weight),\n    );\n\n    return afterEventBy<NavLinkWeight>(receiver => {\n      supplier.to({\n        supply: eventSupply()\n            .needs(receiver.supply)\n            .whenOff(() => {\n              // Fall back to zero weight once the weight supply cut off\n              supplier = afterThe(opts.node, 0);\n              supplier.to(receiver);\n            }),\n        receive: receiver.receive.bind(receiver),\n      });\n    });\n  };\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkWeight(\n    {\n      node,\n      page,\n    }: NavLinkOpts,\n): AfterEvent<NavLinkWeight> {\n\n  const element: Element = node.element;\n  const href = element.getAttribute('href');\n\n  if (href == null) {\n    return afterThe(node, -1);\n  }\n\n  const linkURL = new URL(href, element.ownerDocument!.baseURI);\n\n  return afterThe(node, calcNavLinkWeight(linkURL, page.url));\n}\n\n/**\n * @internal\n */\nfunction calcNavLinkWeight(linkURL: URL, pageURL: URL): number {\n  if (linkURL.origin !== pageURL.origin) {\n    return -1;\n  }\n\n  const linkDir = navLinkPath2dir(linkURL);\n  const pageDir = navLinkPath2dir(pageURL);\n\n  if (linkURL.hash) {\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    // Require search parameters to be equal\n\n    const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n    if (searchParamWeight < 0 || navLinkSearchParamsWeight(pageURL, linkURL) < 0) {\n      return -1;\n    }\n\n    return linkURL.pathname.length\n        + searchParamWeight\n        + calcNavLinkWeight(getHashURL(linkURL), getHashURL(pageURL));\n  }\n\n  const searchParamWeight = navLinkSearchParamsWeight(linkURL, pageURL);\n\n  if (searchParamWeight) {\n    if (searchParamWeight < 0) {\n      return -1;\n    }\n    if (linkDir !== pageDir) {\n      return -1;\n    }\n    return linkURL.pathname.length + searchParamWeight;\n  }\n\n  if (!pageDir.startsWith(linkDir)) {\n    return -1;\n  }\n\n  return linkURL.pathname.length;\n}\n\n/**\n * @internal\n */\nfunction navLinkPath2dir(url: URL): string {\n\n  const path = url.pathname;\n\n  return path.endsWith('/') ? path : path + '/';\n}\n\n/**\n * @internal\n */\nfunction navLinkSearchParamsWeight(\n    { searchParams: linkParams }: URL,\n    { searchParams: pageParams }: URL,\n): number {\n\n  let weight = 0;\n\n  linkParams.forEach((_value, key) => {\n    if (!isIgnoredSearchParam(key)) {\n\n      const pageValues = new Set(pageParams.getAll(key));\n\n      if (weight >= 0) {\n        if (linkParams.getAll(key).every(linkValue => pageValues.has(linkValue))) {\n          weight += 1;\n        } else {\n          weight = -1;\n        }\n      }\n    }\n  });\n\n  return weight;\n}\n\n/**\n * @internal\n */\nfunction isIgnoredSearchParam(key: string): boolean {\n  return key.startsWith('__') && key.endsWith('__');\n}\n\n/**\n * @internal\n */\nconst NavLinkRenderSchedule__symbol = (/*#__PURE__*/ Symbol('nav-link-render-schedule'));\n\n/**\n * @internal\n */\nconst defaultActiveNavLinkClass: QualifiedName = ['active', Wesib__NS];\n\n/**\n * @internal\n */\nfunction activateNavLink(\n    context: ComponentContext,\n    def: ActivateNavLinkDef,\n): (opts: NavLinkOpts) => ActiveNavLink {\n\n  const scheduler = context.get(DefaultRenderScheduler);\n  const { active = defaultActiveNavLinkClass } = def;\n  const activeClass = css__naming.name(active, context.get(DefaultNamespaceAliaser));\n  const activate = def.activate ? def.activate.bind(def) : noop;\n  const assignClass = (active: boolean, { node }: { node: ElementNode }): void => {\n\n    const element: Element = node.element;\n    const { classList } = element;\n\n    if (active) {\n      classList.add(activeClass);\n    } else {\n      classList.remove(activeClass);\n    }\n  };\n\n  return opts => {\n\n    const { element } = opts.node;\n    const schedule = element[NavLinkRenderSchedule__symbol]\n        || (element[NavLinkRenderSchedule__symbol] = scheduler({ node: element }));\n    const makeActive = (active: boolean): void => {\n      schedule(() => assignClass(active, opts));\n      activate(active, opts);\n    };\n\n    makeActive(true);\n\n    let lastSupply: EventSupply | undefined;\n\n    return {\n      supply(): EventSupply {\n\n        const supply = lastSupply = eventSupply(() => {\n          if (lastSupply === supply) {\n            makeActive(false);\n          }\n        });\n\n        return supply;\n      },\n    };\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ArraySet, Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { Navigation } from './navigation';\nimport { NavigationSupport } from './navigation-support.feature';\nimport { Page } from './page';\n\n/**\n * Creates component decorator that handles events (e.g. clicks) on navigation links.\n *\n * Such events would lead to {@link @Navigation navigation actions} instead of default ones.\n *\n * Enables [[NavigationSupport]] feature.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Navigation links handler definition.\n *\n * @returns New component decorator.\n */\nexport function HandleNavLinks<T extends ComponentClass = Class>(\n    def: HandleNavLinksDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const handle = def.handle ? def.handle.bind(def) : defaultHandleNavLinks(def);\n  const events = new ArraySet(def.event || 'click');\n\n  return Component({\n    feature: {\n      needs: NavigationSupport,\n    },\n    define(defContext) {\n      defContext.whenComponent(context => {\n        context.whenOn(supply => {\n\n          const navigation = context.get(Navigation);\n\n          events.forEach(eventType => {\n            context.on(eventType).to({\n              supply,\n              receive(_ctx, event) {\n                navigation.read().once(\n                    page => handle({\n                      event,\n                      page,\n                      context,\n                      navigation,\n                    }),\n                );\n              },\n            });\n          });\n        });\n      });\n    },\n  });\n}\n\n/**\n * Navigation links handler definition.\n *\n * @typeparam T  A type of component.\n */\nexport interface HandleNavLinksDef<T extends object = any> {\n\n  /**\n   * Type or types of events to handle.\n   *\n   * `click` by default.\n   */\n  readonly event?: string | readonly string[];\n\n  /**\n   * Handles event by performing navigation action.\n   *\n   * Every {@link event} sent by one of elements inside decorated component is passed to this function. In response\n   * it may perform a navigation event.\n   *\n   * By default handles events on anchor tags. When such tag contains an `href` attribute containing same-origin URL\n   * it {@link Navigation.open opens} a page at this URL instead of default action. It also prevents navigation\n   * if URL didn't change.\n   *\n   * @param event  A click event to handle.\n   * @param page  Current navigation page.\n   * @param navigation  Navigation service to use.\n   * @param context  Component context.\n   */\n  handle?(\n      {\n        event,\n        page,\n        navigation,\n        context,\n      }: {\n        event: Event;\n        page: Page;\n        navigation: Navigation;\n        context: ComponentContext<T>;\n      },\n  ): void;\n\n  /**\n   * Extracts hyper-reference of clicked element.\n   *\n   * Extracts hyper-reference from `href` attribute of event target.\n   *\n   * @param event  A click event to handle.\n   *\n   * @returns Extracted hyper-reference, or nothing if it can not be extracted. Event will be ignored in this case.\n   */\n  href?(event: Event): string | undefined | null;\n\n}\n\n/**\n * @internal\n */\nfunction defaultNavLinkHref(event: Event): string | null {\n\n  const target = event.target as Element;\n\n  return target.getAttribute('href');\n}\n\n/**\n * @internal\n */\nfunction defaultHandleNavLinks(\n    def: HandleNavLinksDef,\n): (\n    opts: {\n      event: Event;\n      page: Page;\n      navigation: Navigation;\n    },\n) => void {\n\n  const getHref = def.href ? def.href.bind(def) : defaultNavLinkHref;\n\n  return ({\n    event,\n    page,\n    navigation,\n  }) => {\n\n    const href = getHref(event);\n\n    if (href == null) {\n      return;\n    }\n\n    const target = event.target as Element;\n    const pageURL = page.url;\n    const url = new URL(href, target.ownerDocument!.baseURI);\n\n    if (url.origin !== pageURL.origin) {\n      return; // External link\n    }\n\n    event.preventDefault();\n    if (pageURL.href !== url.href) {\n      navigation.open(href);\n    }\n  };\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { isElement } from '@wesib/wesib';\nimport { itsEach, overArray } from 'a-iterable';\n\n/**\n * Imports DOM node from one document to another.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContent]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\n/**\n * Imports DOM node from one document to another and inserts it before the given node.\n *\n * @param from  The node to import.\n * @param to  The node to append imported node to.\n * @param before  The node to insert imported node before, or `null` to append it to the end of target one.\n * @param importContent  A function that imports nodes nested in parent element. [[importNodeContent]] by default.\n *\n * @returns Imported node.\n */\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    before?: Node | null,\n    importContent?: (this: void, from: N, to: N) => void,\n): N;\n\nexport function importNode<N extends Node>(\n    from: N,\n    to: Node,\n    beforeOrImport?: Node | null | ((this: void, from: N, to: N) => void),\n    importContent: (this: void, from: N, to: N) => void = importNodeContent,\n): N {\n\n  let before: Node | null;\n\n  if (typeof beforeOrImport === 'function') {\n    importContent = beforeOrImport;\n    before = null;\n  } else {\n    before = beforeOrImport || null;\n  }\n\n  const doc = to.ownerDocument!;\n\n  if (isElement(from)) {\n\n    const elementClone = doc.createElement(from.tagName.toLowerCase()) as Node as (Element & N);\n\n    from.getAttributeNames().forEach(attr => elementClone.setAttribute(attr, from.getAttribute(attr)!));\n    importContent(from, elementClone);\n    to.insertBefore(elementClone, before);\n\n    return elementClone;\n  }\n\n  const nodeClone = doc.importNode(from, false);\n\n  to.insertBefore(nodeClone, before);\n\n  return nodeClone;\n}\n\n/**\n * Imports DOM node contents from one document to another.\n *\n * @param from  The node which contents to import.\n * @param to  The node to append imported nodes to.\n */\nexport function importNodeContent(from: Node, to: Node): void {\n  itsEach(\n      overArray(from.childNodes),\n      node => importNode(node, to),\n  );\n}\n","import { nextArgs, nextSkip } from 'call-thru';\nimport { eventSupply, EventSupply, OnEvent, onEventBy, trackValue } from 'fun-events';\nimport { Page } from '../page';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport function cachingPageLoader(loader: PageLoader): PageLoader {\n\n  let state: {\n    readonly url: string;\n    readonly on: OnEvent<[PageLoadResponse]>;\n    readonly sup: EventSupply;\n  } | undefined;\n\n  return page => {\n\n    const url = pageUrl(page);\n\n    if (state) {\n      if (state.url === url) {\n        return state.on;\n      }\n      state.sup.off();\n    }\n\n    let tracked: {\n      readonly on: OnEvent<[PageLoadResponse]>;\n      num: number;\n    } | undefined;\n    const supply = eventSupply().whenOff(() => {\n      state = undefined;\n      tracked = undefined;\n    });\n\n    const on = onEventBy<[PageLoadResponse]>(receiver => {\n      if (!tracked) {\n\n        const onLoad = loader(page);\n        const tracker = trackValue<PageLoadResponse>();\n        const trackSupply = onLoad.to(resp => {\n          tracker.it = resp;\n        }).whenOff(reason => {\n          // Error drops page cache, unlike successful page load.\n          if (reason != null) {\n            supply.off(reason);\n          }\n        });\n\n        supply.cuts(trackSupply).cuts(tracker);\n\n        tracked = {\n          on: tracker.read().thru_(\n              response => response ? nextArgs(response) : nextSkip(),\n          ),\n          num: 0,\n        };\n      }\n\n      const requested = tracked;\n\n      ++requested.num;\n\n      return requested.on.tillOff(supply).to(receiver).whenOff(reason => {\n        if (!--requested.num) {\n          // Allow to request the same page again\n          Promise.resolve().then(() => {\n            if (!requested.num && requested === tracked) {\n              supply.off(reason);\n            }\n          });\n        }\n      });\n    });\n\n    state = { url, on, sup: supply };\n\n    return on;\n  };\n}\n\nfunction pageUrl(page: Page): string {\n  return new URL('', page.url).href;\n}\n","import { flatMapIt, itsEach, itsIterator } from 'a-iterable';\nimport { noop } from 'call-thru';\nimport {\n  EventEmitter,\n  eventReceiver,\n  EventReceiver,\n  eventSupply,\n  EventSupply,\n  noEventSupply,\n  OnEvent,\n  onEventBy,\n} from 'fun-events';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageFragmentRequest, PageLoadRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nexport interface PageLoadReq extends PageLoadRequest {\n\n  readonly receiver: EventReceiver.Generic<[PageLoadResponse]>;\n\n}\n\nclass PageLoadAbortError extends Error {}\n\nclass PageLoadRequestsParam$ extends PageParam<PageLoadRequests, PageLoadRequests> {\n\n  create(\n      _page: Page,\n      requests: PageLoadRequests,\n  ): PageParam.Handle<PageLoadRequests, PageLoadRequests> {\n    return {\n      get() {\n        return requests;\n      },\n      put: noop,\n    };\n  }\n\n}\n\n/**\n * @internal\n */\nexport const PageLoadRequestsParam: PageParam<PageLoadRequests, PageLoadRequests> = new PageLoadRequestsParam$();\n\n/**\n * @internal\n */\nexport class PageLoadRequests implements Iterable<PageLoadReq> {\n\n  private readonly _map = new Map<EventSupply, PageLoadReq[]>();\n\n  constructor(\n      private readonly _navigation: Navigation,\n      private readonly _loader: PageLoader,\n  ) {}\n\n  get fragments(): readonly PageFragmentRequest[] {\n\n    const result: PageFragmentRequest[] = [];\n\n    for (const request of this) {\n      if (!request.fragment) {\n        return [];\n      }\n      result.push(request.fragment);\n    }\n\n    return result;\n  }\n\n  [Symbol.iterator](): Iterator<PageLoadReq> {\n    return itsIterator(flatMapIt(this._map.values()));\n  }\n\n  handle(): PageParam.Handle<void, PageLoadRequest> {\n\n    const self = this;\n    const pageSupply = eventSupply();\n    let loadSupply = noEventSupply();\n\n    return {\n      get() {/* void */},\n      put(request: PageLoadRequest): void {\n        self._add(request);\n      },\n      transfer(to: Page, when) {\n        if (when === 'pretend') {\n          return;\n        }\n\n        const transferred = self._transfer();\n\n        to.put(PageLoadRequestsParam, transferred);\n\n        return transferred.handle();\n      },\n      enter(page: Page, when: 'init' | 'open' | 'replace' | 'return'): void {\n        if (when === 'init') {\n          // The page is loaded already. No need to fetch it.\n          return;\n        }\n\n        loadSupply = eventSupply().needs(pageSupply);\n\n        const onLoad = onEventBy<[PageLoadResponse]>(responseReceiver => {\n\n          const emitter = new EventEmitter<[PageLoadResponse]>();\n          const supply = emitter.on(responseReceiver);\n\n          self._loader(page)\n              .tillOff(loadSupply)\n              .to(response => emitter.send(response))\n              .whenOff(error => {\n                if (error !== undefined && !(error instanceof PageLoadAbortError)) {\n                  // Report current page load error as failed load response\n                  emitter.send({\n                    ok: false as const,\n                    page,\n                    error,\n                  });\n                }\n              });\n\n          return supply;\n        }).share();\n\n        itsEach(\n            self,\n            ({ fragment, receiver }) => onFragment(onLoad, fragment).to({\n              supply: eventSupply().needs(receiver.supply),\n              receive(context, response): void {\n                receiver.receive(context, response);\n              },\n            }),\n        );\n      },\n      leave(): void {\n        loadSupply.off(new PageLoadAbortError('page left'));\n      },\n      stay() {\n        pageSupply.off(new PageLoadAbortError('navigation cancelled'));\n      },\n      forget() {\n        pageSupply.off(new PageLoadAbortError('page forgotten'));\n      },\n    };\n\n  }\n\n  private _add(request: PageLoadRequest): void {\n\n    const req = { ...request, receiver: eventReceiver(request.receiver) };\n    const { supply } = req.receiver;\n    const list = this._map.get(supply);\n\n    if (list) {\n      list.push(req);\n    } else {\n      this._map.set(supply, [req]);\n      supply.whenOff(() => this._map.delete(supply));\n    }\n  }\n\n  private _transfer(): PageLoadRequests {\n\n    const transferred = new PageLoadRequests(this._navigation, this._loader);\n\n    for (const [supply, list] of this._map.entries()) {\n      transferred._map.set(supply, Array.from(list));\n    }\n\n    return transferred;\n  }\n\n}\n\nfunction onFragment(\n    onLoad: OnEvent<[PageLoadResponse]>,\n    fragment?: PageFragmentRequest,\n): OnEvent<[PageLoadResponse]> {\n  return fragment\n      ? onLoad.thru_(\n          response => response.ok\n              ? {\n                ...response,\n                fragment: (\n                    fragment.tag != null\n                        ? response.document.getElementsByTagName(fragment.tag)[0]\n                        : response.document.getElementById(fragment.id)\n                ) || undefined,\n              }\n              : response,\n      )\n      : onLoad;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { ContextUpRef } from 'context-values/updatable';\nimport { EventSender, OnEvent } from 'fun-events';\nimport { FetchAgentKey } from '../../fetch/fetch-agent-key.impl';\nimport { PageLoadResponse } from './page-load-response';\n\n/**\n * Page load agent signature.\n *\n * The agent can be used to alter loaded page document processing. For that it should be registered in appropriate\n * context.\n *\n * All registered agents are organized into chain. The first agent in chain is called by page loader.\n */\nexport type PageLoadAgent =\n/**\n * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n * Accepts an optional `Request` parameter. The original request will be used instead when omitted.\n * @param request  HTTP request.\n *\n * @returns An `EventSender` of page load response. It is returned either to preceding agent in chain, or as a loaded\n * document.\n */\n    (\n        this: void,\n        next: (this: void, request?: Request) => OnEvent<[PageLoadResponse]>,\n        request: Request,\n    ) => EventSender<[PageLoadResponse]>;\n\nexport namespace PageLoadAgent {\n\n  /**\n   * Combined page load agent signature.\n   *\n   * This is what is available under [[PageLoadAgent]] key.\n   */\n  export type Combined =\n  /**\n   * @param next  Either calls the next agent in chain, or actually loads page document if this agent is the last one.\n   * Accepts `Request` parameter.\n   * @param request  HTTP request.\n   *\n   * @returns An `OnEvent` registrar of loaded document.\n   */\n      (\n          this: void,\n          next: (this: void, request: Request) => OnEvent<[PageLoadResponse]>,\n          request: Request,\n      ) => OnEvent<[PageLoadResponse]>;\n\n}\n\n/**\n * A key of context value containing an [[PageLoadAgent]] instance.\n *\n * The agent returned combines all registered agents into one. If no agent registered it just performs the fetch.\n */\nexport const PageLoadAgent: ContextUpRef<PageLoadAgent.Combined, PageLoadAgent> = (\n    /*#__PURE__*/ new FetchAgentKey<[PageLoadResponse]>('page-load-agent')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { noop, valueProvider } from 'call-thru';\nimport { ContextUpRef, FnContextKey } from 'context-values/updatable';\n\n/**\n * A signature of page load URL modifier function.\n *\n * All such functions registered in bootstrap context are called in order of their registration with current page URL.\n * They are able to modify it, e.g. by applying additional URL search parameters. The modified URL is used then to load\n * the page.\n */\nexport type PageLoadURLModifier =\n/**\n * @param url  An URL of page to load.\n */\n    (this: void, url: URL) => void;\n\n/**\n * A key of bootstrap context value containing a page load URL modifier.\n *\n * Does not modify URL by default.\n */\nexport const PageLoadURLModifier: ContextUpRef<PageLoadURLModifier, PageLoadURLModifier> = (\n    /*#__PURE__*/ new FnContextKey('page-load-url', { byDefault: valueProvider(noop) })\n);\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { itsReduction } from 'a-iterable';\nimport { nextEach } from 'call-thru';\nimport { SingleContextKey } from 'context-values';\nimport { EventNotifier, onAsync, OnEvent, onEventBy } from 'fun-events';\nimport { hthvParse, hthvQuote } from 'http-header-value';\nimport { HttpFetch } from '../../fetch';\nimport { Page } from '../page';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\n/**\n * @internal\n */\nexport type PageLoader = (this: void, page: Page) => OnEvent<[PageLoadResponse]>;\n\n/**\n * @internal\n */\nexport const PageLoader = (/*#__PURE__*/ new SingleContextKey<PageLoader>(\n    'page-loader',\n    {\n      byDefault: bootstrapDefault(newPageLoader),\n    },\n));\n\nfunction newPageLoader(context: BootstrapContext): PageLoader {\n\n  const window = context.get(BootstrapWindow);\n  const httpFetch = context.get(HttpFetch);\n  const modifyURL = context.get(PageLoadURLModifier);\n  const agent = context.get(PageLoadAgent);\n  const parser: DOMParser = new (window as any).DOMParser();\n\n  return page => {\n\n    const url = new URL(page.url.href);\n\n    modifyURL(url);\n\n    const request = new Request(\n        url.href,\n        {\n          mode: 'same-origin',\n          credentials: 'same-origin',\n          headers: new Headers({ Accept: 'text/html' }),\n        },\n    );\n\n    return onEventBy(receiver => agent(fetch, request).to(receiver));\n\n    function fetch(fetchRequest: Request): OnEvent<[PageLoadResponse]> {\n      requestPageFragments(page, fetchRequest);\n\n      return onEventBy<[PageLoadResponse]>(receiver => {\n\n        const dispatcher = new EventNotifier<[PageLoadResponse]>();\n\n        dispatcher.on(receiver);\n        dispatcher.send({ page });\n\n        onAsync(httpFetch(fetchRequest).thru_(\n            response => Promise.all([response, response.text()]),\n        )).thru_(\n            (...batch: [Response, string][]) => nextEach(batch),\n            ([response, text]): PageLoadResponse => {\n              if (!response.ok) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error: response.status,\n                };\n              }\n              try {\n                return {\n                  ok: true as const,\n                  page,\n                  response,\n                  document: parsePageDocument(parser, url, response, text),\n                };\n              } catch (error) {\n                return {\n                  ok: false as const,\n                  page,\n                  response,\n                  error,\n                };\n              }\n            },\n        ).to(receiver);\n      });\n    }\n  };\n}\n\nfunction requestPageFragments(page: Page, request: Request): void {\n\n  const fragments = page.get(PageLoadRequestsParam)?.fragments;\n\n  if (fragments && fragments.length) {\n    request.headers.set(\n        'Accept-Fragment',\n        itsReduction(\n            fragments,\n            (header, fragment) => (header ? header + ', ' : '') + (\n                fragment.tag != null\n                    ? 'tag=' + hthvQuote(fragment.tag)\n                    : 'id=' + hthvQuote(fragment.id)\n            ),\n            '',\n        ),\n    );\n  }\n}\n\nfunction parsePageDocument(parser: DOMParser, url: URL, response: Response, text: string): Document {\n\n  const doc = parser.parseFromString(\n      text,\n      hthvParse(response.headers.get('Content-Type') || 'text/html')[0].v as SupportedType,\n  );\n\n  if (doc.head) {\n\n    const base = doc.head.querySelector('base');\n\n    if (base) {\n      base.href = new URL(base.getAttribute('href')!, url).href;\n    } else {\n\n      const newBase = doc.createElement('base');\n\n      newBase.href = url.href;\n\n      doc.head.appendChild(newBase);\n    }\n  }\n\n  return doc;\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageParam } from '../page-param';\nimport { PageParamContext } from '../page-param-context';\nimport { cachingPageLoader } from './caching-page-loader.impl';\nimport { PageLoadRequest } from './page-load-request';\nimport { PageLoadRequests, PageLoadRequestsParam } from './page-load-requests.impl';\nimport { PageLoader } from './page-loader.impl';\n\n/**\n * @internal\n */\nclass PageLoadParam$ extends PageParam<void, PageLoadRequest> {\n\n  create(page: Page, request: PageLoadRequest, context: PageParamContext): PageParam.Handle<void, PageLoadRequest> {\n\n    const requests = new PageLoadRequests(context.get(Navigation), cachingPageLoader(context.get(PageLoader)));\n    const handle = requests.handle();\n\n    page.put(PageLoadRequestsParam, requests);\n    handle.put(request);\n\n    return handle;\n  }\n\n}\n\n/**\n * Page load parameter.\n *\n * Accepts a {@link PageLoadRequest page load request} as input.\n *\n * A page load is initiated whenever a page with new address is {@link Navigation.onEnter entered}.\n *\n * Page load won't be initiated if:\n * - page load parameter is not {@link Page.put} added,\n * - all added {@link PageLoadRequest.receiver response receiver}s supplies are cut off, or\n * - the entered page address is the the same one as previous one, except the hash,\n */\nexport const PageLoadParam: PageParam<void, PageLoadRequest> = (/*#__PURE__*/ new PageLoadParam$());\n","import { BootstrapContext, bootstrapDefault, BootstrapWindow } from '@wesib/wesib';\nimport { ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { AfterEvent, afterThe } from 'fun-events';\nimport { Navigation } from '../navigation';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\n\nconst PageCacheBuster__key = (/*#__PURE__*/ new SingleContextKey<PageCacheBuster>(\n    'page-cache-buster',\n    {\n      byDefault: bootstrapDefault(context => new PageCacheBuster(context)),\n    },\n));\n\n/**\n * @internal\n */\nexport const appRevSearchParam = '__wesib_app_rev__';\n\n/**\n * @internal\n */\nexport class PageCacheBuster {\n\n  static get [ContextKey__symbol](): SingleContextKey<PageCacheBuster> {\n    return PageCacheBuster__key;\n  }\n\n  readonly urlModifier: AfterEvent<PageLoadURLModifier[]>;\n  readonly agent: AfterEvent<PageLoadAgent[]>;\n\n  constructor(context: BootstrapContext) {\n\n    const rev = appRev(context.get(BootstrapWindow).document);\n\n    if (!rev) {\n      this.urlModifier = afterThe();\n      this.agent = afterThe();\n    } else {\n\n      const navigation = context.get(Navigation);\n\n      this.urlModifier = afterThe(url => url.searchParams.set(appRevSearchParam, rev));\n      this.agent = afterThe(\n          (next, request) => next(new Request(request.url, request))\n              .thru_(\n                  response => {\n                    if (response.ok) {\n\n                      const newRev = appRev(response.document);\n\n                      if (newRev && newRev !== rev) {\n\n                        const url = new URL(response.page.url.href);\n\n                        url.searchParams.set(appRevSearchParam, newRev);\n                        navigation.update(url);\n                        navigation.reload();\n                      }\n                    }\n\n                    return response;\n                  },\n              ),\n      );\n    }\n  }\n\n}\n\nfunction appRev(doc: Document): string | null | undefined {\n  return doc.querySelector('meta[name=wesib-app-rev]')?.getAttribute('content');\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { filterIt, itsEach, mapIt, overArray } from 'a-iterable';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageScriptsAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (response.ok) {\n\n          const allScripts = new Set<string>(mapIt(\n              externalScripts(doc, overArray(doc.scripts)),\n              ([src]) => src,\n          ));\n\n          itsEach(\n              filterIt(\n                  externalScripts(response.document, overArray(response.document.querySelectorAll('script'))),\n                  ([src]) => !allScripts.has(src),\n              ),\n              ([src, script]) => {\n                importNode(script, doc.head, (_from, to) => to.src = src);\n                allScripts.add(src);\n              },\n          );\n        }\n        return response;\n      },\n  );\n}\n\nfunction externalScripts(\n    doc: Document,\n    scripts: Iterable<HTMLScriptElement>,\n): Iterable<readonly [string, HTMLScriptElement]> {\n  return mapIt(\n      filterIt(\n          scripts,\n          script => !!script.src,\n      ),\n      script => [new URL(script.src, doc.baseURI).href, script] as const,\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { itsEach, itsFirst, overArray } from 'a-iterable';\nimport { importNode } from '../../util';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageStyleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(\n      response => {\n        if (!response.ok) {\n          return response;\n        }\n\n        const newStyles = response.document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n\n        if (!newStyles.length) {\n          return response;\n        }\n\n        let target: Node = doc.head;\n        let before: Node | null = null;\n        const oldStyles = doc.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]');\n        const oldStylesByHref = new Map<string, HTMLLinkElement>();\n        const firstOldStyle = oldStyles.item(0);\n\n        if (firstOldStyle) {\n          target = firstOldStyle.parentNode!;\n          before = firstOldStyle;\n          itsEach(\n              overArray(oldStyles),\n              link => oldStylesByHref.set(new URL(link.href, doc.baseURI).href, link),\n          );\n        }\n\n        itsEach(\n            overArray(newStyles),\n            newStyle => {\n\n              const href = new URL(newStyle.href, doc.baseURI).href;\n              const oldStyle = oldStylesByHref.get(href);\n\n              if (oldStyle) {\n                // Style already exists.\n                if (itsFirst(oldStylesByHref.keys()) === href) {\n                  // In proper position already.\n                  // Insert the remaining styles after it.\n                  target = oldStyle.parentNode!;\n                  before = oldStyle.nextSibling;\n                } else {\n                  // Move to proper position.\n                  target.insertBefore(oldStyle, before);\n                }\n                oldStylesByHref.delete(href);\n              } else {\n                // Import new style\n                importNode(newStyle, target, before, (_from, to) => to.href = href);\n              }\n            },\n        );\n\n        // Remove remaining old styles\n        itsEach(oldStylesByHref.values(), style => style.parentNode!.removeChild(style));\n\n        return response;\n      },\n  );\n}\n","import { BootstrapContext, BootstrapWindow } from '@wesib/wesib';\nimport { PageLoadAgent } from './page-load-agent';\n\n/**\n * @internal\n */\nexport function pageTitleAgent(context: BootstrapContext): PageLoadAgent {\n\n  const doc = context.get(BootstrapWindow).document;\n\n  return next => next().thru_(response => {\n    if (response.ok) {\n\n      const title = response.document.getElementsByTagName('title').item(0);\n\n      if (title && title.textContent) {\n        doc.title = title.textContent;\n      }\n    }\n\n    return response;\n  });\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { NavigationSupport } from '../navigation-support.feature';\nimport { PageCacheBuster } from './page-cache-buster.impl';\nimport { PageLoadAgent } from './page-load-agent';\nimport { PageLoadURLModifier } from './page-load-url-modifier';\nimport { pageScriptsAgent } from './page-scripts-agent.impl';\nimport { pageStyleAgent } from './page-style-agent.impl';\nimport { pageTitleAgent } from './page-title-agent.impl';\n\n/**\n * @internal\n */\nconst PageLoadSupport__feature: FeatureDef = {\n  needs: NavigationSupport,\n  setup(setup) {\n    setup.provide({\n      a: PageLoadURLModifier,\n      by: (buster: PageCacheBuster) => buster.urlModifier,\n      with: [PageCacheBuster],\n    });\n    setup.provide({\n      a: PageLoadAgent,\n      by: (buster: PageCacheBuster) => buster.agent,\n      with: [PageCacheBuster],\n    });\n    setup.provide({ a: PageLoadAgent, by: pageScriptsAgent });\n    setup.provide({ a: PageLoadAgent, by: pageStyleAgent });\n    setup.provide({ a: PageLoadAgent, by: pageTitleAgent });\n  },\n};\n\n/**\n * Page load support feature.\n *\n * Enables default {@link PageLoadAgent page load agents}:\n * 1. Page cache busting agent.\n *    If `<meta name=\"wesib-app-rev\">` tag is present in initial page, then sends this tag's content with each page load\n *    request as `__wesib_app_rev__` search parameter. If the loaded page contains the same named meta tag with\n *    different content, then reloads the page.\n *    This serves both as cache busting technique, and as server-side application updates handler.\n * 2. Scripts agent.\n *    Includes external scripts from loaded page into main document.\n * 3. Style agent.\n *    Replaces external styles of main document styles with the ones from loaded page.\n *    Unless loaded page has no external styles.\n * 4. Title agent.\n *    Applies loaded page title to bootstrap window. If there is one.\n */\nexport class PageLoadSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return PageLoadSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic\n */\nimport {\n  BootstrapWindow,\n  Class,\n  Component,\n  ComponentClass,\n  ComponentContext,\n  ComponentDecorator,\n  DefaultRenderScheduler,\n} from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { importNodeContent } from '../../util';\nimport { Navigation } from '../navigation';\nimport { Page } from '../page';\nimport { PageLoadParam } from './page-load-param';\nimport { PageFragmentRequest } from './page-load-request';\nimport { PageLoadResponse } from './page-load-response';\nimport { PageLoadSupport } from './page-load-support.feature';\n\n/**\n * Creates component decorator that includes page contents into decorated component's element.\n *\n * The page is loaded and included whenever it is {@link Navigation.onEnter entered}.\n *\n * Utilizes [[PageLoadParam]] navigation parameter.\n *\n * Enables [[NavigationSupport]] and [[PageLoadSupport]] features.\n *\n * @typeparam T  A type of decorated component class.\n * @param def  Page inclusion definition.\n *\n * @returns New component decorator.\n */\nexport function IncludePage<T extends ComponentClass = Class>(\n    def: IncludePageDef<InstanceType<T>> = {},\n): ComponentDecorator<T> {\n\n  const onResponse = def.onResponse ? def.onResponse.bind(def) : noop;\n  const contentKey = def.contentKey ? def.contentKey.bind(def) : defaultPageContentKey;\n\n  return Component({\n    feature: {\n      needs: PageLoadSupport,\n    },\n    define(context) {\n      context.whenComponent(context => {\n\n        const document = context.get(BootstrapWindow).document;\n        const schedule = context.get(DefaultRenderScheduler)();\n        const navigation = context.get(Navigation);\n        let lastPageURL: string | undefined = contentKey(navigation.page);\n        const detectFragment = (): PageFragmentRequest => {\n\n          const { fragment } = def;\n\n          if (fragment) {\n            return fragment;\n          }\n\n          const { element: { id, tagName: tag } }: { element: Element } = context;\n\n          return id ? { id } : { tag };\n        };\n\n        context.whenOn(supply => {\n\n          const range = document.createRange();\n\n          range.selectNodeContents(context.contentRoot);\n\n          navigation.read().once(page => {\n            page.put(\n                PageLoadParam,\n                {\n                  fragment: detectFragment(),\n                  receiver: {\n                    supply,\n                    receive: (_ctx, response) => handleResponse(response),\n                  },\n                },\n            );\n          });\n\n          function handleResponse(response: PageLoadResponse): void {\n\n            const newPageURL = contentKey(response.page);\n\n            if (newPageURL === lastPageURL) {\n              return; // Only hash changed. Do not refresh the page.\n            }\n\n            if (!response.ok) {\n              schedule(() => onResponse({ context, range, response }));\n              return;\n            }\n\n            lastPageURL = newPageURL;\n            schedule(() => {\n              range.deleteContents();\n\n              const target = document.createDocumentFragment();\n              const { fragment } = response;\n\n              if (fragment) {\n                importNodeContent(fragment, target);\n                range.insertNode(target);\n              }\n\n              onResponse({ context, range, response });\n            });\n          }\n        });\n      });\n    },\n  });\n}\n\n/**\n * @internal\n */\nfunction defaultPageContentKey({ url }: Page): string {\n  return new URL('', url).href;\n}\n\n/**\n * Page inclusion definition.\n *\n * Configures {@link IncludePage @LoadPage} decorator.\n *\n * @typeparam T  A type of component.\n */\nexport interface IncludePageDef<T extends object = any> {\n\n  /**\n   * Page fragment to include.\n   *\n   * By default uses custom element identifier if present, or element tag name otherwise.\n   */\n  readonly fragment?: PageFragmentRequest;\n\n  /**\n   * Builds content key for the given page.\n   *\n   * The loaded content will replace already included one only when their content key differ.\n   *\n   * By default uses page URL without hash part as a key. This prevents content refresh when only URL hash changes.\n   *\n   * @param page  Target page. Either loaded or not.\n   *\n   * @returns Content key.\n   */\n  contentKey?(page: Page): any;\n\n  /**\n   * Performs additional actions during page load.\n   *\n   * This method is called inside page contents render schedule for {@link PageLoadResponse.ok each stage} of page\n   * load. At the final stage it is called after loaded page contents included.\n   *\n   * This method can be used e.g. to indicate the page load progress.\n   *\n   * @param context  Decorated component context.\n   * @param response  Page load response.\n   * @param range  Document range the loaded page contents going to replace.\n   */\n  onResponse?(\n      {\n        context,\n        response,\n        range,\n      }: {\n        context: ComponentContext<T>;\n        response: PageLoadResponse;\n        range: Range;\n      },\n  ): void;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { SingleContextKey, SingleContextRef } from 'context-values';\nimport { EventSupply } from 'fun-events';\nimport { StypRules } from 'style-producer';\nimport { ComponentStypOptions } from './component-styp-options';\n\n/**\n * Component style producer function interface.\n */\nexport type ComponentStyleProducer =\n/**\n * @param rules  CSS rules to produce stylesheets for. This can be e.g. a `StypRule.rules` to render all rules,\n * or a result of `StypRuleList.grab()` method call to render only matching ones.\n * @param opts  Production options.\n *\n * @returns Styles supply. Once cut off (i.e. its `off()` method is called) the produced stylesheets are removed.\n */\n    (\n        rules: StypRules,\n        opts?: ComponentStypOptions,\n    ) => EventSupply;\n\n/**\n * A key of component context value containing a component style producer.\n */\nexport const ComponentStyleProducer: SingleContextRef<ComponentStyleProducer> = (\n    /*#__PURE__*/ new SingleContextKey<ComponentStyleProducer>('component-style-producer')\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { MultiContextKey, MultiContextRef } from 'context-values';\nimport { StypRenderer } from 'style-producer';\n\n/**\n * A CSS renderer that will be enabled by default by [[ComponentStyleProducer]].\n */\nexport type ComponentStypRenderer = StypRenderer;\n\n/**\n * A key of component context value containing component CSS renderers.\n */\nexport const ComponentStypRenderer: MultiContextRef<ComponentStypRenderer> = (\n    /*#__PURE__*/ new MultiContextKey<ComponentStypRenderer>('component-styp-renderer')\n);\n","import { ComponentContext, DefaultNamespaceAliaser, ElementDef } from '@wesib/wesib';\nimport { ContextValues, SingleContextKey, SingleContextRef } from 'context-values';\nimport { css__naming, html__naming, NamespaceDef, QualifiedName } from 'namespace-aliaser';\n\n/**\n * @internal\n */\nexport type ElementIdClass = QualifiedName;\n\n/**\n * @internal\n */\nexport const ElementIdClass__NS = (/*#__PURE__*/ new NamespaceDef(\n    'https://wesib.github.io/ns/element-id-class',\n    'elic',\n    'element-id-class',\n));\n\n/**\n * @internal\n */\nexport const ElementIdClass: SingleContextRef<ElementIdClass> = (/*#__PURE__*/ new SingleContextKey(\n    'unique-element-class',\n    { byDefault: assignElementId },\n));\n\n/**\n * @internal\n */\nlet uniqueClassSeq = 0;\n\n/**\n * @internal\n */\nfunction assignElementId(contextValues: ContextValues): ElementIdClass {\n\n  const aliaser = contextValues.get(DefaultNamespaceAliaser);\n  const context = contextValues.get(ComponentContext);\n  const elementDef = context.get(ElementDef);\n  const name: string = elementDef.name ? html__naming.name(elementDef.name, aliaser) : 'component';\n  const local = `${name}#${++uniqueClassSeq}`;\n  const qualified = ElementIdClass__NS.name(aliaser(ElementIdClass__NS), local, css__naming);\n  const element = context.element as Element;\n\n  element.classList.add(qualified);\n\n  return qualified;\n}\n","import {\n  ArraySet,\n  BootstrapWindow,\n  ComponentContext,\n  DefaultNamespaceAliaser,\n  DefaultRenderScheduler,\n  ShadowContentRoot,\n} from '@wesib/wesib';\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { EventSupply } from 'fun-events';\nimport {\n  produceBasicStyle,\n  StypPureSelector,\n  StypRenderer,\n  StypRules,\n  stypSelector,\n  StypSelector,\n  StypSubSelector,\n} from 'style-producer';\nimport { ComponentStypOptions } from './component-styp-options';\nimport { ComponentStypRenderer } from './component-styp-renderer';\nimport { ElementIdClass } from './element-id-class.impl';\n\n/**\n * @internal\n */\nconst ComponentStyleProducer__key = (\n    /*#__PURE__*/ new SingleContextKey<ComponentStyleProducer>('component-style-producer:impl')\n);\n\n/**\n * @internal\n */\nexport class ComponentStyleProducer {\n\n  static get [ContextKey__symbol](): ContextKey<ComponentStyleProducer> {\n    return ComponentStyleProducer__key;\n  }\n\n  constructor(\n      private readonly _context: ComponentContext,\n      private readonly _produce = produceBasicStyle,\n  ) {}\n\n  produce(rules: StypRules, options: ComponentStypOptions = {}): EventSupply {\n\n    const context = this._context;\n    const shadowRoot = context.get(ShadowContentRoot, { or: null });\n\n    return this._produce(rules, {\n      ...options,\n      document: options.document || context.get(BootstrapWindow).document,\n      parent: options.parent || context.contentRoot,\n      rootSelector: [],\n      scheduler: options.scheduler || context.get(DefaultRenderScheduler),\n      nsAlias: options.nsAlias || context.get(DefaultNamespaceAliaser),\n      renderer: buildRenderer(),\n    });\n\n    function buildRenderer(): StypRenderer | readonly StypRenderer[] | undefined {\n\n      const { renderer } = options;\n      const renderers = new ArraySet<StypRenderer>(renderer)\n          .add(...context.get(ComponentStypRenderer));\n      const hostSelector = options.hostSelector\n          ? stypSelector(options.hostSelector)[0] as StypPureSelector.NormalizedPart\n          : undefined;\n\n      renderers.add(shadowRoot\n          ? shadowRenderer(hostSelector)\n          : noShadowRenderer(hostSelector || { c: [context.get(ElementIdClass)] }));\n\n      return renderers.value;\n    }\n  }\n\n}\n\n/**\n * @internal\n */\nfunction shadowRenderer(hostSelector: StypPureSelector.NormalizedPart | undefined): StypRenderer {\n  return {\n    order: -100,\n    render(producer, properties) {\n\n      let { selector } = producer;\n\n      if (!selector.length) {\n        selector = [hostSelector || { u: [[':', 'host']] }];\n      } else if (hostSelector) {\n\n        const [rest, host] = extractHostSelector(selector);\n\n        if (host) {\n          if (host.length) {\n            selector = [{ u: [[':', 'host', extendHostSelector(host, hostSelector)]] }, ...rest];\n          } else {\n            selector = [{ u: [[':', 'host', [hostSelector]]] }, ...rest];\n          }\n        }\n      }\n\n      producer.render(properties, { selector });\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction noShadowRenderer(hostSelector: StypPureSelector.NormalizedPart): StypRenderer {\n  return {\n    order: -100,\n    render(producer, properties) {\n\n      let { selector } = producer;\n\n      if (!selector.length) {\n        selector = [hostSelector];\n      } else {\n\n        const [rest, host] = extractHostSelector(selector);\n\n        if (host && host.length) {\n          selector = [...extendHostSelector(host, hostSelector), ...rest];\n        } else {\n          selector = [hostSelector, ...rest];\n        }\n      }\n\n      producer.render(properties, { selector });\n    },\n  };\n}\n\n/**\n * @internal\n */\nfunction extractHostSelector(\n    selector: StypSelector.Normalized,\n): [StypSelector.Normalized, StypSelector.Normalized?] {\n  if (typeof selector[0] !== 'string') {\n\n    const [{ ns, e, i, c, u, s, $ }, ...restParts] = selector;\n\n    if (!ns && !e && !i && !c && !s && u) {\n\n      const [[prefix, name, ...params]] = u;\n\n      if (prefix === ':' && name === 'host') {\n\n        let host: StypSelector.Mutable;\n\n        if (params.length) {\n          host = Array.from(params[0] as StypSubSelector.NormalizedParameter);\n          (host[0] as any).$ = $;\n        } else {\n          host = $ ? [{ $ }] : [];\n        }\n\n        return [restParts, host];\n      }\n    }\n  }\n  return [selector];\n}\n\n/**\n * @internal\n */\nfunction extendHostSelector(\n    selector: StypSelector.Normalized,\n    {\n      ns,\n      e,\n      i,\n      c,\n      u,\n      s,\n    }: StypPureSelector.NormalizedPart,\n): StypSelector.Normalized {\n\n  const [first, ...rest] = selector as [StypSelector.NormalizedPart, ...StypSelector.Normalized];\n\n  return [\n    {\n      ns: first.e || first.ns ? first.ns : ns,\n      e: first.e || first.ns ? first.e : e,\n      i: first.i || i,\n      c: first.c ? (c ? [...first.c, ...c] : first.c) as typeof c : c,\n      u: first.u ? (u ? [...first.u, ...u] : first.u) as typeof u : u,\n      s: ((first.s || '') + (s || '')) || undefined,\n      $: first.$,\n    },\n    ...rest,\n  ];\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { ComponentStyleProducer } from './component-style-producer';\nimport { ComponentStyleProducer as ComponentStyleProducer_ } from './component-style-producer.impl';\n\n/**\n * @internal\n */\nconst BasicStyleProducerSupport__feature: FeatureDef = {\n  setup(setup) {\n    setup.perComponent({ as: ComponentStyleProducer_ });\n    setup.perComponent({\n      a: ComponentStyleProducer,\n      by(producer: ComponentStyleProducer_): ComponentStyleProducer {\n        return (rules, opts) => producer.produce(rules, opts);\n      },\n      with: [ComponentStyleProducer_],\n    });\n  },\n};\n\n/**\n * Basic style producer support feature.\n *\n * Depends on [style-producer].\n *\n * Unlike [[StyleProducerSupport]] feature this one does not enable default CSS renderers.\n *\n * It is enabled automatically by {@link ProduceStyle @ProduceStyle} decorator.\n *\n * [style-producer]: https://www.npmjs.com/package/style-producer\n */\nexport class BasicStyleProducerSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return BasicStyleProducerSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { ComponentContext } from '@wesib/wesib';\nimport { noop } from 'call-thru';\nimport { eventSupply, EventSupply, noEventSupply } from 'fun-events';\nimport { lazyStypRules, StypOptions, StypPureSelector, StypRules } from 'style-producer';\nimport { ComponentStyleProducer } from './component-style-producer';\n\n/**\n * Component CSS styles production options.\n */\nexport interface ComponentStypOptions extends StypOptions {\n\n  /**\n   * Structured CSS selector to use for custom element's host.\n   *\n   * It modifies the selectors of produced CSS rules.\n   *\n   * For custom element with shadow root:\n   * - Replaces root CSS rule selector with `:host(<hostSelector>).\n   * - When `hostSelector` is omitted, then replaces root CSS rule selector with `:host`.\n   * - If CSS rule selector starts with `:host`, then replaces `:host` with `:host(<hostSelector>)`\n   * - If CSS rule selector starts with `:host(<selector>)`, then extends `<selector>` by `hostSelector`.\n   *   I.e. appends CSS classes and sub-selectors to it, and fulfills missing element and identifier selectors.\n   *\n   * For custom element without shadow root either uses provided `hostSelector`, or generates a unique one when omitted.\n   * And additionally:\n   * - Replaces root CSS rule selector it with `hostSelector`.\n   * - If CSS rule selector starts with `:host`, then replaces `:host` with `hostSelector`.\n   * - If CSS rule selector starts with `:host(<selector>), then replaces `:host(<selector>)` with `<selector>` extended\n   *   by `hostSelector`. I.e. appends CSS classes and sub-selectors to it, and fulfills missing element and identifier\n   *   selectors.\n   * - Otherwise prepends CSS rule selector with `hostSelector`.\n   *\n   * This selector should not contain a `:host` sub-selector.\n   */\n  hostSelector?: StypPureSelector.Part | string;\n\n  /**\n   * Root CSS selector is never used for custom elements. A `hostSelector` is applied instead.\n   */\n  rootSelector?: undefined;\n\n  /**\n   * Whether to produce CSS stylesheets while component is not connected.\n   *\n   * Can be one of:\n   * - `true` - to produce stylesheets when first connected and update them even if component is disconnected after\n   *   that. This is the default, as stylesheet updates is expected to be rare operation.\n   * - `false` - to produce stylesheet whenever component is connected and remove them once disconnected.\n   *   This is a good choice if stylesheets are small and updated frequently.\n   * - `always` - to produce stylesheets immediately upon component readiness and update them offline after that.\n   *   This is the right choice if component needs a stylesheet ready before it is added to the document.\n   */\n  offline?: boolean | 'always';\n\n}\n\nexport const ComponentStypOptions = {\n\n  /**\n   * Produces and dynamically updates component's CSS stylesheets based on the given CSS rules.\n   *\n   * @param context  Target component context.\n   * @param rules  A source of CSS rules to produce stylesheets for.\n   * @param options  Production options.\n   *\n   * @returns CSS rules supply. Once cut off the produced stylesheets are removed.\n   */\n  produce(\n      context: ComponentContext,\n      rules: StypRules.Source,\n      options?: ComponentStypOptions,\n  ): EventSupply {\n\n    const css = lazyStypRules(rules);\n    const offline = options && options.offline;\n    const produceStyle = context.get(ComponentStyleProducer);\n\n    let cssSupply = noEventSupply();\n    let doProduceStyle: () => void;\n    const supply = eventSupply(() => {\n      doProduceStyle = noop;\n    }).cuts(cssSupply);\n\n    doProduceStyle = () => {\n      cssSupply = produceStyle(css, options).needs(supply);\n    };\n\n    switch (offline) {\n    case 'always':\n      context.whenReady(doProduceStyle);\n      break;\n    case false:\n      context.whenOn(connectionSupply => {\n        doProduceStyle();\n        cssSupply.needs(connectionSupply);\n      });\n      break;\n    default:\n      context.whenOn().once(doProduceStyle);\n    }\n\n    context.whenDestroyed(reason => supply.off(reason));\n\n    return supply;\n  },\n\n};\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { ComponentClass, ComponentProperty, ComponentPropertyDecorator } from '@wesib/wesib';\nimport { StypRule, StypRules } from 'style-producer';\nimport { BasicStyleProducerSupport } from './basic-style-producer-support.feature';\nimport { ComponentStypOptions } from './component-styp-options';\n\n/**\n * A decorator of component property returning CSS rules to produce.\n *\n * Decorated property value should either contain a CSS rules source of type `StypRules.Source` or be a method\n * returning it.\n *\n * This decorator automatically enables [[BasicStyleProducerSupport]] feature.\n *\n * Utilizes [[ComponentStypOptions.produce]] function to produce CSS stylesheets.\n *\n * @typeparam T  A type of decorated component class.\n * @param options  Non-mandatory CSS style production options.\n *\n * @returns Component property decorator.\n */\nexport function ProduceStyle<T extends ComponentClass>(\n    options?: ComponentStypOptions,\n): ComponentPropertyDecorator<\n    | StypRules.Source\n    | (() => StypRule | StypRules | Promise<StypRule | StypRules>),\n    T> {\n  return ComponentProperty(({ get }) => ({\n    componentDef: {\n      feature: {\n        needs: BasicStyleProducerSupport,\n      },\n      define(defContext) {\n        defContext.whenComponent(context => {\n          context.whenReady(({ component }) => {\n\n            const value = get(component);\n            const source: StypRules.Source = typeof value === 'function' ? value.bind(component) : value;\n\n            ComponentStypOptions.produce(context, source, options);\n          });\n        });\n      },\n    },\n  }));\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { ComponentContext, FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { produceStyle } from 'style-producer';\nimport { BasicStyleProducerSupport } from './basic-style-producer-support.feature';\nimport { ComponentStyleProducer } from './component-style-producer';\nimport { ComponentStyleProducer as ComponentStyleProducer_ } from './component-style-producer.impl';\n\n/**\n * @internal\n */\nconst StyleProducerSupport__feature: FeatureDef = {\n  has: BasicStyleProducerSupport,\n  setup(setup) {\n    setup.perComponent({\n      a: ComponentStyleProducer_,\n      by(context: ComponentContext) {\n        return new ComponentStyleProducer_(context, produceStyle);\n      },\n    });\n    setup.perComponent({\n      a: ComponentStyleProducer,\n      by(producer: ComponentStyleProducer_): ComponentStyleProducer {\n        return (rules, opts) => producer.produce(rules, opts);\n      },\n      with: [ComponentStyleProducer_],\n    });\n  },\n};\n\n/**\n * Style producer support feature.\n *\n * Depends on [style-producer].\n *\n * This is an implementation of [[BasicStyleProducerSupport]] feature that enables default CSS renderers.\n *\n * It is _not_ enabled automatically by {@link ProduceStyle @ProduceStyle} decorator.\n *\n * [style-producer]: https://www.npmjs.com/package/style-producer\n */\nexport class StyleProducerSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return StyleProducerSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { RefStypRule, StypProperties, StypRule, StypRuleRef, StypRules } from 'style-producer';\nimport { ThemeStyle } from './theme-style';\n\n/**\n * @internal\n */\nconst Theme__key = new SingleContextKey<Theme>('theme');\n\n/**\n * A hierarchy of CSS rules within single root.\n *\n * A component may use it to extract styling information.\n *\n * Current theme is available in bootstrap, definition, or component context. By default, only one theme is declared\n * per bootstrap. But this can be overridden.\n */\nexport abstract class Theme {\n\n  /**\n   * A key of bootstrap, definition, or component context value containing current theme instance.\n   */\n  static get [ContextKey__symbol](): ContextKey<Theme> {\n    return Theme__key;\n  }\n\n  /**\n   * Root CSS rule.\n   *\n   * All theme styling is represented as rules within this root.\n   */\n  abstract readonly root: StypRule;\n\n  /**\n   * Obtains CSS rule reference by its `referrer`.\n   *\n   * This is a helper method that resolves the given `referrer` against the `root` CSS rule of this theme.\n   *\n   * @param referrer  Target CSS rule referrer.\n   *\n   * @returns CSS rule reference.\n   */\n  ref<T extends StypProperties<T>>(referrer: RefStypRule<T>): StypRuleRef<T> {\n    return referrer(this.root);\n  }\n\n  /**\n   * Obtains a styling for the given theme styles.\n   *\n   * This method requests the registered {@link ThemeStyle theme styles} for CSS rules they provide.\n   * If some of the styles are not registered then uses the given style as provider.\n   *\n   * @param styles  The styles to obtain styling information for.\n   *\n   * @returns Dynamically updated CSS rule set containing the requested styling.\n   */\n  abstract style(...styles: ThemeStyle.Provider[]): StypRules;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { ContextKey, ContextKey__symbol, SingleContextKey } from 'context-values';\nimport { Theme } from './theme';\n\n/**\n * @internal\n */\nconst ThemeFactory__key = new SingleContextKey<ThemeFactory>('theme-factory');\n\nexport abstract class ThemeFactory {\n\n  static get [ContextKey__symbol](): ContextKey<ThemeFactory> {\n    return ThemeFactory__key;\n  }\n\n  abstract newTheme(): Theme;\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { AIterable } from 'a-iterable';\nimport { ContextRef, ContextValueOpts, ContextValues, SimpleContextKey } from 'context-values';\nimport { stypRules, StypRules } from 'style-producer';\nimport { Theme } from './theme';\n\n/**\n * Theme style provides part of the theme styling information.\n *\n * Theme style(s) can be provided in bootstrap context. They are applied to the theme at most once, when requested\n * by calling [[Theme.style]] method.\n *\n * Theme style is either a function, or an extension of another theme style.\n */\nexport type ThemeStyle = ThemeStyle.Provider | ThemeStyle.Extension;\n\nexport namespace ThemeStyle {\n\n  /**\n   * Theme style provider function.\n   *\n   * This function is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n   *\n   * This function is used as an identifier of particular style and can be extended using [[ThemeStyle.Extension]].\n   *\n   * It is not absolutely necessary to register style provider. It will be applied on request anyway.\n   *\n   * @param theme  A theme to apply styling to.\n   *\n   * @returns Dynamically updated CSS rule set containing the applied styling.\n   */\n  export type Provider = (this: void, theme: Theme) => StypRules;\n\n  /**\n   * Theme style extension.\n   *\n   * An extension should be registered in bootstrap context in order to be applied.\n   */\n  export interface Extension {\n\n    /**\n     * A theme style provider to extend.\n     */\n    readonly style: ThemeStyle.Provider;\n\n    /**\n     * Extends the theme style.\n     *\n     * This method is called at most once per theme to apply styles to the latter. E.g. by declaring CSS rules.\n     *\n     * It will be called after the style provider it extends.\n     *\n     * @param theme  A theme to apply styling to.\n     *\n     * @returns Dynamically updated CSS rule set containing the applied styling.\n     */\n    provide(theme: Theme): StypRules;\n\n  }\n\n  /**\n   * A function obtaining combined style provider. I.e. the one that applies the style along with all extensions.\n   *\n   * @param A  provider of theme style to apply.\n   *\n   * @returns A combined theme style provider.\n   */\n  export type ById = (this: void, style: ThemeStyle.Provider) => ThemeStyle.Provider;\n\n}\n\n/**\n * @internal\n */\nclass ThemeStyleKey extends SimpleContextKey<ThemeStyle.ById, ThemeStyle> {\n\n  constructor() {\n    super('theme-style');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<Ctx, ThemeStyle.ById, ThemeStyle, AIterable<ThemeStyle>>,\n  ): ThemeStyle.ById | null | undefined {\n\n    const providers = new Map<ThemeStyle.Provider, [ThemeStyle.Provider, boolean]>();\n\n    opts.seed.forEach(style => {\n\n      let key: ThemeStyle.Provider;\n      let provider: ThemeStyle.Provider;\n      let isId: boolean;\n\n      if (typeof style === 'function') {\n        key = provider = style;\n        isId = true;\n      } else {\n        key = style.style;\n        provider = style.provide.bind(style);\n        isId = false;\n      }\n\n      const prev = providers.get(key);\n\n      if (!prev) {\n        providers.set(key, [provider, isId]);\n      } else {\n\n        const [prevProvider, hasId] = prev;\n\n        providers.set(\n            key,\n            [\n              isId ? combineStyles(provider, prevProvider) : combineStyles(prevProvider, provider),\n              isId || hasId,\n            ],\n        );\n      }\n    });\n\n    return providers.size ? byId : opts.byDefault(() => byId);\n\n    function byId(id: ThemeStyle.Provider): ThemeStyle.Provider {\n\n      const existing = providers.get(id);\n\n      if (!existing) {\n        return id;\n      }\n\n      const [provider, hasId] = existing;\n\n      return hasId ? provider : combineStyles(id, provider);\n    }\n  }\n\n}\n\n/**\n * A key of bootstrap context value containing theme styles.\n */\nexport const ThemeStyle: ContextRef<ThemeStyle.ById, ThemeStyle> = new ThemeStyleKey();\n\n/**\n * @internal\n */\nfunction combineStyles(first: ThemeStyle.Provider, second: ThemeStyle.Provider): ThemeStyle.Provider {\n  return theme => stypRules(first(theme), second(theme));\n}\n","import { lazyStypRules, stypRoot, StypRule, StypRules } from 'style-producer';\nimport { Theme as Theme_ } from './theme';\nimport { ThemeStyle } from './theme-style';\n\n/**\n * @internal\n */\nexport class Theme extends Theme_ {\n\n  readonly root: StypRule = stypRoot();\n  private readonly _rules = new Map<ThemeStyle.Provider, StypRules>();\n\n  constructor(private readonly _styles: ThemeStyle.ById) {\n    super();\n  }\n\n  style(...styles: ThemeStyle.Provider[]): StypRules {\n\n    const theme = this;\n\n    return lazyStypRules(...styles.reduce<StypRules[]>(addStyleRules, []));\n\n    function addStyleRules(target: StypRules[], style: ThemeStyle.Provider): StypRules[] {\n\n      const existing = theme._rules.get(style);\n\n      if (existing) {\n        target.push(existing);\n      } else {\n\n        const constructed = theme._styles(style)(theme);\n\n        theme._rules.set(style, constructed);\n        target.push(constructed);\n      }\n\n      return target;\n    }\n  }\n\n}\n","import { ThemeFactory as ThemeFactory_ } from './theme-factory';\nimport { ThemeStyle } from './theme-style';\nimport { Theme } from './theme.impl';\n\n/**\n * @internal\n */\nexport class ThemeFactory extends ThemeFactory_ {\n\n  constructor(private readonly _styles: ThemeStyle.ById) {\n    super();\n  }\n\n  newTheme(): Theme {\n    return new Theme(this._styles);\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/styp\n */\nimport { FeatureDef, FeatureDef__symbol } from '@wesib/wesib';\nimport { BasicStyleProducerSupport } from '../styp';\nimport { Theme } from './theme';\nimport { ThemeFactory } from './theme-factory';\nimport { ThemeFactory as ThemeFactory_ } from './theme-factory.impl';\nimport { ThemeStyle } from './theme-style';\n\n/**\n * @internal\n */\nconst ThemeSupport__feature: FeatureDef = {\n  needs: BasicStyleProducerSupport,\n  setup(setup) {\n    setup.provide({ a: ThemeFactory, as: ThemeFactory_, with: [ThemeStyle] });\n    setup.provide({\n      a: Theme,\n      by(factory: ThemeFactory) {\n        return factory.newTheme();\n      },\n      with: [ThemeFactory],\n    });\n  },\n};\n\n/**\n * Theme support feature.\n *\n * This needs to be enabled in order [[Theme]] and [[ThemeFactory]] to be available.\n */\nexport class ThemeSupport {\n\n  static get [FeatureDef__symbol](): FeatureDef {\n    return ThemeSupport__feature;\n  }\n\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { DefaultNamespaceAliaser, DefaultRenderScheduler } from '@wesib/wesib';\nimport { ContextKey__symbol, ContextValueOpts, ContextValues } from 'context-values';\nimport { ContextUpKey, ContextUpRef } from 'context-values/updatable';\nimport { afterAll, AfterEvent, EventKeeper } from 'fun-events';\nimport { InConverter, InNamespaceAliaser, InRenderScheduler, intoConvertedBy } from 'input-aspects';\n\n/**\n * Default input aspects.\n *\n * This is an `AfterEvent` keeper of aspect converter meant to be applied to controls.\n *\n * As a bare minimum it assigns the following aspects to converted controls:\n * - `InRenderScheduler` set to `DefaultRenderScheduler`,\n * - `InNamespaceAliaser` set to `DefaultNamespaceAliaser.\n *\n * More input aspect converters may be registered in context. They may override the default ones.\n */\nexport type DefaultInAspects = AfterEvent<[InConverter.Aspect<any, any>]>;\n\n/**\n * @internal\n */\nclass DefaultInAspectsKey\n    extends ContextUpKey<AfterEvent<[InConverter.Aspect<any, any>]>, InConverter.Aspect<any, any>> {\n\n  get upKey(): this {\n    return this;\n  }\n\n  constructor() {\n    super('default-in-aspects');\n  }\n\n  grow<Ctx extends ContextValues>(\n      opts: ContextValueOpts<\n          Ctx,\n          AfterEvent<[InConverter.Aspect<any, any>]>,\n          EventKeeper<InConverter.Aspect<any, any>[]> | InConverter.Aspect<any, any>,\n          AfterEvent<InConverter.Aspect<any, any>[]>>,\n  ): AfterEvent<[InConverter.Aspect.Factory<any, any>]> {\n\n    const nsAlias = opts.context.get(DefaultNamespaceAliaser);\n\n    return afterAll({\n      scheduler: opts.context.get(DefaultRenderScheduler[ContextKey__symbol].upKey),\n      fns: opts.seed,\n    }).keepThru(\n        ({\n            scheduler: [scheduler],\n            fns,\n        }) => intoConvertedBy(\n            ...fns,\n            InRenderScheduler.to(scheduler),\n            InNamespaceAliaser.to(nsAlias),\n        ),\n    );\n  }\n\n}\n\n/**\n * A key of bootstrap, definition, or component context containing default input aspects.\n */\nexport const DefaultInAspects: ContextUpRef<DefaultInAspects, InConverter.Aspect<any, any>> = (\n    /*#__PURE__*/ new DefaultInAspectsKey()\n);\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { ComponentContext } from '@wesib/wesib';\nimport { SingleContextUpKey, SingleContextUpRef } from 'context-values/updatable';\nimport { eventSupply, EventSupply } from 'fun-events';\nimport { InControl } from 'input-aspects';\nimport { HierarchyContext } from '../hierarchy';\n\n/**\n * A user input originated from control.\n *\n * It is meant to be present in root {@link HierarchyContext hierarchy context}. Nested components may access it from\n * their hierarchy contexts to participate in user input.\n *\n * An [[inputFromControl]] function can be used to initiate user input.\n *\n * @typeparam Value  Input value type.\n */\nexport interface InputFromControl<Value = any> {\n\n  /**\n   * Root component context the input is initiated for.\n   */\n  readonly root: ComponentContext;\n\n  /**\n   * User input control.\n   */\n  readonly control: InControl<Value>;\n\n}\n\n/**\n * No user input originated from control.\n */\nexport interface NoInputFromControl {\n  control?: undefined;\n}\n\n/**\n * A key of hierarchy context value containing a user input originated from control. Potentially\n * {@link NoInputFromControl absent}.\n */\nexport const InputFromControl: SingleContextUpRef<InputFromControl | NoInputFromControl> = (\n    /*#__PURE__*/ new SingleContextUpKey<InputFromControl | NoInputFromControl>(\n        'input-from-control',\n        {\n          byDefault: () => ({}),\n        },\n    )\n);\n\n/**\n * Initiates user input from the given control for the given root component.\n *\n * Constructs an [[InputFromControl]] instance and makes it available in `root` component's hierarchy.\n *\n * @typeparam Value  Input value type.\n * @param root  Root component context to initiate user input for.\n * @param control  User input control.\n *\n * @returns User input supply. The user input would be stopped once this supply is cut off.\n */\nexport function inputFromControl<Value>(\n    root: ComponentContext,\n    control: InControl<Value>,\n): EventSupply {\n\n  const off = root.get(HierarchyContext).provide({\n    a: InputFromControl,\n    by: () => ({\n      root,\n      control,\n    }),\n  });\n\n  return eventSupply(off).needs(control);\n}\n","/**\n * @packageDocumentation\n * @module @wesib/generic/input\n */\nimport { Class, Component, ComponentClass, ComponentContext, ComponentDecorator } from '@wesib/wesib';\nimport { nextArg, nextArgs, NextCall } from 'call-thru';\nimport { afterAll, EventKeeper, EventSupply, eventSupplyOf, nextAfterEvent, OnEventCallChain } from 'fun-events';\nimport { InControl, InConverter } from 'input-aspects';\nimport { HierarchyContext } from '../hierarchy';\nimport { DefaultInAspects } from './default-in-aspects';\nimport { inputFromControl, InputFromControl, NoInputFromControl } from './input-from-control';\n\n/**\n * Constructs component decorator that converts input control from {@link HierarchyContext.up enclosing component}\n * and uses it as an {@link InputFromControl origin of user input} in decorated component.\n *\n * @param convert  Input control converter definition.\n *\n * @returns New component decorator.\n */\nexport function ConvertInput<T extends ComponentClass = Class>(\n    convert: ConvertInputDef<InstanceType<T>>,\n): ComponentDecorator<T> {\n  return Component({\n    define(defContext) {\n      defContext.whenComponent(context => {\n\n        const { up } = context.get(HierarchyContext);\n\n        afterAll({\n          parent: up().keepThru_(\n              upper => upper ? nextAfterEvent(upper.get(InputFromControl)) : nextArg<NoInputFromControl>({}),\n          ),\n          aspects: context.get(DefaultInAspects),\n        }).keepThru_(\n            ({\n              parent: [control],\n              aspects: [aspects],\n            }): NextCall<OnEventCallChain, [InControl<any>?, EventSupply?]> => {\n              if (control.control) {\n\n                const converted = convert({ control, context, aspects });\n\n                if (converted) {\n                  return converted instanceof InControl\n                      ? nextArgs(converted)\n                      : nextAfterEvent(converted);\n                }\n              }\n\n              return nextArgs();\n            },\n        ).consume(\n            (control?: InControl<any> | null, supply?: EventSupply) => {\n              if (!control) {\n                return;\n              }\n\n              const usageSupply = inputFromControl(context, control);\n\n              (supply || eventSupplyOf(control)).needs(usageSupply);\n\n              return usageSupply;\n            },\n        );\n      });\n    },\n  });\n}\n\n/**\n * Converter definition of enclosing component's user input control.\n *\n * The returned converted control keeper may send an event supply as a second parameter. This supply will be cut off\n * once the input from converted control is no longer needed. Otherwise the control's input supply will be cut off\n * instead, and control would become unusable after that.\n *\n * Configures {@link ConvertInput @ConvertInput} component decorator.\n */\nexport type ConvertInputDef<T extends object = any> =\n/**\n * @param control  Enclosing component's user input to convert.\n * @param context  Decorated component context.\n * @param aspects  Default input aspect converter. This is a value of [[DefaultInputAspect]].\n *\n * @returns Either input control, its keeper, or nothing.\n */\n    (\n        this: void,\n        {\n          control,\n          context,\n          aspects,\n        }: {\n          control: InputFromControl;\n          context: ComponentContext<T>;\n          aspects: InConverter.Aspect<any, any>;\n        },\n    ) => InControl<any> | EventKeeper<[InControl<any>?, EventSupply?]> | null | undefined;\n"],"names":["BootstrapContext__key","SingleContextKey","BootstrapContext","ContextValues","ContextKey__symbol","bootstrapDefault","provide","context","key","bootstrapContext","get","ComponentFactory__key","ComponentFactory","[object Object]","element","mount","this","mountTo","connected","BootstrapWindow","byDefault","window","BootstrapRoot","ctx","document","body","DefaultNamespaceAliaser","DefaultRenderSchedulerKey","ContextUpKey","super","upKey","createUpKey","opts","seed","keepThru","fns","length","toDefaultRenderScheduler","defaultProvider","afterThe","newRenderSchedule","nextAfterEvent","delegated","or","undefined","to","scheduler","args","options","DefaultRenderScheduler","isArray","value","Array","ArraySet","AIterable","items","Set","size","Symbol","iterator","next","forEach","item","add","superClassOf","type","satisfying","prototype","Object","getPrototypeOf","superType","constructor","decoratePropertyAccessor","target","propertyKey","desc","updateDescriptor","isField","updatedDesc","writable","isPropertyAccessorDescriptor","value__symbol","initial","accessorDesc","set","newValue","toPropertyAccessorDescriptor","fieldKey","String","configurable","enumerable","fieldAccessorDescriptor","defineProperty","mergeFunctions","first","second","merge","_f","s","apply","isElement","node","nodeType","Node","ELEMENT_NODE","MetaAccessor","symbol","hasOwnProperty","ownDef","own","superDef","of","sources","prevMeta","updates","mapIt","source","meta","newMeta","flatMapIt","PromiseResolver","promise","Promise","resolve","reject","_resolve","_reject","error","FeatureDef__symbol","FeatureMeta","defs","itsReduction","prev","def","needs","has","setup","init","featureMeta","noFeatureDef","FeatureDef","featureType","for","all","define","Feature","FeatureContext__key","FeatureContext","componentType","whenDefined","feature","load","FeatureNeedsError","Error","reduce","reason","need","name","ComponentDef__symbol","ComponentMeta","isQualifiedName","componentMeta","noComponentDef","ComponentDef","Component","decorator","ComponentContext__key","ComponentEventDispatcher__key","values","dispatcher","DomEventDispatcher","eventSupplyOf","dispatch","event","on","ContentRoot","StateUpdater","FnContextKey","valueProvider","noop","ComponentContext__symbol","ComponentContext","updateComponentState","bind","TypeError","contentRoot","oldValue","ComponentEvent","Event","AnonymousComponentProperty__symbol","ComponentProperty","decorateWith","readable","component","componentDef","By","provider","result","proto","descriptor","getValue","setValue","call","notReadableAccessor","notWritableAccessor","updated","With","access","As","Bind","binder","accessor__symbol","accessor","existing","ElementAdapterKey","adapters","combined","adapter","defaultElementAdapter","ElementAdapter","ElementObserver","bsContext","DefaultElementObserver","MutationObserver","callback","mutations","mutation","itsEach","overArray","removedNodes","mountOf","checkConnected","filterIt","addedNodes","observe","childList","ComponentFactory__symbol","componentFactoryOf","factory","CustomElements__key","customElements","nsAlias","CustomElements","componentTypeOrName","elementType","html__naming","extend","elementDef","extends","componentResolver","ComponentResolver__symbol","DefinitionContext__key","ElementDef","elementExtend","HTMLElement","DefinitionContext","BootstrapContextRegistry__key","BootstrapContextRegistry","ContextRegistry","a","is","newValues","ComponentContextRegistry__key","ComponentContextRegistry","DefinitionContextRegistry__key","DefinitionContextRegistry","PostDefSetup__symbol","postDefSetup","tracker","trackValue","emitter","EventEmitter","onSetup","read","thru","nextArgs","nextSkip","onAny","superPostDefSetup","send","it","WhenComponent","currentRev","created","onCreated","onEventBy","receiver","receiverRev","supply","receive","eventContext","componentContext","notifiedRev","recurrentReceiver","onRecurrent","recurrentContext","readNotifier","keepThru_","rev","ElementBuilder","definitionContextRegistry$global","componentContextRegistry$global","definitions","components","whenComponent","componentContextRegistry$perType","ready","whenReady","cls","definitionContext","createComponentContextRegistry","append","componentFactory","createComponent","registry","elementSuper","createMount","elementStatus","el","doc","ownerDocument","contains","componentCreated","definitionContextRegistry","seedIn","F","definitionSetup","perDefinition","spec","perComponent","thru_","once","createRegistry","Element","createElementType","status","destructionReason","whenOff","EventSupply__symbol","sts","whenOn","offSupply","eventSupply","off","cuts","whenDestroyed","done","lastRev","parentNode","parentElement","removeChild","removeElement","ComponentStatus__symbol","notifier","_","prevContext","newComponent","dispatchEvent","bubbles","doNotAdd","ComponentRegistry","_context","_definitionQueue","definition","push","buildElement","FeatureKey__symbol","FeatureKey","from","preferredFeatureClause","afterEventBy","origin","stageId","afterAll","clause","deps","loadFeatureDeps","request","loader","stage","ownLoader","FeatureLoader","ownSource","rcv","unload","share","lastLoader","preventDuplicateLoader","clauses","preferred","required","afterEach","dep","presentFeatureDeps","isPresent","down","_down","_stage","SetupFeatureStage","then","after","state","lastStage","id","prevStage","stop","FeatureStage","_stop","action","map","perDep","unloader","unloads","adder","reverse","newUnloader","componentRegistry","componentContextRegistry","elementBuilder","st","bs","by","nextArg","onDefinition","tillOff","onComponent","onPostDefSetup","newFeatureContext","InitFeatureStage","ActiveFeatureStage","FeatureRequest","_requester","_revoke","featureDef","requester","isClause","_revokeBy","unuse","_uses","revoke","FeatureRequester__key","FeatureRequester","Map","_map","reuse","delete","bootstrapComponents","features","bootstrapContextRegistry","create","complete","newNamespaceAliaser","info","_ctx","ldr","whenDown","AfterEvent__symbol","initBootstrap","AttributeDescriptor","MultiContextKey","AttributePath__root","attributePathTo","attributeStateUpdate","updateState","path","update","updateAttributeState","AttributeRegistry__key","AttributeRegistry","attrs","_attrs","change","observedAttributes","keys","attributeFilter","records","record","attributeName","getAttribute","attributes","attributeOldValue","AttributesSupport__feature","as","AttributesSupport","Attribute","parseAttributeDescriptor","setAttribute","removeAttribute","Attributes","defineByItem","ComponentState__key","ComponentState","StateTracker","StateSupport__feature","with","StateSupport","AttributeTracker","ValueTracker","_name","_path","isOff","track","onUpdate","trackAttribute","DomPropertyPath__root","ElementRenderer","renderer","offline","stateTracker","schedule","stateSupply","scheduleRenderer","renderElement","cancelRenderer","execution","newRenderer","Render","defContext","render","ShadowContentRoot","ShadowDomEvent","shadowRoot","ShadowRootBuilder","ShadowDomSupport__feature","attachShadow","ShadowDomSupport","shadowRootOf","defaultShadowContentDef","mode","AttachShadow","Wesib__NS","NamespaceDef","FetchAgentKey","agents","fetch","agentIdx","agentRequest","agent","onSupplied","nextRequest","combineFetchAgents","defaultFetchAgent","HttpFetchAgent","HttpFetchAborted","HttpFetch","input","Request","responseEmitter","abortController","AbortController","signal","abort","response","customSignal","aborted","catch","HierarchyRoot","root","HierarchyUpdates","issue","HierarchyUpdates__key","hierarchyRoot","parent","findParentContext","immediate","HierarchyContext__key","HierarchyContext$","HierarchyContext","_registry","up","upper","parentHierarchy","rootSupply","parentSupply","updateParent","parentCtx","consume","newParent","onSupply","ComponentNode","ElementNodeList","OnEvent__symbol","WATCH_DEEP","subtree","elementNodeList","selectorOrType","nodeOf","deep","iterable","selector","cache","overNodes","overNodeSubtree","selected","refresh","added","addEventListener","observer","firstReceiver","disconnect","afterSent","valuesProvider","onTrackUpdate","removed","initialEmitter","afterSupplied","list","itsFirst","itsIterator","sel","querySelectorAll","children","matches","select","removeNode","addNode","nodes","childNodes","AttributesObserver","_bs","_observer","Observer","_update","self","_emitter","eventReceiver","_emitters","reconnect","takeRecords","_updates","observeSupply","noEventSupply","NodeAttributes","PropertyTracker","_element","_key","NodeProperties","_props","prop","ElementNode__symbol","ElementNode$","_bind","elementNodeOf","optional","selectNodes","ComponentTreeSupport__feature","ComponentTreeSupport","getHashURL","url","URL","hash","substring","PageParam__symbol","PageParam","_page","NavigationAgentKey","when","navigate","agentTo","nextURL","title","nextTitle","data","nextData","baseURI","visited","current","ref","put","defaultNavigationAgent","_when","_from","NavigationAgent","Navigation__key","Navigation","go","PageParamContext","NavHistory__key","NavHistory","extractNavData","_document","_location","location","_history","history","_uid","btoa","Math","random","entry","newEntry","href","_entries","enter","replaceState","_historyState","PageEntry","_lastId","toEntry","page","pushState","_enter","fromEntry","e","_forget","leave","popState","_changeHash","uid","pageId","existingEntry","transfer","oldEntry","forget","wesib:navigation:data","_bsContext","_params","_status","param","handle","newHandle","_newContext","_init","entries","transferred","at","stay","clear","EnterPageEvent","cancelable","LeavePageEvent","StayOnPageEvent","createNavigation","navHistory","nav","nextEntry","hashChange","listener","onEnter","onLeave","onStay","delta","toURL","withParam","applyParams","open","replace","targetOrCallback","navTarget","navTargetOf","applyAgent","whenLeave","doNavigate","prepared","leavePage","prepare","navigated","NavigationSupport__feature","NavigationSupport","ActivateNavLink","pick","activate","active","defaultActiveNavLinkClass","activeClass","css__naming","NavLinkRenderSchedule__symbol","makeActive","classList","remove","assignClass","lastSupply","activateNavLink","weigh","defaultNavLinkWeight","weight","supplier","navLinkWeight","navigation","componentNode","connectSupply","weights","maxWeight","selectActiveNavLinks","newActive","activeLink","linkURL","calcNavLinkWeight","pageURL","linkDir","navLinkPath2dir","pageDir","searchParamWeight","navLinkSearchParamsWeight","pathname","startsWith","endsWith","searchParams","linkParams","pageParams","_value","isIgnoredSearchParam","pageValues","getAll","every","linkValue","HandleNavLinks","getHref","defaultNavLinkHref","preventDefault","defaultHandleNavLinks","events","eventType","importNode","beforeOrImport","importContent","importNodeContent","before","elementClone","createElement","tagName","toLowerCase","getAttributeNames","attr","insertBefore","nodeClone","cachingPageLoader","pageUrl","sup","tracked","onLoad","trackSupply","resp","num","requested","PageLoadAbortError","PageLoadRequestsParam","requests","PageLoadRequests","_navigation","_loader","fragments","fragment","pageSupply","loadSupply","_add","_transfer","responseReceiver","ok","tag","getElementsByTagName","getElementById","onFragment","req","PageLoadAgent","PageLoadURLModifier","PageLoader","httpFetch","modifyURL","parser","DOMParser","credentials","headers","Headers","Accept","fetchRequest","header","hthvQuote","requestPageFragments","EventNotifier","onAsync","text","batch","nextEach","parsePageDocument","parseFromString","hthvParse","v","head","base","querySelector","newBase","appendChild","PageLoadParam$","PageLoadParam","PageCacheBuster__key","PageCacheBuster","appRev","urlModifier","newRev","reload","pageScriptsAgent","allScripts","externalScripts","scripts","src","script","pageStyleAgent","newStyles","oldStyles","oldStylesByHref","firstOldStyle","link","newStyle","oldStyle","nextSibling","style","pageTitleAgent","textContent","PageLoadSupport__feature","buster","PageLoadSupport","IncludePage","onResponse","contentKey","defaultPageContentKey","lastPageURL","detectFragment","range","createRange","selectNodeContents","newPageURL","deleteContents","createDocumentFragment","insertNode","handleResponse","ComponentStyleProducer","ComponentStypRenderer","ElementIdClass__NS","ElementIdClass","contextValues","aliaser","local","uniqueClassSeq","qualified","ComponentStyleProducer__key","_produce","produceBasicStyle","rules","rootSelector","renderers","hostSelector","stypSelector","shadowRenderer","noShadowRenderer","c","buildRenderer","order","producer","properties","rest","host","extractHostSelector","u","extendHostSelector","ns","i","$","restParts","prefix","params","BasicStyleProducerSupport__feature","ComponentStyleProducer_","produce","BasicStyleProducerSupport","ComponentStypOptions","css","lazyStypRules","produceStyle","doProduceStyle","cssSupply","connectionSupply","ProduceStyle","StyleProducerSupport__feature","StyleProducerSupport","Theme__key","Theme","referrer","ThemeFactory__key","ThemeFactory","ThemeStyle","SimpleContextKey","providers","isId","prevProvider","hasId","combineStyles","byId","theme","stypRules","Theme_","_styles","stypRoot","styles","_rules","constructed","ThemeFactory_","ThemeSupport__feature","newTheme","ThemeSupport","DefaultInAspectsKey","intoConvertedBy","InRenderScheduler","InNamespaceAliaser","DefaultInAspects","InputFromControl","SingleContextUpKey","inputFromControl","control","ConvertInput","convert","aspects","converted","InControl","usageSupply"],"mappings":"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"}